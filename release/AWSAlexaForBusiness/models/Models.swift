// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlexaForBusinessClientTypes.AddressBook: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// An address book with attributes.
    public struct AddressBook: Swift.Equatable {
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// The description of the address book.
        public var description: Swift.String?
        /// The name of the address book.
        public var name: Swift.String?

        public init (
            addressBookArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.AddressBookData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to an address book.
    public struct AddressBookData: Swift.Equatable {
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// The description of the address book.
        public var description: Swift.String?
        /// The name of the address book.
        public var name: Swift.String?

        public init (
            addressBookArn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.addressBookArn = addressBookArn
            self.description = description
            self.name = name
        }
    }

}

extension AlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource being created already exists.
public struct AlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApproveSkillInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension ApproveSkillInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ApproveSkillInput: Swift.Equatable {
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct ApproveSkillInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension ApproveSkillInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension ApproveSkillOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ApproveSkillOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ApproveSkillOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ApproveSkillOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ApproveSkillOutputResponse: Swift.Equatable {

}

extension AssociateContactWithAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension AssociateContactWithAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateContactWithAddressBookInput: Swift.Equatable {
    /// The ARN of the address book with which to associate the contact.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The ARN of the contact to associate with an address book.
    /// This member is required.
    public var contactArn: Swift.String?

    public init (
        addressBookArn: Swift.String? = nil,
        contactArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

struct AssociateContactWithAddressBookInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let addressBookArn: Swift.String?
}

extension AssociateContactWithAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension AssociateContactWithAddressBookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateContactWithAddressBookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateContactWithAddressBookOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateContactWithAddressBookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateContactWithAddressBookOutputResponse: Swift.Equatable {

}

extension AssociateDeviceWithNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

extension AssociateDeviceWithNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDeviceWithNetworkProfileInput: Swift.Equatable {
    /// The device ARN.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The ARN of the network profile to associate with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil,
        networkProfileArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.networkProfileArn = networkProfileArn
    }
}

struct AssociateDeviceWithNetworkProfileInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let networkProfileArn: Swift.String?
}

extension AssociateDeviceWithNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension AssociateDeviceWithNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDeviceWithNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDeviceWithNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDeviceWithNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDeviceWithNetworkProfileOutputResponse: Swift.Equatable {

}

extension AssociateDeviceWithRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension AssociateDeviceWithRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateDeviceWithRoomInput: Swift.Equatable {
    /// The ARN of the device to associate to a room. Required.
    public var deviceArn: Swift.String?
    /// The ARN of the room with which to associate the device. Required.
    public var roomArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.roomArn = roomArn
    }
}

struct AssociateDeviceWithRoomInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let roomArn: Swift.String?
}

extension AssociateDeviceWithRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension AssociateDeviceWithRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateDeviceWithRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateDeviceWithRoomOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateDeviceWithRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateDeviceWithRoomOutputResponse: Swift.Equatable {

}

extension AssociateSkillGroupWithRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension AssociateSkillGroupWithRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateSkillGroupWithRoomInput: Swift.Equatable {
    /// The ARN of the room with which to associate the skill group. Required.
    public var roomArn: Swift.String?
    /// The ARN of the skill group to associate with a room. Required.
    public var skillGroupArn: Swift.String?

    public init (
        roomArn: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

struct AssociateSkillGroupWithRoomInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let roomArn: Swift.String?
}

extension AssociateSkillGroupWithRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension AssociateSkillGroupWithRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSkillGroupWithRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSkillGroupWithRoomOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSkillGroupWithRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSkillGroupWithRoomOutputResponse: Swift.Equatable {

}

extension AssociateSkillWithSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension AssociateSkillWithSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateSkillWithSkillGroupInput: Swift.Equatable {
    /// The ARN of the skill group to associate the skill to. Required.
    public var skillGroupArn: Swift.String?
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        skillGroupArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

struct AssociateSkillWithSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let skillId: Swift.String?
}

extension AssociateSkillWithSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension AssociateSkillWithSkillGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSkillWithSkillGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SkillNotLinkedException" : self = .skillNotLinkedException(try SkillNotLinkedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSkillWithSkillGroupOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case skillNotLinkedException(SkillNotLinkedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSkillWithSkillGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSkillWithSkillGroupOutputResponse: Swift.Equatable {

}

extension AssociateSkillWithUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension AssociateSkillWithUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AssociateSkillWithUsersInput: Swift.Equatable {
    /// The private skill ID you want to make available to enrolled users.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct AssociateSkillWithUsersInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension AssociateSkillWithUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension AssociateSkillWithUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateSkillWithUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateSkillWithUsersOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateSkillWithUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateSkillWithUsersOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.Audio: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale = "Locale"
        case location = "Location"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The audio message. There is a 1 MB limit on the audio file input and the only supported format is MP3. To convert your MP3 audio files to an Alexa-friendly, required codec version (MPEG version 2) and bit rate (48 kbps), you might use converter software. One option for this is a command-line tool, FFmpeg. For more information, see [FFmpeg](https://www.ffmpeg.org/). The following command converts the provided to an MP3 file that is played in the announcement: ffmpeg -i -ac 2 -codec:a libmp3lame -b:a 48k -ar 16000
    public struct Audio: Swift.Equatable {
        /// The locale of the audio message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The location of the audio file. Currently, S3 URLs are supported. Only S3 locations comprised of safe characters are valid. For more information, see [Safe Characters](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html#Safe%20Characters).
        /// This member is required.
        public var location: Swift.String?

        public init (
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            location: Swift.String? = nil
        )
        {
            self.locale = locale
            self.location = location
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReport: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveryTime = "DeliveryTime"
        case downloadUrl = "DownloadUrl"
        case failureCode = "FailureCode"
        case s3Location = "S3Location"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryTime = deliveryTime {
            try encodeContainer.encode(deliveryTime.timeIntervalSince1970, forKey: .deliveryTime)
        }
        if let downloadUrl = downloadUrl {
            try encodeContainer.encode(downloadUrl, forKey: .downloadUrl)
        }
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let s3Location = s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportStatus.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportS3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
        let deliveryTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Usage report with specified parameters.
    public struct BusinessReport: Swift.Equatable {
        /// The time of report delivery.
        public var deliveryTime: ClientRuntime.Date?
        /// The download link where a user can download the report.
        public var downloadUrl: Swift.String?
        /// The failure code.
        public var failureCode: AlexaForBusinessClientTypes.BusinessReportFailureCode?
        /// The S3 location of the output reports.
        public var s3Location: AlexaForBusinessClientTypes.BusinessReportS3Location?
        /// The status of the report generation execution (RUNNING, SUCCEEDED, or FAILED).
        public var status: AlexaForBusinessClientTypes.BusinessReportStatus?

        public init (
            deliveryTime: ClientRuntime.Date? = nil,
            downloadUrl: Swift.String? = nil,
            failureCode: AlexaForBusinessClientTypes.BusinessReportFailureCode? = nil,
            s3Location: AlexaForBusinessClientTypes.BusinessReportS3Location? = nil,
            status: AlexaForBusinessClientTypes.BusinessReportStatus? = nil
        )
        {
            self.deliveryTime = deliveryTime
            self.downloadUrl = downloadUrl
            self.failureCode = failureCode
            self.s3Location = s3Location
            self.status = status
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportContentRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval = "Interval"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = interval {
            try encodeContainer.encode(interval.rawValue, forKey: .interval)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportInterval.self, forKey: .interval)
        interval = intervalDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The content range of the report.
    public struct BusinessReportContentRange: Swift.Equatable {
        /// The interval of the content range.
        /// This member is required.
        public var interval: AlexaForBusinessClientTypes.BusinessReportInterval?

        public init (
            interval: AlexaForBusinessClientTypes.BusinessReportInterval? = nil
        )
        {
            self.interval = interval
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case internalFailure
        case noSuchBucket
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportFailureCode] {
            return [
                .accessDenied,
                .internalFailure,
                .noSuchBucket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .internalFailure: return "INTERNAL_FAILURE"
            case .noSuchBucket: return "NO_SUCH_BUCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportFailureCode(rawValue: rawValue) ?? BusinessReportFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case csvZip
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportFormat] {
            return [
                .csv,
                .csvZip,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .csvZip: return "CSV_ZIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportFormat(rawValue: rawValue) ?? BusinessReportFormat.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportInterval: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oneDay
        case oneWeek
        case thirtyDays
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportInterval] {
            return [
                .oneDay,
                .oneWeek,
                .thirtyDays,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oneDay: return "ONE_DAY"
            case .oneWeek: return "ONE_WEEK"
            case .thirtyDays: return "THIRTY_DAYS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportInterval(rawValue: rawValue) ?? BusinessReportInterval.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.BusinessReportRecurrence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startDate = "StartDate"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startDate = startDate {
            try encodeContainer.encode(startDate, forKey: .startDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDate)
        startDate = startDateDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The recurrence of the reports.
    public struct BusinessReportRecurrence: Swift.Equatable {
        /// The start date.
        public var startDate: Swift.String?

        public init (
            startDate: Swift.String? = nil
        )
        {
            self.startDate = startDate
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportS3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName = "BucketName"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The S3 location of the output reports.
    public struct BusinessReportS3Location: Swift.Equatable {
        /// The S3 bucket name of the output reports.
        public var bucketName: Swift.String?
        /// The path of the business report.
        public var path: Swift.String?

        public init (
            bucketName: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
            self.path = path
        }
    }

}

extension AlexaForBusinessClientTypes.BusinessReportSchedule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentRange = "ContentRange"
        case format = "Format"
        case lastBusinessReport = "LastBusinessReport"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentRange = contentRange {
            try encodeContainer.encode(contentRange, forKey: .contentRange)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let lastBusinessReport = lastBusinessReport {
            try encodeContainer.encode(lastBusinessReport, forKey: .lastBusinessReport)
        }
        if let recurrence = recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleArn = scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
        if let scheduleName = scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
        let scheduleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let contentRangeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportContentRange.self, forKey: .contentRange)
        contentRange = contentRangeDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let lastBusinessReportDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReport.self, forKey: .lastBusinessReport)
        lastBusinessReport = lastBusinessReportDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The schedule of the usage report.
    public struct BusinessReportSchedule: Swift.Equatable {
        /// The content range of the reports.
        public var contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
        /// The format of the generated report (individual CSV files or zipped files of individual files).
        public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
        /// The details of the last business report delivery for a specified time interval.
        public var lastBusinessReport: AlexaForBusinessClientTypes.BusinessReport?
        /// The recurrence of the reports.
        public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
        /// The S3 bucket name of the output reports.
        public var s3BucketName: Swift.String?
        /// The S3 key where the report is delivered.
        public var s3KeyPrefix: Swift.String?
        /// The ARN of the business report schedule.
        public var scheduleArn: Swift.String?
        /// The name identifier of the schedule.
        public var scheduleName: Swift.String?

        public init (
            contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange? = nil,
            format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
            lastBusinessReport: AlexaForBusinessClientTypes.BusinessReport? = nil,
            recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
            s3BucketName: Swift.String? = nil,
            s3KeyPrefix: Swift.String? = nil,
            scheduleArn: Swift.String? = nil,
            scheduleName: Swift.String? = nil
        )
        {
            self.contentRange = contentRange
            self.format = format
            self.lastBusinessReport = lastBusinessReport
            self.recurrence = recurrence
            self.s3BucketName = s3BucketName
            self.s3KeyPrefix = s3KeyPrefix
            self.scheduleArn = scheduleArn
            self.scheduleName = scheduleName
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum BusinessReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case running
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessReportStatus] {
            return [
                .failed,
                .running,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BusinessReportStatus(rawValue: rawValue) ?? BusinessReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Category: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryId = "CategoryId"
        case categoryName = "CategoryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryId = categoryId {
            try encodeContainer.encode(categoryId, forKey: .categoryId)
        }
        if let categoryName = categoryName {
            try encodeContainer.encode(categoryName, forKey: .categoryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .categoryId)
        categoryId = categoryIdDecoded
        let categoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .categoryName)
        categoryName = categoryNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The skill store category that is shown. Alexa skills are assigned a specific skill category during creation, such as News, Social, and Sports.
    public struct Category: Swift.Equatable {
        /// The ID of the skill store category.
        public var categoryId: Swift.Int?
        /// The name of the skill store category.
        public var categoryName: Swift.String?

        public init (
            categoryId: Swift.Int? = nil,
            categoryName: Swift.String? = nil
        )
        {
            self.categoryId = categoryId
            self.categoryName = categoryName
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum CommsProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case h323
        case sip
        case sips
        case sdkUnknown(Swift.String)

        public static var allCases: [CommsProtocol] {
            return [
                .h323,
                .sip,
                .sips,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .h323: return "H323"
            case .sip: return "SIP"
            case .sips: return "SIPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CommsProtocol(rawValue: rawValue) ?? CommsProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There is a concurrent modification of resources.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes.ConferencePreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConferenceProviderArn = "DefaultConferenceProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConferenceProviderArn = defaultConferenceProviderArn {
            try encodeContainer.encode(defaultConferenceProviderArn, forKey: .defaultConferenceProviderArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultConferenceProviderArn)
        defaultConferenceProviderArn = defaultConferenceProviderArnDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The default conference provider that is used if no other scheduled meetings are detected.
    public struct ConferencePreference: Swift.Equatable {
        /// The ARN of the default conference provider.
        public var defaultConferenceProviderArn: Swift.String?

        public init (
            defaultConferenceProviderArn: Swift.String? = nil
        )
        {
            self.defaultConferenceProviderArn = defaultConferenceProviderArn
        }
    }

}

extension AlexaForBusinessClientTypes.ConferenceProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case name = "Name"
        case pSTNDialIn = "PSTNDialIn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let iPDialIn = iPDialIn {
            try encodeContainer.encode(iPDialIn, forKey: .iPDialIn)
        }
        if let meetingSetting = meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pSTNDialIn = pSTNDialIn {
            try encodeContainer.encode(pSTNDialIn, forKey: .pSTNDialIn)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProviderType.self, forKey: .type)
        type = typeDecoded
        let iPDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.IPDialIn.self, forKey: .iPDialIn)
        iPDialIn = iPDialInDecoded
        let pSTNDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PSTNDialIn.self, forKey: .pSTNDialIn)
        pSTNDialIn = pSTNDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// An entity that provides a conferencing solution. Alexa for Business acts as the voice interface and mediator that connects users to their preferred conference provider. Examples of conference providers include Amazon Chime, Zoom, Cisco, and Polycom.
    public struct ConferenceProvider: Swift.Equatable {
        /// The ARN of the newly created conference provider.
        public var arn: Swift.String?
        /// The IP endpoint and protocol for calling.
        public var iPDialIn: AlexaForBusinessClientTypes.IPDialIn?
        /// The meeting settings for the conference provider.
        public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
        /// The name of the conference provider.
        public var name: Swift.String?
        /// The information for PSTN conferencing.
        public var pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
        /// The type of conference providers.
        public var type: AlexaForBusinessClientTypes.ConferenceProviderType?

        public init (
            arn: Swift.String? = nil,
            iPDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
            meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
            name: Swift.String? = nil,
            pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil,
            type: AlexaForBusinessClientTypes.ConferenceProviderType? = nil
        )
        {
            self.arn = arn
            self.iPDialIn = iPDialIn
            self.meetingSetting = meetingSetting
            self.name = name
            self.pSTNDialIn = pSTNDialIn
            self.type = type
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum ConferenceProviderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bluejeans
        case chime
        case custom
        case fuze
        case googleHangouts
        case polycom
        case ringcentral
        case skypeForBusiness
        case webex
        case zoom
        case sdkUnknown(Swift.String)

        public static var allCases: [ConferenceProviderType] {
            return [
                .bluejeans,
                .chime,
                .custom,
                .fuze,
                .googleHangouts,
                .polycom,
                .ringcentral,
                .skypeForBusiness,
                .webex,
                .zoom,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bluejeans: return "BLUEJEANS"
            case .chime: return "CHIME"
            case .custom: return "CUSTOM"
            case .fuze: return "FUZE"
            case .googleHangouts: return "GOOGLE_HANGOUTS"
            case .polycom: return "POLYCOM"
            case .ringcentral: return "RINGCENTRAL"
            case .skypeForBusiness: return "SKYPE_FOR_BUSINESS"
            case .webex: return "WEBEX"
            case .zoom: return "ZOOM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConferenceProviderType(rawValue: rawValue) ?? ConferenceProviderType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum ConnectionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case offline
        case online
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionStatus] {
            return [
                .offline,
                .online,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .offline: return "OFFLINE"
            case .online: return "ONLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionStatus(rawValue: rawValue) ?? ConnectionStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension AlexaForBusinessClientTypes {
    /// A contact with attributes.
    public struct Contact: Swift.Equatable {
        /// The ARN of the contact.
        public var contactArn: Swift.String?
        /// The name of the contact to display on the console.
        public var displayName: Swift.String?
        /// The first name of the contact, used to call the contact on the device.
        public var firstName: Swift.String?
        /// The last name of the contact, used to call the contact on the device.
        public var lastName: Swift.String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public var phoneNumber: Swift.String?
        /// The list of phone numbers for the contact.
        public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

        public init (
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
            sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
        )
        {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }
    }

}

extension AlexaForBusinessClientTypes.ContactData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to a contact.
    public struct ContactData: Swift.Equatable {
        /// The ARN of the contact.
        public var contactArn: Swift.String?
        /// The name of the contact to display on the console.
        public var displayName: Swift.String?
        /// The first name of the contact, used to call the contact on the device.
        public var firstName: Swift.String?
        /// The last name of the contact, used to call the contact on the device.
        public var lastName: Swift.String?
        /// The phone number of the contact. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
        public var phoneNumber: Swift.String?
        /// The list of phone numbers for the contact.
        public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
        /// The list of SIP addresses for the contact.
        public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

        public init (
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phoneNumber: Swift.String? = nil,
            phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
            sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
        )
        {
            self.contactArn = contactArn
            self.displayName = displayName
            self.firstName = firstName
            self.lastName = lastName
            self.phoneNumber = phoneNumber
            self.phoneNumbers = phoneNumbers
            self.sipAddresses = sipAddresses
        }
    }

}

extension AlexaForBusinessClientTypes.Content: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioList = "AudioList"
        case ssmlList = "SsmlList"
        case textList = "TextList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audioList = audioList {
            var audioListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .audioList)
            for audiolist0 in audioList {
                try audioListContainer.encode(audiolist0)
            }
        }
        if let ssmlList = ssmlList {
            var ssmlListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ssmlList)
            for ssmllist0 in ssmlList {
                try ssmlListContainer.encode(ssmllist0)
            }
        }
        if let textList = textList {
            var textListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .textList)
            for textlist0 in textList {
                try textListContainer.encode(textlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Text?].self, forKey: .textList)
        var textListDecoded0:[AlexaForBusinessClientTypes.Text]? = nil
        if let textListContainer = textListContainer {
            textListDecoded0 = [AlexaForBusinessClientTypes.Text]()
            for structure0 in textListContainer {
                if let structure0 = structure0 {
                    textListDecoded0?.append(structure0)
                }
            }
        }
        textList = textListDecoded0
        let ssmlListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Ssml?].self, forKey: .ssmlList)
        var ssmlListDecoded0:[AlexaForBusinessClientTypes.Ssml]? = nil
        if let ssmlListContainer = ssmlListContainer {
            ssmlListDecoded0 = [AlexaForBusinessClientTypes.Ssml]()
            for structure0 in ssmlListContainer {
                if let structure0 = structure0 {
                    ssmlListDecoded0?.append(structure0)
                }
            }
        }
        ssmlList = ssmlListDecoded0
        let audioListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Audio?].self, forKey: .audioList)
        var audioListDecoded0:[AlexaForBusinessClientTypes.Audio]? = nil
        if let audioListContainer = audioListContainer {
            audioListDecoded0 = [AlexaForBusinessClientTypes.Audio]()
            for structure0 in audioListContainer {
                if let structure0 = structure0 {
                    audioListDecoded0?.append(structure0)
                }
            }
        }
        audioList = audioListDecoded0
    }
}

extension AlexaForBusinessClientTypes {
    /// The content definition. This can contain only one text, SSML, or audio list object.
    public struct Content: Swift.Equatable {
        /// The list of audio messages.
        public var audioList: [AlexaForBusinessClientTypes.Audio]?
        /// The list of SSML messages.
        public var ssmlList: [AlexaForBusinessClientTypes.Ssml]?
        /// The list of text messages.
        public var textList: [AlexaForBusinessClientTypes.Text]?

        public init (
            audioList: [AlexaForBusinessClientTypes.Audio]? = nil,
            ssmlList: [AlexaForBusinessClientTypes.Ssml]? = nil,
            textList: [AlexaForBusinessClientTypes.Text]? = nil
        )
        {
            self.audioList = audioList
            self.ssmlList = ssmlList
            self.textList = textList
        }
    }

}

extension CreateAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAddressBookInput: Swift.Equatable {
    /// A unique, user-specified identifier for the request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description of the address book.
    public var description: Swift.String?
    /// The name of the address book.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateAddressBookInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAddressBookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAddressBookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAddressBookOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAddressBookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAddressBookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressBookArn = output.addressBookArn
        } else {
            self.addressBookArn = nil
        }
    }
}

public struct CreateAddressBookOutputResponse: Swift.Equatable {
    /// The ARN of the newly created address book.
    public var addressBookArn: Swift.String?

    public init (
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct CreateAddressBookOutputResponseBody: Swift.Equatable {
    let addressBookArn: Swift.String?
}

extension CreateAddressBookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension CreateBusinessReportScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case contentRange = "ContentRange"
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleName = "ScheduleName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let contentRange = contentRange {
            try encodeContainer.encode(contentRange, forKey: .contentRange)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let recurrence = recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleName = scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateBusinessReportScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBusinessReportScheduleInput: Swift.Equatable {
    /// The client request token.
    public var clientRequestToken: Swift.String?
    /// The content range of the reports.
    /// This member is required.
    public var contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
    /// The format of the generated report (individual CSV files or zipped files of individual files).
    /// This member is required.
    public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
    /// The recurrence of the reports. If this isn't specified, the report will only be delivered one time when the API is called.
    public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    /// The S3 bucket name of the output reports. If this isn't specified, the report can be retrieved from a download link by calling ListBusinessReportSchedule.
    public var s3BucketName: Swift.String?
    /// The S3 key where the report is delivered.
    public var s3KeyPrefix: Swift.String?
    /// The name identifier of the schedule.
    public var scheduleName: Swift.String?
    /// The tags for the business report schedule.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange? = nil,
        format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
        recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        scheduleName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.contentRange = contentRange
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleName = scheduleName
        self.tags = tags
    }
}

struct CreateBusinessReportScheduleInputBody: Swift.Equatable {
    let scheduleName: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let format: AlexaForBusinessClientTypes.BusinessReportFormat?
    let contentRange: AlexaForBusinessClientTypes.BusinessReportContentRange?
    let recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateBusinessReportScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case contentRange = "ContentRange"
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleName = "ScheduleName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let contentRangeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportContentRange.self, forKey: .contentRange)
        contentRange = contentRangeDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBusinessReportScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBusinessReportScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBusinessReportScheduleOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBusinessReportScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBusinessReportScheduleOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.scheduleArn = output.scheduleArn
        } else {
            self.scheduleArn = nil
        }
    }
}

public struct CreateBusinessReportScheduleOutputResponse: Swift.Equatable {
    /// The ARN of the business report schedule.
    public var scheduleArn: Swift.String?

    public init (
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct CreateBusinessReportScheduleOutputResponseBody: Swift.Equatable {
    let scheduleArn: Swift.String?
}

extension CreateBusinessReportScheduleOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

extension CreateConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case conferenceProviderName = "ConferenceProviderName"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let conferenceProviderName = conferenceProviderName {
            try encodeContainer.encode(conferenceProviderName, forKey: .conferenceProviderName)
        }
        if let conferenceProviderType = conferenceProviderType {
            try encodeContainer.encode(conferenceProviderType.rawValue, forKey: .conferenceProviderType)
        }
        if let iPDialIn = iPDialIn {
            try encodeContainer.encode(iPDialIn, forKey: .iPDialIn)
        }
        if let meetingSetting = meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let pSTNDialIn = pSTNDialIn {
            try encodeContainer.encode(pSTNDialIn, forKey: .pSTNDialIn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateConferenceProviderInput: Swift.Equatable {
    /// The request token of the client.
    public var clientRequestToken: Swift.String?
    /// The name of the conference provider.
    /// This member is required.
    public var conferenceProviderName: Swift.String?
    /// Represents a type within a list of predefined types.
    /// This member is required.
    public var conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    /// The IP endpoint and protocol for calling.
    public var iPDialIn: AlexaForBusinessClientTypes.IPDialIn?
    /// The meeting settings for the conference provider.
    /// This member is required.
    public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    /// The information for PSTN conferencing.
    public var pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        conferenceProviderName: Swift.String? = nil,
        conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType? = nil,
        iPDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
        meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
        pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.conferenceProviderName = conferenceProviderName
        self.conferenceProviderType = conferenceProviderType
        self.iPDialIn = iPDialIn
        self.meetingSetting = meetingSetting
        self.pSTNDialIn = pSTNDialIn
        self.tags = tags
    }
}

struct CreateConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderName: Swift.String?
    let conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    let iPDialIn: AlexaForBusinessClientTypes.IPDialIn?
    let pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
    let meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case conferenceProviderName = "ConferenceProviderName"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderName)
        conferenceProviderName = conferenceProviderNameDecoded
        let conferenceProviderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProviderType.self, forKey: .conferenceProviderType)
        conferenceProviderType = conferenceProviderTypeDecoded
        let iPDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.IPDialIn.self, forKey: .iPDialIn)
        iPDialIn = iPDialInDecoded
        let pSTNDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PSTNDialIn.self, forKey: .pSTNDialIn)
        pSTNDialIn = pSTNDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConferenceProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConferenceProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConferenceProviderOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConferenceProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateConferenceProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conferenceProviderArn = output.conferenceProviderArn
        } else {
            self.conferenceProviderArn = nil
        }
    }
}

public struct CreateConferenceProviderOutputResponse: Swift.Equatable {
    /// The ARN of the newly-created conference provider.
    public var conferenceProviderArn: Swift.String?

    public init (
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct CreateConferenceProviderOutputResponseBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
}

extension CreateConferenceProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

extension CreateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContactInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The name of the contact to display on the console.
    public var displayName: Swift.String?
    /// The first name of the contact that is used to call the contact on the device.
    /// This member is required.
    public var firstName: Swift.String?
    /// The last name of the contact that is used to call the contact on the device.
    public var lastName: Swift.String?
    /// The phone number of the contact in E.164 format. The phone number type defaults to WORK. You can specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
    public var phoneNumber: Swift.String?
    /// The list of phone numbers for the contact.
    public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    /// The list of SIP addresses for the contact.
    public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
        sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
        self.tags = tags
    }
}

struct CreateContactInputBody: Swift.Equatable {
    let displayName: Swift.String?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let phoneNumber: Swift.String?
    let phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    let sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateContactOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
        } else {
            self.contactArn = nil
        }
    }
}

public struct CreateContactOutputResponse: Swift.Equatable {
    /// The ARN of the newly created address book.
    public var contactArn: Swift.String?

    public init (
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct CreateContactOutputResponseBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension CreateContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension AlexaForBusinessClientTypes.CreateEndOfMeetingReminder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for endofmeetingreminderminuteslist0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(endofmeetingreminderminuteslist0)
            }
        }
        if let reminderType = reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Swift.Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Swift.Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct CreateEndOfMeetingReminder: Swift.Equatable {
        /// Whether an end of meeting reminder is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// A range of 3 to 15 minutes that determines when the reminder begins.
        /// This member is required.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        /// This member is required.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init (
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension CreateGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateGatewayGroupInput: Swift.Equatable {
    /// A unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The description of the gateway group.
    public var description: Swift.String?
    /// The name of the gateway group.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.name = name
        self.tags = tags
    }
}

struct CreateGatewayGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case name = "Name"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGatewayGroupOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGatewayGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayGroupArn = output.gatewayGroupArn
        } else {
            self.gatewayGroupArn = nil
        }
    }
}

public struct CreateGatewayGroupOutputResponse: Swift.Equatable {
    /// The ARN of the created gateway group.
    public var gatewayGroupArn: Swift.String?

    public init (
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct CreateGatewayGroupOutputResponseBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
}

extension CreateGatewayGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension AlexaForBusinessClientTypes.CreateInstantBooking: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the instant booking feature that are applied to a room profile. When users start their meeting with Alexa, Alexa automatically books the room for the configured duration if the room is available.
    public struct CreateInstantBooking: Swift.Equatable {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?

        public init (
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let requireCheckIn = requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateEndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateInstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateRequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates meeting room settings of a room profile.
    public struct CreateMeetingRoomConfiguration: Swift.Equatable {
        /// Creates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder?
        /// Settings to automatically book a room for a configured duration if it's free when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.CreateInstantBooking?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.CreateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init (
            endOfMeetingReminder: AlexaForBusinessClientTypes.CreateEndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.CreateInstantBooking? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.CreateRequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension CreateNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case clientRequestToken = "ClientRequestToken"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case tags = "Tags"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let currentPassword = currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let securityType = securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchorlist0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchorlist0)
            }
        }
    }
}

extension CreateNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateNetworkProfileInput: Swift.Equatable {
    /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
    public var certificateAuthorityArn: Swift.String?
    /// A unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The current password of the Wi-Fi network.
    public var currentPassword: Swift.String?
    /// Detailed information about a device's network profile.
    public var description: Swift.String?
    /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
    public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
    /// The name of the network profile associated with a device.
    /// This member is required.
    public var networkProfileName: Swift.String?
    /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
    public var nextPassword: Swift.String?
    /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
    /// This member is required.
    public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
    /// The SSID of the Wi-Fi network.
    /// This member is required.
    public var ssid: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The root certificates of your authentication server that is installed on your devices and used to trust your authentication server during EAP negotiation.
    public var trustAnchors: [Swift.String]?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        currentPassword: Swift.String? = nil,
        description: Swift.String? = nil,
        eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
        networkProfileName: Swift.String? = nil,
        nextPassword: Swift.String? = nil,
        securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
        ssid: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        trustAnchors: [Swift.String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.clientRequestToken = clientRequestToken
        self.currentPassword = currentPassword
        self.description = description
        self.eapMethod = eapMethod
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.securityType = securityType
        self.ssid = ssid
        self.tags = tags
        self.trustAnchors = trustAnchors
    }
}

struct CreateNetworkProfileInputBody: Swift.Equatable {
    let networkProfileName: Swift.String?
    let description: Swift.String?
    let ssid: Swift.String?
    let securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
    let eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
    let currentPassword: Swift.String?
    let nextPassword: Swift.String?
    let certificateAuthorityArn: Swift.String?
    let trustAnchors: [Swift.String]?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case clientRequestToken = "ClientRequestToken"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case tags = "Tags"
        case trustAnchors = "TrustAnchors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[Swift.String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [Swift.String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateAuthorityException" : self = .invalidCertificateAuthorityException(try InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidServiceLinkedRoleStateException" : self = .invalidServiceLinkedRoleStateException(try InvalidServiceLinkedRoleStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case invalidCertificateAuthorityException(InvalidCertificateAuthorityException)
    case invalidServiceLinkedRoleStateException(InvalidServiceLinkedRoleStateException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfileArn = output.networkProfileArn
        } else {
            self.networkProfileArn = nil
        }
    }
}

public struct CreateNetworkProfileOutputResponse: Swift.Equatable {
    /// The ARN of the network profile associated with a device.
    public var networkProfileArn: Swift.String?

    public init (
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct CreateNetworkProfileOutputResponseBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
}

extension CreateNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension CreateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clientRequestToken = "ClientRequestToken"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case tags = "Tags"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataRetentionOptIn = dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pSTNEnabled = pSTNEnabled {
            try encodeContainer.encode(pSTNEnabled, forKey: .pSTNEnabled)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }
}

extension CreateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateProfileInput: Swift.Equatable {
    /// The valid address for the room.
    /// This member is required.
    public var address: Swift.String?
    /// The user-specified token that is used during the creation of a profile.
    public var clientRequestToken: Swift.String?
    /// Whether data retention of the profile is enabled.
    public var dataRetentionOptIn: Swift.Bool?
    /// The distance unit to be used by devices in the profile.
    /// This member is required.
    public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    /// The locale of the room profile. (This is currently only available to a limited preview audience.)
    public var locale: Swift.String?
    /// The maximum volume limit for a room profile.
    public var maxVolumeLimit: Swift.Int?
    /// The meeting room settings of a room profile.
    public var meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration?
    /// Whether PSTN calling is enabled.
    public var pSTNEnabled: Swift.Bool?
    /// The name of a room profile.
    /// This member is required.
    public var profileName: Swift.String?
    /// Whether room profile setup is enabled.
    public var setupModeDisabled: Swift.Bool?
    /// The tags for the profile.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The temperature unit to be used by devices in the profile.
    /// This member is required.
    public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    /// The time zone used by a room profile.
    /// This member is required.
    public var timezone: Swift.String?
    /// A wake word for Alexa, Echo, Amazon, or a computer.
    /// This member is required.
    public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

    public init (
        address: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        dataRetentionOptIn: Swift.Bool? = nil,
        distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
        locale: Swift.String? = nil,
        maxVolumeLimit: Swift.Int? = nil,
        meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration? = nil,
        pSTNEnabled: Swift.Bool? = nil,
        profileName: Swift.String? = nil,
        setupModeDisabled: Swift.Bool? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
        timezone: Swift.String? = nil,
        wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
    )
    {
        self.address = address
        self.clientRequestToken = clientRequestToken
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.pSTNEnabled = pSTNEnabled
        self.profileName = profileName
        self.setupModeDisabled = setupModeDisabled
        self.tags = tags
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

struct CreateProfileInputBody: Swift.Equatable {
    let profileName: Swift.String?
    let timezone: Swift.String?
    let address: Swift.String?
    let distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    let temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    let wakeWord: AlexaForBusinessClientTypes.WakeWord?
    let locale: Swift.String?
    let clientRequestToken: Swift.String?
    let setupModeDisabled: Swift.Bool?
    let maxVolumeLimit: Swift.Int?
    let pSTNEnabled: Swift.Bool?
    let dataRetentionOptIn: Swift.Bool?
    let meetingRoomConfiguration: AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case clientRequestToken = "ClientRequestToken"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case tags = "Tags"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pSTNEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pSTNEnabled)
        pSTNEnabled = pSTNEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CreateMeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProfileOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profileArn = output.profileArn
        } else {
            self.profileArn = nil
        }
    }
}

public struct CreateProfileOutputResponse: Swift.Equatable {
    /// The ARN of the newly created room profile in the response.
    public var profileArn: Swift.String?

    public init (
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct CreateProfileOutputResponseBody: Swift.Equatable {
    let profileArn: Swift.String?
}

extension CreateProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension AlexaForBusinessClientTypes.CreateRequireCheckIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Creates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct CreateRequireCheckIn: Swift.Equatable {
        /// Whether require check in is enabled or not.
        /// This member is required.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        /// This member is required.
        public var releaseAfterMinutes: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension CreateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomName = "RoomName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRoomInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description for the room.
    public var description: Swift.String?
    /// The profile ARN for the room. This is required.
    public var profileArn: Swift.String?
    /// The calendar ARN for the room.
    public var providerCalendarId: Swift.String?
    /// The name for the room.
    /// This member is required.
    public var roomName: Swift.String?
    /// The tags for the room.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        providerCalendarId: Swift.String? = nil,
        roomName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomName = roomName
        self.tags = tags
    }
}

struct CreateRoomInputBody: Swift.Equatable {
    let roomName: Swift.String?
    let description: Swift.String?
    let profileArn: Swift.String?
    let providerCalendarId: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomName = "RoomName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRoomOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.roomArn = output.roomArn
        } else {
            self.roomArn = nil
        }
    }
}

public struct CreateRoomOutputResponse: Swift.Equatable {
    /// The ARN of the newly created room in the response.
    public var roomArn: Swift.String?

    public init (
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct CreateRoomOutputResponseBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension CreateRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension CreateSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case skillGroupName = "SkillGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension CreateSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateSkillGroupInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The description for the skill group.
    public var description: Swift.String?
    /// The name for the skill group.
    /// This member is required.
    public var skillGroupName: Swift.String?
    /// The tags for the skill group.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        clientRequestToken: Swift.String? = nil,
        description: Swift.String? = nil,
        skillGroupName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.description = description
        self.skillGroupName = skillGroupName
        self.tags = tags
    }
}

struct CreateSkillGroupInputBody: Swift.Equatable {
    let skillGroupName: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case description = "Description"
        case skillGroupName = "SkillGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSkillGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSkillGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSkillGroupOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSkillGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateSkillGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.skillGroupArn = output.skillGroupArn
        } else {
            self.skillGroupArn = nil
        }
    }
}

public struct CreateSkillGroupOutputResponse: Swift.Equatable {
    /// The ARN of the newly created skill group in the response.
    public var skillGroupArn: Swift.String?

    public init (
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct CreateSkillGroupOutputResponseBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
}

extension CreateSkillGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
        case tags = "Tags"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// A unique, user-specified identifier for this request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    /// The email address for the user.
    public var email: Swift.String?
    /// The first name for the user.
    public var firstName: Swift.String?
    /// The last name for the user.
    public var lastName: Swift.String?
    /// The tags for the user.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The ARN for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        email: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.email = email
        self.firstName = firstName
        self.lastName = lastName
        self.tags = tags
        self.userId = userId
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let userId: Swift.String?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let email: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case email = "Email"
        case firstName = "FirstName"
        case lastName = "LastName"
        case tags = "Tags"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case limitExceededException(LimitExceededException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userArn = output.userArn
        } else {
            self.userArn = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The ARN of the newly created user in the response.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DeleteAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
    }
}

extension DeleteAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAddressBookInput: Swift.Equatable {
    /// The ARN of the address book to delete.
    /// This member is required.
    public var addressBookArn: Swift.String?

    public init (
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct DeleteAddressBookInputBody: Swift.Equatable {
    let addressBookArn: Swift.String?
}

extension DeleteAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension DeleteAddressBookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAddressBookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAddressBookOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAddressBookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAddressBookOutputResponse: Swift.Equatable {

}

extension DeleteBusinessReportScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleArn = scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
    }
}

extension DeleteBusinessReportScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBusinessReportScheduleInput: Swift.Equatable {
    /// The ARN of the business report schedule.
    /// This member is required.
    public var scheduleArn: Swift.String?

    public init (
        scheduleArn: Swift.String? = nil
    )
    {
        self.scheduleArn = scheduleArn
    }
}

struct DeleteBusinessReportScheduleInputBody: Swift.Equatable {
    let scheduleArn: Swift.String?
}

extension DeleteBusinessReportScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleArn = "ScheduleArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
    }
}

extension DeleteBusinessReportScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBusinessReportScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBusinessReportScheduleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBusinessReportScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBusinessReportScheduleOutputResponse: Swift.Equatable {

}

extension DeleteConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
    }
}

extension DeleteConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteConferenceProviderInput: Swift.Equatable {
    /// The ARN of the conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?

    public init (
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct DeleteConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
}

extension DeleteConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

extension DeleteConferenceProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConferenceProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConferenceProviderOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConferenceProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteConferenceProviderOutputResponse: Swift.Equatable {

}

extension DeleteContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension DeleteContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContactInput: Swift.Equatable {
    /// The ARN of the contact to delete.
    /// This member is required.
    public var contactArn: Swift.String?

    public init (
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct DeleteContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension DeleteContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension DeleteContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteContactOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteContactOutputResponse: Swift.Equatable {

}

extension DeleteDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

extension DeleteDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// The ARN of the device for which to request details.
    /// This member is required.
    public var deviceArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension DeleteDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension DeleteDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateAuthorityException" : self = .invalidCertificateAuthorityException(try InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidCertificateAuthorityException(InvalidCertificateAuthorityException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceOutputResponse: Swift.Equatable {

}

extension DeleteDeviceUsageDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceUsageType = "DeviceUsageType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceUsageType = deviceUsageType {
            try encodeContainer.encode(deviceUsageType.rawValue, forKey: .deviceUsageType)
        }
    }
}

extension DeleteDeviceUsageDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteDeviceUsageDataInput: Swift.Equatable {
    /// The ARN of the device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The type of usage data to delete.
    /// This member is required.
    public var deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType?

    public init (
        deviceArn: Swift.String? = nil,
        deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceUsageType = deviceUsageType
    }
}

struct DeleteDeviceUsageDataInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let deviceUsageType: AlexaForBusinessClientTypes.DeviceUsageType?
}

extension DeleteDeviceUsageDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceUsageType = "DeviceUsageType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceUsageTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceUsageType.self, forKey: .deviceUsageType)
        deviceUsageType = deviceUsageTypeDecoded
    }
}

extension DeleteDeviceUsageDataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceUsageDataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceUsageDataOutputError: Swift.Error, Swift.Equatable {
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceUsageDataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDeviceUsageDataOutputResponse: Swift.Equatable {

}

extension DeleteGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
    }
}

extension DeleteGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteGatewayGroupInput: Swift.Equatable {
    /// The ARN of the gateway group to delete.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?

    public init (
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct DeleteGatewayGroupInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
}

extension DeleteGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension DeleteGatewayGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceAssociatedException" : self = .resourceAssociatedException(try ResourceAssociatedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayGroupOutputError: Swift.Error, Swift.Equatable {
    case resourceAssociatedException(ResourceAssociatedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGatewayGroupOutputResponse: Swift.Equatable {

}

extension DeleteNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

extension DeleteNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init (
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct DeleteNetworkProfileInputBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
}

extension DeleteNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension DeleteNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteNetworkProfileOutputResponse: Swift.Equatable {

}

extension DeleteProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

extension DeleteProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteProfileInput: Swift.Equatable {
    /// The ARN of the room profile to delete. Required.
    public var profileArn: Swift.String?

    public init (
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct DeleteProfileInputBody: Swift.Equatable {
    let profileArn: Swift.String?
}

extension DeleteProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension DeleteProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProfileOutputResponse: Swift.Equatable {

}

extension DeleteRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension DeleteRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRoomInput: Swift.Equatable {
    /// The ARN of the room to delete. Required.
    public var roomArn: Swift.String?

    public init (
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct DeleteRoomInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension DeleteRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DeleteRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoomOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomOutputResponse: Swift.Equatable {

}

extension DeleteRoomSkillParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DeleteRoomSkillParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRoomSkillParameterInput: Swift.Equatable {
    /// The room skill parameter key for which to remove details.
    /// This member is required.
    public var parameterKey: Swift.String?
    /// The ARN of the room from which to remove the room skill parameter details.
    public var roomArn: Swift.String?
    /// The ID of the skill from which to remove the room skill parameter details.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        parameterKey: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct DeleteRoomSkillParameterInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let skillId: Swift.String?
    let parameterKey: Swift.String?
}

extension DeleteRoomSkillParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
    }
}

extension DeleteRoomSkillParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRoomSkillParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRoomSkillParameterOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRoomSkillParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRoomSkillParameterOutputResponse: Swift.Equatable {

}

extension DeleteSkillAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DeleteSkillAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSkillAuthorizationInput: Swift.Equatable {
    /// The room that the skill is authorized for.
    public var roomArn: Swift.String?
    /// The unique identifier of a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct DeleteSkillAuthorizationInputBody: Swift.Equatable {
    let skillId: Swift.String?
    let roomArn: Swift.String?
}

extension DeleteSkillAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DeleteSkillAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSkillAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSkillAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSkillAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSkillAuthorizationOutputResponse: Swift.Equatable {

}

extension DeleteSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension DeleteSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteSkillGroupInput: Swift.Equatable {
    /// The ARN of the skill group to delete. Required.
    public var skillGroupArn: Swift.String?

    public init (
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct DeleteSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
}

extension DeleteSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

extension DeleteSkillGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSkillGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSkillGroupOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSkillGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSkillGroupOutputResponse: Swift.Equatable {

}

extension DeleteUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enrollmentId = enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DeleteUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteUserInput: Swift.Equatable {
    /// The ARN of the user's enrollment in the organization. Required.
    /// This member is required.
    public var enrollmentId: Swift.String?
    /// The ARN of the user to delete in the organization. Required.
    public var userArn: Swift.String?

    public init (
        enrollmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

struct DeleteUserInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let enrollmentId: Swift.String?
}

extension DeleteUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension DeleteUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteUserOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.DeveloperInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case developerName = "DeveloperName"
        case email = "Email"
        case privacyPolicy = "PrivacyPolicy"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let developerName = developerName {
            try encodeContainer.encode(developerName, forKey: .developerName)
        }
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let privacyPolicy = privacyPolicy {
            try encodeContainer.encode(privacyPolicy, forKey: .privacyPolicy)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let developerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .developerName)
        developerName = developerNameDecoded
        let privacyPolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privacyPolicy)
        privacyPolicy = privacyPolicyDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The details about the developer that published the skill.
    public struct DeveloperInfo: Swift.Equatable {
        /// The name of the developer.
        public var developerName: Swift.String?
        /// The email of the developer.
        public var email: Swift.String?
        /// The URL of the privacy policy.
        public var privacyPolicy: Swift.String?
        /// The website of the developer.
        public var url: Swift.String?

        public init (
            developerName: Swift.String? = nil,
            email: Swift.String? = nil,
            privacyPolicy: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.developerName = developerName
            self.email = email
            self.privacyPolicy = privacyPolicy
            self.url = url
        }
    }

}

extension AlexaForBusinessClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
        case deviceSerialNumber = "DeviceSerialNumber"
        case deviceStatus = "DeviceStatus"
        case deviceStatusInfo = "DeviceStatusInfo"
        case deviceType = "DeviceType"
        case macAddress = "MacAddress"
        case networkProfileInfo = "NetworkProfileInfo"
        case roomArn = "RoomArn"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceSerialNumber = deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceStatusInfo = deviceStatusInfo {
            try encodeContainer.encode(deviceStatusInfo, forKey: .deviceStatusInfo)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let networkProfileInfo = networkProfileInfo {
            try encodeContainer.encode(networkProfileInfo, forKey: .networkProfileInfo)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let deviceStatusInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatusInfo.self, forKey: .deviceStatusInfo)
        deviceStatusInfo = deviceStatusInfoDecoded
        let networkProfileInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceNetworkProfileInfo.self, forKey: .networkProfileInfo)
        networkProfileInfo = networkProfileInfoDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A device with attributes.
    public struct Device: Swift.Equatable {
        /// The ARN of a device.
        public var deviceArn: Swift.String?
        /// The name of a device.
        public var deviceName: Swift.String?
        /// The serial number of a device.
        public var deviceSerialNumber: Swift.String?
        /// The status of a device. If the status is not READY, check the DeviceStatusInfo value for details.
        public var deviceStatus: AlexaForBusinessClientTypes.DeviceStatus?
        /// Detailed information about a device's status.
        public var deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo?
        /// The type of a device.
        public var deviceType: Swift.String?
        /// The MAC address of a device.
        public var macAddress: Swift.String?
        /// Detailed information about a device's network profile.
        public var networkProfileInfo: AlexaForBusinessClientTypes.DeviceNetworkProfileInfo?
        /// The room ARN of a device.
        public var roomArn: Swift.String?
        /// The software version of a device.
        public var softwareVersion: Swift.String?

        public init (
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceSerialNumber: Swift.String? = nil,
            deviceStatus: AlexaForBusinessClientTypes.DeviceStatus? = nil,
            deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo? = nil,
            deviceType: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            networkProfileInfo: AlexaForBusinessClientTypes.DeviceNetworkProfileInfo? = nil,
            roomArn: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileInfo = networkProfileInfo
            self.roomArn = roomArn
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.DeviceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdTime = "CreatedTime"
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
        case deviceSerialNumber = "DeviceSerialNumber"
        case deviceStatus = "DeviceStatus"
        case deviceStatusInfo = "DeviceStatusInfo"
        case deviceType = "DeviceType"
        case macAddress = "MacAddress"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let deviceSerialNumber = deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let deviceStatus = deviceStatus {
            try encodeContainer.encode(deviceStatus.rawValue, forKey: .deviceStatus)
        }
        if let deviceStatusInfo = deviceStatusInfo {
            try encodeContainer.encode(deviceStatusInfo, forKey: .deviceStatusInfo)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let deviceStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatus.self, forKey: .deviceStatus)
        deviceStatus = deviceStatusDecoded
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let deviceStatusInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatusInfo.self, forKey: .deviceStatusInfo)
        deviceStatusInfo = deviceStatusInfoDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Device attributes.
    public struct DeviceData: Swift.Equatable {
        /// The time (in epoch) when the device data was created.
        public var createdTime: ClientRuntime.Date?
        /// The ARN of a device.
        public var deviceArn: Swift.String?
        /// The name of a device.
        public var deviceName: Swift.String?
        /// The serial number of a device.
        public var deviceSerialNumber: Swift.String?
        /// The status of a device.
        public var deviceStatus: AlexaForBusinessClientTypes.DeviceStatus?
        /// Detailed information about a device's status.
        public var deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo?
        /// The type of a device.
        public var deviceType: Swift.String?
        /// The MAC address of a device.
        public var macAddress: Swift.String?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The room ARN associated with a device.
        public var roomArn: Swift.String?
        /// The name of the room associated with a device.
        public var roomName: Swift.String?
        /// The software version of a device.
        public var softwareVersion: Swift.String?

        public init (
            createdTime: ClientRuntime.Date? = nil,
            deviceArn: Swift.String? = nil,
            deviceName: Swift.String? = nil,
            deviceSerialNumber: Swift.String? = nil,
            deviceStatus: AlexaForBusinessClientTypes.DeviceStatus? = nil,
            deviceStatusInfo: AlexaForBusinessClientTypes.DeviceStatusInfo? = nil,
            deviceType: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.createdTime = createdTime
            self.deviceArn = deviceArn
            self.deviceName = deviceName
            self.deviceSerialNumber = deviceSerialNumber
            self.deviceStatus = deviceStatus
            self.deviceStatusInfo = deviceStatusInfo
            self.deviceType = deviceType
            self.macAddress = macAddress
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.roomArn = roomArn
            self.roomName = roomName
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.DeviceEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp = "Timestamp"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceEventType.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The list of device events.
    public struct DeviceEvent: Swift.Equatable {
        /// The time (in epoch) when the event occurred.
        public var timestamp: ClientRuntime.Date?
        /// The type of device event.
        public var type: AlexaForBusinessClientTypes.DeviceEventType?
        /// The value of the event.
        public var value: Swift.String?

        public init (
            timestamp: ClientRuntime.Date? = nil,
            type: AlexaForBusinessClientTypes.DeviceEventType? = nil,
            value: Swift.String? = nil
        )
        {
            self.timestamp = timestamp
            self.type = type
            self.value = value
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum DeviceEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionStatus
        case deviceStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceEventType] {
            return [
                .connectionStatus,
                .deviceStatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionStatus: return "CONNECTION_STATUS"
            case .deviceStatus: return "DEVICE_STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceEventType(rawValue: rawValue) ?? DeviceEventType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceNetworkProfileInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case certificateExpirationTime = "CertificateExpirationTime"
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let certificateExpirationTime = certificateExpirationTime {
            try encodeContainer.encode(certificateExpirationTime.timeIntervalSince1970, forKey: .certificateExpirationTime)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let certificateExpirationTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .certificateExpirationTime)
        certificateExpirationTime = certificateExpirationTimeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Detailed information about a device's network profile.
    public struct DeviceNetworkProfileInfo: Swift.Equatable {
        /// The ARN of the certificate associated with a device.
        public var certificateArn: Swift.String?
        /// The time (in epoch) when the certificate expires.
        public var certificateExpirationTime: ClientRuntime.Date?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            certificateExpirationTime: ClientRuntime.Date? = nil,
            networkProfileArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.certificateExpirationTime = certificateExpirationTime
            self.networkProfileArn = networkProfileArn
        }
    }

}

extension DeviceNotRegisteredException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeviceNotRegisteredExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request failed because this device is no longer registered and therefore no longer managed by this account.
public struct DeviceNotRegisteredException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceNotRegisteredExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceNotRegisteredExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistered
        case failed
        case pending
        case ready
        case wasOffline
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .deregistered,
                .failed,
                .pending,
                .ready,
                .wasOffline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistered: return "DEREGISTERED"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .ready: return "READY"
            case .wasOffline: return "WAS_OFFLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceStatusDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case feature = "Feature"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let feature = feature {
            try encodeContainer.encode(feature.rawValue, forKey: .feature)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Feature.self, forKey: .feature)
        feature = featureDecoded
        let codeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceStatusDetailCode.self, forKey: .code)
        code = codeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Details of a devices status.
    public struct DeviceStatusDetail: Swift.Equatable {
        /// The device status detail code.
        public var code: AlexaForBusinessClientTypes.DeviceStatusDetailCode?
        /// The list of available features on the device.
        public var feature: AlexaForBusinessClientTypes.Feature?

        public init (
            code: AlexaForBusinessClientTypes.DeviceStatusDetailCode? = nil,
            feature: AlexaForBusinessClientTypes.Feature? = nil
        )
        {
            self.code = code
            self.feature = feature
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum DeviceStatusDetailCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associationRejection
        case authenticationFailure
        case certificateAuthorityAccessDenied
        case certificateIssuingLimitExceeded
        case credentialsAccessFailure
        case deviceSoftwareUpdateNeeded
        case deviceWasOffline
        case dhcpFailure
        case dnsFailure
        case internetUnavailable
        case invalidCertificateAuthority
        case invalidPasswordState
        case networkProfileNotFound
        case passwordManagerAccessDenied
        case passwordNotFound
        case tlsVersionMismatch
        case unknownFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatusDetailCode] {
            return [
                .associationRejection,
                .authenticationFailure,
                .certificateAuthorityAccessDenied,
                .certificateIssuingLimitExceeded,
                .credentialsAccessFailure,
                .deviceSoftwareUpdateNeeded,
                .deviceWasOffline,
                .dhcpFailure,
                .dnsFailure,
                .internetUnavailable,
                .invalidCertificateAuthority,
                .invalidPasswordState,
                .networkProfileNotFound,
                .passwordManagerAccessDenied,
                .passwordNotFound,
                .tlsVersionMismatch,
                .unknownFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associationRejection: return "ASSOCIATION_REJECTION"
            case .authenticationFailure: return "AUTHENTICATION_FAILURE"
            case .certificateAuthorityAccessDenied: return "CERTIFICATE_AUTHORITY_ACCESS_DENIED"
            case .certificateIssuingLimitExceeded: return "CERTIFICATE_ISSUING_LIMIT_EXCEEDED"
            case .credentialsAccessFailure: return "CREDENTIALS_ACCESS_FAILURE"
            case .deviceSoftwareUpdateNeeded: return "DEVICE_SOFTWARE_UPDATE_NEEDED"
            case .deviceWasOffline: return "DEVICE_WAS_OFFLINE"
            case .dhcpFailure: return "DHCP_FAILURE"
            case .dnsFailure: return "DNS_FAILURE"
            case .internetUnavailable: return "INTERNET_UNAVAILABLE"
            case .invalidCertificateAuthority: return "INVALID_CERTIFICATE_AUTHORITY"
            case .invalidPasswordState: return "INVALID_PASSWORD_STATE"
            case .networkProfileNotFound: return "NETWORK_PROFILE_NOT_FOUND"
            case .passwordManagerAccessDenied: return "PASSWORD_MANAGER_ACCESS_DENIED"
            case .passwordNotFound: return "PASSWORD_NOT_FOUND"
            case .tlsVersionMismatch: return "TLS_VERSION_MISMATCH"
            case .unknownFailure: return "UNKNOWN_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatusDetailCode(rawValue: rawValue) ?? DeviceStatusDetailCode.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.DeviceStatusInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionStatus = "ConnectionStatus"
        case connectionStatusUpdatedTime = "ConnectionStatusUpdatedTime"
        case deviceStatusDetails = "DeviceStatusDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionStatus = connectionStatus {
            try encodeContainer.encode(connectionStatus.rawValue, forKey: .connectionStatus)
        }
        if let connectionStatusUpdatedTime = connectionStatusUpdatedTime {
            try encodeContainer.encode(connectionStatusUpdatedTime.timeIntervalSince1970, forKey: .connectionStatusUpdatedTime)
        }
        if let deviceStatusDetails = deviceStatusDetails {
            var deviceStatusDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .deviceStatusDetails)
            for devicestatusdetails0 in deviceStatusDetails {
                try deviceStatusDetailsContainer.encode(devicestatusdetails0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceStatusDetailsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.DeviceStatusDetail?].self, forKey: .deviceStatusDetails)
        var deviceStatusDetailsDecoded0:[AlexaForBusinessClientTypes.DeviceStatusDetail]? = nil
        if let deviceStatusDetailsContainer = deviceStatusDetailsContainer {
            deviceStatusDetailsDecoded0 = [AlexaForBusinessClientTypes.DeviceStatusDetail]()
            for structure0 in deviceStatusDetailsContainer {
                if let structure0 = structure0 {
                    deviceStatusDetailsDecoded0?.append(structure0)
                }
            }
        }
        deviceStatusDetails = deviceStatusDetailsDecoded0
        let connectionStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConnectionStatus.self, forKey: .connectionStatus)
        connectionStatus = connectionStatusDecoded
        let connectionStatusUpdatedTimeDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .connectionStatusUpdatedTime)
        connectionStatusUpdatedTime = connectionStatusUpdatedTimeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Detailed information about a device's status.
    public struct DeviceStatusInfo: Swift.Equatable {
        /// The latest available information about the connection status of a device.
        public var connectionStatus: AlexaForBusinessClientTypes.ConnectionStatus?
        /// The time (in epoch) when the device connection status changed.
        public var connectionStatusUpdatedTime: ClientRuntime.Date?
        /// One or more device status detail descriptions.
        public var deviceStatusDetails: [AlexaForBusinessClientTypes.DeviceStatusDetail]?

        public init (
            connectionStatus: AlexaForBusinessClientTypes.ConnectionStatus? = nil,
            connectionStatusUpdatedTime: ClientRuntime.Date? = nil,
            deviceStatusDetails: [AlexaForBusinessClientTypes.DeviceStatusDetail]? = nil
        )
        {
            self.connectionStatus = connectionStatus
            self.connectionStatusUpdatedTime = connectionStatusUpdatedTime
            self.deviceStatusDetails = deviceStatusDetails
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum DeviceUsageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceUsageType] {
            return [
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceUsageType(rawValue: rawValue) ?? DeviceUsageType.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateContactFromAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension DisassociateContactFromAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateContactFromAddressBookInput: Swift.Equatable {
    /// The ARN of the address from which to disassociate the contact.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The ARN of the contact to disassociate from an address book.
    /// This member is required.
    public var contactArn: Swift.String?

    public init (
        addressBookArn: Swift.String? = nil,
        contactArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.contactArn = contactArn
    }
}

struct DisassociateContactFromAddressBookInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let addressBookArn: Swift.String?
}

extension DisassociateContactFromAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension DisassociateContactFromAddressBookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateContactFromAddressBookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateContactFromAddressBookOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateContactFromAddressBookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateContactFromAddressBookOutputResponse: Swift.Equatable {

}

extension DisassociateDeviceFromRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

extension DisassociateDeviceFromRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateDeviceFromRoomInput: Swift.Equatable {
    /// The ARN of the device to disassociate from a room. Required.
    public var deviceArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct DisassociateDeviceFromRoomInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension DisassociateDeviceFromRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension DisassociateDeviceFromRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateDeviceFromRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateDeviceFromRoomOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateDeviceFromRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateDeviceFromRoomOutputResponse: Swift.Equatable {

}

extension DisassociateSkillFromSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DisassociateSkillFromSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateSkillFromSkillGroupInput: Swift.Equatable {
    /// The unique identifier of a skill. Required.
    public var skillGroupArn: Swift.String?
    /// The ARN of a skill group to associate to a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        skillGroupArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
        self.skillId = skillId
    }
}

struct DisassociateSkillFromSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let skillId: Swift.String?
}

extension DisassociateSkillFromSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension DisassociateSkillFromSkillGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSkillFromSkillGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSkillFromSkillGroupOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSkillFromSkillGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSkillFromSkillGroupOutputResponse: Swift.Equatable {

}

extension DisassociateSkillFromUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension DisassociateSkillFromUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateSkillFromUsersInput: Swift.Equatable {
    /// The private skill ID you want to make unavailable for enrolled users.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct DisassociateSkillFromUsersInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension DisassociateSkillFromUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension DisassociateSkillFromUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSkillFromUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSkillFromUsersOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSkillFromUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSkillFromUsersOutputResponse: Swift.Equatable {

}

extension DisassociateSkillGroupFromRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension DisassociateSkillGroupFromRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateSkillGroupFromRoomInput: Swift.Equatable {
    /// The ARN of the room from which the skill group is to be disassociated. Required.
    public var roomArn: Swift.String?
    /// The ARN of the skill group to disassociate from a room. Required.
    public var skillGroupArn: Swift.String?

    public init (
        roomArn: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.skillGroupArn = skillGroupArn
    }
}

struct DisassociateSkillGroupFromRoomInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let roomArn: Swift.String?
}

extension DisassociateSkillGroupFromRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension DisassociateSkillGroupFromRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateSkillGroupFromRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateSkillGroupFromRoomOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateSkillGroupFromRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateSkillGroupFromRoomOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes {
    public enum DistanceUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imperial
        case metric
        case sdkUnknown(Swift.String)

        public static var allCases: [DistanceUnit] {
            return [
                .imperial,
                .metric,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imperial: return "IMPERIAL"
            case .metric: return "METRIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DistanceUnit(rawValue: rawValue) ?? DistanceUnit.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum EnablementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementType] {
            return [
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnablementType(rawValue: rawValue) ?? EnablementType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum EnablementTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [EnablementTypeFilter] {
            return [
                .enabled,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnablementTypeFilter(rawValue: rawValue) ?? EnablementTypeFilter.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.EndOfMeetingReminder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for endofmeetingreminderminuteslist0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(endofmeetingreminderminuteslist0)
            }
        }
        if let reminderType = reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Swift.Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Swift.Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct EndOfMeetingReminder: Swift.Equatable {
        /// Whether an end of meeting reminder is enabled or not.
        public var enabled: Swift.Bool?
        /// A range of 3 to 15 minutes that determines when the reminder begins.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init (
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum EndOfMeetingReminderType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case announcementTimeCheck
        case announcementVariableTimeLeft
        case chime
        case knock
        case sdkUnknown(Swift.String)

        public static var allCases: [EndOfMeetingReminderType] {
            return [
                .announcementTimeCheck,
                .announcementVariableTimeLeft,
                .chime,
                .knock,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .announcementTimeCheck: return "ANNOUNCEMENT_TIME_CHECK"
            case .announcementVariableTimeLeft: return "ANNOUNCEMENT_VARIABLE_TIME_LEFT"
            case .chime: return "CHIME"
            case .knock: return "KNOCK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndOfMeetingReminderType(rawValue: rawValue) ?? EndOfMeetingReminderType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum EnrollmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deregistering
        case disassociating
        case initialized
        case pending
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [EnrollmentStatus] {
            return [
                .deregistering,
                .disassociating,
                .initialized,
                .pending,
                .registered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deregistering: return "DEREGISTERING"
            case .disassociating: return "DISASSOCIATING"
            case .initialized: return "INITIALIZED"
            case .pending: return "PENDING"
            case .registered: return "REGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnrollmentStatus(rawValue: rawValue) ?? EnrollmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum Feature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case bluetooth
        case lists
        case networkProfile
        case notifications
        case settings
        case skills
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [Feature] {
            return [
                .all,
                .bluetooth,
                .lists,
                .networkProfile,
                .notifications,
                .settings,
                .skills,
                .volume,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .bluetooth: return "BLUETOOTH"
            case .lists: return "LISTS"
            case .networkProfile: return "NETWORK_PROFILE"
            case .notifications: return "NOTIFICATIONS"
            case .settings: return "SETTINGS"
            case .skills: return "SKILLS"
            case .volume: return "VOLUME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Feature(rawValue: rawValue) ?? Feature.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case values = "Values"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for filtervaluelist0 in values {
                try valuesContainer.encode(filtervaluelist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AlexaForBusinessClientTypes {
    /// A filter name and value pair that is used to return a more specific list of results. Filters can be used to match a set of resources by various criteria.
    public struct Filter: Swift.Equatable {
        /// The key of a filter.
        /// This member is required.
        public var key: Swift.String?
        /// The values of a filter.
        /// This member is required.
        public var values: [Swift.String]?

        public init (
            key: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.values = values
        }
    }

}

extension ForgetSmartHomeAppliancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension ForgetSmartHomeAppliancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ForgetSmartHomeAppliancesInput: Swift.Equatable {
    /// The room that the appliances are associated with.
    /// This member is required.
    public var roomArn: Swift.String?

    public init (
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct ForgetSmartHomeAppliancesInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension ForgetSmartHomeAppliancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension ForgetSmartHomeAppliancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ForgetSmartHomeAppliancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ForgetSmartHomeAppliancesOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ForgetSmartHomeAppliancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ForgetSmartHomeAppliancesOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.Gateway: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The details of the gateway.
    public struct Gateway: Swift.Equatable {
        /// The ARN of the gateway.
        public var arn: Swift.String?
        /// The description of the gateway.
        public var description: Swift.String?
        /// The ARN of the gateway group that the gateway is associated to.
        public var gatewayGroupArn: Swift.String?
        /// The name of the gateway.
        public var name: Swift.String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public var softwareVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            gatewayGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }
    }

}

extension AlexaForBusinessClientTypes.GatewayGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The details of the gateway group.
    public struct GatewayGroup: Swift.Equatable {
        /// The ARN of the gateway group.
        public var arn: Swift.String?
        /// The description of the gateway group.
        public var description: Swift.String?
        /// The name of the gateway group.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.GatewayGroupSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of a gateway group.
    public struct GatewayGroupSummary: Swift.Equatable {
        /// The ARN of the gateway group.
        public var arn: Swift.String?
        /// The description of the gateway group.
        public var description: Swift.String?
        /// The name of the gateway group.
        public var name: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.name = name
        }
    }

}

extension AlexaForBusinessClientTypes.GatewaySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of a gateway.
    public struct GatewaySummary: Swift.Equatable {
        /// The ARN of the gateway.
        public var arn: Swift.String?
        /// The description of the gateway.
        public var description: Swift.String?
        /// The ARN of the gateway group that the gateway is associated to.
        public var gatewayGroupArn: Swift.String?
        /// The name of the gateway.
        public var name: Swift.String?
        /// The software version of the gateway. The gateway automatically updates its software version during normal operation.
        public var softwareVersion: Swift.String?

        public init (
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            gatewayGroupArn: Swift.String? = nil,
            name: Swift.String? = nil,
            softwareVersion: Swift.String? = nil
        )
        {
            self.arn = arn
            self.description = description
            self.gatewayGroupArn = gatewayGroupArn
            self.name = name
            self.softwareVersion = softwareVersion
        }
    }

}

extension GetAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
    }
}

extension GetAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAddressBookInput: Swift.Equatable {
    /// The ARN of the address book for which to request details.
    /// This member is required.
    public var addressBookArn: Swift.String?

    public init (
        addressBookArn: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
    }
}

struct GetAddressBookInputBody: Swift.Equatable {
    let addressBookArn: Swift.String?
}

extension GetAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
    }
}

extension GetAddressBookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAddressBookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAddressBookOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAddressBookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAddressBookOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressBook = output.addressBook
        } else {
            self.addressBook = nil
        }
    }
}

public struct GetAddressBookOutputResponse: Swift.Equatable {
    /// The details of the requested address book.
    public var addressBook: AlexaForBusinessClientTypes.AddressBook?

    public init (
        addressBook: AlexaForBusinessClientTypes.AddressBook? = nil
    )
    {
        self.addressBook = addressBook
    }
}

struct GetAddressBookOutputResponseBody: Swift.Equatable {
    let addressBook: AlexaForBusinessClientTypes.AddressBook?
}

extension GetAddressBookOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBook = "AddressBook"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.AddressBook.self, forKey: .addressBook)
        addressBook = addressBookDecoded
    }
}

extension GetConferencePreferenceInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetConferencePreferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConferencePreferenceInput: Swift.Equatable {

}

struct GetConferencePreferenceInputBody: Swift.Equatable {
}

extension GetConferencePreferenceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetConferencePreferenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConferencePreferenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConferencePreferenceOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConferencePreferenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConferencePreferenceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.preference = output.preference
        } else {
            self.preference = nil
        }
    }
}

public struct GetConferencePreferenceOutputResponse: Swift.Equatable {
    /// The conference preference.
    public var preference: AlexaForBusinessClientTypes.ConferencePreference?

    public init (
        preference: AlexaForBusinessClientTypes.ConferencePreference? = nil
    )
    {
        self.preference = preference
    }
}

struct GetConferencePreferenceOutputResponseBody: Swift.Equatable {
    let preference: AlexaForBusinessClientTypes.ConferencePreference?
}

extension GetConferencePreferenceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case preference = "Preference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let preferenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferencePreference.self, forKey: .preference)
        preference = preferenceDecoded
    }
}

extension GetConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
    }
}

extension GetConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConferenceProviderInput: Swift.Equatable {
    /// The ARN of the newly created conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?

    public init (
        conferenceProviderArn: Swift.String? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
    }
}

struct GetConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
}

extension GetConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
    }
}

extension GetConferenceProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConferenceProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConferenceProviderOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConferenceProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetConferenceProviderOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conferenceProvider = output.conferenceProvider
        } else {
            self.conferenceProvider = nil
        }
    }
}

public struct GetConferenceProviderOutputResponse: Swift.Equatable {
    /// The conference provider.
    public var conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider?

    public init (
        conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider? = nil
    )
    {
        self.conferenceProvider = conferenceProvider
    }
}

struct GetConferenceProviderOutputResponseBody: Swift.Equatable {
    let conferenceProvider: AlexaForBusinessClientTypes.ConferenceProvider?
}

extension GetConferenceProviderOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProvider = "ConferenceProvider"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProvider.self, forKey: .conferenceProvider)
        conferenceProvider = conferenceProviderDecoded
    }
}

extension GetContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension GetContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactInput: Swift.Equatable {
    /// The ARN of the contact for which to request details.
    /// This member is required.
    public var contactArn: Swift.String?

    public init (
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct GetContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension GetContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension GetContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetContactOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetContactOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contact = output.contact
        } else {
            self.contact = nil
        }
    }
}

public struct GetContactOutputResponse: Swift.Equatable {
    /// The details of the requested contact.
    public var contact: AlexaForBusinessClientTypes.Contact?

    public init (
        contact: AlexaForBusinessClientTypes.Contact? = nil
    )
    {
        self.contact = contact
    }
}

struct GetContactOutputResponseBody: Swift.Equatable {
    let contact: AlexaForBusinessClientTypes.Contact?
}

extension GetContactOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contact = "Contact"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Contact.self, forKey: .contact)
        contact = contactDecoded
    }
}

extension GetDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
    }
}

extension GetDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDeviceInput: Swift.Equatable {
    /// The ARN of the device for which to request details. Required.
    public var deviceArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct GetDeviceInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension GetDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension GetDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDeviceOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct GetDeviceOutputResponse: Swift.Equatable {
    /// The details of the device requested. Required.
    public var device: AlexaForBusinessClientTypes.Device?

    public init (
        device: AlexaForBusinessClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputResponseBody: Swift.Equatable {
    let device: AlexaForBusinessClientTypes.Device?
}

extension GetDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device = "Device"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension GetGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
    }
}

extension GetGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGatewayGroupInput: Swift.Equatable {
    /// The ARN of the gateway group to get.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?

    public init (
        gatewayGroupArn: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
    }
}

struct GetGatewayGroupInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
}

extension GetGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
    }
}

extension GetGatewayGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayGroupOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGatewayGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayGroup = output.gatewayGroup
        } else {
            self.gatewayGroup = nil
        }
    }
}

public struct GetGatewayGroupOutputResponse: Swift.Equatable {
    /// The details of the gateway group.
    public var gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup?

    public init (
        gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup? = nil
    )
    {
        self.gatewayGroup = gatewayGroup
    }
}

struct GetGatewayGroupOutputResponseBody: Swift.Equatable {
    let gatewayGroup: AlexaForBusinessClientTypes.GatewayGroup?
}

extension GetGatewayGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroup = "GatewayGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.GatewayGroup.self, forKey: .gatewayGroup)
        gatewayGroup = gatewayGroupDecoded
    }
}

extension GetGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayArn = gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
    }
}

extension GetGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetGatewayInput: Swift.Equatable {
    /// The ARN of the gateway to get.
    /// This member is required.
    public var gatewayArn: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
    }
}

struct GetGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
}

extension GetGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn = "GatewayArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension GetGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGatewayOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gateway = output.gateway
        } else {
            self.gateway = nil
        }
    }
}

public struct GetGatewayOutputResponse: Swift.Equatable {
    /// The details of the gateway.
    public var gateway: AlexaForBusinessClientTypes.Gateway?

    public init (
        gateway: AlexaForBusinessClientTypes.Gateway? = nil
    )
    {
        self.gateway = gateway
    }
}

struct GetGatewayOutputResponseBody: Swift.Equatable {
    let gateway: AlexaForBusinessClientTypes.Gateway?
}

extension GetGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateway = "Gateway"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Gateway.self, forKey: .gateway)
        gateway = gatewayDecoded
    }
}

extension GetInvitationConfigurationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetInvitationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInvitationConfigurationInput: Swift.Equatable {

}

struct GetInvitationConfigurationInputBody: Swift.Equatable {
}

extension GetInvitationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInvitationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInvitationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInvitationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contactEmail = output.contactEmail
            self.organizationName = output.organizationName
            self.privateSkillIds = output.privateSkillIds
        } else {
            self.contactEmail = nil
            self.organizationName = nil
            self.privateSkillIds = nil
        }
    }
}

public struct GetInvitationConfigurationOutputResponse: Swift.Equatable {
    /// The email ID of the organization or individual contact that the enrolled user can use.
    public var contactEmail: Swift.String?
    /// The name of the organization sending the enrollment invite to a user.
    public var organizationName: Swift.String?
    /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
    public var privateSkillIds: [Swift.String]?

    public init (
        contactEmail: Swift.String? = nil,
        organizationName: Swift.String? = nil,
        privateSkillIds: [Swift.String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

struct GetInvitationConfigurationOutputResponseBody: Swift.Equatable {
    let organizationName: Swift.String?
    let contactEmail: Swift.String?
    let privateSkillIds: [Swift.String]?
}

extension GetInvitationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let contactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactEmail)
        contactEmail = contactEmailDecoded
        let privateSkillIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .privateSkillIds)
        var privateSkillIdsDecoded0:[Swift.String]? = nil
        if let privateSkillIdsContainer = privateSkillIdsContainer {
            privateSkillIdsDecoded0 = [Swift.String]()
            for string0 in privateSkillIdsContainer {
                if let string0 = string0 {
                    privateSkillIdsDecoded0?.append(string0)
                }
            }
        }
        privateSkillIds = privateSkillIdsDecoded0
    }
}

extension GetNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
    }
}

extension GetNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetNetworkProfileInput: Swift.Equatable {
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?

    public init (
        networkProfileArn: Swift.String? = nil
    )
    {
        self.networkProfileArn = networkProfileArn
    }
}

struct GetNetworkProfileInputBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
}

extension GetNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfileArn = "NetworkProfileArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
    }
}

extension GetNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidSecretsManagerResourceException" : self = .invalidSecretsManagerResourceException(try InvalidSecretsManagerResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case invalidSecretsManagerResourceException(InvalidSecretsManagerResourceException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetNetworkProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfile = output.networkProfile
        } else {
            self.networkProfile = nil
        }
    }
}

public struct GetNetworkProfileOutputResponse: Swift.Equatable {
    /// The network profile associated with a device.
    public var networkProfile: AlexaForBusinessClientTypes.NetworkProfile?

    public init (
        networkProfile: AlexaForBusinessClientTypes.NetworkProfile? = nil
    )
    {
        self.networkProfile = networkProfile
    }
}

struct GetNetworkProfileOutputResponseBody: Swift.Equatable {
    let networkProfile: AlexaForBusinessClientTypes.NetworkProfile?
}

extension GetNetworkProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfile = "NetworkProfile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkProfile.self, forKey: .networkProfile)
        networkProfile = networkProfileDecoded
    }
}

extension GetProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
    }
}

extension GetProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetProfileInput: Swift.Equatable {
    /// The ARN of the room profile for which to request details. Required.
    public var profileArn: Swift.String?

    public init (
        profileArn: Swift.String? = nil
    )
    {
        self.profileArn = profileArn
    }
}

struct GetProfileInputBody: Swift.Equatable {
    let profileArn: Swift.String?
}

extension GetProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profileArn = "ProfileArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension GetProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProfileOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetProfileOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.profile = output.profile
        } else {
            self.profile = nil
        }
    }
}

public struct GetProfileOutputResponse: Swift.Equatable {
    /// The details of the room profile requested. Required.
    public var profile: AlexaForBusinessClientTypes.Profile?

    public init (
        profile: AlexaForBusinessClientTypes.Profile? = nil
    )
    {
        self.profile = profile
    }
}

struct GetProfileOutputResponseBody: Swift.Equatable {
    let profile: AlexaForBusinessClientTypes.Profile?
}

extension GetProfileOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case profile = "Profile"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Profile.self, forKey: .profile)
        profile = profileDecoded
    }
}

extension GetRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension GetRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoomInput: Swift.Equatable {
    /// The ARN of the room for which to request details. Required.
    public var roomArn: Swift.String?

    public init (
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct GetRoomInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension GetRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension GetRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoomOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.room = output.room
        } else {
            self.room = nil
        }
    }
}

public struct GetRoomOutputResponse: Swift.Equatable {
    /// The details of the room requested.
    public var room: AlexaForBusinessClientTypes.Room?

    public init (
        room: AlexaForBusinessClientTypes.Room? = nil
    )
    {
        self.room = room
    }
}

struct GetRoomOutputResponseBody: Swift.Equatable {
    let room: AlexaForBusinessClientTypes.Room?
}

extension GetRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case room = "Room"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Room.self, forKey: .room)
        room = roomDecoded
    }
}

extension GetRoomSkillParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension GetRoomSkillParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRoomSkillParameterInput: Swift.Equatable {
    /// The room skill parameter key for which to get details. Required.
    /// This member is required.
    public var parameterKey: Swift.String?
    /// The ARN of the room from which to get the room skill parameter details.
    public var roomArn: Swift.String?
    /// The ARN of the skill from which to get the room skill parameter details. Required.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        parameterKey: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.parameterKey = parameterKey
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct GetRoomSkillParameterInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let skillId: Swift.String?
    let parameterKey: Swift.String?
}

extension GetRoomSkillParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
    }
}

extension GetRoomSkillParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRoomSkillParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRoomSkillParameterOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRoomSkillParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetRoomSkillParameterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.roomSkillParameter = output.roomSkillParameter
        } else {
            self.roomSkillParameter = nil
        }
    }
}

public struct GetRoomSkillParameterOutputResponse: Swift.Equatable {
    /// The details of the room skill parameter requested. Required.
    public var roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?

    public init (
        roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter? = nil
    )
    {
        self.roomSkillParameter = roomSkillParameter
    }
}

struct GetRoomSkillParameterOutputResponseBody: Swift.Equatable {
    let roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?
}

extension GetRoomSkillParameterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomSkillParameter = "RoomSkillParameter"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomSkillParameterDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RoomSkillParameter.self, forKey: .roomSkillParameter)
        roomSkillParameter = roomSkillParameterDecoded
    }
}

extension GetSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
    }
}

extension GetSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetSkillGroupInput: Swift.Equatable {
    /// The ARN of the skill group for which to get details. Required.
    public var skillGroupArn: Swift.String?

    public init (
        skillGroupArn: Swift.String? = nil
    )
    {
        self.skillGroupArn = skillGroupArn
    }
}

struct GetSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
}

extension GetSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroupArn = "SkillGroupArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
    }
}

extension GetSkillGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSkillGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSkillGroupOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSkillGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetSkillGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.skillGroup = output.skillGroup
        } else {
            self.skillGroup = nil
        }
    }
}

public struct GetSkillGroupOutputResponse: Swift.Equatable {
    /// The details of the skill group requested. Required.
    public var skillGroup: AlexaForBusinessClientTypes.SkillGroup?

    public init (
        skillGroup: AlexaForBusinessClientTypes.SkillGroup? = nil
    )
    {
        self.skillGroup = skillGroup
    }
}

struct GetSkillGroupOutputResponseBody: Swift.Equatable {
    let skillGroup: AlexaForBusinessClientTypes.SkillGroup?
}

extension GetSkillGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillGroup = "SkillGroup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillGroup.self, forKey: .skillGroup)
        skillGroup = skillGroupDecoded
    }
}

extension AlexaForBusinessClientTypes.IPDialIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commsProtocol = "CommsProtocol"
        case endpoint = "Endpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commsProtocol = commsProtocol {
            try encodeContainer.encode(commsProtocol.rawValue, forKey: .commsProtocol)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let commsProtocolDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.CommsProtocol.self, forKey: .commsProtocol)
        commsProtocol = commsProtocolDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The IP endpoint and protocol for calling.
    public struct IPDialIn: Swift.Equatable {
        /// The protocol, including SIP, SIPS, and H323.
        /// This member is required.
        public var commsProtocol: AlexaForBusinessClientTypes.CommsProtocol?
        /// The IP address.
        /// This member is required.
        public var endpoint: Swift.String?

        public init (
            commsProtocol: AlexaForBusinessClientTypes.CommsProtocol? = nil,
            endpoint: Swift.String? = nil
        )
        {
            self.commsProtocol = commsProtocol
            self.endpoint = endpoint
        }
    }

}

extension AlexaForBusinessClientTypes.InstantBooking: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the instant booking feature that are applied to a room profile. When users start their meeting with Alexa, Alexa automatically books the room for the configured duration if the room is available.
    public struct InstantBooking: Swift.Equatable {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        public var enabled: Swift.Bool?

        public init (
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension InvalidCertificateAuthorityException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidCertificateAuthorityExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Certificate Authority can't issue or revoke a certificate.
public struct InvalidCertificateAuthorityException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidCertificateAuthorityExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidCertificateAuthorityExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeviceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidDeviceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The device is in an invalid state.
public struct InvalidDeviceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeviceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeviceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecretsManagerResourceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidSecretsManagerResourceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A password in SecretsManager is in an invalid state.
public struct InvalidSecretsManagerResourceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidSecretsManagerResourceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidSecretsManagerResourceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidServiceLinkedRoleStateException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidServiceLinkedRoleStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The service linked role is locked for deletion.
public struct InvalidServiceLinkedRoleStateException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidServiceLinkedRoleStateExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidServiceLinkedRoleStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidUserStatusException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidUserStatusExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The attempt to update a user is invalid due to the user's current status.
public struct InvalidUserStatusException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidUserStatusExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidUserStatusExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are performing an action that would put you beyond your account's limits.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBusinessReportSchedulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListBusinessReportSchedulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListBusinessReportSchedulesInput: Swift.Equatable {
    /// The maximum number of schedules listed in the call.
    public var maxResults: Swift.Int?
    /// The token used to list the remaining schedules from the previous API call.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBusinessReportSchedulesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListBusinessReportSchedulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListBusinessReportSchedulesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBusinessReportSchedulesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListBusinessReportSchedulesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBusinessReportSchedulesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListBusinessReportSchedulesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.businessReportSchedules = output.businessReportSchedules
            self.nextToken = output.nextToken
        } else {
            self.businessReportSchedules = nil
            self.nextToken = nil
        }
    }
}

public struct ListBusinessReportSchedulesOutputResponse: Swift.Equatable {
    /// The schedule of the reports.
    public var businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]?
    /// The token used to list the remaining schedules from the previous API call.
    public var nextToken: Swift.String?

    public init (
        businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.businessReportSchedules = businessReportSchedules
        self.nextToken = nextToken
    }
}

struct ListBusinessReportSchedulesOutputResponseBody: Swift.Equatable {
    let businessReportSchedules: [AlexaForBusinessClientTypes.BusinessReportSchedule]?
    let nextToken: Swift.String?
}

extension ListBusinessReportSchedulesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessReportSchedules = "BusinessReportSchedules"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessReportSchedulesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.BusinessReportSchedule?].self, forKey: .businessReportSchedules)
        var businessReportSchedulesDecoded0:[AlexaForBusinessClientTypes.BusinessReportSchedule]? = nil
        if let businessReportSchedulesContainer = businessReportSchedulesContainer {
            businessReportSchedulesDecoded0 = [AlexaForBusinessClientTypes.BusinessReportSchedule]()
            for structure0 in businessReportSchedulesContainer {
                if let structure0 = structure0 {
                    businessReportSchedulesDecoded0?.append(structure0)
                }
            }
        }
        businessReportSchedules = businessReportSchedulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConferenceProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListConferenceProvidersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListConferenceProvidersInput: Swift.Equatable {
    /// The maximum number of conference providers to be returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConferenceProvidersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListConferenceProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListConferenceProvidersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConferenceProvidersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConferenceProvidersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConferenceProvidersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConferenceProvidersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.conferenceProviders = output.conferenceProviders
            self.nextToken = output.nextToken
        } else {
            self.conferenceProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListConferenceProvidersOutputResponse: Swift.Equatable {
    /// The conference providers.
    public var conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init (
        conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.conferenceProviders = conferenceProviders
        self.nextToken = nextToken
    }
}

struct ListConferenceProvidersOutputResponseBody: Swift.Equatable {
    let conferenceProviders: [AlexaForBusinessClientTypes.ConferenceProvider]?
    let nextToken: Swift.String?
}

extension ListConferenceProvidersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviders = "ConferenceProviders"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProvidersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.ConferenceProvider?].self, forKey: .conferenceProviders)
        var conferenceProvidersDecoded0:[AlexaForBusinessClientTypes.ConferenceProvider]? = nil
        if let conferenceProvidersContainer = conferenceProvidersContainer {
            conferenceProvidersDecoded0 = [AlexaForBusinessClientTypes.ConferenceProvider]()
            for structure0 in conferenceProvidersContainer {
                if let structure0 = structure0 {
                    conferenceProvidersDecoded0?.append(structure0)
                }
            }
        }
        conferenceProviders = conferenceProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDeviceEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case eventType = "EventType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListDeviceEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListDeviceEventsInput: Swift.Equatable {
    /// The ARN of a device.
    /// This member is required.
    public var deviceArn: Swift.String?
    /// The event type to filter device events. If EventType isn't specified, this returns a list of all device events in reverse chronological order. If EventType is specified, this returns a list of device events for that EventType in reverse chronological order.
    public var eventType: AlexaForBusinessClientTypes.DeviceEventType?
    /// The maximum number of results to include in the response. The default value is 50. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults. When the end of results is reached, the response has a value of null.
    public var nextToken: Swift.String?

    public init (
        deviceArn: Swift.String? = nil,
        eventType: AlexaForBusinessClientTypes.DeviceEventType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.eventType = eventType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceEventsInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let eventType: AlexaForBusinessClientTypes.DeviceEventType?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListDeviceEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case eventType = "EventType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeviceEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListDeviceEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDeviceEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDeviceEventsOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDeviceEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDeviceEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceEvents = output.deviceEvents
            self.nextToken = output.nextToken
        } else {
            self.deviceEvents = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceEventsOutputResponse: Swift.Equatable {
    /// The device events requested for the device ARN.
    public var deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?

    public init (
        deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceEvents = deviceEvents
        self.nextToken = nextToken
    }
}

struct ListDeviceEventsOutputResponseBody: Swift.Equatable {
    let deviceEvents: [AlexaForBusinessClientTypes.DeviceEvent]?
    let nextToken: Swift.String?
}

extension ListDeviceEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceEvents = "DeviceEvents"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceEventsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.DeviceEvent?].self, forKey: .deviceEvents)
        var deviceEventsDecoded0:[AlexaForBusinessClientTypes.DeviceEvent]? = nil
        if let deviceEventsContainer = deviceEventsContainer {
            deviceEventsDecoded0 = [AlexaForBusinessClientTypes.DeviceEvent]()
            for structure0 in deviceEventsContainer {
                if let structure0 = structure0 {
                    deviceEventsDecoded0?.append(structure0)
                }
            }
        }
        deviceEvents = deviceEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGatewayGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGatewayGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGatewayGroupsInput: Swift.Equatable {
    /// The maximum number of gateway group summaries to return. The default is 50.
    public var maxResults: Swift.Int?
    /// The token used to paginate though multiple pages of gateway group summaries.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewayGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGatewayGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGatewayGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewayGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewayGroupsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewayGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGatewayGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayGroups = output.gatewayGroups
            self.nextToken = output.nextToken
        } else {
            self.gatewayGroups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewayGroupsOutputResponse: Swift.Equatable {
    /// The gateway groups in the list.
    public var gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]?
    /// The token used to paginate though multiple pages of gateway group summaries.
    public var nextToken: Swift.String?

    public init (
        gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayGroups = gatewayGroups
        self.nextToken = nextToken
    }
}

struct ListGatewayGroupsOutputResponseBody: Swift.Equatable {
    let gatewayGroups: [AlexaForBusinessClientTypes.GatewayGroupSummary]?
    let nextToken: Swift.String?
}

extension ListGatewayGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroups = "GatewayGroups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.GatewayGroupSummary?].self, forKey: .gatewayGroups)
        var gatewayGroupsDecoded0:[AlexaForBusinessClientTypes.GatewayGroupSummary]? = nil
        if let gatewayGroupsContainer = gatewayGroupsContainer {
            gatewayGroupsDecoded0 = [AlexaForBusinessClientTypes.GatewayGroupSummary]()
            for structure0 in gatewayGroupsContainer {
                if let structure0 = structure0 {
                    gatewayGroupsDecoded0?.append(structure0)
                }
            }
        }
        gatewayGroups = gatewayGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGatewaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The gateway group ARN for which to list gateways.
    public var gatewayGroupArn: Swift.String?
    /// The maximum number of gateway summaries to return. The default is 50.
    public var maxResults: Swift.Int?
    /// The token used to paginate though multiple pages of gateway summaries.
    public var nextToken: Swift.String?

    public init (
        gatewayGroupArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewayGroupArn = gatewayGroupArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListGatewaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayGroupArn = "GatewayGroupArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewaysOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gateways = output.gateways
            self.nextToken = output.nextToken
        } else {
            self.gateways = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Swift.Equatable {
    /// The gateways in the list.
    public var gateways: [AlexaForBusinessClientTypes.GatewaySummary]?
    /// The token used to paginate though multiple pages of gateway summaries.
    public var nextToken: Swift.String?

    public init (
        gateways: [AlexaForBusinessClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gateways = gateways
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputResponseBody: Swift.Equatable {
    let gateways: [AlexaForBusinessClientTypes.GatewaySummary]?
    let nextToken: Swift.String?
}

extension ListGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gateways = "Gateways"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaysContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.GatewaySummary?].self, forKey: .gateways)
        var gatewaysDecoded0:[AlexaForBusinessClientTypes.GatewaySummary]? = nil
        if let gatewaysContainer = gatewaysContainer {
            gatewaysDecoded0 = [AlexaForBusinessClientTypes.GatewaySummary]()
            for structure0 in gatewaysContainer {
                if let structure0 = structure0 {
                    gatewaysDecoded0?.append(structure0)
                }
            }
        }
        gateways = gatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSkillsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enablementType = "EnablementType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case skillGroupArn = "SkillGroupArn"
        case skillType = "SkillType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enablementType = enablementType {
            try encodeContainer.encode(enablementType.rawValue, forKey: .enablementType)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillType = skillType {
            try encodeContainer.encode(skillType.rawValue, forKey: .skillType)
        }
    }
}

extension ListSkillsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSkillsInput: Swift.Equatable {
    /// Whether the skill is enabled under the user's account.
    public var enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The ARN of the skill group for which to list enabled skills.
    public var skillGroupArn: Swift.String?
    /// Whether the skill is publicly available or is a private skill.
    public var skillType: AlexaForBusinessClientTypes.SkillTypeFilter?

    public init (
        enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil,
        skillType: AlexaForBusinessClientTypes.SkillTypeFilter? = nil
    )
    {
        self.enablementType = enablementType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.skillGroupArn = skillGroupArn
        self.skillType = skillType
    }
}

struct ListSkillsInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let enablementType: AlexaForBusinessClientTypes.EnablementTypeFilter?
    let skillType: AlexaForBusinessClientTypes.SkillTypeFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSkillsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enablementType = "EnablementType"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case skillGroupArn = "SkillGroupArn"
        case skillType = "SkillType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let enablementTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EnablementTypeFilter.self, forKey: .enablementType)
        enablementType = enablementTypeDecoded
        let skillTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillTypeFilter.self, forKey: .skillType)
        skillType = skillTypeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSkillsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSkillsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSkillsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSkillsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.skillSummaries = output.skillSummaries
        } else {
            self.nextToken = nil
            self.skillSummaries = nil
        }
    }
}

public struct ListSkillsOutputResponse: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The list of enabled skills requested. Required.
    public var skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]?

    public init (
        nextToken: Swift.String? = nil,
        skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillSummaries = skillSummaries
    }
}

struct ListSkillsOutputResponseBody: Swift.Equatable {
    let skillSummaries: [AlexaForBusinessClientTypes.SkillSummary]?
    let nextToken: Swift.String?
}

extension ListSkillsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case skillSummaries = "SkillSummaries"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillSummariesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SkillSummary?].self, forKey: .skillSummaries)
        var skillSummariesDecoded0:[AlexaForBusinessClientTypes.SkillSummary]? = nil
        if let skillSummariesContainer = skillSummariesContainer {
            skillSummariesDecoded0 = [AlexaForBusinessClientTypes.SkillSummary]()
            for structure0 in skillSummariesContainer {
                if let structure0 = structure0 {
                    skillSummariesDecoded0?.append(structure0)
                }
            }
        }
        skillSummaries = skillSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSkillsStoreCategoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSkillsStoreCategoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSkillsStoreCategoriesInput: Swift.Equatable {
    /// The maximum number of categories returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreCategoriesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSkillsStoreCategoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsStoreCategoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSkillsStoreCategoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSkillsStoreCategoriesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSkillsStoreCategoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSkillsStoreCategoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.categoryList = output.categoryList
            self.nextToken = output.nextToken
        } else {
            self.categoryList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSkillsStoreCategoriesOutputResponse: Swift.Equatable {
    /// The list of categories.
    public var categoryList: [AlexaForBusinessClientTypes.Category]?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init (
        categoryList: [AlexaForBusinessClientTypes.Category]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categoryList = categoryList
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreCategoriesOutputResponseBody: Swift.Equatable {
    let categoryList: [AlexaForBusinessClientTypes.Category]?
    let nextToken: Swift.String?
}

extension ListSkillsStoreCategoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryList = "CategoryList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryListContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Category?].self, forKey: .categoryList)
        var categoryListDecoded0:[AlexaForBusinessClientTypes.Category]? = nil
        if let categoryListContainer = categoryListContainer {
            categoryListDecoded0 = [AlexaForBusinessClientTypes.Category]()
            for structure0 in categoryListContainer {
                if let structure0 = structure0 {
                    categoryListDecoded0?.append(structure0)
                }
            }
        }
        categoryList = categoryListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSkillsStoreSkillsByCategoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryId = "CategoryId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let categoryId = categoryId {
            try encodeContainer.encode(categoryId, forKey: .categoryId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSkillsStoreSkillsByCategoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSkillsStoreSkillsByCategoryInput: Swift.Equatable {
    /// The category ID for which the skills are being retrieved from the skill store.
    /// This member is required.
    public var categoryId: Swift.Int?
    /// The maximum number of skills returned per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?

    public init (
        categoryId: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.categoryId = categoryId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSkillsStoreSkillsByCategoryInputBody: Swift.Equatable {
    let categoryId: Swift.Int?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListSkillsStoreSkillsByCategoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case categoryId = "CategoryId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let categoryIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .categoryId)
        categoryId = categoryIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListSkillsStoreSkillsByCategoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSkillsStoreSkillsByCategoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSkillsStoreSkillsByCategoryOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSkillsStoreSkillsByCategoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSkillsStoreSkillsByCategoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.skillsStoreSkills = output.skillsStoreSkills
        } else {
            self.nextToken = nil
            self.skillsStoreSkills = nil
        }
    }
}

public struct ListSkillsStoreSkillsByCategoryOutputResponse: Swift.Equatable {
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The skill store skills.
    public var skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]?

    public init (
        nextToken: Swift.String? = nil,
        skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]? = nil
    )
    {
        self.nextToken = nextToken
        self.skillsStoreSkills = skillsStoreSkills
    }
}

struct ListSkillsStoreSkillsByCategoryOutputResponseBody: Swift.Equatable {
    let skillsStoreSkills: [AlexaForBusinessClientTypes.SkillsStoreSkill]?
    let nextToken: Swift.String?
}

extension ListSkillsStoreSkillsByCategoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case skillsStoreSkills = "SkillsStoreSkills"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillsStoreSkillsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SkillsStoreSkill?].self, forKey: .skillsStoreSkills)
        var skillsStoreSkillsDecoded0:[AlexaForBusinessClientTypes.SkillsStoreSkill]? = nil
        if let skillsStoreSkillsContainer = skillsStoreSkillsContainer {
            skillsStoreSkillsDecoded0 = [AlexaForBusinessClientTypes.SkillsStoreSkill]()
            for structure0 in skillsStoreSkillsContainer {
                if let structure0 = structure0 {
                    skillsStoreSkillsDecoded0?.append(structure0)
                }
            }
        }
        skillsStoreSkills = skillsStoreSkillsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSmartHomeAppliancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension ListSmartHomeAppliancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListSmartHomeAppliancesInput: Swift.Equatable {
    /// The maximum number of appliances to be returned, per paginated calls.
    public var maxResults: Swift.Int?
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The room that the appliances are associated with.
    /// This member is required.
    public var roomArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.roomArn = roomArn
    }
}

struct ListSmartHomeAppliancesInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListSmartHomeAppliancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSmartHomeAppliancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSmartHomeAppliancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListSmartHomeAppliancesOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSmartHomeAppliancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListSmartHomeAppliancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.smartHomeAppliances = output.smartHomeAppliances
        } else {
            self.nextToken = nil
            self.smartHomeAppliances = nil
        }
    }
}

public struct ListSmartHomeAppliancesOutputResponse: Swift.Equatable {
    /// The tokens used for pagination.
    public var nextToken: Swift.String?
    /// The smart home appliances.
    public var smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]?

    public init (
        nextToken: Swift.String? = nil,
        smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]? = nil
    )
    {
        self.nextToken = nextToken
        self.smartHomeAppliances = smartHomeAppliances
    }
}

struct ListSmartHomeAppliancesOutputResponseBody: Swift.Equatable {
    let smartHomeAppliances: [AlexaForBusinessClientTypes.SmartHomeAppliance]?
    let nextToken: Swift.String?
}

extension ListSmartHomeAppliancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case smartHomeAppliances = "SmartHomeAppliances"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let smartHomeAppliancesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SmartHomeAppliance?].self, forKey: .smartHomeAppliances)
        var smartHomeAppliancesDecoded0:[AlexaForBusinessClientTypes.SmartHomeAppliance]? = nil
        if let smartHomeAppliancesContainer = smartHomeAppliancesContainer {
            smartHomeAppliancesDecoded0 = [AlexaForBusinessClientTypes.SmartHomeAppliance]()
            for structure0 in smartHomeAppliancesContainer {
                if let structure0 = structure0 {
                    smartHomeAppliancesDecoded0?.append(structure0)
                }
            }
        }
        smartHomeAppliances = smartHomeAppliancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTagsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsInput: Swift.Equatable {
    /// The ARN of the specified resource for which to list tags.
    /// This member is required.
    public var arn: Swift.String?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?

    public init (
        arn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.arn = arn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTagsInputBody: Swift.Equatable {
    let arn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTagsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The tags requested for the specified resource.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Swift.Equatable {
    let tags: [AlexaForBusinessClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public enum Locale: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enUs
        case sdkUnknown(Swift.String)

        public static var allCases: [Locale] {
            return [
                .enUs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enUs: return "en-US"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.MeetingRoomConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let requireCheckIn = requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.InstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Meeting room settings of a room profile.
    public struct MeetingRoomConfiguration: Swift.Equatable {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.EndOfMeetingReminder?
        /// Settings to automatically book the room if available for a configured duration when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.InstantBooking?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into. This makes the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.RequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init (
            endOfMeetingReminder: AlexaForBusinessClientTypes.EndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.InstantBooking? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.RequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension AlexaForBusinessClientTypes.MeetingSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case requirePin = "RequirePin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let requirePin = requirePin {
            try encodeContainer.encode(requirePin.rawValue, forKey: .requirePin)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requirePinDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RequirePin.self, forKey: .requirePin)
        requirePin = requirePinDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The values that indicate whether a pin is always required (YES), never required (NO), or OPTIONAL.
    ///
    /// * If YES, Alexa will always ask for a meeting pin.
    ///
    /// * If NO, Alexa will never ask for a meeting pin.
    ///
    /// * If OPTIONAL, Alexa will ask if you have a meeting pin and if the customer responds with yes, it will ask for the meeting pin.
    public struct MeetingSetting: Swift.Equatable {
        /// The values that indicate whether the pin is always required.
        /// This member is required.
        public var requirePin: AlexaForBusinessClientTypes.RequirePin?

        public init (
            requirePin: AlexaForBusinessClientTypes.RequirePin? = nil
        )
        {
            self.requirePin = requirePin
        }
    }

}

extension NameInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NameInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The name sent in the request is already in use.
public struct NameInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NameInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NameInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes {
    public enum NetworkEapMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eapTls
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkEapMethod] {
            return [
                .eapTls,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eapTls: return "EAP_TLS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkEapMethod(rawValue: rawValue) ?? NetworkEapMethod.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.NetworkProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case securityType = "SecurityType"
        case ssid = "Ssid"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let currentPassword = currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let securityType = securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchorlist0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchorlist0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[Swift.String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [Swift.String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

extension AlexaForBusinessClientTypes {
    /// The network profile associated with a device.
    public struct NetworkProfile: Swift.Equatable {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public var certificateAuthorityArn: Swift.String?
        /// The current password of the Wi-Fi network.
        public var currentPassword: Swift.String?
        /// Detailed information about a device's network profile.
        public var description: Swift.String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
        public var nextPassword: Swift.String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public var ssid: Swift.String?
        /// The root certificates of your authentication server, which is installed on your devices and used to trust your authentication server during EAP negotiation.
        public var trustAnchors: [Swift.String]?

        public init (
            certificateAuthorityArn: Swift.String? = nil,
            currentPassword: Swift.String? = nil,
            description: Swift.String? = nil,
            eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            nextPassword: Swift.String? = nil,
            securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
            ssid: Swift.String? = nil,
            trustAnchors: [Swift.String]? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.currentPassword = currentPassword
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.nextPassword = nextPassword
            self.securityType = securityType
            self.ssid = ssid
            self.trustAnchors = trustAnchors
        }
    }

}

extension AlexaForBusinessClientTypes.NetworkProfileData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case description = "Description"
        case eapMethod = "EapMethod"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case securityType = "SecurityType"
        case ssid = "Ssid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eapMethod = eapMethod {
            try encodeContainer.encode(eapMethod.rawValue, forKey: .eapMethod)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let securityType = securityType {
            try encodeContainer.encode(securityType.rawValue, forKey: .securityType)
        }
        if let ssid = ssid {
            try encodeContainer.encode(ssid, forKey: .ssid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let ssidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssid)
        ssid = ssidDecoded
        let securityTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkSecurityType.self, forKey: .securityType)
        securityType = securityTypeDecoded
        let eapMethodDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.NetworkEapMethod.self, forKey: .eapMethod)
        eapMethod = eapMethodDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The data associated with a network profile.
    public struct NetworkProfileData: Swift.Equatable {
        /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
        public var certificateAuthorityArn: Swift.String?
        /// Detailed information about a device's network profile.
        public var description: Swift.String?
        /// The authentication standard that is used in the EAP framework. Currently, EAP_TLS is supported.
        public var eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod?
        /// The ARN of the network profile associated with a device.
        public var networkProfileArn: Swift.String?
        /// The name of the network profile associated with a device.
        public var networkProfileName: Swift.String?
        /// The security type of the Wi-Fi network. This can be WPA2_ENTERPRISE, WPA2_PSK, WPA_PSK, WEP, or OPEN.
        public var securityType: AlexaForBusinessClientTypes.NetworkSecurityType?
        /// The SSID of the Wi-Fi network.
        public var ssid: Swift.String?

        public init (
            certificateAuthorityArn: Swift.String? = nil,
            description: Swift.String? = nil,
            eapMethod: AlexaForBusinessClientTypes.NetworkEapMethod? = nil,
            networkProfileArn: Swift.String? = nil,
            networkProfileName: Swift.String? = nil,
            securityType: AlexaForBusinessClientTypes.NetworkSecurityType? = nil,
            ssid: Swift.String? = nil
        )
        {
            self.certificateAuthorityArn = certificateAuthorityArn
            self.description = description
            self.eapMethod = eapMethod
            self.networkProfileArn = networkProfileArn
            self.networkProfileName = networkProfileName
            self.securityType = securityType
            self.ssid = ssid
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum NetworkSecurityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `open`
        case wep
        case wpa2Enterprise
        case wpa2Psk
        case wpaPsk
        case sdkUnknown(Swift.String)

        public static var allCases: [NetworkSecurityType] {
            return [
                .open,
                .wep,
                .wpa2Enterprise,
                .wpa2Psk,
                .wpaPsk,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .open: return "OPEN"
            case .wep: return "WEP"
            case .wpa2Enterprise: return "WPA2_ENTERPRISE"
            case .wpa2Psk: return "WPA2_PSK"
            case .wpaPsk: return "WPA_PSK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NetworkSecurityType(rawValue: rawValue) ?? NetworkSecurityType.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource is not found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes.PSTNDialIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "CountryCode"
        case oneClickIdDelay = "OneClickIdDelay"
        case oneClickPinDelay = "OneClickPinDelay"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let oneClickIdDelay = oneClickIdDelay {
            try encodeContainer.encode(oneClickIdDelay, forKey: .oneClickIdDelay)
        }
        if let oneClickPinDelay = oneClickPinDelay {
            try encodeContainer.encode(oneClickPinDelay, forKey: .oneClickPinDelay)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let oneClickIdDelayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oneClickIdDelay)
        oneClickIdDelay = oneClickIdDelayDecoded
        let oneClickPinDelayDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .oneClickPinDelay)
        oneClickPinDelay = oneClickPinDelayDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The information for public switched telephone network (PSTN) conferencing.
    public struct PSTNDialIn: Swift.Equatable {
        /// The zip code.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The delay duration before Alexa enters the conference ID with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        /// This member is required.
        public var oneClickIdDelay: Swift.String?
        /// The delay duration before Alexa enters the conference pin with dual-tone multi-frequency (DTMF). Each number on the dial pad corresponds to a DTMF tone, which is how we send data over the telephone network.
        /// This member is required.
        public var oneClickPinDelay: Swift.String?
        /// The phone number to call to join the conference.
        /// This member is required.
        public var phoneNumber: Swift.String?

        public init (
            countryCode: Swift.String? = nil,
            oneClickIdDelay: Swift.String? = nil,
            oneClickPinDelay: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.oneClickIdDelay = oneClickIdDelay
            self.oneClickPinDelay = oneClickPinDelay
            self.phoneNumber = phoneNumber
        }
    }

}

extension AlexaForBusinessClientTypes.PhoneNumber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case number = "Number"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let number = number {
            try encodeContainer.encode(number, forKey: .number)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .number)
        number = numberDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PhoneNumberType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The phone number for the contact containing the raw number and phone number type.
    public struct PhoneNumber: Swift.Equatable {
        /// The raw value of the phone number.
        /// This member is required.
        public var number: Swift.String?
        /// The type of the phone number.
        /// This member is required.
        public var type: AlexaForBusinessClientTypes.PhoneNumberType?

        public init (
            number: Swift.String? = nil,
            type: AlexaForBusinessClientTypes.PhoneNumberType? = nil
        )
        {
            self.number = number
            self.type = type
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum PhoneNumberType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case home
        case mobile
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [PhoneNumberType] {
            return [
                .home,
                .mobile,
                .work,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .home: return "HOME"
            case .mobile: return "MOBILE"
            case .work: return "WORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PhoneNumberType(rawValue: rawValue) ?? PhoneNumberType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Profile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case addressBookArn = "AddressBookArn"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let dataRetentionOptIn = dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pSTNEnabled = pSTNEnabled {
            try encodeContainer.encode(pSTNEnabled, forKey: .pSTNEnabled)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pSTNEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pSTNEnabled)
        pSTNEnabled = pSTNEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A room profile with attributes.
    public struct Profile: Swift.Equatable {
        /// The address of a room profile.
        public var address: Swift.String?
        /// The ARN of the address book.
        public var addressBookArn: Swift.String?
        /// Whether data retention of the profile is enabled.
        public var dataRetentionOptIn: Swift.Bool?
        /// The distance unit of a room profile.
        public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
        /// Retrieves if the profile is default or not.
        public var isDefault: Swift.Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public var locale: Swift.String?
        /// The max volume limit of a room profile.
        public var maxVolumeLimit: Swift.Int?
        /// Meeting room settings of a room profile.
        public var meetingRoomConfiguration: AlexaForBusinessClientTypes.MeetingRoomConfiguration?
        /// The PSTN setting of a room profile.
        public var pSTNEnabled: Swift.Bool?
        /// The ARN of a room profile.
        public var profileArn: Swift.String?
        /// The name of a room profile.
        public var profileName: Swift.String?
        /// The setup mode of a room profile.
        public var setupModeDisabled: Swift.Bool?
        /// The temperature unit of a room profile.
        public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
        /// The time zone of a room profile.
        public var timezone: Swift.String?
        /// The wake word of a room profile.
        public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

        public init (
            address: Swift.String? = nil,
            addressBookArn: Swift.String? = nil,
            dataRetentionOptIn: Swift.Bool? = nil,
            distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
            isDefault: Swift.Bool? = nil,
            locale: Swift.String? = nil,
            maxVolumeLimit: Swift.Int? = nil,
            meetingRoomConfiguration: AlexaForBusinessClientTypes.MeetingRoomConfiguration? = nil,
            pSTNEnabled: Swift.Bool? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            setupModeDisabled: Swift.Bool? = nil,
            temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
            timezone: Swift.String? = nil,
            wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
        )
        {
            self.address = address
            self.addressBookArn = addressBookArn
            self.dataRetentionOptIn = dataRetentionOptIn
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.maxVolumeLimit = maxVolumeLimit
            self.meetingRoomConfiguration = meetingRoomConfiguration
            self.pSTNEnabled = pSTNEnabled
            self.profileArn = profileArn
            self.profileName = profileName
            self.setupModeDisabled = setupModeDisabled
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }
    }

}

extension AlexaForBusinessClientTypes.ProfileData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The data of a room profile.
    public struct ProfileData: Swift.Equatable {
        /// The address of a room profile.
        public var address: Swift.String?
        /// The distance unit of a room profile.
        public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
        /// Retrieves if the profile data is default or not.
        public var isDefault: Swift.Bool?
        /// The locale of a room profile. (This is currently available only to a limited preview audience.)
        public var locale: Swift.String?
        /// The ARN of a room profile.
        public var profileArn: Swift.String?
        /// The name of a room profile.
        public var profileName: Swift.String?
        /// The temperature unit of a room profile.
        public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
        /// The time zone of a room profile.
        public var timezone: Swift.String?
        /// The wake word of a room profile.
        public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

        public init (
            address: Swift.String? = nil,
            distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
            isDefault: Swift.Bool? = nil,
            locale: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
            timezone: Swift.String? = nil,
            wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
        )
        {
            self.address = address
            self.distanceUnit = distanceUnit
            self.isDefault = isDefault
            self.locale = locale
            self.profileArn = profileArn
            self.profileName = profileName
            self.temperatureUnit = temperatureUnit
            self.timezone = timezone
            self.wakeWord = wakeWord
        }
    }

}

extension PutConferencePreferenceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferencePreference = "ConferencePreference"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferencePreference = conferencePreference {
            try encodeContainer.encode(conferencePreference, forKey: .conferencePreference)
        }
    }
}

extension PutConferencePreferenceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutConferencePreferenceInput: Swift.Equatable {
    /// The conference preference of a specific conference provider.
    /// This member is required.
    public var conferencePreference: AlexaForBusinessClientTypes.ConferencePreference?

    public init (
        conferencePreference: AlexaForBusinessClientTypes.ConferencePreference? = nil
    )
    {
        self.conferencePreference = conferencePreference
    }
}

struct PutConferencePreferenceInputBody: Swift.Equatable {
    let conferencePreference: AlexaForBusinessClientTypes.ConferencePreference?
}

extension PutConferencePreferenceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferencePreference = "ConferencePreference"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferencePreferenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferencePreference.self, forKey: .conferencePreference)
        conferencePreference = conferencePreferenceDecoded
    }
}

extension PutConferencePreferenceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutConferencePreferenceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutConferencePreferenceOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutConferencePreferenceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutConferencePreferenceOutputResponse: Swift.Equatable {

}

extension PutInvitationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactEmail = contactEmail {
            try encodeContainer.encode(contactEmail, forKey: .contactEmail)
        }
        if let organizationName = organizationName {
            try encodeContainer.encode(organizationName, forKey: .organizationName)
        }
        if let privateSkillIds = privateSkillIds {
            var privateSkillIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateSkillIds)
            for shortskillidlist0 in privateSkillIds {
                try privateSkillIdsContainer.encode(shortskillidlist0)
            }
        }
    }
}

extension PutInvitationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInvitationConfigurationInput: Swift.Equatable {
    /// The email ID of the organization or individual contact that the enrolled user can use.
    public var contactEmail: Swift.String?
    /// The name of the organization sending the enrollment invite to a user.
    /// This member is required.
    public var organizationName: Swift.String?
    /// The list of private skill IDs that you want to recommend to the user to enable in the invitation.
    public var privateSkillIds: [Swift.String]?

    public init (
        contactEmail: Swift.String? = nil,
        organizationName: Swift.String? = nil,
        privateSkillIds: [Swift.String]? = nil
    )
    {
        self.contactEmail = contactEmail
        self.organizationName = organizationName
        self.privateSkillIds = privateSkillIds
    }
}

struct PutInvitationConfigurationInputBody: Swift.Equatable {
    let organizationName: Swift.String?
    let contactEmail: Swift.String?
    let privateSkillIds: [Swift.String]?
}

extension PutInvitationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactEmail = "ContactEmail"
        case organizationName = "OrganizationName"
        case privateSkillIds = "PrivateSkillIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .organizationName)
        organizationName = organizationNameDecoded
        let contactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactEmail)
        contactEmail = contactEmailDecoded
        let privateSkillIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .privateSkillIds)
        var privateSkillIdsDecoded0:[Swift.String]? = nil
        if let privateSkillIdsContainer = privateSkillIdsContainer {
            privateSkillIdsDecoded0 = [Swift.String]()
            for string0 in privateSkillIdsContainer {
                if let string0 = string0 {
                    privateSkillIdsDecoded0?.append(string0)
                }
            }
        }
        privateSkillIds = privateSkillIdsDecoded0
    }
}

extension PutInvitationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutInvitationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutInvitationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutInvitationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutInvitationConfigurationOutputResponse: Swift.Equatable {

}

extension PutRoomSkillParameterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case roomSkillParameter = "RoomSkillParameter"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomSkillParameter = roomSkillParameter {
            try encodeContainer.encode(roomSkillParameter, forKey: .roomSkillParameter)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension PutRoomSkillParameterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRoomSkillParameterInput: Swift.Equatable {
    /// The ARN of the room associated with the room skill parameter. Required.
    public var roomArn: Swift.String?
    /// The updated room skill parameter. Required.
    /// This member is required.
    public var roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?
    /// The ARN of the skill associated with the room skill parameter. Required.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        roomArn: Swift.String? = nil,
        roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
        self.roomSkillParameter = roomSkillParameter
        self.skillId = skillId
    }
}

struct PutRoomSkillParameterInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let skillId: Swift.String?
    let roomSkillParameter: AlexaForBusinessClientTypes.RoomSkillParameter?
}

extension PutRoomSkillParameterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case roomSkillParameter = "RoomSkillParameter"
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomSkillParameterDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.RoomSkillParameter.self, forKey: .roomSkillParameter)
        roomSkillParameter = roomSkillParameterDecoded
    }
}

extension PutRoomSkillParameterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutRoomSkillParameterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutRoomSkillParameterOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutRoomSkillParameterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutRoomSkillParameterOutputResponse: Swift.Equatable {

}

extension PutSkillAuthorizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationResult = "AuthorizationResult"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationResult = authorizationResult {
            var authorizationResultContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .authorizationResult)
            for (dictKey0, authorizationresult0) in authorizationResult {
                try authorizationResultContainer.encode(authorizationresult0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension PutSkillAuthorizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutSkillAuthorizationInput: Swift.Equatable {
    /// The authorization result specific to OAUTH code grant output. "Code must be populated in the AuthorizationResult map to establish the authorization.
    /// This member is required.
    public var authorizationResult: [Swift.String:Swift.String]?
    /// The room that the skill is authorized for.
    public var roomArn: Swift.String?
    /// The unique identifier of a skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        authorizationResult: [Swift.String:Swift.String]? = nil,
        roomArn: Swift.String? = nil,
        skillId: Swift.String? = nil
    )
    {
        self.authorizationResult = authorizationResult
        self.roomArn = roomArn
        self.skillId = skillId
    }
}

struct PutSkillAuthorizationInputBody: Swift.Equatable {
    let authorizationResult: [Swift.String:Swift.String]?
    let skillId: Swift.String?
    let roomArn: Swift.String?
}

extension PutSkillAuthorizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationResult = "AuthorizationResult"
        case roomArn = "RoomArn"
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationResultContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .authorizationResult)
        var authorizationResultDecoded0: [Swift.String:Swift.String]? = nil
        if let authorizationResultContainer = authorizationResultContainer {
            authorizationResultDecoded0 = [Swift.String:Swift.String]()
            for (key0, value0) in authorizationResultContainer {
                if let value0 = value0 {
                    authorizationResultDecoded0?[key0] = value0
                }
            }
        }
        authorizationResult = authorizationResultDecoded0
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension PutSkillAuthorizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSkillAuthorizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutSkillAuthorizationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSkillAuthorizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutSkillAuthorizationOutputResponse: Swift.Equatable {

}

extension RegisterAVSDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case clientId = "ClientId"
        case deviceSerialNumber = "DeviceSerialNumber"
        case productId = "ProductId"
        case roomArn = "RoomArn"
        case tags = "Tags"
        case userCode = "UserCode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amazonId = amazonId {
            try encodeContainer.encode(amazonId, forKey: .amazonId)
        }
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let deviceSerialNumber = deviceSerialNumber {
            try encodeContainer.encode(deviceSerialNumber, forKey: .deviceSerialNumber)
        }
        if let productId = productId {
            try encodeContainer.encode(productId, forKey: .productId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let userCode = userCode {
            try encodeContainer.encode(userCode, forKey: .userCode)
        }
    }
}

extension RegisterAVSDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RegisterAVSDeviceInput: Swift.Equatable {
    /// The device type ID for your AVS device generated by Amazon when the OEM creates a new product on Amazon's Developer Console.
    /// This member is required.
    public var amazonId: Swift.String?
    /// The client ID of the OEM used for code-based linking authorization on an AVS device.
    /// This member is required.
    public var clientId: Swift.String?
    /// The key generated by the OEM that uniquely identifies a specified instance of your AVS device.
    public var deviceSerialNumber: Swift.String?
    /// The product ID used to identify your AVS device during authorization.
    /// This member is required.
    public var productId: Swift.String?
    /// The Amazon Resource Name (ARN) of the room with which to associate your AVS device.
    public var roomArn: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags.
    public var tags: [AlexaForBusinessClientTypes.Tag]?
    /// The code that is obtained after your AVS device has made a POST request to LWA as a part of the Device Authorization Request component of the OAuth code-based linking specification.
    /// This member is required.
    public var userCode: Swift.String?

    public init (
        amazonId: Swift.String? = nil,
        clientId: Swift.String? = nil,
        deviceSerialNumber: Swift.String? = nil,
        productId: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil,
        userCode: Swift.String? = nil
    )
    {
        self.amazonId = amazonId
        self.clientId = clientId
        self.deviceSerialNumber = deviceSerialNumber
        self.productId = productId
        self.roomArn = roomArn
        self.tags = tags
        self.userCode = userCode
    }
}

struct RegisterAVSDeviceInputBody: Swift.Equatable {
    let clientId: Swift.String?
    let userCode: Swift.String?
    let productId: Swift.String?
    let deviceSerialNumber: Swift.String?
    let amazonId: Swift.String?
    let roomArn: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension RegisterAVSDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amazonId = "AmazonId"
        case clientId = "ClientId"
        case deviceSerialNumber = "DeviceSerialNumber"
        case productId = "ProductId"
        case roomArn = "RoomArn"
        case tags = "Tags"
        case userCode = "UserCode"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let userCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userCode)
        userCode = userCodeDecoded
        let productIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productId)
        productId = productIdDecoded
        let deviceSerialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceSerialNumber)
        deviceSerialNumber = deviceSerialNumberDecoded
        let amazonIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amazonId)
        amazonId = amazonIdDecoded
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension RegisterAVSDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterAVSDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeviceException" : self = .invalidDeviceException(try InvalidDeviceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterAVSDeviceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidDeviceException(InvalidDeviceException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterAVSDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RegisterAVSDeviceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.deviceArn = output.deviceArn
        } else {
            self.deviceArn = nil
        }
    }
}

public struct RegisterAVSDeviceOutputResponse: Swift.Equatable {
    /// The ARN of the device.
    public var deviceArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
    }
}

struct RegisterAVSDeviceOutputResponseBody: Swift.Equatable {
    let deviceArn: Swift.String?
}

extension RegisterAVSDeviceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
    }
}

extension RejectSkillInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
    }
}

extension RejectSkillInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RejectSkillInput: Swift.Equatable {
    /// The unique identifier of the skill.
    /// This member is required.
    public var skillId: Swift.String?

    public init (
        skillId: Swift.String? = nil
    )
    {
        self.skillId = skillId
    }
}

struct RejectSkillInputBody: Swift.Equatable {
    let skillId: Swift.String?
}

extension RejectSkillInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension RejectSkillOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RejectSkillOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RejectSkillOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RejectSkillOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RejectSkillOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.RequireCheckIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct RequireCheckIn: Swift.Equatable {
        /// Whether require check in is enabled or not.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public var releaseAfterMinutes: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum RequirePin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case no
        case `optional`
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [RequirePin] {
            return [
                .no,
                .optional,
                .yes,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .no: return "NO"
            case .optional: return "OPTIONAL"
            case .yes: return "YES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RequirePin(rawValue: rawValue) ?? RequirePin.sdkUnknown(rawValue)
        }
    }
}

extension ResolveRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
        case userId = "UserId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }
}

extension ResolveRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ResolveRoomInput: Swift.Equatable {
    /// The ARN of the skill that was requested. Required.
    /// This member is required.
    public var skillId: Swift.String?
    /// The ARN of the user. Required.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        skillId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.skillId = skillId
        self.userId = userId
    }
}

struct ResolveRoomInputBody: Swift.Equatable {
    let userId: Swift.String?
    let skillId: Swift.String?
}

extension ResolveRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case skillId = "SkillId"
        case userId = "UserId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
    }
}

extension ResolveRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResolveRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ResolveRoomOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResolveRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResolveRoomOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.roomArn = output.roomArn
            self.roomName = output.roomName
            self.roomSkillParameters = output.roomSkillParameters
        } else {
            self.roomArn = nil
            self.roomName = nil
            self.roomSkillParameters = nil
        }
    }
}

public struct ResolveRoomOutputResponse: Swift.Equatable {
    /// The ARN of the room from which the skill request was invoked.
    public var roomArn: Swift.String?
    /// The name of the room from which the skill request was invoked.
    public var roomName: Swift.String?
    /// Response to get the room profile request. Required.
    public var roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]?

    public init (
        roomArn: Swift.String? = nil,
        roomName: Swift.String? = nil,
        roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]? = nil
    )
    {
        self.roomArn = roomArn
        self.roomName = roomName
        self.roomSkillParameters = roomSkillParameters
    }
}

struct ResolveRoomOutputResponseBody: Swift.Equatable {
    let roomArn: Swift.String?
    let roomName: Swift.String?
    let roomSkillParameters: [AlexaForBusinessClientTypes.RoomSkillParameter]?
}

extension ResolveRoomOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
        case roomName = "RoomName"
        case roomSkillParameters = "RoomSkillParameters"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let roomSkillParametersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.RoomSkillParameter?].self, forKey: .roomSkillParameters)
        var roomSkillParametersDecoded0:[AlexaForBusinessClientTypes.RoomSkillParameter]? = nil
        if let roomSkillParametersContainer = roomSkillParametersContainer {
            roomSkillParametersDecoded0 = [AlexaForBusinessClientTypes.RoomSkillParameter]()
            for structure0 in roomSkillParametersContainer {
                if let structure0 = structure0 {
                    roomSkillParametersDecoded0?.append(structure0)
                }
            }
        }
        roomSkillParameters = roomSkillParametersDecoded0
    }
}

extension ResourceAssociatedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAssociatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Another resource is associated with the resource in the request.
public struct ResourceAssociatedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAssociatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceAssociatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.clientRequestToken = output.clientRequestToken
            self.message = output.message
        } else {
            self.clientRequestToken = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource in the request is already in use.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// A unique, user-specified identifier for the request that ensures idempotency.
    public var clientRequestToken: Swift.String?
    public var message: Swift.String?

    public init (
        clientRequestToken: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let clientRequestToken: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension RevokeInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enrollmentId = enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension RevokeInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct RevokeInvitationInput: Swift.Equatable {
    /// The ARN of the enrollment invitation to revoke. Required.
    public var enrollmentId: Swift.String?
    /// The ARN of the user for whom to revoke an enrollment invitation. Required.
    public var userArn: Swift.String?

    public init (
        enrollmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.enrollmentId = enrollmentId
        self.userArn = userArn
    }
}

struct RevokeInvitationInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let enrollmentId: Swift.String?
}

extension RevokeInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enrollmentId = "EnrollmentId"
        case userArn = "UserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension RevokeInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RevokeInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RevokeInvitationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RevokeInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct RevokeInvitationOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.Room: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A room with attributes.
    public struct Room: Swift.Equatable {
        /// The description of a room.
        public var description: Swift.String?
        /// The profile ARN of a room.
        public var profileArn: Swift.String?
        /// The provider calendar ARN of a room.
        public var providerCalendarId: Swift.String?
        /// The ARN of a room.
        public var roomArn: Swift.String?
        /// The name of a room.
        public var roomName: Swift.String?

        public init (
            description: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            providerCalendarId: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil
        )
        {
            self.description = description
            self.profileArn = profileArn
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }
    }

}

extension AlexaForBusinessClientTypes.RoomData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The data of a room.
    public struct RoomData: Swift.Equatable {
        /// The description of a room.
        public var description: Swift.String?
        /// The profile ARN of a room.
        public var profileArn: Swift.String?
        /// The profile name of a room.
        public var profileName: Swift.String?
        /// The provider calendar ARN of a room.
        public var providerCalendarId: Swift.String?
        /// The ARN of a room.
        public var roomArn: Swift.String?
        /// The name of a room.
        public var roomName: Swift.String?

        public init (
            description: Swift.String? = nil,
            profileArn: Swift.String? = nil,
            profileName: Swift.String? = nil,
            providerCalendarId: Swift.String? = nil,
            roomArn: Swift.String? = nil,
            roomName: Swift.String? = nil
        )
        {
            self.description = description
            self.profileArn = profileArn
            self.profileName = profileName
            self.providerCalendarId = providerCalendarId
            self.roomArn = roomArn
            self.roomName = roomName
        }
    }

}

extension AlexaForBusinessClientTypes.RoomSkillParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameterKey = "ParameterKey"
        case parameterValue = "ParameterValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameterKey = parameterKey {
            try encodeContainer.encode(parameterKey, forKey: .parameterKey)
        }
        if let parameterValue = parameterValue {
            try encodeContainer.encode(parameterValue, forKey: .parameterValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parameterKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterKey)
        parameterKey = parameterKeyDecoded
        let parameterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterValue)
        parameterValue = parameterValueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A skill parameter associated with a room.
    public struct RoomSkillParameter: Swift.Equatable {
        /// The parameter key of a room skill parameter. ParameterKey is an enumerated type that only takes DEFAULT or SCOPE as valid values.
        /// This member is required.
        public var parameterKey: Swift.String?
        /// The parameter value of a room skill parameter.
        /// This member is required.
        public var parameterValue: Swift.String?

        public init (
            parameterKey: Swift.String? = nil,
            parameterValue: Swift.String? = nil
        )
        {
            self.parameterKey = parameterKey
            self.parameterValue = parameterValue
        }
    }

}

extension SearchAddressBooksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchAddressBooksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchAddressBooksInput: Swift.Equatable {
    /// The filters to use to list a specified set of address books. The supported filter key is AddressBookName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of address books. The supported sort key is AddressBookName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchAddressBooksInputBody: Swift.Equatable {
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchAddressBooksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchAddressBooksOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchAddressBooksOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchAddressBooksOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchAddressBooksOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchAddressBooksOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.addressBooks = output.addressBooks
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.addressBooks = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchAddressBooksOutputResponse: Swift.Equatable {
    /// The address books that meet the specified set of filter criteria, in sort order.
    public var addressBooks: [AlexaForBusinessClientTypes.AddressBookData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of address books returned.
    public var totalCount: Swift.Int?

    public init (
        addressBooks: [AlexaForBusinessClientTypes.AddressBookData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.addressBooks = addressBooks
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchAddressBooksOutputResponseBody: Swift.Equatable {
    let addressBooks: [AlexaForBusinessClientTypes.AddressBookData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchAddressBooksOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBooks = "AddressBooks"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBooksContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.AddressBookData?].self, forKey: .addressBooks)
        var addressBooksDecoded0:[AlexaForBusinessClientTypes.AddressBookData]? = nil
        if let addressBooksContainer = addressBooksContainer {
            addressBooksDecoded0 = [AlexaForBusinessClientTypes.AddressBookData]()
            for structure0 in addressBooksContainer {
                if let structure0 = structure0 {
                    addressBooksDecoded0?.append(structure0)
                }
            }
        }
        addressBooks = addressBooksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SearchContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchContactsInput: Swift.Equatable {
    /// The filters to use to list a specified set of address books. The supported filter keys are DisplayName, FirstName, LastName, and AddressBookArns.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response only includes results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of contacts. The supported sort keys are DisplayName, FirstName, and LastName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchContactsInputBody: Swift.Equatable {
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension SearchContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension SearchContactsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchContactsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchContactsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchContactsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchContactsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.contacts = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchContactsOutputResponse: Swift.Equatable {
    /// The contacts that meet the specified set of filter criteria, in sort order.
    public var contacts: [AlexaForBusinessClientTypes.ContactData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of contacts returned.
    public var totalCount: Swift.Int?

    public init (
        contacts: [AlexaForBusinessClientTypes.ContactData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchContactsOutputResponseBody: Swift.Equatable {
    let contacts: [AlexaForBusinessClientTypes.ContactData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchContactsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.ContactData?].self, forKey: .contacts)
        var contactsDecoded0:[AlexaForBusinessClientTypes.ContactData]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [AlexaForBusinessClientTypes.ContactData]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SearchDevicesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchDevicesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchDevicesInput: Swift.Equatable {
    /// The filters to use to list a specified set of devices. Supported filter keys are DeviceName, DeviceStatus, DeviceStatusDetailCode, RoomName, DeviceType, DeviceSerialNumber, UnassociatedOnly, ConnectionStatus (ONLINE and OFFLINE), NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of devices. Supported sort keys are DeviceName, DeviceStatus, RoomName, DeviceType, DeviceSerialNumber, ConnectionStatus, NetworkProfileName, NetworkProfileArn, Feature, and FailureCode.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchDevicesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchDevicesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchDevicesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchDevicesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchDevicesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchDevicesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchDevicesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.devices = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchDevicesOutputResponse: Swift.Equatable {
    /// The devices that meet the specified set of filter criteria, in sort order.
    public var devices: [AlexaForBusinessClientTypes.DeviceData]?
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of devices returned.
    public var totalCount: Swift.Int?

    public init (
        devices: [AlexaForBusinessClientTypes.DeviceData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchDevicesOutputResponseBody: Swift.Equatable {
    let devices: [AlexaForBusinessClientTypes.DeviceData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchDevicesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.DeviceData?].self, forKey: .devices)
        var devicesDecoded0:[AlexaForBusinessClientTypes.DeviceData]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [AlexaForBusinessClientTypes.DeviceData]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SearchNetworkProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchNetworkProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchNetworkProfilesInput: Swift.Equatable {
    /// The filters to use to list a specified set of network profiles. Valid filters are NetworkProfileName, Ssid, and SecurityType.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use to list the specified set of network profiles. Valid sort criteria includes NetworkProfileName, Ssid, and SecurityType.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchNetworkProfilesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchNetworkProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchNetworkProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchNetworkProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchNetworkProfilesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchNetworkProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchNetworkProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.networkProfiles = output.networkProfiles
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
        } else {
            self.networkProfiles = nil
            self.nextToken = nil
            self.totalCount = nil
        }
    }
}

public struct SearchNetworkProfilesOutputResponse: Swift.Equatable {
    /// The network profiles that meet the specified set of filter criteria, in sort order. It is a list of NetworkProfileData objects.
    public var networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The total number of network profiles returned.
    public var totalCount: Swift.Int?

    public init (
        networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]? = nil,
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.networkProfiles = networkProfiles
        self.nextToken = nextToken
        self.totalCount = totalCount
    }
}

struct SearchNetworkProfilesOutputResponseBody: Swift.Equatable {
    let networkProfiles: [AlexaForBusinessClientTypes.NetworkProfileData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchNetworkProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case networkProfiles = "NetworkProfiles"
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfilesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.NetworkProfileData?].self, forKey: .networkProfiles)
        var networkProfilesDecoded0:[AlexaForBusinessClientTypes.NetworkProfileData]? = nil
        if let networkProfilesContainer = networkProfilesContainer {
            networkProfilesDecoded0 = [AlexaForBusinessClientTypes.NetworkProfileData]()
            for structure0 in networkProfilesContainer {
                if let structure0 = structure0 {
                    networkProfilesDecoded0?.append(structure0)
                }
            }
        }
        networkProfiles = networkProfilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SearchProfilesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchProfilesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchProfilesInput: Swift.Equatable {
    /// The filters to use to list a specified set of room profiles. Supported filter keys are ProfileName and Address. Required.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of room profiles. Supported sort keys are ProfileName and Address.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchProfilesInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchProfilesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchProfilesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchProfilesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchProfilesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchProfilesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchProfilesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.profiles = output.profiles
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.profiles = nil
            self.totalCount = nil
        }
    }
}

public struct SearchProfilesOutputResponse: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The profiles that meet the specified set of filter criteria, in sort order.
    public var profiles: [AlexaForBusinessClientTypes.ProfileData]?
    /// The total number of room profiles returned.
    public var totalCount: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        profiles: [AlexaForBusinessClientTypes.ProfileData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.profiles = profiles
        self.totalCount = totalCount
    }
}

struct SearchProfilesOutputResponseBody: Swift.Equatable {
    let profiles: [AlexaForBusinessClientTypes.ProfileData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchProfilesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case profiles = "Profiles"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profilesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.ProfileData?].self, forKey: .profiles)
        var profilesDecoded0:[AlexaForBusinessClientTypes.ProfileData]? = nil
        if let profilesContainer = profilesContainer {
            profilesDecoded0 = [AlexaForBusinessClientTypes.ProfileData]()
            for structure0 in profilesContainer {
                if let structure0 = structure0 {
                    profilesDecoded0?.append(structure0)
                }
            }
        }
        profiles = profilesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SearchRoomsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchRoomsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchRoomsInput: Swift.Equatable {
    /// The filters to use to list a specified set of rooms. The supported filter keys are RoomName and ProfileName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of rooms. The supported sort keys are RoomName and ProfileName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchRoomsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchRoomsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchRoomsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchRoomsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchRoomsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchRoomsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchRoomsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rooms = output.rooms
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.rooms = nil
            self.totalCount = nil
        }
    }
}

public struct SearchRoomsOutputResponse: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The rooms that meet the specified set of filter criteria, in sort order.
    public var rooms: [AlexaForBusinessClientTypes.RoomData]?
    /// The total number of rooms returned.
    public var totalCount: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        rooms: [AlexaForBusinessClientTypes.RoomData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.rooms = rooms
        self.totalCount = totalCount
    }
}

struct SearchRoomsOutputResponseBody: Swift.Equatable {
    let rooms: [AlexaForBusinessClientTypes.RoomData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchRoomsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rooms = "Rooms"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.RoomData?].self, forKey: .rooms)
        var roomsDecoded0:[AlexaForBusinessClientTypes.RoomData]? = nil
        if let roomsContainer = roomsContainer {
            roomsDecoded0 = [AlexaForBusinessClientTypes.RoomData]()
            for structure0 in roomsContainer {
                if let structure0 = structure0 {
                    roomsDecoded0?.append(structure0)
                }
            }
        }
        rooms = roomsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SearchSkillGroupsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchSkillGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchSkillGroupsInput: Swift.Equatable {
    /// The filters to use to list a specified set of skill groups. The supported filter key is SkillGroupName.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the specified set of skill groups. The supported sort key is SkillGroupName.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchSkillGroupsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchSkillGroupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchSkillGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchSkillGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchSkillGroupsOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchSkillGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchSkillGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.skillGroups = output.skillGroups
            self.totalCount = output.totalCount
        } else {
            self.nextToken = nil
            self.skillGroups = nil
            self.totalCount = nil
        }
    }
}

public struct SearchSkillGroupsOutputResponse: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The skill groups that meet the filter criteria, in sort order.
    public var skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]?
    /// The total number of skill groups returned.
    public var totalCount: Swift.Int?

    public init (
        nextToken: Swift.String? = nil,
        skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]? = nil,
        totalCount: Swift.Int? = nil
    )
    {
        self.nextToken = nextToken
        self.skillGroups = skillGroups
        self.totalCount = totalCount
    }
}

struct SearchSkillGroupsOutputResponseBody: Swift.Equatable {
    let skillGroups: [AlexaForBusinessClientTypes.SkillGroupData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchSkillGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case skillGroups = "SkillGroups"
        case totalCount = "TotalCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SkillGroupData?].self, forKey: .skillGroups)
        var skillGroupsDecoded0:[AlexaForBusinessClientTypes.SkillGroupData]? = nil
        if let skillGroupsContainer = skillGroupsContainer {
            skillGroupsDecoded0 = [AlexaForBusinessClientTypes.SkillGroupData]()
            for structure0 in skillGroupsContainer {
                if let structure0 = structure0 {
                    skillGroupsDecoded0?.append(structure0)
                }
            }
        }
        skillGroups = skillGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SearchUsersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = sortCriteria {
            var sortCriteriaContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortCriteria)
            for sortlist0 in sortCriteria {
                try sortCriteriaContainer.encode(sortlist0)
            }
        }
    }
}

extension SearchUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SearchUsersInput: Swift.Equatable {
    /// The filters to use for listing a specific set of users. Required. Supported filter keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
    public var filters: [AlexaForBusinessClientTypes.Filter]?
    /// The maximum number of results to include in the response. If more results exist than the specified MaxResults value, a token is included in the response so that the remaining results can be retrieved. Required.
    public var maxResults: Swift.Int?
    /// An optional token returned from a prior request. Use this token for pagination of results from this action. If this parameter is specified, the response includes only results beyond the token, up to the value specified by MaxResults. Required.
    public var nextToken: Swift.String?
    /// The sort order to use in listing the filtered set of users. Required. Supported sort keys are UserId, FirstName, LastName, Email, and EnrollmentStatus.
    public var sortCriteria: [AlexaForBusinessClientTypes.Sort]?

    public init (
        filters: [AlexaForBusinessClientTypes.Filter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: [AlexaForBusinessClientTypes.Sort]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct SearchUsersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filters: [AlexaForBusinessClientTypes.Filter]?
    let sortCriteria: [AlexaForBusinessClientTypes.Sort]?
}

extension SearchUsersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters = "Filters"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case sortCriteria = "SortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filtersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .filters)
        var filtersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortCriteriaContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Sort?].self, forKey: .sortCriteria)
        var sortCriteriaDecoded0:[AlexaForBusinessClientTypes.Sort]? = nil
        if let sortCriteriaContainer = sortCriteriaContainer {
            sortCriteriaDecoded0 = [AlexaForBusinessClientTypes.Sort]()
            for structure0 in sortCriteriaContainer {
                if let structure0 = structure0 {
                    sortCriteriaDecoded0?.append(structure0)
                }
            }
        }
        sortCriteria = sortCriteriaDecoded0
    }
}

extension SearchUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SearchUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SearchUsersOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension SearchUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SearchUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.totalCount = output.totalCount
            self.users = output.users
        } else {
            self.nextToken = nil
            self.totalCount = nil
            self.users = nil
        }
    }
}

public struct SearchUsersOutputResponse: Swift.Equatable {
    /// The token returned to indicate that there is more data available.
    public var nextToken: Swift.String?
    /// The total number of users returned.
    public var totalCount: Swift.Int?
    /// The users that meet the specified set of filter criteria, in sort order.
    public var users: [AlexaForBusinessClientTypes.UserData]?

    public init (
        nextToken: Swift.String? = nil,
        totalCount: Swift.Int? = nil,
        users: [AlexaForBusinessClientTypes.UserData]? = nil
    )
    {
        self.nextToken = nextToken
        self.totalCount = totalCount
        self.users = users
    }
}

struct SearchUsersOutputResponseBody: Swift.Equatable {
    let users: [AlexaForBusinessClientTypes.UserData]?
    let nextToken: Swift.String?
    let totalCount: Swift.Int?
}

extension SearchUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case totalCount = "TotalCount"
        case users = "Users"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.UserData?].self, forKey: .users)
        var usersDecoded0:[AlexaForBusinessClientTypes.UserData]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [AlexaForBusinessClientTypes.UserData]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let totalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalCount)
        totalCount = totalCountDecoded
    }
}

extension SendAnnouncementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case roomFilters = "RoomFilters"
        case timeToLiveInSeconds = "TimeToLiveInSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let roomFilters = roomFilters {
            var roomFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roomFilters)
            for filterlist0 in roomFilters {
                try roomFiltersContainer.encode(filterlist0)
            }
        }
        if let timeToLiveInSeconds = timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
    }
}

extension SendAnnouncementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendAnnouncementInput: Swift.Equatable {
    /// The unique, user-specified identifier for the request that ensures idempotency.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The announcement content. This can contain only one of the three possible announcement types (text, SSML or audio).
    /// This member is required.
    public var content: AlexaForBusinessClientTypes.Content?
    /// The filters to use to send an announcement to a specified list of rooms. The supported filter keys are RoomName, ProfileName, RoomArn, and ProfileArn. To send to all rooms, specify an empty RoomFilters list.
    /// This member is required.
    public var roomFilters: [AlexaForBusinessClientTypes.Filter]?
    /// The time to live for an announcement. Default is 300. If delivery doesn't occur within this time, the announcement is not delivered.
    public var timeToLiveInSeconds: Swift.Int?

    public init (
        clientRequestToken: Swift.String? = nil,
        content: AlexaForBusinessClientTypes.Content? = nil,
        roomFilters: [AlexaForBusinessClientTypes.Filter]? = nil,
        timeToLiveInSeconds: Swift.Int? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.content = content
        self.roomFilters = roomFilters
        self.timeToLiveInSeconds = timeToLiveInSeconds
    }
}

struct SendAnnouncementInputBody: Swift.Equatable {
    let roomFilters: [AlexaForBusinessClientTypes.Filter]?
    let content: AlexaForBusinessClientTypes.Content?
    let timeToLiveInSeconds: Swift.Int?
    let clientRequestToken: Swift.String?
}

extension SendAnnouncementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case content = "Content"
        case roomFilters = "RoomFilters"
        case timeToLiveInSeconds = "TimeToLiveInSeconds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomFiltersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Filter?].self, forKey: .roomFilters)
        var roomFiltersDecoded0:[AlexaForBusinessClientTypes.Filter]? = nil
        if let roomFiltersContainer = roomFiltersContainer {
            roomFiltersDecoded0 = [AlexaForBusinessClientTypes.Filter]()
            for structure0 in roomFiltersContainer {
                if let structure0 = structure0 {
                    roomFiltersDecoded0?.append(structure0)
                }
            }
        }
        roomFilters = roomFiltersDecoded0
        let contentDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Content.self, forKey: .content)
        content = contentDecoded
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension SendAnnouncementOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendAnnouncementOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendAnnouncementOutputError: Swift.Error, Swift.Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case limitExceededException(LimitExceededException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendAnnouncementOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SendAnnouncementOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.announcementArn = output.announcementArn
        } else {
            self.announcementArn = nil
        }
    }
}

public struct SendAnnouncementOutputResponse: Swift.Equatable {
    /// The identifier of the announcement.
    public var announcementArn: Swift.String?

    public init (
        announcementArn: Swift.String? = nil
    )
    {
        self.announcementArn = announcementArn
    }
}

struct SendAnnouncementOutputResponseBody: Swift.Equatable {
    let announcementArn: Swift.String?
}

extension SendAnnouncementOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case announcementArn = "AnnouncementArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let announcementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .announcementArn)
        announcementArn = announcementArnDecoded
    }
}

extension SendInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension SendInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendInvitationInput: Swift.Equatable {
    /// The ARN of the user to whom to send an invitation. Required.
    public var userArn: Swift.String?

    public init (
        userArn: Swift.String? = nil
    )
    {
        self.userArn = userArn
    }
}

struct SendInvitationInputBody: Swift.Equatable {
    let userArn: Swift.String?
}

extension SendInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userArn = "UserArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension SendInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidUserStatusException" : self = .invalidUserStatusException(try InvalidUserStatusException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendInvitationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidUserStatusException(InvalidUserStatusException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct SendInvitationOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.SipAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "Type"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uri = uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let typeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SipType.self, forKey: .type)
        type = typeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The SIP address for the contact containing the URI and SIP address type.
    public struct SipAddress: Swift.Equatable {
        /// The type of the SIP address.
        /// This member is required.
        public var type: AlexaForBusinessClientTypes.SipType?
        /// The URI for the SIP address.
        /// This member is required.
        public var uri: Swift.String?

        public init (
            type: AlexaForBusinessClientTypes.SipType? = nil,
            uri: Swift.String? = nil
        )
        {
            self.type = type
            self.uri = uri
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum SipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case work
        case sdkUnknown(Swift.String)

        public static var allCases: [SipType] {
            return [
                .work,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .work: return "WORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SipType(rawValue: rawValue) ?? SipType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.SkillDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulletPoints = "BulletPoints"
        case developerInfo = "DeveloperInfo"
        case endUserLicenseAgreement = "EndUserLicenseAgreement"
        case genericKeywords = "GenericKeywords"
        case invocationPhrase = "InvocationPhrase"
        case newInThisVersionBulletPoints = "NewInThisVersionBulletPoints"
        case productDescription = "ProductDescription"
        case releaseDate = "ReleaseDate"
        case reviews = "Reviews"
        case skillTypes = "SkillTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bulletPoints = bulletPoints {
            var bulletPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .bulletPoints)
            for bulletpoints0 in bulletPoints {
                try bulletPointsContainer.encode(bulletpoints0)
            }
        }
        if let developerInfo = developerInfo {
            try encodeContainer.encode(developerInfo, forKey: .developerInfo)
        }
        if let endUserLicenseAgreement = endUserLicenseAgreement {
            try encodeContainer.encode(endUserLicenseAgreement, forKey: .endUserLicenseAgreement)
        }
        if let genericKeywords = genericKeywords {
            var genericKeywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .genericKeywords)
            for generickeywords0 in genericKeywords {
                try genericKeywordsContainer.encode(generickeywords0)
            }
        }
        if let invocationPhrase = invocationPhrase {
            try encodeContainer.encode(invocationPhrase, forKey: .invocationPhrase)
        }
        if let newInThisVersionBulletPoints = newInThisVersionBulletPoints {
            var newInThisVersionBulletPointsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .newInThisVersionBulletPoints)
            for newinthisversionbulletpoints0 in newInThisVersionBulletPoints {
                try newInThisVersionBulletPointsContainer.encode(newinthisversionbulletpoints0)
            }
        }
        if let productDescription = productDescription {
            try encodeContainer.encode(productDescription, forKey: .productDescription)
        }
        if let releaseDate = releaseDate {
            try encodeContainer.encode(releaseDate, forKey: .releaseDate)
        }
        if let reviews = reviews {
            var reviewsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .reviews)
            for (dictKey0, reviews0) in reviews {
                try reviewsContainer.encode(reviews0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let skillTypes = skillTypes {
            var skillTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skillTypes)
            for skilltypes0 in skillTypes {
                try skillTypesContainer.encode(skilltypes0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let productDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productDescription)
        productDescription = productDescriptionDecoded
        let invocationPhraseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invocationPhrase)
        invocationPhrase = invocationPhraseDecoded
        let releaseDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseDate)
        releaseDate = releaseDateDecoded
        let endUserLicenseAgreementDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endUserLicenseAgreement)
        endUserLicenseAgreement = endUserLicenseAgreementDecoded
        let genericKeywordsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .genericKeywords)
        var genericKeywordsDecoded0:[Swift.String]? = nil
        if let genericKeywordsContainer = genericKeywordsContainer {
            genericKeywordsDecoded0 = [Swift.String]()
            for string0 in genericKeywordsContainer {
                if let string0 = string0 {
                    genericKeywordsDecoded0?.append(string0)
                }
            }
        }
        genericKeywords = genericKeywordsDecoded0
        let bulletPointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .bulletPoints)
        var bulletPointsDecoded0:[Swift.String]? = nil
        if let bulletPointsContainer = bulletPointsContainer {
            bulletPointsDecoded0 = [Swift.String]()
            for string0 in bulletPointsContainer {
                if let string0 = string0 {
                    bulletPointsDecoded0?.append(string0)
                }
            }
        }
        bulletPoints = bulletPointsDecoded0
        let newInThisVersionBulletPointsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .newInThisVersionBulletPoints)
        var newInThisVersionBulletPointsDecoded0:[Swift.String]? = nil
        if let newInThisVersionBulletPointsContainer = newInThisVersionBulletPointsContainer {
            newInThisVersionBulletPointsDecoded0 = [Swift.String]()
            for string0 in newInThisVersionBulletPointsContainer {
                if let string0 = string0 {
                    newInThisVersionBulletPointsDecoded0?.append(string0)
                }
            }
        }
        newInThisVersionBulletPoints = newInThisVersionBulletPointsDecoded0
        let skillTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .skillTypes)
        var skillTypesDecoded0:[Swift.String]? = nil
        if let skillTypesContainer = skillTypesContainer {
            skillTypesDecoded0 = [Swift.String]()
            for string0 in skillTypesContainer {
                if let string0 = string0 {
                    skillTypesDecoded0?.append(string0)
                }
            }
        }
        skillTypes = skillTypesDecoded0
        let reviewsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .reviews)
        var reviewsDecoded0: [Swift.String:Swift.String]? = nil
        if let reviewsContainer = reviewsContainer {
            reviewsDecoded0 = [Swift.String:Swift.String]()
            for (key0, reviewvalue0) in reviewsContainer {
                if let reviewvalue0 = reviewvalue0 {
                    reviewsDecoded0?[key0] = reviewvalue0
                }
            }
        }
        reviews = reviewsDecoded0
        let developerInfoDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DeveloperInfo.self, forKey: .developerInfo)
        developerInfo = developerInfoDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Granular information about the skill.
    public struct SkillDetails: Swift.Equatable {
        /// The details about what the skill supports organized as bullet points.
        public var bulletPoints: [Swift.String]?
        /// The details about the developer that published the skill.
        public var developerInfo: AlexaForBusinessClientTypes.DeveloperInfo?
        /// The URL of the end user license agreement.
        public var endUserLicenseAgreement: Swift.String?
        /// The generic keywords associated with the skill that can be used to find a skill.
        public var genericKeywords: [Swift.String]?
        /// The phrase used to trigger the skill.
        public var invocationPhrase: Swift.String?
        /// The updates added in bullet points.
        public var newInThisVersionBulletPoints: [Swift.String]?
        /// The description of the product.
        public var productDescription: Swift.String?
        /// The date when the skill was released.
        public var releaseDate: Swift.String?
        /// This member has been deprecated. The list of reviews for the skill, including Key and Value pair.
        public var reviews: [Swift.String:Swift.String]?
        /// The types of skills.
        public var skillTypes: [Swift.String]?

        public init (
            bulletPoints: [Swift.String]? = nil,
            developerInfo: AlexaForBusinessClientTypes.DeveloperInfo? = nil,
            endUserLicenseAgreement: Swift.String? = nil,
            genericKeywords: [Swift.String]? = nil,
            invocationPhrase: Swift.String? = nil,
            newInThisVersionBulletPoints: [Swift.String]? = nil,
            productDescription: Swift.String? = nil,
            releaseDate: Swift.String? = nil,
            reviews: [Swift.String:Swift.String]? = nil,
            skillTypes: [Swift.String]? = nil
        )
        {
            self.bulletPoints = bulletPoints
            self.developerInfo = developerInfo
            self.endUserLicenseAgreement = endUserLicenseAgreement
            self.genericKeywords = genericKeywords
            self.invocationPhrase = invocationPhrase
            self.newInThisVersionBulletPoints = newInThisVersionBulletPoints
            self.productDescription = productDescription
            self.releaseDate = releaseDate
            self.reviews = reviews
            self.skillTypes = skillTypes
        }
    }

}

extension AlexaForBusinessClientTypes.SkillGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A skill group with attributes.
    public struct SkillGroup: Swift.Equatable {
        /// The description of a skill group.
        public var description: Swift.String?
        /// The ARN of a skill group.
        public var skillGroupArn: Swift.String?
        /// The name of a skill group.
        public var skillGroupName: Swift.String?

        public init (
            description: Swift.String? = nil,
            skillGroupArn: Swift.String? = nil,
            skillGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }
    }

}

extension AlexaForBusinessClientTypes.SkillGroupData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The attributes of a skill group.
    public struct SkillGroupData: Swift.Equatable {
        /// The description of a skill group.
        public var description: Swift.String?
        /// The skill group ARN of a skill group.
        public var skillGroupArn: Swift.String?
        /// The skill group name of a skill group.
        public var skillGroupName: Swift.String?

        public init (
            description: Swift.String? = nil,
            skillGroupArn: Swift.String? = nil,
            skillGroupName: Swift.String? = nil
        )
        {
            self.description = description
            self.skillGroupArn = skillGroupArn
            self.skillGroupName = skillGroupName
        }
    }

}

extension SkillNotLinkedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: SkillNotLinkedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The skill must be linked to a third-party account.
public struct SkillNotLinkedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct SkillNotLinkedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension SkillNotLinkedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AlexaForBusinessClientTypes.SkillSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enablementType = "EnablementType"
        case skillId = "SkillId"
        case skillName = "SkillName"
        case skillType = "SkillType"
        case supportsLinking = "SupportsLinking"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enablementType = enablementType {
            try encodeContainer.encode(enablementType.rawValue, forKey: .enablementType)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let skillName = skillName {
            try encodeContainer.encode(skillName, forKey: .skillName)
        }
        if let skillType = skillType {
            try encodeContainer.encode(skillType.rawValue, forKey: .skillType)
        }
        if supportsLinking != false {
            try encodeContainer.encode(supportsLinking, forKey: .supportsLinking)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let skillNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillName)
        skillName = skillNameDecoded
        let supportsLinkingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLinking)
        supportsLinking = supportsLinkingDecoded
        let enablementTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EnablementType.self, forKey: .enablementType)
        enablementType = enablementTypeDecoded
        let skillTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillType.self, forKey: .skillType)
        skillType = skillTypeDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The summary of skills.
    public struct SkillSummary: Swift.Equatable {
        /// Whether the skill is enabled under the user's account, or if it requires linking to be used.
        public var enablementType: AlexaForBusinessClientTypes.EnablementType?
        /// The ARN of the skill summary.
        public var skillId: Swift.String?
        /// The name of the skill.
        public var skillName: Swift.String?
        /// Whether the skill is publicly available or is a private skill.
        public var skillType: AlexaForBusinessClientTypes.SkillType?
        /// Linking support for a skill.
        public var supportsLinking: Swift.Bool

        public init (
            enablementType: AlexaForBusinessClientTypes.EnablementType? = nil,
            skillId: Swift.String? = nil,
            skillName: Swift.String? = nil,
            skillType: AlexaForBusinessClientTypes.SkillType? = nil,
            supportsLinking: Swift.Bool = false
        )
        {
            self.enablementType = enablementType
            self.skillId = skillId
            self.skillName = skillName
            self.skillType = skillType
            self.supportsLinking = supportsLinking
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum SkillType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SkillType] {
            return [
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SkillType(rawValue: rawValue) ?? SkillType.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes {
    public enum SkillTypeFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [SkillTypeFilter] {
            return [
                .all,
                .private,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SkillTypeFilter(rawValue: rawValue) ?? SkillTypeFilter.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.SkillsStoreSkill: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iconUrl = "IconUrl"
        case sampleUtterances = "SampleUtterances"
        case shortDescription = "ShortDescription"
        case skillDetails = "SkillDetails"
        case skillId = "SkillId"
        case skillName = "SkillName"
        case supportsLinking = "SupportsLinking"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iconUrl = iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
        if let sampleUtterances = sampleUtterances {
            var sampleUtterancesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sampleUtterances)
            for sampleutterances0 in sampleUtterances {
                try sampleUtterancesContainer.encode(sampleutterances0)
            }
        }
        if let shortDescription = shortDescription {
            try encodeContainer.encode(shortDescription, forKey: .shortDescription)
        }
        if let skillDetails = skillDetails {
            try encodeContainer.encode(skillDetails, forKey: .skillDetails)
        }
        if let skillId = skillId {
            try encodeContainer.encode(skillId, forKey: .skillId)
        }
        if let skillName = skillName {
            try encodeContainer.encode(skillName, forKey: .skillName)
        }
        if supportsLinking != false {
            try encodeContainer.encode(supportsLinking, forKey: .supportsLinking)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillId)
        skillId = skillIdDecoded
        let skillNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillName)
        skillName = skillNameDecoded
        let shortDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shortDescription)
        shortDescription = shortDescriptionDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let sampleUtterancesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sampleUtterances)
        var sampleUtterancesDecoded0:[Swift.String]? = nil
        if let sampleUtterancesContainer = sampleUtterancesContainer {
            sampleUtterancesDecoded0 = [Swift.String]()
            for string0 in sampleUtterancesContainer {
                if let string0 = string0 {
                    sampleUtterancesDecoded0?.append(string0)
                }
            }
        }
        sampleUtterances = sampleUtterancesDecoded0
        let skillDetailsDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SkillDetails.self, forKey: .skillDetails)
        skillDetails = skillDetailsDecoded
        let supportsLinkingDecoded = try containerValues.decode(Swift.Bool.self, forKey: .supportsLinking)
        supportsLinking = supportsLinkingDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The detailed information about an Alexa skill.
    public struct SkillsStoreSkill: Swift.Equatable {
        /// The URL where the skill icon resides.
        public var iconUrl: Swift.String?
        /// Sample utterances that interact with the skill.
        public var sampleUtterances: [Swift.String]?
        /// Short description about the skill.
        public var shortDescription: Swift.String?
        /// Information about the skill.
        public var skillDetails: AlexaForBusinessClientTypes.SkillDetails?
        /// The ARN of the skill.
        public var skillId: Swift.String?
        /// The name of the skill.
        public var skillName: Swift.String?
        /// Linking support for a skill.
        public var supportsLinking: Swift.Bool

        public init (
            iconUrl: Swift.String? = nil,
            sampleUtterances: [Swift.String]? = nil,
            shortDescription: Swift.String? = nil,
            skillDetails: AlexaForBusinessClientTypes.SkillDetails? = nil,
            skillId: Swift.String? = nil,
            skillName: Swift.String? = nil,
            supportsLinking: Swift.Bool = false
        )
        {
            self.iconUrl = iconUrl
            self.sampleUtterances = sampleUtterances
            self.shortDescription = shortDescription
            self.skillDetails = skillDetails
            self.skillId = skillId
            self.skillName = skillName
            self.supportsLinking = supportsLinking
        }
    }

}

extension AlexaForBusinessClientTypes.SmartHomeAppliance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case friendlyName = "FriendlyName"
        case manufacturerName = "ManufacturerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let friendlyName = friendlyName {
            try encodeContainer.encode(friendlyName, forKey: .friendlyName)
        }
        if let manufacturerName = manufacturerName {
            try encodeContainer.encode(manufacturerName, forKey: .manufacturerName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let friendlyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .friendlyName)
        friendlyName = friendlyNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let manufacturerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .manufacturerName)
        manufacturerName = manufacturerNameDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A smart home appliance that can connect to a central system. Any domestic device can be a smart appliance.
    public struct SmartHomeAppliance: Swift.Equatable {
        /// The description of the smart home appliance.
        public var description: Swift.String?
        /// The friendly name of the smart home appliance.
        public var friendlyName: Swift.String?
        /// The name of the manufacturer of the smart home appliance.
        public var manufacturerName: Swift.String?

        public init (
            description: Swift.String? = nil,
            friendlyName: Swift.String? = nil,
            manufacturerName: Swift.String? = nil
        )
        {
            self.description = description
            self.friendlyName = friendlyName
            self.manufacturerName = manufacturerName
        }
    }

}

extension AlexaForBusinessClientTypes.Sort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value.rawValue, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.SortValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// An object representing a sort criteria.
    public struct Sort: Swift.Equatable {
        /// The sort key of a sort object.
        /// This member is required.
        public var key: Swift.String?
        /// The sort value of a sort object.
        /// This member is required.
        public var value: AlexaForBusinessClientTypes.SortValue?

        public init (
            key: Swift.String? = nil,
            value: AlexaForBusinessClientTypes.SortValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum SortValue: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortValue] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortValue(rawValue: rawValue) ?? SortValue.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Ssml: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale = "Locale"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The SSML message. For more information, see [SSML Reference](https://developer.amazon.com/docs/custom-skills/speech-synthesis-markup-language-ssml-reference.html).
    public struct Ssml: Swift.Equatable {
        /// The locale of the SSML message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The value of the SSML message in the correct SSML format. The audio tag is not supported.
        /// This member is required.
        public var value: Swift.String?

        public init (
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            value: Swift.String? = nil
        )
        {
            self.locale = locale
            self.value = value
        }
    }

}

extension StartDeviceSyncInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case features = "Features"
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for features0 in features {
                try featuresContainer.encode(features0.rawValue)
            }
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension StartDeviceSyncInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartDeviceSyncInput: Swift.Equatable {
    /// The ARN of the device to sync. Required.
    public var deviceArn: Swift.String?
    /// Request structure to start the device sync. Required.
    /// This member is required.
    public var features: [AlexaForBusinessClientTypes.Feature]?
    /// The ARN of the room with which the device to sync is associated. Required.
    public var roomArn: Swift.String?

    public init (
        deviceArn: Swift.String? = nil,
        features: [AlexaForBusinessClientTypes.Feature]? = nil,
        roomArn: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.features = features
        self.roomArn = roomArn
    }
}

struct StartDeviceSyncInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let deviceArn: Swift.String?
    let features: [AlexaForBusinessClientTypes.Feature]?
}

extension StartDeviceSyncInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case features = "Features"
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let featuresContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Feature?].self, forKey: .features)
        var featuresDecoded0:[AlexaForBusinessClientTypes.Feature]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [AlexaForBusinessClientTypes.Feature]()
            for string0 in featuresContainer {
                if let string0 = string0 {
                    featuresDecoded0?.append(string0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension StartDeviceSyncOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartDeviceSyncOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartDeviceSyncOutputError: Swift.Error, Swift.Equatable {
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartDeviceSyncOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartDeviceSyncOutputResponse: Swift.Equatable {

}

extension StartSmartHomeApplianceDiscoveryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
    }
}

extension StartSmartHomeApplianceDiscoveryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartSmartHomeApplianceDiscoveryInput: Swift.Equatable {
    /// The room where smart home appliance discovery was initiated.
    /// This member is required.
    public var roomArn: Swift.String?

    public init (
        roomArn: Swift.String? = nil
    )
    {
        self.roomArn = roomArn
    }
}

struct StartSmartHomeApplianceDiscoveryInputBody: Swift.Equatable {
    let roomArn: Swift.String?
}

extension StartSmartHomeApplianceDiscoveryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roomArn = "RoomArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
    }
}

extension StartSmartHomeApplianceDiscoveryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSmartHomeApplianceDiscoveryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartSmartHomeApplianceDiscoveryOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSmartHomeApplianceDiscoveryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StartSmartHomeApplianceDiscoveryOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// A key-value pair that can be associated with a resource.
    public struct Tag: Swift.Equatable {
        /// The key of a tag. Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value of a tag. Tag values are case sensitive and can be null.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the resource to which to add metadata tags. Required.
    /// This member is required.
    public var arn: Swift.String?
    /// The tags to be added to the specified resource. Do not provide system tags. Required.
    /// This member is required.
    public var tags: [AlexaForBusinessClientTypes.Tag]?

    public init (
        arn: Swift.String? = nil,
        tags: [AlexaForBusinessClientTypes.Tag]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tags: [AlexaForBusinessClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[AlexaForBusinessClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [AlexaForBusinessClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes {
    public enum TemperatureUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case celsius
        case fahrenheit
        case sdkUnknown(Swift.String)

        public static var allCases: [TemperatureUnit] {
            return [
                .celsius,
                .fahrenheit,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .celsius: return "CELSIUS"
            case .fahrenheit: return "FAHRENHEIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TemperatureUnit(rawValue: rawValue) ?? TemperatureUnit.sdkUnknown(rawValue)
        }
    }
}

extension AlexaForBusinessClientTypes.Text: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale = "Locale"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.Locale.self, forKey: .locale)
        locale = localeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// The text message.
    public struct Text: Swift.Equatable {
        /// The locale of the text message. Currently, en-US is supported.
        /// This member is required.
        public var locale: AlexaForBusinessClientTypes.Locale?
        /// The value of the text message.
        /// This member is required.
        public var value: Swift.String?

        public init (
            locale: AlexaForBusinessClientTypes.Locale? = nil,
            value: Swift.String? = nil
        )
        {
            self.locale = locale
            self.value = value
        }
    }

}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller has no permissions to operate on the resource involved in the API call.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the resource from which to remove metadata tags. Required.
    /// This member is required.
    public var arn: Swift.String?
    /// The tags to be removed from the specified resource. Do not provide system tags. Required.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let arn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateAddressBookInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressBookArn = addressBookArn {
            try encodeContainer.encode(addressBookArn, forKey: .addressBookArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAddressBookInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAddressBookInput: Swift.Equatable {
    /// The ARN of the room to update.
    /// This member is required.
    public var addressBookArn: Swift.String?
    /// The updated description of the room.
    public var description: Swift.String?
    /// The updated name of the room.
    public var name: Swift.String?

    public init (
        addressBookArn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.addressBookArn = addressBookArn
        self.description = description
        self.name = name
    }
}

struct UpdateAddressBookInputBody: Swift.Equatable {
    let addressBookArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateAddressBookInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressBookArn = "AddressBookArn"
        case description = "Description"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressBookArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressBookArn)
        addressBookArn = addressBookArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAddressBookOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAddressBookOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAddressBookOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAddressBookOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAddressBookOutputResponse: Swift.Equatable {

}

extension UpdateBusinessReportScheduleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let recurrence = recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let s3BucketName = s3BucketName {
            try encodeContainer.encode(s3BucketName, forKey: .s3BucketName)
        }
        if let s3KeyPrefix = s3KeyPrefix {
            try encodeContainer.encode(s3KeyPrefix, forKey: .s3KeyPrefix)
        }
        if let scheduleArn = scheduleArn {
            try encodeContainer.encode(scheduleArn, forKey: .scheduleArn)
        }
        if let scheduleName = scheduleName {
            try encodeContainer.encode(scheduleName, forKey: .scheduleName)
        }
    }
}

extension UpdateBusinessReportScheduleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateBusinessReportScheduleInput: Swift.Equatable {
    /// The format of the generated report (individual CSV files or zipped files of individual files).
    public var format: AlexaForBusinessClientTypes.BusinessReportFormat?
    /// The recurrence of the reports.
    public var recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
    /// The S3 location of the output reports.
    public var s3BucketName: Swift.String?
    /// The S3 key where the report is delivered.
    public var s3KeyPrefix: Swift.String?
    /// The ARN of the business report schedule.
    /// This member is required.
    public var scheduleArn: Swift.String?
    /// The name identifier of the schedule.
    public var scheduleName: Swift.String?

    public init (
        format: AlexaForBusinessClientTypes.BusinessReportFormat? = nil,
        recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence? = nil,
        s3BucketName: Swift.String? = nil,
        s3KeyPrefix: Swift.String? = nil,
        scheduleArn: Swift.String? = nil,
        scheduleName: Swift.String? = nil
    )
    {
        self.format = format
        self.recurrence = recurrence
        self.s3BucketName = s3BucketName
        self.s3KeyPrefix = s3KeyPrefix
        self.scheduleArn = scheduleArn
        self.scheduleName = scheduleName
    }
}

struct UpdateBusinessReportScheduleInputBody: Swift.Equatable {
    let scheduleArn: Swift.String?
    let s3BucketName: Swift.String?
    let s3KeyPrefix: Swift.String?
    let format: AlexaForBusinessClientTypes.BusinessReportFormat?
    let scheduleName: Swift.String?
    let recurrence: AlexaForBusinessClientTypes.BusinessReportRecurrence?
}

extension UpdateBusinessReportScheduleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "Format"
        case recurrence = "Recurrence"
        case s3BucketName = "S3BucketName"
        case s3KeyPrefix = "S3KeyPrefix"
        case scheduleArn = "ScheduleArn"
        case scheduleName = "ScheduleName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleArn)
        scheduleArn = scheduleArnDecoded
        let s3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3BucketName)
        s3BucketName = s3BucketNameDecoded
        let s3KeyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3KeyPrefix)
        s3KeyPrefix = s3KeyPrefixDecoded
        let formatDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportFormat.self, forKey: .format)
        format = formatDecoded
        let scheduleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleName)
        scheduleName = scheduleNameDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.BusinessReportRecurrence.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
    }
}

extension UpdateBusinessReportScheduleOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBusinessReportScheduleOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBusinessReportScheduleOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBusinessReportScheduleOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateBusinessReportScheduleOutputResponse: Swift.Equatable {

}

extension UpdateConferenceProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conferenceProviderArn = conferenceProviderArn {
            try encodeContainer.encode(conferenceProviderArn, forKey: .conferenceProviderArn)
        }
        if let conferenceProviderType = conferenceProviderType {
            try encodeContainer.encode(conferenceProviderType.rawValue, forKey: .conferenceProviderType)
        }
        if let iPDialIn = iPDialIn {
            try encodeContainer.encode(iPDialIn, forKey: .iPDialIn)
        }
        if let meetingSetting = meetingSetting {
            try encodeContainer.encode(meetingSetting, forKey: .meetingSetting)
        }
        if let pSTNDialIn = pSTNDialIn {
            try encodeContainer.encode(pSTNDialIn, forKey: .pSTNDialIn)
        }
    }
}

extension UpdateConferenceProviderInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateConferenceProviderInput: Swift.Equatable {
    /// The ARN of the conference provider.
    /// This member is required.
    public var conferenceProviderArn: Swift.String?
    /// The type of the conference provider.
    /// This member is required.
    public var conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    /// The IP endpoint and protocol for calling.
    public var iPDialIn: AlexaForBusinessClientTypes.IPDialIn?
    /// The meeting settings for the conference provider.
    /// This member is required.
    public var meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
    /// The information for PSTN conferencing.
    public var pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn?

    public init (
        conferenceProviderArn: Swift.String? = nil,
        conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType? = nil,
        iPDialIn: AlexaForBusinessClientTypes.IPDialIn? = nil,
        meetingSetting: AlexaForBusinessClientTypes.MeetingSetting? = nil,
        pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn? = nil
    )
    {
        self.conferenceProviderArn = conferenceProviderArn
        self.conferenceProviderType = conferenceProviderType
        self.iPDialIn = iPDialIn
        self.meetingSetting = meetingSetting
        self.pSTNDialIn = pSTNDialIn
    }
}

struct UpdateConferenceProviderInputBody: Swift.Equatable {
    let conferenceProviderArn: Swift.String?
    let conferenceProviderType: AlexaForBusinessClientTypes.ConferenceProviderType?
    let iPDialIn: AlexaForBusinessClientTypes.IPDialIn?
    let pSTNDialIn: AlexaForBusinessClientTypes.PSTNDialIn?
    let meetingSetting: AlexaForBusinessClientTypes.MeetingSetting?
}

extension UpdateConferenceProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conferenceProviderArn = "ConferenceProviderArn"
        case conferenceProviderType = "ConferenceProviderType"
        case iPDialIn = "IPDialIn"
        case meetingSetting = "MeetingSetting"
        case pSTNDialIn = "PSTNDialIn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conferenceProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conferenceProviderArn)
        conferenceProviderArn = conferenceProviderArnDecoded
        let conferenceProviderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.ConferenceProviderType.self, forKey: .conferenceProviderType)
        conferenceProviderType = conferenceProviderTypeDecoded
        let iPDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.IPDialIn.self, forKey: .iPDialIn)
        iPDialIn = iPDialInDecoded
        let pSTNDialInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.PSTNDialIn.self, forKey: .pSTNDialIn)
        pSTNDialIn = pSTNDialInDecoded
        let meetingSettingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.MeetingSetting.self, forKey: .meetingSetting)
        meetingSetting = meetingSettingDecoded
    }
}

extension UpdateConferenceProviderOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConferenceProviderOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConferenceProviderOutputError: Swift.Error, Swift.Equatable {
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConferenceProviderOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateConferenceProviderOutputResponse: Swift.Equatable {

}

extension UpdateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
        if let phoneNumbers = phoneNumbers {
            var phoneNumbersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .phoneNumbers)
            for phonenumberlist0 in phoneNumbers {
                try phoneNumbersContainer.encode(phonenumberlist0)
            }
        }
        if let sipAddresses = sipAddresses {
            var sipAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sipAddresses)
            for sipaddresslist0 in sipAddresses {
                try sipAddressesContainer.encode(sipaddresslist0)
            }
        }
    }
}

extension UpdateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateContactInput: Swift.Equatable {
    /// The ARN of the contact to update.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The updated display name of the contact.
    public var displayName: Swift.String?
    /// The updated first name of the contact.
    public var firstName: Swift.String?
    /// The updated last name of the contact.
    public var lastName: Swift.String?
    /// The updated phone number of the contact. The phone number type defaults to WORK. You can either specify PhoneNumber or PhoneNumbers. We recommend that you use PhoneNumbers, which lets you specify the phone number type and multiple numbers.
    public var phoneNumber: Swift.String?
    /// The list of phone numbers for the contact.
    public var phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    /// The list of SIP addresses for the contact.
    public var sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?

    public init (
        contactArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        phoneNumber: Swift.String? = nil,
        phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]? = nil,
        sipAddresses: [AlexaForBusinessClientTypes.SipAddress]? = nil
    )
    {
        self.contactArn = contactArn
        self.displayName = displayName
        self.firstName = firstName
        self.lastName = lastName
        self.phoneNumber = phoneNumber
        self.phoneNumbers = phoneNumbers
        self.sipAddresses = sipAddresses
    }
}

struct UpdateContactInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let displayName: Swift.String?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let phoneNumber: Swift.String?
    let phoneNumbers: [AlexaForBusinessClientTypes.PhoneNumber]?
    let sipAddresses: [AlexaForBusinessClientTypes.SipAddress]?
}

extension UpdateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case firstName = "FirstName"
        case lastName = "LastName"
        case phoneNumber = "PhoneNumber"
        case phoneNumbers = "PhoneNumbers"
        case sipAddresses = "SipAddresses"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let phoneNumbersContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.PhoneNumber?].self, forKey: .phoneNumbers)
        var phoneNumbersDecoded0:[AlexaForBusinessClientTypes.PhoneNumber]? = nil
        if let phoneNumbersContainer = phoneNumbersContainer {
            phoneNumbersDecoded0 = [AlexaForBusinessClientTypes.PhoneNumber]()
            for structure0 in phoneNumbersContainer {
                if let structure0 = structure0 {
                    phoneNumbersDecoded0?.append(structure0)
                }
            }
        }
        phoneNumbers = phoneNumbersDecoded0
        let sipAddressesContainer = try containerValues.decodeIfPresent([AlexaForBusinessClientTypes.SipAddress?].self, forKey: .sipAddresses)
        var sipAddressesDecoded0:[AlexaForBusinessClientTypes.SipAddress]? = nil
        if let sipAddressesContainer = sipAddressesContainer {
            sipAddressesDecoded0 = [AlexaForBusinessClientTypes.SipAddress]()
            for structure0 in sipAddressesContainer {
                if let structure0 = structure0 {
                    sipAddressesDecoded0?.append(structure0)
                }
            }
        }
        sipAddresses = sipAddressesDecoded0
    }
}

extension UpdateContactOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateContactOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateContactOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateContactOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateContactOutputResponse: Swift.Equatable {

}

extension UpdateDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }
}

extension UpdateDeviceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateDeviceInput: Swift.Equatable {
    /// The ARN of the device to update. Required.
    public var deviceArn: Swift.String?
    /// The updated device name. Required.
    public var deviceName: Swift.String?

    public init (
        deviceArn: Swift.String? = nil,
        deviceName: Swift.String? = nil
    )
    {
        self.deviceArn = deviceArn
        self.deviceName = deviceName
    }
}

struct UpdateDeviceInputBody: Swift.Equatable {
    let deviceArn: Swift.String?
    let deviceName: Swift.String?
}

extension UpdateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceArn = "DeviceArn"
        case deviceName = "DeviceName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
    }
}

extension UpdateDeviceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceNotRegisteredException" : self = .deviceNotRegisteredException(try DeviceNotRegisteredException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case deviceNotRegisteredException(DeviceNotRegisteredException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDeviceOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case reminderAtMinutes = "ReminderAtMinutes"
        case reminderType = "ReminderType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let reminderAtMinutes = reminderAtMinutes {
            var reminderAtMinutesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .reminderAtMinutes)
            for endofmeetingreminderminuteslist0 in reminderAtMinutes {
                try reminderAtMinutesContainer.encode(endofmeetingreminderminuteslist0)
            }
        }
        if let reminderType = reminderType {
            try encodeContainer.encode(reminderType.rawValue, forKey: .reminderType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reminderAtMinutesContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .reminderAtMinutes)
        var reminderAtMinutesDecoded0:[Swift.Int]? = nil
        if let reminderAtMinutesContainer = reminderAtMinutesContainer {
            reminderAtMinutesDecoded0 = [Swift.Int]()
            for integer0 in reminderAtMinutesContainer {
                if let integer0 = integer0 {
                    reminderAtMinutesDecoded0?.append(integer0)
                }
            }
        }
        reminderAtMinutes = reminderAtMinutesDecoded0
        let reminderTypeDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EndOfMeetingReminderType.self, forKey: .reminderType)
        reminderType = reminderTypeDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
    public struct UpdateEndOfMeetingReminder: Swift.Equatable {
        /// Whether an end of meeting reminder is enabled or not.
        public var enabled: Swift.Bool?
        /// Updates settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var reminderAtMinutes: [Swift.Int]?
        /// The type of sound that users hear during the end of meeting reminder.
        public var reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType?

        public init (
            enabled: Swift.Bool? = nil,
            reminderAtMinutes: [Swift.Int]? = nil,
            reminderType: AlexaForBusinessClientTypes.EndOfMeetingReminderType? = nil
        )
        {
            self.enabled = enabled
            self.reminderAtMinutes = reminderAtMinutes
            self.reminderType = reminderType
        }
    }

}

extension UpdateGatewayGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayGroupArn = gatewayGroupArn {
            try encodeContainer.encode(gatewayGroupArn, forKey: .gatewayGroupArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateGatewayGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewayGroupInput: Swift.Equatable {
    /// The updated description of the gateway group.
    public var description: Swift.String?
    /// The ARN of the gateway group to update.
    /// This member is required.
    public var gatewayGroupArn: Swift.String?
    /// The updated name of the gateway group.
    public var name: Swift.String?

    public init (
        description: Swift.String? = nil,
        gatewayGroupArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.gatewayGroupArn = gatewayGroupArn
        self.name = name
    }
}

struct UpdateGatewayGroupInputBody: Swift.Equatable {
    let gatewayGroupArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateGatewayGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayGroupArn = "GatewayGroupArn"
        case name = "Name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayGroupArn)
        gatewayGroupArn = gatewayGroupArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGatewayGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayGroupOutputError: Swift.Error, Swift.Equatable {
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGatewayGroupOutputResponse: Swift.Equatable {

}

extension UpdateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayArn = "GatewayArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let gatewayArn = gatewayArn {
            try encodeContainer.encode(gatewayArn, forKey: .gatewayArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareVersion = softwareVersion {
            try encodeContainer.encode(softwareVersion, forKey: .softwareVersion)
        }
    }
}

extension UpdateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateGatewayInput: Swift.Equatable {
    /// The updated description of the gateway.
    public var description: Swift.String?
    /// The ARN of the gateway to update.
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The updated name of the gateway.
    public var name: Swift.String?
    /// The updated software version of the gateway. The gateway automatically updates its software version during normal operation.
    public var softwareVersion: Swift.String?

    public init (
        description: Swift.String? = nil,
        gatewayArn: Swift.String? = nil,
        name: Swift.String? = nil,
        softwareVersion: Swift.String? = nil
    )
    {
        self.description = description
        self.gatewayArn = gatewayArn
        self.name = name
        self.softwareVersion = softwareVersion
    }
}

struct UpdateGatewayInputBody: Swift.Equatable {
    let gatewayArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let softwareVersion: Swift.String?
}

extension UpdateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case gatewayArn = "GatewayArn"
        case name = "Name"
        case softwareVersion = "SoftwareVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let softwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .softwareVersion)
        softwareVersion = softwareVersionDecoded
    }
}

extension UpdateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayOutputError: Swift.Error, Swift.Equatable {
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGatewayOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.UpdateInstantBooking: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates settings for the instant booking feature that are applied to a room profile. If instant booking is enabled, Alexa automatically reserves a room if it is free when a user joins a meeting with Alexa.
    public struct UpdateInstantBooking: Swift.Equatable {
        /// Duration between 15 and 240 minutes at increments of 15 that determines how long to book an available room when a meeting is started with Alexa.
        public var durationInMinutes: Swift.Int?
        /// Whether instant booking is enabled or not.
        public var enabled: Swift.Bool?

        public init (
            durationInMinutes: Swift.Int? = nil,
            enabled: Swift.Bool? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.enabled = enabled
        }
    }

}

extension AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endOfMeetingReminder = "EndOfMeetingReminder"
        case instantBooking = "InstantBooking"
        case requireCheckIn = "RequireCheckIn"
        case roomUtilizationMetricsEnabled = "RoomUtilizationMetricsEnabled"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endOfMeetingReminder = endOfMeetingReminder {
            try encodeContainer.encode(endOfMeetingReminder, forKey: .endOfMeetingReminder)
        }
        if let instantBooking = instantBooking {
            try encodeContainer.encode(instantBooking, forKey: .instantBooking)
        }
        if let requireCheckIn = requireCheckIn {
            try encodeContainer.encode(requireCheckIn, forKey: .requireCheckIn)
        }
        if let roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled {
            try encodeContainer.encode(roomUtilizationMetricsEnabled, forKey: .roomUtilizationMetricsEnabled)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomUtilizationMetricsEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .roomUtilizationMetricsEnabled)
        roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabledDecoded
        let endOfMeetingReminderDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder.self, forKey: .endOfMeetingReminder)
        endOfMeetingReminder = endOfMeetingReminderDecoded
        let instantBookingDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateInstantBooking.self, forKey: .instantBooking)
        instantBooking = instantBookingDecoded
        let requireCheckInDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateRequireCheckIn.self, forKey: .requireCheckIn)
        requireCheckIn = requireCheckInDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates meeting room settings of a room profile.
    public struct UpdateMeetingRoomConfiguration: Swift.Equatable {
        /// Settings for the end of meeting reminder feature that are applied to a room profile. The end of meeting reminder enables Alexa to remind users when a meeting is ending.
        public var endOfMeetingReminder: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder?
        /// Settings to automatically book an available room available for a configured duration when joining a meeting with Alexa.
        public var instantBooking: AlexaForBusinessClientTypes.UpdateInstantBooking?
        /// Settings for requiring a check in when a room is reserved. Alexa can cancel a room reservation if it's not checked into to make the room available for others. Users can check in by joining the meeting with Alexa or an AVS device, or by saying Alexa, check in.
        public var requireCheckIn: AlexaForBusinessClientTypes.UpdateRequireCheckIn?
        /// Whether room utilization metrics are enabled or not.
        public var roomUtilizationMetricsEnabled: Swift.Bool?

        public init (
            endOfMeetingReminder: AlexaForBusinessClientTypes.UpdateEndOfMeetingReminder? = nil,
            instantBooking: AlexaForBusinessClientTypes.UpdateInstantBooking? = nil,
            requireCheckIn: AlexaForBusinessClientTypes.UpdateRequireCheckIn? = nil,
            roomUtilizationMetricsEnabled: Swift.Bool? = nil
        )
        {
            self.endOfMeetingReminder = endOfMeetingReminder
            self.instantBooking = instantBooking
            self.requireCheckIn = requireCheckIn
            self.roomUtilizationMetricsEnabled = roomUtilizationMetricsEnabled
        }
    }

}

extension UpdateNetworkProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case trustAnchors = "TrustAnchors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArn = certificateAuthorityArn {
            try encodeContainer.encode(certificateAuthorityArn, forKey: .certificateAuthorityArn)
        }
        if let currentPassword = currentPassword {
            try encodeContainer.encode(currentPassword, forKey: .currentPassword)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let networkProfileArn = networkProfileArn {
            try encodeContainer.encode(networkProfileArn, forKey: .networkProfileArn)
        }
        if let networkProfileName = networkProfileName {
            try encodeContainer.encode(networkProfileName, forKey: .networkProfileName)
        }
        if let nextPassword = nextPassword {
            try encodeContainer.encode(nextPassword, forKey: .nextPassword)
        }
        if let trustAnchors = trustAnchors {
            var trustAnchorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .trustAnchors)
            for trustanchorlist0 in trustAnchors {
                try trustAnchorsContainer.encode(trustanchorlist0)
            }
        }
    }
}

extension UpdateNetworkProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateNetworkProfileInput: Swift.Equatable {
    /// The ARN of the Private Certificate Authority (PCA) created in AWS Certificate Manager (ACM). This is used to issue certificates to the devices.
    public var certificateAuthorityArn: Swift.String?
    /// The current password of the Wi-Fi network.
    public var currentPassword: Swift.String?
    /// Detailed information about a device's network profile.
    public var description: Swift.String?
    /// The ARN of the network profile associated with a device.
    /// This member is required.
    public var networkProfileArn: Swift.String?
    /// The name of the network profile associated with a device.
    public var networkProfileName: Swift.String?
    /// The next, or subsequent, password of the Wi-Fi network. This password is asynchronously transmitted to the device and is used when the password of the network changes to NextPassword.
    public var nextPassword: Swift.String?
    /// The root certificate(s) of your authentication server that will be installed on your devices and used to trust your authentication server during EAP negotiation.
    public var trustAnchors: [Swift.String]?

    public init (
        certificateAuthorityArn: Swift.String? = nil,
        currentPassword: Swift.String? = nil,
        description: Swift.String? = nil,
        networkProfileArn: Swift.String? = nil,
        networkProfileName: Swift.String? = nil,
        nextPassword: Swift.String? = nil,
        trustAnchors: [Swift.String]? = nil
    )
    {
        self.certificateAuthorityArn = certificateAuthorityArn
        self.currentPassword = currentPassword
        self.description = description
        self.networkProfileArn = networkProfileArn
        self.networkProfileName = networkProfileName
        self.nextPassword = nextPassword
        self.trustAnchors = trustAnchors
    }
}

struct UpdateNetworkProfileInputBody: Swift.Equatable {
    let networkProfileArn: Swift.String?
    let networkProfileName: Swift.String?
    let description: Swift.String?
    let currentPassword: Swift.String?
    let nextPassword: Swift.String?
    let certificateAuthorityArn: Swift.String?
    let trustAnchors: [Swift.String]?
}

extension UpdateNetworkProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityArn = "CertificateAuthorityArn"
        case currentPassword = "CurrentPassword"
        case description = "Description"
        case networkProfileArn = "NetworkProfileArn"
        case networkProfileName = "NetworkProfileName"
        case nextPassword = "NextPassword"
        case trustAnchors = "TrustAnchors"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileArn)
        networkProfileArn = networkProfileArnDecoded
        let networkProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkProfileName)
        networkProfileName = networkProfileNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let currentPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentPassword)
        currentPassword = currentPasswordDecoded
        let nextPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextPassword)
        nextPassword = nextPasswordDecoded
        let certificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityArn)
        certificateAuthorityArn = certificateAuthorityArnDecoded
        let trustAnchorsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .trustAnchors)
        var trustAnchorsDecoded0:[Swift.String]? = nil
        if let trustAnchorsContainer = trustAnchorsContainer {
            trustAnchorsDecoded0 = [Swift.String]()
            for string0 in trustAnchorsContainer {
                if let string0 = string0 {
                    trustAnchorsDecoded0?.append(string0)
                }
            }
        }
        trustAnchors = trustAnchorsDecoded0
    }
}

extension UpdateNetworkProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNetworkProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCertificateAuthorityException" : self = .invalidCertificateAuthorityException(try InvalidCertificateAuthorityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecretsManagerResourceException" : self = .invalidSecretsManagerResourceException(try InvalidSecretsManagerResourceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateNetworkProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case invalidCertificateAuthorityException(InvalidCertificateAuthorityException)
    case invalidSecretsManagerResourceException(InvalidSecretsManagerResourceException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNetworkProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNetworkProfileOutputResponse: Swift.Equatable {

}

extension UpdateProfileInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let dataRetentionOptIn = dataRetentionOptIn {
            try encodeContainer.encode(dataRetentionOptIn, forKey: .dataRetentionOptIn)
        }
        if let distanceUnit = distanceUnit {
            try encodeContainer.encode(distanceUnit.rawValue, forKey: .distanceUnit)
        }
        if let isDefault = isDefault {
            try encodeContainer.encode(isDefault, forKey: .isDefault)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxVolumeLimit = maxVolumeLimit {
            try encodeContainer.encode(maxVolumeLimit, forKey: .maxVolumeLimit)
        }
        if let meetingRoomConfiguration = meetingRoomConfiguration {
            try encodeContainer.encode(meetingRoomConfiguration, forKey: .meetingRoomConfiguration)
        }
        if let pSTNEnabled = pSTNEnabled {
            try encodeContainer.encode(pSTNEnabled, forKey: .pSTNEnabled)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let profileName = profileName {
            try encodeContainer.encode(profileName, forKey: .profileName)
        }
        if let setupModeDisabled = setupModeDisabled {
            try encodeContainer.encode(setupModeDisabled, forKey: .setupModeDisabled)
        }
        if let temperatureUnit = temperatureUnit {
            try encodeContainer.encode(temperatureUnit.rawValue, forKey: .temperatureUnit)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let wakeWord = wakeWord {
            try encodeContainer.encode(wakeWord.rawValue, forKey: .wakeWord)
        }
    }
}

extension UpdateProfileInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateProfileInput: Swift.Equatable {
    /// The updated address for the room profile.
    public var address: Swift.String?
    /// Whether data retention of the profile is enabled.
    public var dataRetentionOptIn: Swift.Bool?
    /// The updated distance unit for the room profile.
    public var distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    /// Sets the profile as default if selected. If this is missing, no update is done to the default status.
    public var isDefault: Swift.Bool?
    /// The updated locale for the room profile. (This is currently only available to a limited preview audience.)
    public var locale: Swift.String?
    /// The updated maximum volume limit for the room profile.
    public var maxVolumeLimit: Swift.Int?
    /// The updated meeting room settings of a room profile.
    public var meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration?
    /// Whether the PSTN setting of the room profile is enabled.
    public var pSTNEnabled: Swift.Bool?
    /// The ARN of the room profile to update. Required.
    public var profileArn: Swift.String?
    /// The updated name for the room profile.
    public var profileName: Swift.String?
    /// Whether the setup mode of the profile is enabled.
    public var setupModeDisabled: Swift.Bool?
    /// The updated temperature unit for the room profile.
    public var temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    /// The updated timezone for the room profile.
    public var timezone: Swift.String?
    /// The updated wake word for the room profile.
    public var wakeWord: AlexaForBusinessClientTypes.WakeWord?

    public init (
        address: Swift.String? = nil,
        dataRetentionOptIn: Swift.Bool? = nil,
        distanceUnit: AlexaForBusinessClientTypes.DistanceUnit? = nil,
        isDefault: Swift.Bool? = nil,
        locale: Swift.String? = nil,
        maxVolumeLimit: Swift.Int? = nil,
        meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration? = nil,
        pSTNEnabled: Swift.Bool? = nil,
        profileArn: Swift.String? = nil,
        profileName: Swift.String? = nil,
        setupModeDisabled: Swift.Bool? = nil,
        temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit? = nil,
        timezone: Swift.String? = nil,
        wakeWord: AlexaForBusinessClientTypes.WakeWord? = nil
    )
    {
        self.address = address
        self.dataRetentionOptIn = dataRetentionOptIn
        self.distanceUnit = distanceUnit
        self.isDefault = isDefault
        self.locale = locale
        self.maxVolumeLimit = maxVolumeLimit
        self.meetingRoomConfiguration = meetingRoomConfiguration
        self.pSTNEnabled = pSTNEnabled
        self.profileArn = profileArn
        self.profileName = profileName
        self.setupModeDisabled = setupModeDisabled
        self.temperatureUnit = temperatureUnit
        self.timezone = timezone
        self.wakeWord = wakeWord
    }
}

struct UpdateProfileInputBody: Swift.Equatable {
    let profileArn: Swift.String?
    let profileName: Swift.String?
    let isDefault: Swift.Bool?
    let timezone: Swift.String?
    let address: Swift.String?
    let distanceUnit: AlexaForBusinessClientTypes.DistanceUnit?
    let temperatureUnit: AlexaForBusinessClientTypes.TemperatureUnit?
    let wakeWord: AlexaForBusinessClientTypes.WakeWord?
    let locale: Swift.String?
    let setupModeDisabled: Swift.Bool?
    let maxVolumeLimit: Swift.Int?
    let pSTNEnabled: Swift.Bool?
    let dataRetentionOptIn: Swift.Bool?
    let meetingRoomConfiguration: AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration?
}

extension UpdateProfileInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case dataRetentionOptIn = "DataRetentionOptIn"
        case distanceUnit = "DistanceUnit"
        case isDefault = "IsDefault"
        case locale = "Locale"
        case maxVolumeLimit = "MaxVolumeLimit"
        case meetingRoomConfiguration = "MeetingRoomConfiguration"
        case pSTNEnabled = "PSTNEnabled"
        case profileArn = "ProfileArn"
        case profileName = "ProfileName"
        case setupModeDisabled = "SetupModeDisabled"
        case temperatureUnit = "TemperatureUnit"
        case timezone = "Timezone"
        case wakeWord = "WakeWord"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
        let profileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileName)
        profileName = profileNameDecoded
        let isDefaultDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDefault)
        isDefault = isDefaultDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let distanceUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.DistanceUnit.self, forKey: .distanceUnit)
        distanceUnit = distanceUnitDecoded
        let temperatureUnitDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.TemperatureUnit.self, forKey: .temperatureUnit)
        temperatureUnit = temperatureUnitDecoded
        let wakeWordDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.WakeWord.self, forKey: .wakeWord)
        wakeWord = wakeWordDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let setupModeDisabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .setupModeDisabled)
        setupModeDisabled = setupModeDisabledDecoded
        let maxVolumeLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxVolumeLimit)
        maxVolumeLimit = maxVolumeLimitDecoded
        let pSTNEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pSTNEnabled)
        pSTNEnabled = pSTNEnabledDecoded
        let dataRetentionOptInDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dataRetentionOptIn)
        dataRetentionOptIn = dataRetentionOptInDecoded
        let meetingRoomConfigurationDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.UpdateMeetingRoomConfiguration.self, forKey: .meetingRoomConfiguration)
        meetingRoomConfiguration = meetingRoomConfigurationDecoded
    }
}

extension UpdateProfileOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProfileOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProfileOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProfileOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProfileOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.UpdateRequireCheckIn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled = "Enabled"
        case releaseAfterMinutes = "ReleaseAfterMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let releaseAfterMinutes = releaseAfterMinutes {
            try encodeContainer.encode(releaseAfterMinutes, forKey: .releaseAfterMinutes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let releaseAfterMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .releaseAfterMinutes)
        releaseAfterMinutes = releaseAfterMinutesDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Updates settings for the require check in feature that are applied to a room profile. Require check in allows a meeting rooms Alexa or AVS device to prompt the user to check in; otherwise, the room will be released.
    public struct UpdateRequireCheckIn: Swift.Equatable {
        /// Whether require check in is enabled or not.
        public var enabled: Swift.Bool?
        /// Duration between 5 and 20 minutes to determine when to release the room if it's not checked into.
        public var releaseAfterMinutes: Swift.Int?

        public init (
            enabled: Swift.Bool? = nil,
            releaseAfterMinutes: Swift.Int? = nil
        )
        {
            self.enabled = enabled
            self.releaseAfterMinutes = releaseAfterMinutes
        }
    }

}

extension UpdateRoomInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let profileArn = profileArn {
            try encodeContainer.encode(profileArn, forKey: .profileArn)
        }
        if let providerCalendarId = providerCalendarId {
            try encodeContainer.encode(providerCalendarId, forKey: .providerCalendarId)
        }
        if let roomArn = roomArn {
            try encodeContainer.encode(roomArn, forKey: .roomArn)
        }
        if let roomName = roomName {
            try encodeContainer.encode(roomName, forKey: .roomName)
        }
    }
}

extension UpdateRoomInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRoomInput: Swift.Equatable {
    /// The updated description for the room.
    public var description: Swift.String?
    /// The updated profile ARN for the room.
    public var profileArn: Swift.String?
    /// The updated provider calendar ARN for the room.
    public var providerCalendarId: Swift.String?
    /// The ARN of the room to update.
    public var roomArn: Swift.String?
    /// The updated name for the room.
    public var roomName: Swift.String?

    public init (
        description: Swift.String? = nil,
        profileArn: Swift.String? = nil,
        providerCalendarId: Swift.String? = nil,
        roomArn: Swift.String? = nil,
        roomName: Swift.String? = nil
    )
    {
        self.description = description
        self.profileArn = profileArn
        self.providerCalendarId = providerCalendarId
        self.roomArn = roomArn
        self.roomName = roomName
    }
}

struct UpdateRoomInputBody: Swift.Equatable {
    let roomArn: Swift.String?
    let roomName: Swift.String?
    let description: Swift.String?
    let providerCalendarId: Swift.String?
    let profileArn: Swift.String?
}

extension UpdateRoomInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case profileArn = "ProfileArn"
        case providerCalendarId = "ProviderCalendarId"
        case roomArn = "RoomArn"
        case roomName = "RoomName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roomArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomArn)
        roomArn = roomArnDecoded
        let roomNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roomName)
        roomName = roomNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let providerCalendarIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .providerCalendarId)
        providerCalendarId = providerCalendarIdDecoded
        let profileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .profileArn)
        profileArn = profileArnDecoded
    }
}

extension UpdateRoomOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRoomOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRoomOutputError: Swift.Error, Swift.Equatable {
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRoomOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRoomOutputResponse: Swift.Equatable {

}

extension UpdateSkillGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let skillGroupArn = skillGroupArn {
            try encodeContainer.encode(skillGroupArn, forKey: .skillGroupArn)
        }
        if let skillGroupName = skillGroupName {
            try encodeContainer.encode(skillGroupName, forKey: .skillGroupName)
        }
    }
}

extension UpdateSkillGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateSkillGroupInput: Swift.Equatable {
    /// The updated description for the skill group.
    public var description: Swift.String?
    /// The ARN of the skill group to update.
    public var skillGroupArn: Swift.String?
    /// The updated name for the skill group.
    public var skillGroupName: Swift.String?

    public init (
        description: Swift.String? = nil,
        skillGroupArn: Swift.String? = nil,
        skillGroupName: Swift.String? = nil
    )
    {
        self.description = description
        self.skillGroupArn = skillGroupArn
        self.skillGroupName = skillGroupName
    }
}

struct UpdateSkillGroupInputBody: Swift.Equatable {
    let skillGroupArn: Swift.String?
    let skillGroupName: Swift.String?
    let description: Swift.String?
}

extension UpdateSkillGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case skillGroupArn = "SkillGroupArn"
        case skillGroupName = "SkillGroupName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let skillGroupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupArn)
        skillGroupArn = skillGroupArnDecoded
        let skillGroupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .skillGroupName)
        skillGroupName = skillGroupNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateSkillGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSkillGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NameInUseException" : self = .nameInUseException(try NameInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSkillGroupOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case nameInUseException(NameInUseException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSkillGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSkillGroupOutputResponse: Swift.Equatable {

}

extension AlexaForBusinessClientTypes.UserData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email = "Email"
        case enrollmentId = "EnrollmentId"
        case enrollmentStatus = "EnrollmentStatus"
        case firstName = "FirstName"
        case lastName = "LastName"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let enrollmentId = enrollmentId {
            try encodeContainer.encode(enrollmentId, forKey: .enrollmentId)
        }
        if let enrollmentStatus = enrollmentStatus {
            try encodeContainer.encode(enrollmentStatus.rawValue, forKey: .enrollmentStatus)
        }
        if let firstName = firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let enrollmentStatusDecoded = try containerValues.decodeIfPresent(AlexaForBusinessClientTypes.EnrollmentStatus.self, forKey: .enrollmentStatus)
        enrollmentStatus = enrollmentStatusDecoded
        let enrollmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .enrollmentId)
        enrollmentId = enrollmentIdDecoded
    }
}

extension AlexaForBusinessClientTypes {
    /// Information related to a user.
    public struct UserData: Swift.Equatable {
        /// The email of a user.
        public var email: Swift.String?
        /// The enrollment ARN of a user.
        public var enrollmentId: Swift.String?
        /// The enrollment status of a user.
        public var enrollmentStatus: AlexaForBusinessClientTypes.EnrollmentStatus?
        /// The first name of a user.
        public var firstName: Swift.String?
        /// The last name of a user.
        public var lastName: Swift.String?
        /// The ARN of a user.
        public var userArn: Swift.String?

        public init (
            email: Swift.String? = nil,
            enrollmentId: Swift.String? = nil,
            enrollmentStatus: AlexaForBusinessClientTypes.EnrollmentStatus? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.email = email
            self.enrollmentId = enrollmentId
            self.enrollmentStatus = enrollmentStatus
            self.firstName = firstName
            self.lastName = lastName
            self.userArn = userArn
        }
    }

}

extension AlexaForBusinessClientTypes {
    public enum WakeWord: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alexa
        case amazon
        case computer
        case echo
        case sdkUnknown(Swift.String)

        public static var allCases: [WakeWord] {
            return [
                .alexa,
                .amazon,
                .computer,
                .echo,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alexa: return "ALEXA"
            case .amazon: return "AMAZON"
            case .computer: return "COMPUTER"
            case .echo: return "ECHO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = WakeWord(rawValue: rawValue) ?? WakeWord.sdkUnknown(rawValue)
        }
    }
}
