// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(FileAccessLog.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the access logging information for a virtual node.</p>
public enum AccessLog: Equatable {
    /// <p>The file object to send virtual node access logs to.</p>
    case file(FileAccessLog?)
    case sdkUnknown(String?)
}

extension AwsCloudMapInstanceAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension AwsCloudMapInstanceAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudMapInstanceAttribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>An object that represents the AWS Cloud Map attribute information for your virtual
///          node.</p>
///          <note>
///             <p>AWS Cloud Map is not available in the eu-south-1 Region.</p>
///          </note>
public struct AwsCloudMapInstanceAttribute: Equatable {
    /// <p>The name of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service
    ///          instance that contains the specified key and value is returned.</p>
    public let key: String?
    /// <p>The value of an AWS Cloud Map service instance attribute key. Any AWS Cloud Map service
    ///          instance that contains the specified key and value is returned.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension AwsCloudMapServiceDiscovery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case namespaceName
        case serviceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for awscloudmapinstanceattributes0 in attributes {
                try attributesContainer.encode(awscloudmapinstanceattributes0)
            }
        }
        if let namespaceName = namespaceName {
            try encodeContainer.encode(namespaceName, forKey: .namespaceName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namespaceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namespaceName)
        namespaceName = namespaceNameDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let attributesContainer = try containerValues.decodeIfPresent([AwsCloudMapInstanceAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[AwsCloudMapInstanceAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AwsCloudMapInstanceAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AwsCloudMapServiceDiscovery: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AwsCloudMapServiceDiscovery(attributes: \(String(describing: attributes)), namespaceName: \(String(describing: namespaceName)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>An object that represents the AWS Cloud Map service discovery information for your virtual
///          node.</p>
///          <note>
///             <p>AWS Cloud Map is not available in the eu-south-1 Region.</p>
///          </note>
public struct AwsCloudMapServiceDiscovery: Equatable {
    /// <p>A string map that contains attributes with values that you can use to filter instances
    ///          by any custom attribute that you specified when you registered the instance. Only instances
    ///          that match all of the specified key/value pairs will be returned.</p>
    public let attributes: [AwsCloudMapInstanceAttribute]?
    /// <p>The name of the AWS Cloud Map namespace to use.</p>
    public let namespaceName: String?
    /// <p>The name of the AWS Cloud Map service to use.</p>
    public let serviceName: String?

    public init (
        attributes: [AwsCloudMapInstanceAttribute]? = nil,
        namespaceName: String? = nil,
        serviceName: String? = nil
    )
    {
        self.attributes = attributes
        self.namespaceName = namespaceName
        self.serviceName = serviceName
    }
}

extension Backend: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sdkUnknown
        case virtualService
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .virtualService(virtualService):
                if let virtualService = virtualService {
                    try container.encode(virtualService, forKey: .virtualService)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try values.decodeIfPresent(VirtualServiceBackend.self, forKey: .virtualService)
        if let virtualService = virtualServiceDecoded {
            self = .virtualService(virtualService)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the backends that a virtual node is expected to send outbound
///          traffic to.</p>
public enum Backend: Equatable {
    /// <p>Specifies a virtual service to use as a backend.  </p>
    case virtualService(VirtualServiceBackend?)
    case sdkUnknown(String?)
}

extension BackendDefaults: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientPolicy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientPolicy = clientPolicy {
            try encodeContainer.encode(clientPolicy, forKey: .clientPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPolicyDecoded = try containerValues.decodeIfPresent(ClientPolicy.self, forKey: .clientPolicy)
        clientPolicy = clientPolicyDecoded
    }
}

extension BackendDefaults: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BackendDefaults(clientPolicy: \(String(describing: clientPolicy)))"}
}

/// <p>An object that represents the default properties for a backend.</p>
public struct BackendDefaults: Equatable {
    /// <p>A reference to an object that represents a client policy.</p>
    public let clientPolicy: ClientPolicy?

    public init (
        clientPolicy: ClientPolicy? = nil
    )
    {
        self.clientPolicy = clientPolicy
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request syntax was malformed. Check your request syntax and try again.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ClientPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tls
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tls = tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsDecoded = try containerValues.decodeIfPresent(ClientPolicyTls.self, forKey: .tls)
        tls = tlsDecoded
    }
}

extension ClientPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientPolicy(tls: \(String(describing: tls)))"}
}

/// <p>An object that represents a client policy.</p>
public struct ClientPolicy: Equatable {
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) client policy.</p>
    public let tls: ClientPolicyTls?

    public init (
        tls: ClientPolicyTls? = nil
    )
    {
        self.tls = tls
    }
}

extension ClientPolicyTls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate
        case enforce
        case ports
        case validation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let enforce = enforce {
            try encodeContainer.encode(enforce, forKey: .enforce)
        }
        if let ports = ports {
            var portsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ports)
            for portset0 in ports {
                try portsContainer.encode(portset0)
            }
        }
        if let validation = validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enforce)
        enforce = enforceDecoded
        let portsContainer = try containerValues.decodeIfPresent(Set<Int>.self, forKey: .ports)
        var portsDecoded0:Set<Int>? = nil
        if let portsContainer = portsContainer {
            portsDecoded0 = Set<Int>()
            for integer0 in portsContainer {
                portsDecoded0?.insert(integer0)
            }
        }
        ports = portsDecoded0
        let certificateDecoded = try containerValues.decodeIfPresent(ClientTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
        let validationDecoded = try containerValues.decodeIfPresent(TlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension ClientPolicyTls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ClientPolicyTls(certificate: \(String(describing: certificate)), enforce: \(String(describing: enforce)), ports: \(String(describing: ports)), validation: \(String(describing: validation)))"}
}

/// <p>A reference to an object that represents a Transport Layer Security (TLS) client policy.</p>
public struct ClientPolicyTls: Equatable {
    /// <p>A reference to an object that represents a client's TLS certificate.</p>
    public let certificate: ClientTlsCertificate?
    /// <p>Whether the policy is enforced. The default is <code>True</code>, if a value isn't specified.</p>
    public let enforce: Bool?
    /// <p>One or more ports that the policy is enforced for.</p>
    public let ports: Set<Int>?
    /// <p>A reference to an object that represents a TLS validation context.</p>
    public let validation: TlsValidationContext?

    public init (
        certificate: ClientTlsCertificate? = nil,
        enforce: Bool? = nil,
        ports: Set<Int>? = nil,
        validation: TlsValidationContext? = nil
    )
    {
        self.certificate = certificate
        self.enforce = enforce
        self.ports = ports
        self.validation = validation
    }
}

extension ClientTlsCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(ListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(ListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the client's certificate.</p>
public enum ClientTlsCertificate: Equatable {
    /// <p>An object that represents a local file certificate.
    ///          The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.</p>
    case file(ListenerTlsFileCertificate?)
    /// <p>A reference to an object that represents a client's TLS Secret Discovery Service
    ///          certificate.</p>
    case sds(ListenerTlsSdsCertificate?)
    case sdkUnknown(String?)
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request contains a client token that was used for a previous update resource call
///          with different specifications. Try the request again with a new client token.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct CreateGatewayRouteInputBodyMiddleware: Middleware {
    public let id: String = "CreateGatewayRouteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayRouteInput>
    public typealias MOutput = OperationOutput<CreateGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayRouteOutputError>
}

extension CreateGatewayRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGatewayRouteInput(clientToken: \(String(describing: clientToken)), gatewayRouteName: \(String(describing: gatewayRouteName)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), tags: \(String(describing: tags)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension CreateGatewayRouteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case gatewayRouteName
        case spec
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let gatewayRouteName = gatewayRouteName {
            try encodeContainer.encode(gatewayRouteName, forKey: .gatewayRouteName)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateGatewayRouteInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGatewayRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayRouteInput>
    public typealias MOutput = OperationOutput<CreateGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayRouteOutputError>
}

public struct CreateGatewayRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGatewayRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGatewayRouteInput>
    public typealias MOutput = OperationOutput<CreateGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGatewayRouteOutputError>
}

public struct CreateGatewayRouteInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name to use for the gateway route.</p>
    public let gatewayRouteName: String?
    /// <p>The name of the service mesh to create the gateway route in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
    ///                the account that you specify must share the mesh with your account before you can create
    ///              the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The gateway route specification to apply.</p>
    public let spec: GatewayRouteSpec?
    /// <p>Optional metadata that you can apply to the gateway route to assist with categorization
    ///          and organization. Each tag consists of a key and an optional value, both of which you
    ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?
    /// <p>The name of the virtual gateway to associate the gateway route with. If the virtual
    ///          gateway is in a shared mesh, then you must be the owner of the virtual gateway
    ///          resource.</p>
    public let virtualGatewayName: String?

    public init (
        clientToken: String? = nil,
        gatewayRouteName: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: GatewayRouteSpec? = nil,
        tags: [TagRef]? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualGatewayName = virtualGatewayName
    }
}

struct CreateGatewayRouteInputBody: Equatable {
    public let gatewayRouteName: String?
    public let spec: GatewayRouteSpec?
    public let tags: [TagRef]?
    public let clientToken: String?
}

extension CreateGatewayRouteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case gatewayRouteName
        case spec
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayRouteName)
        gatewayRouteName = gatewayRouteNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(GatewayRouteSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateGatewayRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGatewayRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGatewayRouteOutputResponse(gatewayRoute: \(String(describing: gatewayRoute)))"}
}

extension CreateGatewayRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: GatewayRouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct CreateGatewayRouteOutputResponse: Equatable {
    /// <p>The full description of your gateway route following the create call.</p>
    public let gatewayRoute: GatewayRouteData?

    public init (
        gatewayRoute: GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct CreateGatewayRouteOutputResponseBody: Equatable {
    public let gatewayRoute: GatewayRouteData?
}

extension CreateGatewayRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

public struct CreateMeshInputBodyMiddleware: Middleware {
    public let id: String = "CreateMeshInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMeshInput>
    public typealias MOutput = OperationOutput<CreateMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMeshOutputError>
}

extension CreateMeshInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMeshInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), spec: \(String(describing: spec)), tags: \(String(describing: tags)))"}
}

extension CreateMeshInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case meshName
        case spec
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateMeshInputHeadersMiddleware: Middleware {
    public let id: String = "CreateMeshInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMeshInput>
    public typealias MOutput = OperationOutput<CreateMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMeshOutputError>
}

public struct CreateMeshInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateMeshInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateMeshInput>
    public typealias MOutput = OperationOutput<CreateMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateMeshOutputError>
}

///
public struct CreateMeshInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name to use for the service mesh.</p>
    public let meshName: String?
    /// <p>The service mesh specification to apply.</p>
    public let spec: MeshSpec?
    /// <p>Optional metadata that you can apply to the service mesh to assist with categorization
    ///          and organization. Each tag consists of a key and an optional value, both of which you
    ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        spec: MeshSpec? = nil,
        tags: [TagRef]? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.spec = spec
        self.tags = tags
    }
}

struct CreateMeshInputBody: Equatable {
    public let meshName: String?
    public let spec: MeshSpec?
    public let tags: [TagRef]?
    public let clientToken: String?
}

extension CreateMeshInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case meshName
        case spec
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(MeshSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateMeshOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMeshOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateMeshOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMeshOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateMeshOutputResponse(mesh: \(String(describing: mesh)))"}
}

extension CreateMeshOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MeshData = try responseDecoder.decode(responseBody: unwrappedData)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct CreateMeshOutputResponse: Equatable {
    /// <p>The full description of your service mesh following the create call.</p>
    public let mesh: MeshData?

    public init (
        mesh: MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct CreateMeshOutputResponseBody: Equatable {
    public let mesh: MeshData?
}

extension CreateMeshOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mesh
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

public struct CreateRouteInputBodyMiddleware: Middleware {
    public let id: String = "CreateRouteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteInput>
    public typealias MOutput = OperationOutput<CreateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteOutputError>
}

extension CreateRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRouteInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), routeName: \(String(describing: routeName)), spec: \(String(describing: spec)), tags: \(String(describing: tags)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension CreateRouteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case routeName
        case spec
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let routeName = routeName {
            try encodeContainer.encode(routeName, forKey: .routeName)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateRouteInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteInput>
    public typealias MOutput = OperationOutput<CreateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteOutputError>
}

public struct CreateRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRouteInput>
    public typealias MOutput = OperationOutput<CreateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRouteOutputError>
}

///
public struct CreateRouteInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh to create the route in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
    ///                the account that you specify must share the mesh with your account before you can create
    ///              the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name to use for the route.</p>
    public let routeName: String?
    /// <p>The route specification to apply.</p>
    public let spec: RouteSpec?
    /// <p>Optional metadata that you can apply to the route to assist with categorization and
    ///          organization. Each tag consists of a key and an optional value, both of which you define.
    ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?
    /// <p>The name of the virtual router in which to create the route. If the virtual router is in
    ///          a shared mesh, then you must be the owner of the virtual router resource.</p>
    public let virtualRouterName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        routeName: String? = nil,
        spec: RouteSpec? = nil,
        tags: [TagRef]? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.spec = spec
        self.tags = tags
        self.virtualRouterName = virtualRouterName
    }
}

struct CreateRouteInputBody: Equatable {
    public let routeName: String?
    public let spec: RouteSpec?
    public let tags: [TagRef]?
    public let clientToken: String?
}

extension CreateRouteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case routeName
        case spec
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeName)
        routeName = routeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(RouteSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRouteOutputResponse(route: \(String(describing: route)))"}
}

extension CreateRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct CreateRouteOutputResponse: Equatable {
    /// <p>The full description of your mesh following the create call.</p>
    public let route: RouteData?

    public init (
        route: RouteData? = nil
    )
    {
        self.route = route
    }
}

struct CreateRouteOutputResponseBody: Equatable {
    public let route: RouteData?
}

extension CreateRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case route
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

public struct CreateVirtualGatewayInputBodyMiddleware: Middleware {
    public let id: String = "CreateVirtualGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualGatewayInput>
    public typealias MOutput = OperationOutput<CreateVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualGatewayOutputError>
}

extension CreateVirtualGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualGatewayInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), tags: \(String(describing: tags)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension CreateVirtualGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualGatewayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualGatewayName = virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }
}

public struct CreateVirtualGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVirtualGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualGatewayInput>
    public typealias MOutput = OperationOutput<CreateVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualGatewayOutputError>
}

public struct CreateVirtualGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVirtualGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualGatewayInput>
    public typealias MOutput = OperationOutput<CreateVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualGatewayOutputError>
}

public struct CreateVirtualGatewayInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh to create the virtual gateway in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
    ///                the account that you specify must share the mesh with your account before you can create
    ///              the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The virtual gateway specification to apply.</p>
    public let spec: VirtualGatewaySpec?
    /// <p>Optional metadata that you can apply to the virtual gateway to assist with
    ///          categorization and organization. Each tag consists of a key and an optional value, both of
    ///          which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?
    /// <p>The name to use for the virtual gateway.</p>
    public let virtualGatewayName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualGatewaySpec? = nil,
        tags: [TagRef]? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualGatewayName = virtualGatewayName
    }
}

struct CreateVirtualGatewayInputBody: Equatable {
    public let virtualGatewayName: String?
    public let spec: VirtualGatewaySpec?
    public let tags: [TagRef]?
    public let clientToken: String?
}

extension CreateVirtualGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualGatewayName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualGatewaySpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualGatewayOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualGatewayOutputResponse(virtualGateway: \(String(describing: virtualGateway)))"}
}

extension CreateVirtualGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualGatewayData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct CreateVirtualGatewayOutputResponse: Equatable {
    /// <p>The full description of your virtual gateway following the create call.</p>
    public let virtualGateway: VirtualGatewayData?

    public init (
        virtualGateway: VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct CreateVirtualGatewayOutputResponseBody: Equatable {
    public let virtualGateway: VirtualGatewayData?
}

extension CreateVirtualGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

public struct CreateVirtualNodeInputBodyMiddleware: Middleware {
    public let id: String = "CreateVirtualNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualNodeInput>
    public typealias MOutput = OperationOutput<CreateVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualNodeOutputError>
}

extension CreateVirtualNodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualNodeInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), tags: \(String(describing: tags)), virtualNodeName: \(String(describing: virtualNodeName)))"}
}

extension CreateVirtualNodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualNodeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualNodeName = virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }
}

public struct CreateVirtualNodeInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVirtualNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualNodeInput>
    public typealias MOutput = OperationOutput<CreateVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualNodeOutputError>
}

public struct CreateVirtualNodeInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVirtualNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualNodeInput>
    public typealias MOutput = OperationOutput<CreateVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualNodeOutputError>
}

///
public struct CreateVirtualNodeInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh to create the virtual node in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
    ///                the account that you specify must share the mesh with your account before you can create
    ///              the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The virtual node specification to apply.</p>
    public let spec: VirtualNodeSpec?
    /// <p>Optional metadata that you can apply to the virtual node to assist with categorization
    ///          and organization. Each tag consists of a key and an optional value, both of which you
    ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?
    /// <p>The name to use for the virtual node.</p>
    public let virtualNodeName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualNodeSpec? = nil,
        tags: [TagRef]? = nil,
        virtualNodeName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualNodeName = virtualNodeName
    }
}

struct CreateVirtualNodeInputBody: Equatable {
    public let virtualNodeName: String?
    public let spec: VirtualNodeSpec?
    public let tags: [TagRef]?
    public let clientToken: String?
}

extension CreateVirtualNodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualNodeName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualNodeSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualNodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualNodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualNodeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualNodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualNodeOutputResponse(virtualNode: \(String(describing: virtualNode)))"}
}

extension CreateVirtualNodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualNodeData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct CreateVirtualNodeOutputResponse: Equatable {
    /// <p>The full description of your virtual node following the create call.</p>
    public let virtualNode: VirtualNodeData?

    public init (
        virtualNode: VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct CreateVirtualNodeOutputResponseBody: Equatable {
    public let virtualNode: VirtualNodeData?
}

extension CreateVirtualNodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualNode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

public struct CreateVirtualRouterInputBodyMiddleware: Middleware {
    public let id: String = "CreateVirtualRouterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualRouterInput>
    public typealias MOutput = OperationOutput<CreateVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualRouterOutputError>
}

extension CreateVirtualRouterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualRouterInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), tags: \(String(describing: tags)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension CreateVirtualRouterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualRouterName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualRouterName = virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }
}

public struct CreateVirtualRouterInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVirtualRouterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualRouterInput>
    public typealias MOutput = OperationOutput<CreateVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualRouterOutputError>
}

public struct CreateVirtualRouterInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVirtualRouterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualRouterInput>
    public typealias MOutput = OperationOutput<CreateVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualRouterOutputError>
}

///
public struct CreateVirtualRouterInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh to create the virtual router in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
    ///                the account that you specify must share the mesh with your account before you can create
    ///              the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The virtual router specification to apply.</p>
    public let spec: VirtualRouterSpec?
    /// <p>Optional metadata that you can apply to the virtual router to assist with categorization
    ///          and organization. Each tag consists of a key and an optional value, both of which you
    ///          define. Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?
    /// <p>The name to use for the virtual router.</p>
    public let virtualRouterName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualRouterSpec? = nil,
        tags: [TagRef]? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualRouterName = virtualRouterName
    }
}

struct CreateVirtualRouterInputBody: Equatable {
    public let virtualRouterName: String?
    public let spec: VirtualRouterSpec?
    public let tags: [TagRef]?
    public let clientToken: String?
}

extension CreateVirtualRouterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualRouterName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualRouterSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualRouterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualRouterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualRouterOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualRouterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualRouterOutputResponse(virtualRouter: \(String(describing: virtualRouter)))"}
}

extension CreateVirtualRouterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualRouterData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct CreateVirtualRouterOutputResponse: Equatable {
    /// <p>The full description of your virtual router following the create call.</p>
    public let virtualRouter: VirtualRouterData?

    public init (
        virtualRouter: VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct CreateVirtualRouterOutputResponseBody: Equatable {
    public let virtualRouter: VirtualRouterData?
}

extension CreateVirtualRouterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualRouter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

public struct CreateVirtualServiceInputBodyMiddleware: Middleware {
    public let id: String = "CreateVirtualServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualServiceInput>
    public typealias MOutput = OperationOutput<CreateVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualServiceOutputError>
}

extension CreateVirtualServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualServiceInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), tags: \(String(describing: tags)), virtualServiceName: \(String(describing: virtualServiceName)))"}
}

extension CreateVirtualServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let virtualServiceName = virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }
}

public struct CreateVirtualServiceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVirtualServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualServiceInput>
    public typealias MOutput = OperationOutput<CreateVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualServiceOutputError>
}

public struct CreateVirtualServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVirtualServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVirtualServiceInput>
    public typealias MOutput = OperationOutput<CreateVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVirtualServiceOutputError>
}

///
public struct CreateVirtualServiceInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh to create the virtual service in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then
    ///                the account that you specify must share the mesh with your account before you can create
    ///              the resource in the service mesh. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The virtual service specification to apply.</p>
    public let spec: VirtualServiceSpec?
    /// <p>Optional metadata that you can apply to the virtual service to assist with
    ///          categorization and organization. Each tag consists of a key and an optional value, both of
    ///          which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?
    /// <p>The name to use for the virtual service.</p>
    public let virtualServiceName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualServiceSpec? = nil,
        tags: [TagRef]? = nil,
        virtualServiceName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.tags = tags
        self.virtualServiceName = virtualServiceName
    }
}

struct CreateVirtualServiceInputBody: Equatable {
    public let virtualServiceName: String?
    public let spec: VirtualServiceSpec?
    public let tags: [TagRef]?
    public let clientToken: String?
}

extension CreateVirtualServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
        case tags
        case virtualServiceName
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualServiceSpec.self, forKey: .spec)
        spec = specDecoded
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateVirtualServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVirtualServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVirtualServiceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVirtualServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVirtualServiceOutputResponse(virtualService: \(String(describing: virtualService)))"}
}

extension CreateVirtualServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualServiceData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct CreateVirtualServiceOutputResponse: Equatable {
    /// <p>The full description of your virtual service following the create call.</p>
    public let virtualService: VirtualServiceData?

    public init (
        virtualService: VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct CreateVirtualServiceOutputResponseBody: Equatable {
    public let virtualService: VirtualServiceData?
}

extension CreateVirtualServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualService
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension DeleteGatewayRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayRouteInput(gatewayRouteName: \(String(describing: gatewayRouteName)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension DeleteGatewayRouteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGatewayRouteInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGatewayRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayRouteInput>
    public typealias MOutput = OperationOutput<DeleteGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayRouteOutputError>
}

public struct DeleteGatewayRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGatewayRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGatewayRouteInput>
    public typealias MOutput = OperationOutput<DeleteGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGatewayRouteOutputError>
}

public struct DeleteGatewayRouteInput: Equatable {
    /// <p>The name of the gateway route to delete.</p>
    public let gatewayRouteName: String?
    /// <p>The name of the service mesh to delete the gateway route from.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual gateway to delete the route from.</p>
    public let virtualGatewayName: String?

    public init (
        gatewayRouteName: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DeleteGatewayRouteInputBody: Equatable {
}

extension DeleteGatewayRouteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGatewayRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGatewayRouteOutputResponse(gatewayRoute: \(String(describing: gatewayRoute)))"}
}

extension DeleteGatewayRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: GatewayRouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct DeleteGatewayRouteOutputResponse: Equatable {
    /// <p>The gateway route that was deleted.</p>
    public let gatewayRoute: GatewayRouteData?

    public init (
        gatewayRoute: GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct DeleteGatewayRouteOutputResponseBody: Equatable {
    public let gatewayRoute: GatewayRouteData?
}

extension DeleteGatewayRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

extension DeleteMeshInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMeshInput(meshName: \(String(describing: meshName)))"}
}

extension DeleteMeshInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteMeshInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteMeshInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMeshInput>
    public typealias MOutput = OperationOutput<DeleteMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMeshOutputError>
}

public struct DeleteMeshInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteMeshInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteMeshInput>
    public typealias MOutput = OperationOutput<DeleteMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteMeshOutputError>
}

///
public struct DeleteMeshInput: Equatable {
    /// <p>The name of the service mesh to delete.</p>
    public let meshName: String?

    public init (
        meshName: String? = nil
    )
    {
        self.meshName = meshName
    }
}

struct DeleteMeshInputBody: Equatable {
}

extension DeleteMeshInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteMeshOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMeshOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteMeshOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMeshOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteMeshOutputResponse(mesh: \(String(describing: mesh)))"}
}

extension DeleteMeshOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MeshData = try responseDecoder.decode(responseBody: unwrappedData)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct DeleteMeshOutputResponse: Equatable {
    /// <p>The service mesh that was deleted.</p>
    public let mesh: MeshData?

    public init (
        mesh: MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct DeleteMeshOutputResponseBody: Equatable {
    public let mesh: MeshData?
}

extension DeleteMeshOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mesh
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

extension DeleteRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), routeName: \(String(describing: routeName)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension DeleteRouteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRouteInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteInput>
    public typealias MOutput = OperationOutput<DeleteRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteOutputError>
}

public struct DeleteRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRouteInput>
    public typealias MOutput = OperationOutput<DeleteRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRouteOutputError>
}

///
public struct DeleteRouteInput: Equatable {
    /// <p>The name of the service mesh to delete the route in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the route to delete.</p>
    public let routeName: String?
    /// <p>The name of the virtual router to delete the route in.</p>
    public let virtualRouterName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        routeName: String? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.virtualRouterName = virtualRouterName
    }
}

struct DeleteRouteInputBody: Equatable {
}

extension DeleteRouteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRouteOutputResponse(route: \(String(describing: route)))"}
}

extension DeleteRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct DeleteRouteOutputResponse: Equatable {
    /// <p>The route that was deleted.</p>
    public let route: RouteData?

    public init (
        route: RouteData? = nil
    )
    {
        self.route = route
    }
}

struct DeleteRouteOutputResponseBody: Equatable {
    public let route: RouteData?
}

extension DeleteRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case route
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

extension DeleteVirtualGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualGatewayInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension DeleteVirtualGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVirtualGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVirtualGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualGatewayInput>
    public typealias MOutput = OperationOutput<DeleteVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualGatewayOutputError>
}

public struct DeleteVirtualGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVirtualGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualGatewayInput>
    public typealias MOutput = OperationOutput<DeleteVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualGatewayOutputError>
}

public struct DeleteVirtualGatewayInput: Equatable {
    /// <p>The name of the service mesh to delete the virtual gateway from.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual gateway to delete.</p>
    public let virtualGatewayName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DeleteVirtualGatewayInputBody: Equatable {
}

extension DeleteVirtualGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVirtualGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualGatewayOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualGatewayOutputResponse(virtualGateway: \(String(describing: virtualGateway)))"}
}

extension DeleteVirtualGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualGatewayData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct DeleteVirtualGatewayOutputResponse: Equatable {
    /// <p>The virtual gateway that was deleted.</p>
    public let virtualGateway: VirtualGatewayData?

    public init (
        virtualGateway: VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct DeleteVirtualGatewayOutputResponseBody: Equatable {
    public let virtualGateway: VirtualGatewayData?
}

extension DeleteVirtualGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

extension DeleteVirtualNodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualNodeInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualNodeName: \(String(describing: virtualNodeName)))"}
}

extension DeleteVirtualNodeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVirtualNodeInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVirtualNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualNodeInput>
    public typealias MOutput = OperationOutput<DeleteVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualNodeOutputError>
}

public struct DeleteVirtualNodeInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVirtualNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualNodeInput>
    public typealias MOutput = OperationOutput<DeleteVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualNodeOutputError>
}

///
public struct DeleteVirtualNodeInput: Equatable {
    /// <p>The name of the service mesh to delete the virtual node in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual node to delete.</p>
    public let virtualNodeName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualNodeName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualNodeName = virtualNodeName
    }
}

struct DeleteVirtualNodeInputBody: Equatable {
}

extension DeleteVirtualNodeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVirtualNodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualNodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualNodeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualNodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualNodeOutputResponse(virtualNode: \(String(describing: virtualNode)))"}
}

extension DeleteVirtualNodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualNodeData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct DeleteVirtualNodeOutputResponse: Equatable {
    /// <p>The virtual node that was deleted.</p>
    public let virtualNode: VirtualNodeData?

    public init (
        virtualNode: VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct DeleteVirtualNodeOutputResponseBody: Equatable {
    public let virtualNode: VirtualNodeData?
}

extension DeleteVirtualNodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualNode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

extension DeleteVirtualRouterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualRouterInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension DeleteVirtualRouterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVirtualRouterInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVirtualRouterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualRouterInput>
    public typealias MOutput = OperationOutput<DeleteVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualRouterOutputError>
}

public struct DeleteVirtualRouterInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVirtualRouterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualRouterInput>
    public typealias MOutput = OperationOutput<DeleteVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualRouterOutputError>
}

///
public struct DeleteVirtualRouterInput: Equatable {
    /// <p>The name of the service mesh to delete the virtual router in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual router to delete.</p>
    public let virtualRouterName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualRouterName = virtualRouterName
    }
}

struct DeleteVirtualRouterInputBody: Equatable {
}

extension DeleteVirtualRouterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVirtualRouterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualRouterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualRouterOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualRouterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualRouterOutputResponse(virtualRouter: \(String(describing: virtualRouter)))"}
}

extension DeleteVirtualRouterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualRouterData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct DeleteVirtualRouterOutputResponse: Equatable {
    /// <p>The virtual router that was deleted.</p>
    public let virtualRouter: VirtualRouterData?

    public init (
        virtualRouter: VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct DeleteVirtualRouterOutputResponseBody: Equatable {
    public let virtualRouter: VirtualRouterData?
}

extension DeleteVirtualRouterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualRouter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

extension DeleteVirtualServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualServiceInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualServiceName: \(String(describing: virtualServiceName)))"}
}

extension DeleteVirtualServiceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVirtualServiceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVirtualServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualServiceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualServiceOutputError>
}

public struct DeleteVirtualServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVirtualServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVirtualServiceInput>
    public typealias MOutput = OperationOutput<DeleteVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVirtualServiceOutputError>
}

///
public struct DeleteVirtualServiceInput: Equatable {
    /// <p>The name of the service mesh to delete the virtual service in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual service to delete.</p>
    public let virtualServiceName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualServiceName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualServiceName = virtualServiceName
    }
}

struct DeleteVirtualServiceInputBody: Equatable {
}

extension DeleteVirtualServiceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVirtualServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVirtualServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVirtualServiceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case resourceInUseException(ResourceInUseException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVirtualServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVirtualServiceOutputResponse(virtualService: \(String(describing: virtualService)))"}
}

extension DeleteVirtualServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualServiceData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct DeleteVirtualServiceOutputResponse: Equatable {
    /// <p>The virtual service that was deleted.</p>
    public let virtualService: VirtualServiceData?

    public init (
        virtualService: VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct DeleteVirtualServiceOutputResponseBody: Equatable {
    public let virtualService: VirtualServiceData?
}

extension DeleteVirtualServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualService
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension DescribeGatewayRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayRouteInput(gatewayRouteName: \(String(describing: gatewayRouteName)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension DescribeGatewayRouteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeGatewayRouteInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGatewayRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayRouteInput>
    public typealias MOutput = OperationOutput<DescribeGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayRouteOutputError>
}

public struct DescribeGatewayRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGatewayRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGatewayRouteInput>
    public typealias MOutput = OperationOutput<DescribeGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGatewayRouteOutputError>
}

public struct DescribeGatewayRouteInput: Equatable {
    /// <p>The name of the gateway route to describe.</p>
    public let gatewayRouteName: String?
    /// <p>The name of the service mesh that the gateway route resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual gateway that the gateway route is associated with.</p>
    public let virtualGatewayName: String?

    public init (
        gatewayRouteName: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DescribeGatewayRouteInputBody: Equatable {
}

extension DescribeGatewayRouteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeGatewayRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGatewayRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGatewayRouteOutputResponse(gatewayRoute: \(String(describing: gatewayRoute)))"}
}

extension DescribeGatewayRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: GatewayRouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct DescribeGatewayRouteOutputResponse: Equatable {
    /// <p>The full description of your gateway route.</p>
    public let gatewayRoute: GatewayRouteData?

    public init (
        gatewayRoute: GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct DescribeGatewayRouteOutputResponseBody: Equatable {
    public let gatewayRoute: GatewayRouteData?
}

extension DescribeGatewayRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

extension DescribeMeshInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMeshInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)))"}
}

extension DescribeMeshInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeMeshInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeMeshInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMeshInput>
    public typealias MOutput = OperationOutput<DescribeMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMeshOutputError>
}

public struct DescribeMeshInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeMeshInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeMeshInput>
    public typealias MOutput = OperationOutput<DescribeMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeMeshOutputError>
}

///
public struct DescribeMeshInput: Equatable {
    /// <p>The name of the service mesh to describe.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
    }
}

struct DescribeMeshInputBody: Equatable {
}

extension DescribeMeshInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeMeshOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMeshOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeMeshOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMeshOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeMeshOutputResponse(mesh: \(String(describing: mesh)))"}
}

extension DescribeMeshOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MeshData = try responseDecoder.decode(responseBody: unwrappedData)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct DescribeMeshOutputResponse: Equatable {
    /// <p>The full description of your service mesh.</p>
    public let mesh: MeshData?

    public init (
        mesh: MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct DescribeMeshOutputResponseBody: Equatable {
    public let mesh: MeshData?
}

extension DescribeMeshOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mesh
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

extension DescribeRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRouteInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), routeName: \(String(describing: routeName)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension DescribeRouteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeRouteInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRouteInput>
    public typealias MOutput = OperationOutput<DescribeRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRouteOutputError>
}

public struct DescribeRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRouteInput>
    public typealias MOutput = OperationOutput<DescribeRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRouteOutputError>
}

///
public struct DescribeRouteInput: Equatable {
    /// <p>The name of the service mesh that the route resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the route to describe.</p>
    public let routeName: String?
    /// <p>The name of the virtual router that the route is associated with.</p>
    public let virtualRouterName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        routeName: String? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.virtualRouterName = virtualRouterName
    }
}

struct DescribeRouteInputBody: Equatable {
}

extension DescribeRouteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRouteOutputResponse(route: \(String(describing: route)))"}
}

extension DescribeRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct DescribeRouteOutputResponse: Equatable {
    /// <p>The full description of your route.</p>
    public let route: RouteData?

    public init (
        route: RouteData? = nil
    )
    {
        self.route = route
    }
}

struct DescribeRouteOutputResponseBody: Equatable {
    public let route: RouteData?
}

extension DescribeRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case route
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

extension DescribeVirtualGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualGatewayInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension DescribeVirtualGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVirtualGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVirtualGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualGatewayInput>
    public typealias MOutput = OperationOutput<DescribeVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualGatewayOutputError>
}

public struct DescribeVirtualGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVirtualGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualGatewayInput>
    public typealias MOutput = OperationOutput<DescribeVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualGatewayOutputError>
}

public struct DescribeVirtualGatewayInput: Equatable {
    /// <p>The name of the service mesh that the gateway route resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual gateway to describe.</p>
    public let virtualGatewayName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualGatewayName = virtualGatewayName
    }
}

struct DescribeVirtualGatewayInputBody: Equatable {
}

extension DescribeVirtualGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVirtualGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualGatewayOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualGatewayOutputResponse(virtualGateway: \(String(describing: virtualGateway)))"}
}

extension DescribeVirtualGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualGatewayData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct DescribeVirtualGatewayOutputResponse: Equatable {
    /// <p>The full description of your virtual gateway.</p>
    public let virtualGateway: VirtualGatewayData?

    public init (
        virtualGateway: VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct DescribeVirtualGatewayOutputResponseBody: Equatable {
    public let virtualGateway: VirtualGatewayData?
}

extension DescribeVirtualGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

extension DescribeVirtualNodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualNodeInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualNodeName: \(String(describing: virtualNodeName)))"}
}

extension DescribeVirtualNodeInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVirtualNodeInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVirtualNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualNodeInput>
    public typealias MOutput = OperationOutput<DescribeVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualNodeOutputError>
}

public struct DescribeVirtualNodeInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVirtualNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualNodeInput>
    public typealias MOutput = OperationOutput<DescribeVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualNodeOutputError>
}

///
public struct DescribeVirtualNodeInput: Equatable {
    /// <p>The name of the service mesh that the virtual node resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual node to describe.</p>
    public let virtualNodeName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualNodeName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualNodeName = virtualNodeName
    }
}

struct DescribeVirtualNodeInputBody: Equatable {
}

extension DescribeVirtualNodeInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVirtualNodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualNodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualNodeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualNodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualNodeOutputResponse(virtualNode: \(String(describing: virtualNode)))"}
}

extension DescribeVirtualNodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualNodeData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct DescribeVirtualNodeOutputResponse: Equatable {
    /// <p>The full description of your virtual node.</p>
    public let virtualNode: VirtualNodeData?

    public init (
        virtualNode: VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct DescribeVirtualNodeOutputResponseBody: Equatable {
    public let virtualNode: VirtualNodeData?
}

extension DescribeVirtualNodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualNode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

extension DescribeVirtualRouterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualRouterInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension DescribeVirtualRouterInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVirtualRouterInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVirtualRouterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualRouterInput>
    public typealias MOutput = OperationOutput<DescribeVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualRouterOutputError>
}

public struct DescribeVirtualRouterInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVirtualRouterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualRouterInput>
    public typealias MOutput = OperationOutput<DescribeVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualRouterOutputError>
}

///
public struct DescribeVirtualRouterInput: Equatable {
    /// <p>The name of the service mesh that the virtual router resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual router to describe.</p>
    public let virtualRouterName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualRouterName = virtualRouterName
    }
}

struct DescribeVirtualRouterInputBody: Equatable {
}

extension DescribeVirtualRouterInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVirtualRouterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualRouterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualRouterOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualRouterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualRouterOutputResponse(virtualRouter: \(String(describing: virtualRouter)))"}
}

extension DescribeVirtualRouterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualRouterData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct DescribeVirtualRouterOutputResponse: Equatable {
    /// <p>The full description of your virtual router.</p>
    public let virtualRouter: VirtualRouterData?

    public init (
        virtualRouter: VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct DescribeVirtualRouterOutputResponseBody: Equatable {
    public let virtualRouter: VirtualRouterData?
}

extension DescribeVirtualRouterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualRouter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

extension DescribeVirtualServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualServiceInput(meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), virtualServiceName: \(String(describing: virtualServiceName)))"}
}

extension DescribeVirtualServiceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeVirtualServiceInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeVirtualServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualServiceInput>
    public typealias MOutput = OperationOutput<DescribeVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualServiceOutputError>
}

public struct DescribeVirtualServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeVirtualServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeVirtualServiceInput>
    public typealias MOutput = OperationOutput<DescribeVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeVirtualServiceOutputError>
}

///
public struct DescribeVirtualServiceInput: Equatable {
    /// <p>The name of the service mesh that the virtual service resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the virtual service to describe.</p>
    public let virtualServiceName: String?

    public init (
        meshName: String? = nil,
        meshOwner: String? = nil,
        virtualServiceName: String? = nil
    )
    {
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.virtualServiceName = virtualServiceName
    }
}

struct DescribeVirtualServiceInputBody: Equatable {
}

extension DescribeVirtualServiceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeVirtualServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeVirtualServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeVirtualServiceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeVirtualServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeVirtualServiceOutputResponse(virtualService: \(String(describing: virtualService)))"}
}

extension DescribeVirtualServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualServiceData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct DescribeVirtualServiceOutputResponse: Equatable {
    /// <p>The full description of your virtual service.</p>
    public let virtualService: VirtualServiceData?

    public init (
        virtualService: VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct DescribeVirtualServiceOutputResponseBody: Equatable {
    public let virtualService: VirtualServiceData?
}

extension DescribeVirtualServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualService
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension DnsServiceDiscovery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case hostname
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
    }
}

extension DnsServiceDiscovery: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DnsServiceDiscovery(hostname: \(String(describing: hostname)))"}
}

/// <p>An object that represents the DNS service discovery information for your virtual
///          node.</p>
public struct DnsServiceDiscovery: Equatable {
    /// <p>Specifies the DNS service discovery hostname for the virtual node. </p>
    public let hostname: String?

    public init (
        hostname: String? = nil
    )
    {
        self.hostname = hostname
    }
}

extension Duration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case unit
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let unit = unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .value)
        value = valueDecoded
        let unitDecoded = try containerValues.decodeIfPresent(DurationUnit.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension Duration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Duration(unit: \(String(describing: unit)), value: \(String(describing: value)))"}
}

/// <p>An object that represents a duration of time.</p>
public struct Duration: Equatable {
    /// <p>A unit of time.</p>
    public let unit: DurationUnit?
    /// <p>A number of time units.</p>
    public let value: Int?

    public init (
        unit: DurationUnit? = nil,
        value: Int? = nil
    )
    {
        self.unit = unit
        self.value = value
    }
}

public enum DurationUnit {
    case ms
    case s
    case sdkUnknown(String)
}

extension DurationUnit : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DurationUnit] {
        return [
            .ms,
            .s,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ms: return "ms"
        case .s: return "s"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DurationUnit(rawValue: rawValue) ?? DurationUnit.sdkUnknown(rawValue)
    }
}

extension EgressFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(EgressFilterType.self, forKey: .type)
        type = typeDecoded
    }
}

extension EgressFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EgressFilter(type: \(String(describing: type)))"}
}

/// <p>An object that represents the egress filter rules for a service mesh.</p>
public struct EgressFilter: Equatable {
    /// <p>The egress filter type. By default, the type is <code>DROP_ALL</code>, which allows
    ///          egress only from virtual nodes to other defined resources in the service mesh (and any
    ///          traffic to <code>*.amazonaws.com</code> for AWS API calls). You can set the egress filter
    ///          type to <code>ALLOW_ALL</code> to allow egress to any endpoint inside or outside of the
    ///          service mesh.</p>
    public let type: EgressFilterType?

    public init (
        type: EgressFilterType? = nil
    )
    {
        self.type = type
    }
}

public enum EgressFilterType {
    case allowAll
    case dropAll
    case sdkUnknown(String)
}

extension EgressFilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EgressFilterType] {
        return [
            .allowAll,
            .dropAll,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .allowAll: return "ALLOW_ALL"
        case .dropAll: return "DROP_ALL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EgressFilterType(rawValue: rawValue) ?? EgressFilterType.sdkUnknown(rawValue)
    }
}

extension FileAccessLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
    }
}

extension FileAccessLog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileAccessLog(path: \(String(describing: path)))"}
}

/// <p>An object that represents an access log file.</p>
public struct FileAccessLog: Equatable {
    /// <p>The file path to write access logs to. You can use <code>/dev/stdout</code> to send
    ///          access logs to standard out and configure your Envoy container to use a log driver, such as
    ///             <code>awslogs</code>, to export the access logs to a log storage service such as Amazon
    ///          CloudWatch Logs. You can also specify a path in the Envoy container's file system to write
    ///          the files to disk.</p>
    ///          <note>
    ///             <p>The Envoy process must have write permissions to the path that you specify here.
    ///             Otherwise, Envoy fails to bootstrap properly.</p>
    ///          </note>
    public let path: String?

    public init (
        path: String? = nil
    )
    {
        self.path = path
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have permissions to perform this action.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GatewayRouteData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gatewayRouteName
        case meshName
        case metadata
        case spec
        case status
        case virtualGatewayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayRouteName = gatewayRouteName {
            try encodeContainer.encode(gatewayRouteName, forKey: .gatewayRouteName)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualGatewayName = virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let gatewayRouteNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayRouteName)
        gatewayRouteName = gatewayRouteNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(GatewayRouteSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GatewayRouteStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GatewayRouteData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayRouteData(gatewayRouteName: \(String(describing: gatewayRouteName)), meshName: \(String(describing: meshName)), metadata: \(String(describing: metadata)), spec: \(String(describing: spec)), status: \(String(describing: status)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

/// <p>An object that represents a gateway route returned by a describe operation.</p>
public struct GatewayRouteData: Equatable {
    /// <p>The name of the gateway route.</p>
    public let gatewayRouteName: String?
    /// <p>The name of the service mesh that the resource resides in. </p>
    public let meshName: String?
    /// <p>An object that represents metadata for a resource.</p>
    public let metadata: ResourceMetadata?
    /// <p>The specifications of the gateway route.</p>
    public let spec: GatewayRouteSpec?
    /// <p>The status of the gateway route.</p>
    public let status: GatewayRouteStatus?
    /// <p>The virtual gateway that the gateway route is associated with.</p>
    public let virtualGatewayName: String?

    public init (
        gatewayRouteName: String? = nil,
        meshName: String? = nil,
        metadata: ResourceMetadata? = nil,
        spec: GatewayRouteSpec? = nil,
        status: GatewayRouteStatus? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.metadata = metadata
        self.spec = spec
        self.status = status
        self.virtualGatewayName = virtualGatewayName
    }
}

extension GatewayRouteRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case gatewayRouteName
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualGatewayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let gatewayRouteName = gatewayRouteName {
            try encodeContainer.encode(gatewayRouteName, forKey: .gatewayRouteName)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualGatewayName = virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let gatewayRouteNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .gatewayRouteName)
        gatewayRouteName = gatewayRouteNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension GatewayRouteRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayRouteRef(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), gatewayRouteName: \(String(describing: gatewayRouteName)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), version: \(String(describing: version)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

/// <p>An object that represents a gateway route returned by a list operation.</p>
public struct GatewayRouteRef: Equatable {
    /// <p>The full Amazon Resource Name (ARN) for the gateway route.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The name of the gateway route.</p>
    public let gatewayRouteName: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the service mesh that the resource resides in. </p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?
    /// <p>The virtual gateway that the gateway route is associated with.</p>
    public let virtualGatewayName: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        gatewayRouteName: String? = nil,
        lastUpdatedAt: Date? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        version: Int? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.gatewayRouteName = gatewayRouteName
        self.lastUpdatedAt = lastUpdatedAt
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.version = version
        self.virtualGatewayName = virtualGatewayName
    }
}

extension GatewayRouteSpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grpcRoute
        case http2Route
        case httpRoute
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grpcRoute = grpcRoute {
            try encodeContainer.encode(grpcRoute, forKey: .grpcRoute)
        }
        if let http2Route = http2Route {
            try encodeContainer.encode(http2Route, forKey: .http2Route)
        }
        if let httpRoute = httpRoute {
            try encodeContainer.encode(httpRoute, forKey: .httpRoute)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let httpRouteDecoded = try containerValues.decodeIfPresent(HttpGatewayRoute.self, forKey: .httpRoute)
        httpRoute = httpRouteDecoded
        let http2RouteDecoded = try containerValues.decodeIfPresent(HttpGatewayRoute.self, forKey: .http2Route)
        http2Route = http2RouteDecoded
        let grpcRouteDecoded = try containerValues.decodeIfPresent(GrpcGatewayRoute.self, forKey: .grpcRoute)
        grpcRoute = grpcRouteDecoded
    }
}

extension GatewayRouteSpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayRouteSpec(grpcRoute: \(String(describing: grpcRoute)), http2Route: \(String(describing: http2Route)), httpRoute: \(String(describing: httpRoute)))"}
}

/// <p>An object that represents a gateway route specification. Specify one gateway route
///          type.</p>
public struct GatewayRouteSpec: Equatable {
    /// <p>An object that represents the specification of a gRPC gateway route.</p>
    public let grpcRoute: GrpcGatewayRoute?
    /// <p>An object that represents the specification of an HTTP/2 gateway route.</p>
    public let http2Route: HttpGatewayRoute?
    /// <p>An object that represents the specification of an HTTP gateway route.</p>
    public let httpRoute: HttpGatewayRoute?

    public init (
        grpcRoute: GrpcGatewayRoute? = nil,
        http2Route: HttpGatewayRoute? = nil,
        httpRoute: HttpGatewayRoute? = nil
    )
    {
        self.grpcRoute = grpcRoute
        self.http2Route = http2Route
        self.httpRoute = httpRoute
    }
}

extension GatewayRouteStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GatewayRouteStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension GatewayRouteStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayRouteStatus(status: \(String(describing: status)))"}
}

/// <p>An object that represents the current status of a gateway route.</p>
public struct GatewayRouteStatus: Equatable {
    /// <p>The current status for the gateway route.</p>
    public let status: GatewayRouteStatusCode?

    public init (
        status: GatewayRouteStatusCode? = nil
    )
    {
        self.status = status
    }
}

public enum GatewayRouteStatusCode {
    case active
    case deleted
    case inactive
    case sdkUnknown(String)
}

extension GatewayRouteStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GatewayRouteStatusCode] {
        return [
            .active,
            .deleted,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GatewayRouteStatusCode(rawValue: rawValue) ?? GatewayRouteStatusCode.sdkUnknown(rawValue)
    }
}

extension GatewayRouteTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualService
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualService = virtualService {
            try encodeContainer.encode(virtualService, forKey: .virtualService)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(GatewayRouteVirtualService.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension GatewayRouteTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayRouteTarget(virtualService: \(String(describing: virtualService)))"}
}

/// <p>An object that represents a gateway route target.</p>
public struct GatewayRouteTarget: Equatable {
    /// <p>An object that represents a virtual service gateway route target.</p>
    public let virtualService: GatewayRouteVirtualService?

    public init (
        virtualService: GatewayRouteVirtualService? = nil
    )
    {
        self.virtualService = virtualService
    }
}

extension GatewayRouteVirtualService: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualServiceName = virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
    }
}

extension GatewayRouteVirtualService: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GatewayRouteVirtualService(virtualServiceName: \(String(describing: virtualServiceName)))"}
}

/// <p>An object that represents the virtual service that traffic is routed to.</p>
public struct GatewayRouteVirtualService: Equatable {
    /// <p>The name of the virtual service that traffic is routed to.</p>
    public let virtualServiceName: String?

    public init (
        virtualServiceName: String? = nil
    )
    {
        self.virtualServiceName = virtualServiceName
    }
}

extension GrpcGatewayRoute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case match
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(GrpcGatewayRouteMatch.self, forKey: .match)
        match = matchDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GrpcGatewayRouteAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension GrpcGatewayRoute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcGatewayRoute(action: \(String(describing: action)), match: \(String(describing: match)))"}
}

/// <p>An object that represents a gRPC gateway route.</p>
public struct GrpcGatewayRoute: Equatable {
    /// <p>An object that represents the action to take if a match is determined.</p>
    public let action: GrpcGatewayRouteAction?
    /// <p>An object that represents the criteria for determining a request match.</p>
    public let match: GrpcGatewayRouteMatch?

    public init (
        action: GrpcGatewayRouteAction? = nil,
        match: GrpcGatewayRouteMatch? = nil
    )
    {
        self.action = action
        self.match = match
    }
}

extension GrpcGatewayRouteAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(GatewayRouteTarget.self, forKey: .target)
        target = targetDecoded
    }
}

extension GrpcGatewayRouteAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcGatewayRouteAction(target: \(String(describing: target)))"}
}

/// <p>An object that represents the action to take if a match is determined.</p>
public struct GrpcGatewayRouteAction: Equatable {
    /// <p>An object that represents the target that traffic is routed to when a request matches the gateway route.</p>
    public let target: GatewayRouteTarget?

    public init (
        target: GatewayRouteTarget? = nil
    )
    {
        self.target = target
    }
}

extension GrpcGatewayRouteMatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serviceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
    }
}

extension GrpcGatewayRouteMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcGatewayRouteMatch(serviceName: \(String(describing: serviceName)))"}
}

/// <p>An object that represents the criteria for determining a request match.</p>
public struct GrpcGatewayRouteMatch: Equatable {
    /// <p>The fully qualified domain name for the service to match from the request.</p>
    public let serviceName: String?

    public init (
        serviceName: String? = nil
    )
    {
        self.serviceName = serviceName
    }
}

extension GrpcRetryPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grpcRetryEvents
        case httpRetryEvents
        case maxRetries
        case perRetryTimeout
        case tcpRetryEvents
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grpcRetryEvents = grpcRetryEvents {
            var grpcRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .grpcRetryEvents)
            for grpcretrypolicyevents0 in grpcRetryEvents {
                try grpcRetryEventsContainer.encode(grpcretrypolicyevents0.rawValue)
            }
        }
        if let httpRetryEvents = httpRetryEvents {
            var httpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpRetryEvents)
            for httpretrypolicyevents0 in httpRetryEvents {
                try httpRetryEventsContainer.encode(httpretrypolicyevents0)
            }
        }
        if let maxRetries = maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let perRetryTimeout = perRetryTimeout {
            try encodeContainer.encode(perRetryTimeout, forKey: .perRetryTimeout)
        }
        if let tcpRetryEvents = tcpRetryEvents {
            var tcpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tcpRetryEvents)
            for tcpretrypolicyevents0 in tcpRetryEvents {
                try tcpRetryEventsContainer.encode(tcpretrypolicyevents0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRetryTimeoutDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .perRetryTimeout)
        perRetryTimeout = perRetryTimeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let httpRetryEventsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .httpRetryEvents)
        var httpRetryEventsDecoded0:[String]? = nil
        if let httpRetryEventsContainer = httpRetryEventsContainer {
            httpRetryEventsDecoded0 = [String]()
            for string0 in httpRetryEventsContainer {
                if let string0 = string0 {
                    httpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        httpRetryEvents = httpRetryEventsDecoded0
        let tcpRetryEventsContainer = try containerValues.decodeIfPresent([TcpRetryPolicyEvent?].self, forKey: .tcpRetryEvents)
        var tcpRetryEventsDecoded0:[TcpRetryPolicyEvent]? = nil
        if let tcpRetryEventsContainer = tcpRetryEventsContainer {
            tcpRetryEventsDecoded0 = [TcpRetryPolicyEvent]()
            for string0 in tcpRetryEventsContainer {
                if let string0 = string0 {
                    tcpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        tcpRetryEvents = tcpRetryEventsDecoded0
        let grpcRetryEventsContainer = try containerValues.decodeIfPresent([GrpcRetryPolicyEvent?].self, forKey: .grpcRetryEvents)
        var grpcRetryEventsDecoded0:[GrpcRetryPolicyEvent]? = nil
        if let grpcRetryEventsContainer = grpcRetryEventsContainer {
            grpcRetryEventsDecoded0 = [GrpcRetryPolicyEvent]()
            for string0 in grpcRetryEventsContainer {
                if let string0 = string0 {
                    grpcRetryEventsDecoded0?.append(string0)
                }
            }
        }
        grpcRetryEvents = grpcRetryEventsDecoded0
    }
}

extension GrpcRetryPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcRetryPolicy(grpcRetryEvents: \(String(describing: grpcRetryEvents)), httpRetryEvents: \(String(describing: httpRetryEvents)), maxRetries: \(String(describing: maxRetries)), perRetryTimeout: \(String(describing: perRetryTimeout)), tcpRetryEvents: \(String(describing: tcpRetryEvents)))"}
}

/// <p>An object that represents a retry policy. Specify at least one value for at least one of the types of <code>RetryEvents</code>, a value for <code>maxRetries</code>, and a value for <code>perRetryTimeout</code>.</p>
public struct GrpcRetryPolicy: Equatable {
    /// <p>Specify at least one of the valid values.</p>
    public let grpcRetryEvents: [GrpcRetryPolicyEvent]?
    /// <p>Specify at least one of the following values.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>server-error</b> – HTTP status codes 500, 501,
    ///                   502, 503, 504, 505, 506, 507, 508, 510, and 511</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>gateway-error</b> – HTTP status codes 502,
    ///                   503, and 504</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>client-error</b> – HTTP status code 409</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>stream-error</b> – Retry on refused
    ///                   stream</p>
    ///             </li>
    ///          </ul>
    public let httpRetryEvents: [String]?
    /// <p>The maximum number of retry attempts.</p>
    public let maxRetries: Int?
    /// <p>The timeout for each retry attempt.</p>
    public let perRetryTimeout: Duration?
    /// <p>Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.</p>
    public let tcpRetryEvents: [TcpRetryPolicyEvent]?

    public init (
        grpcRetryEvents: [GrpcRetryPolicyEvent]? = nil,
        httpRetryEvents: [String]? = nil,
        maxRetries: Int? = nil,
        perRetryTimeout: Duration? = nil,
        tcpRetryEvents: [TcpRetryPolicyEvent]? = nil
    )
    {
        self.grpcRetryEvents = grpcRetryEvents
        self.httpRetryEvents = httpRetryEvents
        self.maxRetries = maxRetries
        self.perRetryTimeout = perRetryTimeout
        self.tcpRetryEvents = tcpRetryEvents
    }
}

public enum GrpcRetryPolicyEvent {
    case cancelled
    case deadlineExceeded
    case `internal`
    case resourceExhausted
    case unavailable
    case sdkUnknown(String)
}

extension GrpcRetryPolicyEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GrpcRetryPolicyEvent] {
        return [
            .cancelled,
            .deadlineExceeded,
            .internal,
            .resourceExhausted,
            .unavailable,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cancelled: return "cancelled"
        case .deadlineExceeded: return "deadline-exceeded"
        case .internal: return "internal"
        case .resourceExhausted: return "resource-exhausted"
        case .unavailable: return "unavailable"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GrpcRetryPolicyEvent(rawValue: rawValue) ?? GrpcRetryPolicyEvent.sdkUnknown(rawValue)
    }
}

extension GrpcRoute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case match
        case retryPolicy
        case timeout
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let retryPolicy = retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(GrpcRouteAction.self, forKey: .action)
        action = actionDecoded
        let matchDecoded = try containerValues.decodeIfPresent(GrpcRouteMatch.self, forKey: .match)
        match = matchDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(GrpcRetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(GrpcTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension GrpcRoute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcRoute(action: \(String(describing: action)), match: \(String(describing: match)), retryPolicy: \(String(describing: retryPolicy)), timeout: \(String(describing: timeout)))"}
}

/// <p>An object that represents a gRPC route type.</p>
public struct GrpcRoute: Equatable {
    /// <p>An object that represents the action to take if a match is determined.</p>
    public let action: GrpcRouteAction?
    /// <p>An object that represents the criteria for determining a request match.</p>
    public let match: GrpcRouteMatch?
    /// <p>An object that represents a retry policy.</p>
    public let retryPolicy: GrpcRetryPolicy?
    /// <p>An object that represents types of timeouts. </p>
    public let timeout: GrpcTimeout?

    public init (
        action: GrpcRouteAction? = nil,
        match: GrpcRouteMatch? = nil,
        retryPolicy: GrpcRetryPolicy? = nil,
        timeout: GrpcTimeout? = nil
    )
    {
        self.action = action
        self.match = match
        self.retryPolicy = retryPolicy
        self.timeout = timeout
    }
}

extension GrpcRouteAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case weightedTargets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let weightedTargets = weightedTargets {
            var weightedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedTargets)
            for weightedtargets0 in weightedTargets {
                try weightedTargetsContainer.encode(weightedtargets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightedTargetsContainer = try containerValues.decodeIfPresent([WeightedTarget?].self, forKey: .weightedTargets)
        var weightedTargetsDecoded0:[WeightedTarget]? = nil
        if let weightedTargetsContainer = weightedTargetsContainer {
            weightedTargetsDecoded0 = [WeightedTarget]()
            for structure0 in weightedTargetsContainer {
                if let structure0 = structure0 {
                    weightedTargetsDecoded0?.append(structure0)
                }
            }
        }
        weightedTargets = weightedTargetsDecoded0
    }
}

extension GrpcRouteAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcRouteAction(weightedTargets: \(String(describing: weightedTargets)))"}
}

/// <p>An object that represents the action to take if a match is determined.</p>
public struct GrpcRouteAction: Equatable {
    /// <p>An object that represents the targets that traffic is routed to when a request matches the route.</p>
    public let weightedTargets: [WeightedTarget]?

    public init (
        weightedTargets: [WeightedTarget]? = nil
    )
    {
        self.weightedTargets = weightedTargets
    }
}

extension GrpcRouteMatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case metadata
        case methodName
        case serviceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .metadata)
            for grpcroutemetadatalist0 in metadata {
                try metadataContainer.encode(grpcroutemetadatalist0)
            }
        }
        if let methodName = methodName {
            try encodeContainer.encode(methodName, forKey: .methodName)
        }
        if let serviceName = serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let methodNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .methodName)
        methodName = methodNameDecoded
        let metadataContainer = try containerValues.decodeIfPresent([GrpcRouteMetadata?].self, forKey: .metadata)
        var metadataDecoded0:[GrpcRouteMetadata]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [GrpcRouteMetadata]()
            for structure0 in metadataContainer {
                if let structure0 = structure0 {
                    metadataDecoded0?.append(structure0)
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension GrpcRouteMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcRouteMatch(metadata: \(String(describing: metadata)), methodName: \(String(describing: methodName)), serviceName: \(String(describing: serviceName)))"}
}

/// <p>An object that represents the criteria for determining a request match.</p>
public struct GrpcRouteMatch: Equatable {
    /// <p>An object that represents the data to match from the request.</p>
    public let metadata: [GrpcRouteMetadata]?
    /// <p>The method name to match from the request. If you specify a name, you must also specify
    ///          a <code>serviceName</code>.</p>
    public let methodName: String?
    /// <p>The fully qualified domain name for the service to match from the request.</p>
    public let serviceName: String?

    public init (
        metadata: [GrpcRouteMetadata]? = nil,
        methodName: String? = nil,
        serviceName: String? = nil
    )
    {
        self.metadata = metadata
        self.methodName = methodName
        self.serviceName = serviceName
    }
}

extension GrpcRouteMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invert
        case match
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invert = invert {
            try encodeContainer.encode(invert, forKey: .invert)
        }
        if let match = match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let invertDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .invert)
        invert = invertDecoded
        let matchDecoded = try containerValues.decodeIfPresent(GrpcRouteMetadataMatchMethod.self, forKey: .match)
        match = matchDecoded
    }
}

extension GrpcRouteMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcRouteMetadata(invert: \(String(describing: invert)), match: \(String(describing: match)), name: \(String(describing: name)))"}
}

/// <p>An object that represents the match metadata for the route.</p>
public struct GrpcRouteMetadata: Equatable {
    /// <p>Specify <code>True</code> to match anything except the match criteria. The default value is <code>False</code>.</p>
    public let invert: Bool?
    /// <p>An object that represents the data to match from the request.</p>
    public let match: GrpcRouteMetadataMatchMethod?
    /// <p>The name of the route.</p>
    public let name: String?

    public init (
        invert: Bool? = nil,
        match: GrpcRouteMetadataMatchMethod? = nil,
        name: String? = nil
    )
    {
        self.invert = invert
        self.match = match
        self.name = name
    }
}

extension GrpcRouteMetadataMatchMethod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exact
        case prefix
        case range
        case regex
        case sdkUnknown
        case suffix
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .exact(exact):
                if let exact = exact {
                    try container.encode(exact, forKey: .exact)
                }
            case let .prefix(prefix):
                if let prefix = prefix {
                    try container.encode(prefix, forKey: .prefix)
                }
            case let .range(range):
                if let range = range {
                    try container.encode(range, forKey: .range)
                }
            case let .regex(regex):
                if let regex = regex {
                    try container.encode(regex, forKey: .regex)
                }
            case let .suffix(suffix):
                if let suffix = suffix {
                    try container.encode(suffix, forKey: .suffix)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let regexDecoded = try values.decodeIfPresent(String.self, forKey: .regex)
        if let regex = regexDecoded {
            self = .regex(regex)
            return
        }
        let rangeDecoded = try values.decodeIfPresent(MatchRange.self, forKey: .range)
        if let range = rangeDecoded {
            self = .range(range)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(String.self, forKey: .prefix)
        if let prefix = prefixDecoded {
            self = .prefix(prefix)
            return
        }
        let suffixDecoded = try values.decodeIfPresent(String.self, forKey: .suffix)
        if let suffix = suffixDecoded {
            self = .suffix(suffix)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the match method. Specify one of the match values.</p>
public enum GrpcRouteMetadataMatchMethod: Equatable {
    /// <p>The value sent by the client must match the specified value exactly.</p>
    case exact(String?)
    /// <p>The value sent by the client must include the specified characters.</p>
    case regex(String?)
    /// <p>An object that represents the range of values to match on.</p>
    case range(MatchRange?)
    /// <p>The value sent by the client must begin with the specified characters.</p>
    case prefix(String?)
    /// <p>The value sent by the client must end with the specified characters.</p>
    case suffix(String?)
    case sdkUnknown(String?)
}

extension GrpcTimeout: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case idle
        case perRequest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idle = idle {
            try encodeContainer.encode(idle, forKey: .idle)
        }
        if let perRequest = perRequest {
            try encodeContainer.encode(perRequest, forKey: .perRequest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRequestDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .perRequest)
        perRequest = perRequestDecoded
        let idleDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .idle)
        idle = idleDecoded
    }
}

extension GrpcTimeout: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GrpcTimeout(idle: \(String(describing: idle)), perRequest: \(String(describing: perRequest)))"}
}

/// <p>An object that represents types of timeouts. </p>
public struct GrpcTimeout: Equatable {
    /// <p>An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.</p>
    public let idle: Duration?
    /// <p>An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh
    ///                                   resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15
    ///                                   seconds for the source and destination virtual node and the route.</p>
    public let perRequest: Duration?

    public init (
        idle: Duration? = nil,
        perRequest: Duration? = nil
    )
    {
        self.idle = idle
        self.perRequest = perRequest
    }
}

extension HeaderMatchMethod: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exact
        case prefix
        case range
        case regex
        case sdkUnknown
        case suffix
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .exact(exact):
                if let exact = exact {
                    try container.encode(exact, forKey: .exact)
                }
            case let .prefix(prefix):
                if let prefix = prefix {
                    try container.encode(prefix, forKey: .prefix)
                }
            case let .range(range):
                if let range = range {
                    try container.encode(range, forKey: .range)
                }
            case let .regex(regex):
                if let regex = regex {
                    try container.encode(regex, forKey: .regex)
                }
            case let .suffix(suffix):
                if let suffix = suffix {
                    try container.encode(suffix, forKey: .suffix)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let exactDecoded = try values.decodeIfPresent(String.self, forKey: .exact)
        if let exact = exactDecoded {
            self = .exact(exact)
            return
        }
        let regexDecoded = try values.decodeIfPresent(String.self, forKey: .regex)
        if let regex = regexDecoded {
            self = .regex(regex)
            return
        }
        let rangeDecoded = try values.decodeIfPresent(MatchRange.self, forKey: .range)
        if let range = rangeDecoded {
            self = .range(range)
            return
        }
        let prefixDecoded = try values.decodeIfPresent(String.self, forKey: .prefix)
        if let prefix = prefixDecoded {
            self = .prefix(prefix)
            return
        }
        let suffixDecoded = try values.decodeIfPresent(String.self, forKey: .suffix)
        if let suffix = suffixDecoded {
            self = .suffix(suffix)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the method and value to match with the header value sent in a
///          request. Specify one match method.</p>
public enum HeaderMatchMethod: Equatable {
    /// <p>The value sent by the client must match the specified value exactly.</p>
    case exact(String?)
    /// <p>The value sent by the client must include the specified characters.</p>
    case regex(String?)
    /// <p>An object that represents the range of values to match on.</p>
    case range(MatchRange?)
    /// <p>The value sent by the client must begin with the specified characters.</p>
    case prefix(String?)
    /// <p>The value sent by the client must end with the specified characters.</p>
    case suffix(String?)
    case sdkUnknown(String?)
}

extension HealthCheckPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthyThreshold
        case intervalMillis
        case path
        case port
        case `protocol` = "protocol"
        case timeoutMillis
        case unhealthyThreshold
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if healthyThreshold != 0 {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let intervalMillis = intervalMillis {
            try encodeContainer.encode(intervalMillis, forKey: .intervalMillis)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeoutMillis = timeoutMillis {
            try encodeContainer.encode(timeoutMillis, forKey: .timeoutMillis)
        }
        if unhealthyThreshold != 0 {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutMillis)
        timeoutMillis = timeoutMillisDecoded
        let intervalMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .intervalMillis)
        intervalMillis = intervalMillisDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(PortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let healthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension HealthCheckPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HealthCheckPolicy(healthyThreshold: \(String(describing: healthyThreshold)), intervalMillis: \(String(describing: intervalMillis)), path: \(String(describing: path)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), timeoutMillis: \(String(describing: timeoutMillis)), unhealthyThreshold: \(String(describing: unhealthyThreshold)))"}
}

/// <p>An object that represents the health check policy for a virtual node's listener.</p>
public struct HealthCheckPolicy: Equatable {
    /// <p>The protocol for the health check request. If you specify <code>grpc</code>, then your
    ///          service must conform to the <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">GRPC Health
    ///             Checking Protocol</a>.</p>
    public let `protocol`: PortProtocol?
    /// <p>The number of consecutive successful health checks that must occur before declaring
    ///          listener healthy.</p>
    public let healthyThreshold: Int
    /// <p>The time period in milliseconds between each health check execution.</p>
    public let intervalMillis: Int?
    /// <p>The destination path for the health check request. This value is only used if the
    ///          specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.</p>
    public let path: String?
    /// <p>The destination port for the health check request. This port must match the port defined
    ///          in the <a>PortMapping</a> for the listener.</p>
    public let port: Int
    /// <p>The amount of time to wait when receiving a response from the health check, in
    ///          milliseconds.</p>
    public let timeoutMillis: Int?
    /// <p>The number of consecutive failed health checks that must occur before declaring a
    ///          virtual node unhealthy. </p>
    public let unhealthyThreshold: Int

    public init (
        `protocol`: PortProtocol? = nil,
        healthyThreshold: Int = 0,
        intervalMillis: Int? = nil,
        path: String? = nil,
        port: Int = 0,
        timeoutMillis: Int? = nil,
        unhealthyThreshold: Int = 0
    )
    {
        self.`protocol` = `protocol`
        self.healthyThreshold = healthyThreshold
        self.intervalMillis = intervalMillis
        self.path = path
        self.port = port
        self.timeoutMillis = timeoutMillis
        self.unhealthyThreshold = unhealthyThreshold
    }
}

extension HttpGatewayRoute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case match
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(HttpGatewayRouteMatch.self, forKey: .match)
        match = matchDecoded
        let actionDecoded = try containerValues.decodeIfPresent(HttpGatewayRouteAction.self, forKey: .action)
        action = actionDecoded
    }
}

extension HttpGatewayRoute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpGatewayRoute(action: \(String(describing: action)), match: \(String(describing: match)))"}
}

/// <p>An object that represents an HTTP gateway route.</p>
public struct HttpGatewayRoute: Equatable {
    /// <p>An object that represents the action to take if a match is determined.</p>
    public let action: HttpGatewayRouteAction?
    /// <p>An object that represents the criteria for determining a request match.</p>
    public let match: HttpGatewayRouteMatch?

    public init (
        action: HttpGatewayRouteAction? = nil,
        match: HttpGatewayRouteMatch? = nil
    )
    {
        self.action = action
        self.match = match
    }
}

extension HttpGatewayRouteAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case target
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let target = target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDecoded = try containerValues.decodeIfPresent(GatewayRouteTarget.self, forKey: .target)
        target = targetDecoded
    }
}

extension HttpGatewayRouteAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpGatewayRouteAction(target: \(String(describing: target)))"}
}

/// <p>An object that represents the action to take if a match is determined.</p>
public struct HttpGatewayRouteAction: Equatable {
    /// <p>An object that represents the target that traffic is routed to when a request matches the gateway route.</p>
    public let target: GatewayRouteTarget?

    public init (
        target: GatewayRouteTarget? = nil
    )
    {
        self.target = target
    }
}

extension HttpGatewayRouteMatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case prefix
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
    }
}

extension HttpGatewayRouteMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpGatewayRouteMatch(prefix: \(String(describing: prefix)))"}
}

/// <p>An object that represents the criteria for determining a request match.</p>
public struct HttpGatewayRouteMatch: Equatable {
    /// <p>Specifies the path to match requests with. This parameter must always start with
    ///             <code>/</code>, which by itself matches all requests to the virtual service name. You
    ///          can also match for path-based routing of requests. For example, if your virtual service
    ///          name is <code>my-service.local</code> and you want the route to match requests to
    ///             <code>my-service.local/metrics</code>, your prefix should be
    ///          <code>/metrics</code>.</p>
    public let prefix: String?

    public init (
        prefix: String? = nil
    )
    {
        self.prefix = prefix
    }
}

public enum HttpMethod {
    case connect
    case delete
    case `get`
    case head
    case options
    case patch
    case post
    case put
    case trace
    case sdkUnknown(String)
}

extension HttpMethod : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HttpMethod] {
        return [
            .connect,
            .delete,
            .get,
            .head,
            .options,
            .patch,
            .post,
            .put,
            .trace,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connect: return "CONNECT"
        case .delete: return "DELETE"
        case .get: return "GET"
        case .head: return "HEAD"
        case .options: return "OPTIONS"
        case .patch: return "PATCH"
        case .post: return "POST"
        case .put: return "PUT"
        case .trace: return "TRACE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HttpMethod(rawValue: rawValue) ?? HttpMethod.sdkUnknown(rawValue)
    }
}

extension HttpRetryPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case httpRetryEvents
        case maxRetries
        case perRetryTimeout
        case tcpRetryEvents
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let httpRetryEvents = httpRetryEvents {
            var httpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .httpRetryEvents)
            for httpretrypolicyevents0 in httpRetryEvents {
                try httpRetryEventsContainer.encode(httpretrypolicyevents0)
            }
        }
        if let maxRetries = maxRetries {
            try encodeContainer.encode(maxRetries, forKey: .maxRetries)
        }
        if let perRetryTimeout = perRetryTimeout {
            try encodeContainer.encode(perRetryTimeout, forKey: .perRetryTimeout)
        }
        if let tcpRetryEvents = tcpRetryEvents {
            var tcpRetryEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tcpRetryEvents)
            for tcpretrypolicyevents0 in tcpRetryEvents {
                try tcpRetryEventsContainer.encode(tcpretrypolicyevents0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRetryTimeoutDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .perRetryTimeout)
        perRetryTimeout = perRetryTimeoutDecoded
        let maxRetriesDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxRetries)
        maxRetries = maxRetriesDecoded
        let httpRetryEventsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .httpRetryEvents)
        var httpRetryEventsDecoded0:[String]? = nil
        if let httpRetryEventsContainer = httpRetryEventsContainer {
            httpRetryEventsDecoded0 = [String]()
            for string0 in httpRetryEventsContainer {
                if let string0 = string0 {
                    httpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        httpRetryEvents = httpRetryEventsDecoded0
        let tcpRetryEventsContainer = try containerValues.decodeIfPresent([TcpRetryPolicyEvent?].self, forKey: .tcpRetryEvents)
        var tcpRetryEventsDecoded0:[TcpRetryPolicyEvent]? = nil
        if let tcpRetryEventsContainer = tcpRetryEventsContainer {
            tcpRetryEventsDecoded0 = [TcpRetryPolicyEvent]()
            for string0 in tcpRetryEventsContainer {
                if let string0 = string0 {
                    tcpRetryEventsDecoded0?.append(string0)
                }
            }
        }
        tcpRetryEvents = tcpRetryEventsDecoded0
    }
}

extension HttpRetryPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpRetryPolicy(httpRetryEvents: \(String(describing: httpRetryEvents)), maxRetries: \(String(describing: maxRetries)), perRetryTimeout: \(String(describing: perRetryTimeout)), tcpRetryEvents: \(String(describing: tcpRetryEvents)))"}
}

/// <p>An object that represents a retry policy. Specify at least one value for at least one of the types of <code>RetryEvents</code>, a value for <code>maxRetries</code>, and a value for <code>perRetryTimeout</code>.</p>
public struct HttpRetryPolicy: Equatable {
    /// <p>Specify at least one of the following values.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>server-error</b> – HTTP status codes 500, 501,
    ///                   502, 503, 504, 505, 506, 507, 508, 510, and 511</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>gateway-error</b> – HTTP status codes 502,
    ///                   503, and 504</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>client-error</b> – HTTP status code 409</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>stream-error</b> – Retry on refused
    ///                   stream</p>
    ///             </li>
    ///          </ul>
    public let httpRetryEvents: [String]?
    /// <p>The maximum number of retry attempts.</p>
    public let maxRetries: Int?
    /// <p>The timeout for each retry attempt.</p>
    public let perRetryTimeout: Duration?
    /// <p>Specify a valid value. The event occurs before any processing of a request has started and is encountered when the upstream is temporarily or permanently unavailable.</p>
    public let tcpRetryEvents: [TcpRetryPolicyEvent]?

    public init (
        httpRetryEvents: [String]? = nil,
        maxRetries: Int? = nil,
        perRetryTimeout: Duration? = nil,
        tcpRetryEvents: [TcpRetryPolicyEvent]? = nil
    )
    {
        self.httpRetryEvents = httpRetryEvents
        self.maxRetries = maxRetries
        self.perRetryTimeout = perRetryTimeout
        self.tcpRetryEvents = tcpRetryEvents
    }
}

extension HttpRoute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case match
        case retryPolicy
        case timeout
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let match = match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let retryPolicy = retryPolicy {
            try encodeContainer.encode(retryPolicy, forKey: .retryPolicy)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(HttpRouteMatch.self, forKey: .match)
        match = matchDecoded
        let actionDecoded = try containerValues.decodeIfPresent(HttpRouteAction.self, forKey: .action)
        action = actionDecoded
        let retryPolicyDecoded = try containerValues.decodeIfPresent(HttpRetryPolicy.self, forKey: .retryPolicy)
        retryPolicy = retryPolicyDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(HttpTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension HttpRoute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpRoute(action: \(String(describing: action)), match: \(String(describing: match)), retryPolicy: \(String(describing: retryPolicy)), timeout: \(String(describing: timeout)))"}
}

/// <p>An object that represents an HTTP or HTTP/2 route type.</p>
public struct HttpRoute: Equatable {
    /// <p>An object that represents the action to take if a match is determined.</p>
    public let action: HttpRouteAction?
    /// <p>An object that represents the criteria for determining a request match.</p>
    public let match: HttpRouteMatch?
    /// <p>An object that represents a retry policy.</p>
    public let retryPolicy: HttpRetryPolicy?
    /// <p>An object that represents types of timeouts. </p>
    public let timeout: HttpTimeout?

    public init (
        action: HttpRouteAction? = nil,
        match: HttpRouteMatch? = nil,
        retryPolicy: HttpRetryPolicy? = nil,
        timeout: HttpTimeout? = nil
    )
    {
        self.action = action
        self.match = match
        self.retryPolicy = retryPolicy
        self.timeout = timeout
    }
}

extension HttpRouteAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case weightedTargets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let weightedTargets = weightedTargets {
            var weightedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedTargets)
            for weightedtargets0 in weightedTargets {
                try weightedTargetsContainer.encode(weightedtargets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightedTargetsContainer = try containerValues.decodeIfPresent([WeightedTarget?].self, forKey: .weightedTargets)
        var weightedTargetsDecoded0:[WeightedTarget]? = nil
        if let weightedTargetsContainer = weightedTargetsContainer {
            weightedTargetsDecoded0 = [WeightedTarget]()
            for structure0 in weightedTargetsContainer {
                if let structure0 = structure0 {
                    weightedTargetsDecoded0?.append(structure0)
                }
            }
        }
        weightedTargets = weightedTargetsDecoded0
    }
}

extension HttpRouteAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpRouteAction(weightedTargets: \(String(describing: weightedTargets)))"}
}

/// <p>An object that represents the action to take if a match is determined.</p>
public struct HttpRouteAction: Equatable {
    /// <p>An object that represents the targets that traffic is routed to when a request matches the route.</p>
    public let weightedTargets: [WeightedTarget]?

    public init (
        weightedTargets: [WeightedTarget]? = nil
    )
    {
        self.weightedTargets = weightedTargets
    }
}

extension HttpRouteHeader: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invert
        case match
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invert = invert {
            try encodeContainer.encode(invert, forKey: .invert)
        }
        if let match = match {
            try encodeContainer.encode(match, forKey: .match)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let invertDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .invert)
        invert = invertDecoded
        let matchDecoded = try containerValues.decodeIfPresent(HeaderMatchMethod.self, forKey: .match)
        match = matchDecoded
    }
}

extension HttpRouteHeader: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpRouteHeader(invert: \(String(describing: invert)), match: \(String(describing: match)), name: \(String(describing: name)))"}
}

/// <p>An object that represents the HTTP header in the request.</p>
public struct HttpRouteHeader: Equatable {
    /// <p>Specify <code>True</code> to match anything except the match criteria. The default value is <code>False</code>.</p>
    public let invert: Bool?
    /// <p>The <code>HeaderMatchMethod</code> object.</p>
    public let match: HeaderMatchMethod?
    /// <p>A name for the HTTP header in the client request that will be matched on.</p>
    public let name: String?

    public init (
        invert: Bool? = nil,
        match: HeaderMatchMethod? = nil,
        name: String? = nil
    )
    {
        self.invert = invert
        self.match = match
        self.name = name
    }
}

extension HttpRouteMatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headers
        case method
        case prefix
        case scheme
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for httprouteheaders0 in headers {
                try headersContainer.encode(httprouteheaders0)
            }
        }
        if let method = method {
            try encodeContainer.encode(method.rawValue, forKey: .method)
        }
        if let prefix = prefix {
            try encodeContainer.encode(prefix, forKey: .prefix)
        }
        if let scheme = scheme {
            try encodeContainer.encode(scheme.rawValue, forKey: .scheme)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .prefix)
        prefix = prefixDecoded
        let methodDecoded = try containerValues.decodeIfPresent(HttpMethod.self, forKey: .method)
        method = methodDecoded
        let schemeDecoded = try containerValues.decodeIfPresent(HttpScheme.self, forKey: .scheme)
        scheme = schemeDecoded
        let headersContainer = try containerValues.decodeIfPresent([HttpRouteHeader?].self, forKey: .headers)
        var headersDecoded0:[HttpRouteHeader]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [HttpRouteHeader]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
    }
}

extension HttpRouteMatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpRouteMatch(headers: \(String(describing: headers)), method: \(String(describing: method)), prefix: \(String(describing: prefix)), scheme: \(String(describing: scheme)))"}
}

/// <p>An object that represents the requirements for a route to match HTTP requests for a
///          virtual router.</p>
public struct HttpRouteMatch: Equatable {
    /// <p>An object that represents the client request headers to match on.</p>
    public let headers: [HttpRouteHeader]?
    /// <p>The client request method to match on. Specify only one.</p>
    public let method: HttpMethod?
    /// <p>Specifies the path to match requests with. This parameter must always start with
    ///             <code>/</code>, which by itself matches all requests to the virtual service name. You
    ///          can also match for path-based routing of requests. For example, if your virtual service
    ///          name is <code>my-service.local</code> and you want the route to match requests to
    ///             <code>my-service.local/metrics</code>, your prefix should be
    ///          <code>/metrics</code>.</p>
    public let prefix: String?
    /// <p>The client request scheme to match on. Specify only one.</p>
    public let scheme: HttpScheme?

    public init (
        headers: [HttpRouteHeader]? = nil,
        method: HttpMethod? = nil,
        prefix: String? = nil,
        scheme: HttpScheme? = nil
    )
    {
        self.headers = headers
        self.method = method
        self.prefix = prefix
        self.scheme = scheme
    }
}

public enum HttpScheme {
    case http
    case https
    case sdkUnknown(String)
}

extension HttpScheme : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [HttpScheme] {
        return [
            .http,
            .https,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .http: return "http"
        case .https: return "https"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = HttpScheme(rawValue: rawValue) ?? HttpScheme.sdkUnknown(rawValue)
    }
}

extension HttpTimeout: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case idle
        case perRequest
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idle = idle {
            try encodeContainer.encode(idle, forKey: .idle)
        }
        if let perRequest = perRequest {
            try encodeContainer.encode(perRequest, forKey: .perRequest)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let perRequestDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .perRequest)
        perRequest = perRequestDecoded
        let idleDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .idle)
        idle = idleDecoded
    }
}

extension HttpTimeout: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HttpTimeout(idle: \(String(describing: idle)), perRequest: \(String(describing: perRequest)))"}
}

/// <p>An object that represents types of timeouts. </p>
public struct HttpTimeout: Equatable {
    /// <p>An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.</p>
    public let idle: Duration?
    /// <p>An object that represents a per request timeout. The default value is 15 seconds. If you set a higher timeout, then make sure that the higher value is set for each App Mesh
    ///                                   resource in a conversation. For example, if a virtual node backend uses a virtual router provider to route to another virtual node, then the timeout should be greater than 15
    ///                                   seconds for the source and destination virtual node and the route.</p>
    public let perRequest: Duration?

    public init (
        idle: Duration? = nil,
        perRequest: Duration? = nil
    )
    {
        self.idle = idle
        self.perRequest = perRequest
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception, or
///          failure.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded a service limit for your account. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/service-quotas.html">Service
///             Limits</a> in the <i>AWS App Mesh User Guide</i>.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListGatewayRoutesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewayRoutesInput(limit: \(String(describing: limit)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), nextToken: \(String(describing: nextToken)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension ListGatewayRoutesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListGatewayRoutesInputHeadersMiddleware: Middleware {
    public let id: String = "ListGatewayRoutesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewayRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewayRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewayRoutesInput>
    public typealias MOutput = OperationOutput<ListGatewayRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewayRoutesOutputError>
}

public struct ListGatewayRoutesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListGatewayRoutesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListGatewayRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListGatewayRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListGatewayRoutesInput>
    public typealias MOutput = OperationOutput<ListGatewayRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListGatewayRoutesOutputError>
}

public struct ListGatewayRoutesInput: Equatable {
    /// <p>The maximum number of results returned by <code>ListGatewayRoutes</code> in paginated
    ///          output. When you use this parameter, <code>ListGatewayRoutes</code> returns only
    ///             <code>limit</code> results in a single page along with a <code>nextToken</code> response
    ///          element. You can see the remaining results of the initial request by sending another
    ///             <code>ListGatewayRoutes</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If you don't use this
    ///          parameter, <code>ListGatewayRoutes</code> returns up to 100 results and a
    ///             <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The name of the service mesh to list gateway routes in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListGatewayRoutes</code> request where <code>limit</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous
    ///          results that returned the <code>nextToken</code> value.</p>
    public let nextToken: String?
    /// <p>The name of the virtual gateway to list gateway routes in.</p>
    public let virtualGatewayName: String?

    public init (
        limit: Int? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
        self.virtualGatewayName = virtualGatewayName
    }
}

struct ListGatewayRoutesInputBody: Equatable {
}

extension ListGatewayRoutesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListGatewayRoutesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewayRoutesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewayRoutesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewayRoutesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListGatewayRoutesOutputResponse(gatewayRoutes: \(String(describing: gatewayRoutes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListGatewayRoutesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListGatewayRoutesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.gatewayRoutes = output.gatewayRoutes
            self.nextToken = output.nextToken
        } else {
            self.gatewayRoutes = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewayRoutesOutputResponse: Equatable {
    /// <p>The list of existing gateway routes for the specified service mesh and virtual
    ///          gateway.</p>
    public let gatewayRoutes: [GatewayRouteRef]?
    /// <p>The <code>nextToken</code> value to include in a future <code>ListGatewayRoutes</code>
    ///          request. When the results of a <code>ListGatewayRoutes</code> request exceed
    ///             <code>limit</code>, you can use this value to retrieve the next page of results. This
    ///          value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?

    public init (
        gatewayRoutes: [GatewayRouteRef]? = nil,
        nextToken: String? = nil
    )
    {
        self.gatewayRoutes = gatewayRoutes
        self.nextToken = nextToken
    }
}

struct ListGatewayRoutesOutputResponseBody: Equatable {
    public let gatewayRoutes: [GatewayRouteRef]?
    public let nextToken: String?
}

extension ListGatewayRoutesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayRoutes
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRoutesContainer = try containerValues.decodeIfPresent([GatewayRouteRef?].self, forKey: .gatewayRoutes)
        var gatewayRoutesDecoded0:[GatewayRouteRef]? = nil
        if let gatewayRoutesContainer = gatewayRoutesContainer {
            gatewayRoutesDecoded0 = [GatewayRouteRef]()
            for structure0 in gatewayRoutesContainer {
                if let structure0 = structure0 {
                    gatewayRoutesDecoded0?.append(structure0)
                }
            }
        }
        gatewayRoutes = gatewayRoutesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMeshesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMeshesInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMeshesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListMeshesInputHeadersMiddleware: Middleware {
    public let id: String = "ListMeshesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMeshesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMeshesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMeshesInput>
    public typealias MOutput = OperationOutput<ListMeshesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMeshesOutputError>
}

public struct ListMeshesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListMeshesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListMeshesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListMeshesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListMeshesInput>
    public typealias MOutput = OperationOutput<ListMeshesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListMeshesOutputError>
}

///
public struct ListMeshesInput: Equatable {
    /// <p>The maximum number of results returned by <code>ListMeshes</code> in paginated output.
    ///          When you use this parameter, <code>ListMeshes</code> returns only <code>limit</code>
    ///          results in a single page along with a <code>nextToken</code> response element. You can see
    ///          the remaining results of the initial request by sending another <code>ListMeshes</code>
    ///          request with the returned <code>nextToken</code> value. This value can be between
    ///          1 and 100. If you don't use this parameter,
    ///             <code>ListMeshes</code> returns up to 100 results and a
    ///             <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListMeshes</code> request where <code>limit</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous
    ///          results that returned the <code>nextToken</code> value.</p>
    ///          <note>
    ///             <p>This token should be treated as an opaque identifier that is used only to
    ///                 retrieve the next items in a list and not for other programmatic purposes.</p>
    ///         </note>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
    }
}

struct ListMeshesInputBody: Equatable {
}

extension ListMeshesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListMeshesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMeshesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListMeshesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMeshesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListMeshesOutputResponse(meshes: \(String(describing: meshes)), nextToken: \(String(describing: nextToken)))"}
}

extension ListMeshesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListMeshesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.meshes = output.meshes
            self.nextToken = output.nextToken
        } else {
            self.meshes = nil
            self.nextToken = nil
        }
    }
}

///
public struct ListMeshesOutputResponse: Equatable {
    /// <p>The list of existing service meshes.</p>
    public let meshes: [MeshRef]?
    /// <p>The <code>nextToken</code> value to include in a future <code>ListMeshes</code> request.
    ///          When the results of a <code>ListMeshes</code> request exceed <code>limit</code>, you can
    ///          use this value to retrieve the next page of results. This value is <code>null</code> when
    ///          there are no more results to return.</p>
    public let nextToken: String?

    public init (
        meshes: [MeshRef]? = nil,
        nextToken: String? = nil
    )
    {
        self.meshes = meshes
        self.nextToken = nextToken
    }
}

struct ListMeshesOutputResponseBody: Equatable {
    public let meshes: [MeshRef]?
    public let nextToken: String?
}

extension ListMeshesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case meshes
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshesContainer = try containerValues.decodeIfPresent([MeshRef?].self, forKey: .meshes)
        var meshesDecoded0:[MeshRef]? = nil
        if let meshesContainer = meshesContainer {
            meshesDecoded0 = [MeshRef]()
            for structure0 in meshesContainer {
                if let structure0 = structure0 {
                    meshesDecoded0?.append(structure0)
                }
            }
        }
        meshes = meshesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRoutesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoutesInput(limit: \(String(describing: limit)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), nextToken: \(String(describing: nextToken)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension ListRoutesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListRoutesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRoutesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoutesInput>
    public typealias MOutput = OperationOutput<ListRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoutesOutputError>
}

public struct ListRoutesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRoutesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRoutesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRoutesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRoutesInput>
    public typealias MOutput = OperationOutput<ListRoutesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRoutesOutputError>
}

///
public struct ListRoutesInput: Equatable {
    /// <p>The maximum number of results returned by <code>ListRoutes</code> in paginated output.
    ///          When you use this parameter, <code>ListRoutes</code> returns only <code>limit</code>
    ///          results in a single page along with a <code>nextToken</code> response element. You can see
    ///          the remaining results of the initial request by sending another <code>ListRoutes</code>
    ///          request with the returned <code>nextToken</code> value. This value can be between
    ///          1 and 100. If you don't use this parameter,
    ///             <code>ListRoutes</code> returns up to 100 results and a
    ///             <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The name of the service mesh to list routes in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListRoutes</code> request where <code>limit</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous
    ///          results that returned the <code>nextToken</code> value.</p>
    public let nextToken: String?
    /// <p>The name of the virtual router to list routes in.</p>
    public let virtualRouterName: String?

    public init (
        limit: Int? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        nextToken: String? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
        self.virtualRouterName = virtualRouterName
    }
}

struct ListRoutesInputBody: Equatable {
}

extension ListRoutesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListRoutesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRoutesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRoutesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRoutesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRoutesOutputResponse(nextToken: \(String(describing: nextToken)), routes: \(String(describing: routes)))"}
}

extension ListRoutesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRoutesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.routes = output.routes
        } else {
            self.nextToken = nil
            self.routes = nil
        }
    }
}

///
public struct ListRoutesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListRoutes</code> request.
    ///          When the results of a <code>ListRoutes</code> request exceed <code>limit</code>, you can
    ///          use this value to retrieve the next page of results. This value is <code>null</code> when
    ///          there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The list of existing routes for the specified service mesh and virtual router.</p>
    public let routes: [RouteRef]?

    public init (
        nextToken: String? = nil,
        routes: [RouteRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.routes = routes
    }
}

struct ListRoutesOutputResponseBody: Equatable {
    public let routes: [RouteRef]?
    public let nextToken: String?
}

extension ListRoutesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case routes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routesContainer = try containerValues.decodeIfPresent([RouteRef?].self, forKey: .routes)
        var routesDecoded0:[RouteRef]? = nil
        if let routesContainer = routesContainer {
            routesDecoded0 = [RouteRef]()
            for structure0 in routesContainer {
                if let structure0 = structure0 {
                    routesDecoded0?.append(structure0)
                }
            }
        }
        routes = routesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(limit: \(String(describing: limit)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

///
public struct ListTagsForResourceInput: Equatable {
    /// <p>The maximum number of tag results returned by <code>ListTagsForResource</code> in
    ///          paginated output. When this parameter is used, <code>ListTagsForResource</code> returns
    ///          only <code>limit</code> results in a single page along with a <code>nextToken</code>
    ///          response element. You can see the remaining results of the initial request by sending
    ///          another <code>ListTagsForResource</code> request with the returned <code>nextToken</code>
    ///          value. This value can be between 1 and 100. If you don't use
    ///          this parameter, <code>ListTagsForResource</code> returns up to 100
    ///          results and a <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListTagsForResource</code> request where <code>limit</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) that identifies the resource to list the tags for.</p>
    public let resourceArn: String?

    public init (
        limit: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.limit = limit
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

///
public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListTagsForResource</code>
    ///          request. When the results of a <code>ListTagsForResource</code> request exceed
    ///             <code>limit</code>, you can use this value to retrieve the next page of results. This
    ///          value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The tags for the resource.</p>
    public let tags: [TagRef]?

    public init (
        nextToken: String? = nil,
        tags: [TagRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [TagRef]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualGatewaysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualGatewaysInput(limit: \(String(describing: limit)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), nextToken: \(String(describing: nextToken)))"}
}

extension ListVirtualGatewaysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVirtualGatewaysInputHeadersMiddleware: Middleware {
    public let id: String = "ListVirtualGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualGatewaysInput>
    public typealias MOutput = OperationOutput<ListVirtualGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualGatewaysOutputError>
}

public struct ListVirtualGatewaysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVirtualGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualGatewaysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualGatewaysInput>
    public typealias MOutput = OperationOutput<ListVirtualGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualGatewaysOutputError>
}

public struct ListVirtualGatewaysInput: Equatable {
    /// <p>The maximum number of results returned by <code>ListVirtualGateways</code> in paginated
    ///          output. When you use this parameter, <code>ListVirtualGateways</code> returns only
    ///             <code>limit</code> results in a single page along with a <code>nextToken</code> response
    ///          element. You can see the remaining results of the initial request by sending another
    ///             <code>ListVirtualGateways</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If you don't use this
    ///          parameter, <code>ListVirtualGateways</code> returns up to 100 results and
    ///          a <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The name of the service mesh to list virtual gateways in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListVirtualGateways</code> request where <code>limit</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualGatewaysInputBody: Equatable {
}

extension ListVirtualGatewaysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVirtualGatewaysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualGatewaysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualGatewaysOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualGatewaysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualGatewaysOutputResponse(nextToken: \(String(describing: nextToken)), virtualGateways: \(String(describing: virtualGateways)))"}
}

extension ListVirtualGatewaysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVirtualGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.virtualGateways = output.virtualGateways
        } else {
            self.nextToken = nil
            self.virtualGateways = nil
        }
    }
}

public struct ListVirtualGatewaysOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListVirtualGateways</code>
    ///          request. When the results of a <code>ListVirtualGateways</code> request exceed
    ///             <code>limit</code>, you can use this value to retrieve the next page of results. This
    ///          value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The list of existing virtual gateways for the specified service mesh.</p>
    public let virtualGateways: [VirtualGatewayRef]?

    public init (
        nextToken: String? = nil,
        virtualGateways: [VirtualGatewayRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualGateways = virtualGateways
    }
}

struct ListVirtualGatewaysOutputResponseBody: Equatable {
    public let virtualGateways: [VirtualGatewayRef]?
    public let nextToken: String?
}

extension ListVirtualGatewaysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case virtualGateways
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewaysContainer = try containerValues.decodeIfPresent([VirtualGatewayRef?].self, forKey: .virtualGateways)
        var virtualGatewaysDecoded0:[VirtualGatewayRef]? = nil
        if let virtualGatewaysContainer = virtualGatewaysContainer {
            virtualGatewaysDecoded0 = [VirtualGatewayRef]()
            for structure0 in virtualGatewaysContainer {
                if let structure0 = structure0 {
                    virtualGatewaysDecoded0?.append(structure0)
                }
            }
        }
        virtualGateways = virtualGatewaysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualNodesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualNodesInput(limit: \(String(describing: limit)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), nextToken: \(String(describing: nextToken)))"}
}

extension ListVirtualNodesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVirtualNodesInputHeadersMiddleware: Middleware {
    public let id: String = "ListVirtualNodesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualNodesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualNodesInput>
    public typealias MOutput = OperationOutput<ListVirtualNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualNodesOutputError>
}

public struct ListVirtualNodesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVirtualNodesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualNodesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualNodesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualNodesInput>
    public typealias MOutput = OperationOutput<ListVirtualNodesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualNodesOutputError>
}

///
public struct ListVirtualNodesInput: Equatable {
    /// <p>The maximum number of results returned by <code>ListVirtualNodes</code> in paginated
    ///          output. When you use this parameter, <code>ListVirtualNodes</code> returns only
    ///             <code>limit</code> results in a single page along with a <code>nextToken</code> response
    ///          element. You can see the remaining results of the initial request by sending another
    ///             <code>ListVirtualNodes</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If you don't use this
    ///          parameter, <code>ListVirtualNodes</code> returns up to 100 results and a
    ///             <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The name of the service mesh to list virtual nodes in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListVirtualNodes</code> request where <code>limit</code> was used and the results
    ///          exceeded the value of that parameter. Pagination continues from the end of the previous
    ///          results that returned the <code>nextToken</code> value.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualNodesInputBody: Equatable {
}

extension ListVirtualNodesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVirtualNodesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualNodesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualNodesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualNodesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualNodesOutputResponse(nextToken: \(String(describing: nextToken)), virtualNodes: \(String(describing: virtualNodes)))"}
}

extension ListVirtualNodesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVirtualNodesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.virtualNodes = output.virtualNodes
        } else {
            self.nextToken = nil
            self.virtualNodes = nil
        }
    }
}

///
public struct ListVirtualNodesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListVirtualNodes</code>
    ///          request. When the results of a <code>ListVirtualNodes</code> request exceed
    ///             <code>limit</code>, you can use this value to retrieve the next page of results. This
    ///          value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The list of existing virtual nodes for the specified service mesh.</p>
    public let virtualNodes: [VirtualNodeRef]?

    public init (
        nextToken: String? = nil,
        virtualNodes: [VirtualNodeRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualNodes = virtualNodes
    }
}

struct ListVirtualNodesOutputResponseBody: Equatable {
    public let virtualNodes: [VirtualNodeRef]?
    public let nextToken: String?
}

extension ListVirtualNodesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case virtualNodes
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodesContainer = try containerValues.decodeIfPresent([VirtualNodeRef?].self, forKey: .virtualNodes)
        var virtualNodesDecoded0:[VirtualNodeRef]? = nil
        if let virtualNodesContainer = virtualNodesContainer {
            virtualNodesDecoded0 = [VirtualNodeRef]()
            for structure0 in virtualNodesContainer {
                if let structure0 = structure0 {
                    virtualNodesDecoded0?.append(structure0)
                }
            }
        }
        virtualNodes = virtualNodesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualRoutersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualRoutersInput(limit: \(String(describing: limit)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), nextToken: \(String(describing: nextToken)))"}
}

extension ListVirtualRoutersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVirtualRoutersInputHeadersMiddleware: Middleware {
    public let id: String = "ListVirtualRoutersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualRoutersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualRoutersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualRoutersInput>
    public typealias MOutput = OperationOutput<ListVirtualRoutersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualRoutersOutputError>
}

public struct ListVirtualRoutersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVirtualRoutersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualRoutersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualRoutersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualRoutersInput>
    public typealias MOutput = OperationOutput<ListVirtualRoutersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualRoutersOutputError>
}

///
public struct ListVirtualRoutersInput: Equatable {
    /// <p>The maximum number of results returned by <code>ListVirtualRouters</code> in paginated
    ///          output. When you use this parameter, <code>ListVirtualRouters</code> returns only
    ///             <code>limit</code> results in a single page along with a <code>nextToken</code> response
    ///          element. You can see the remaining results of the initial request by sending another
    ///             <code>ListVirtualRouters</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If you don't use this
    ///          parameter, <code>ListVirtualRouters</code> returns up to 100 results and
    ///          a <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The name of the service mesh to list virtual routers in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListVirtualRouters</code> request where <code>limit</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualRoutersInputBody: Equatable {
}

extension ListVirtualRoutersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVirtualRoutersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualRoutersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualRoutersOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualRoutersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualRoutersOutputResponse(nextToken: \(String(describing: nextToken)), virtualRouters: \(String(describing: virtualRouters)))"}
}

extension ListVirtualRoutersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVirtualRoutersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.virtualRouters = output.virtualRouters
        } else {
            self.nextToken = nil
            self.virtualRouters = nil
        }
    }
}

///
public struct ListVirtualRoutersOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListVirtualRouters</code>
    ///          request. When the results of a <code>ListVirtualRouters</code> request exceed
    ///             <code>limit</code>, you can use this value to retrieve the next page of results. This
    ///          value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The list of existing virtual routers for the specified service mesh.</p>
    public let virtualRouters: [VirtualRouterRef]?

    public init (
        nextToken: String? = nil,
        virtualRouters: [VirtualRouterRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualRouters = virtualRouters
    }
}

struct ListVirtualRoutersOutputResponseBody: Equatable {
    public let virtualRouters: [VirtualRouterRef]?
    public let nextToken: String?
}

extension ListVirtualRoutersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case virtualRouters
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRoutersContainer = try containerValues.decodeIfPresent([VirtualRouterRef?].self, forKey: .virtualRouters)
        var virtualRoutersDecoded0:[VirtualRouterRef]? = nil
        if let virtualRoutersContainer = virtualRoutersContainer {
            virtualRoutersDecoded0 = [VirtualRouterRef]()
            for structure0 in virtualRoutersContainer {
                if let structure0 = structure0 {
                    virtualRoutersDecoded0?.append(structure0)
                }
            }
        }
        virtualRouters = virtualRoutersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListVirtualServicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualServicesInput(limit: \(String(describing: limit)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), nextToken: \(String(describing: nextToken)))"}
}

extension ListVirtualServicesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVirtualServicesInputHeadersMiddleware: Middleware {
    public let id: String = "ListVirtualServicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualServicesInput>
    public typealias MOutput = OperationOutput<ListVirtualServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualServicesOutputError>
}

public struct ListVirtualServicesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVirtualServicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVirtualServicesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVirtualServicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let limit = input.operationInput.limit {
            let limitQueryItem = URLQueryItem(name: "limit".urlPercentEncoding(), value: String(limit).urlPercentEncoding())
            input.builder.withQueryItem(limitQueryItem)
        }
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVirtualServicesInput>
    public typealias MOutput = OperationOutput<ListVirtualServicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVirtualServicesOutputError>
}

///
public struct ListVirtualServicesInput: Equatable {
    /// <p>The maximum number of results returned by <code>ListVirtualServices</code> in paginated
    ///          output. When you use this parameter, <code>ListVirtualServices</code> returns only
    ///             <code>limit</code> results in a single page along with a <code>nextToken</code> response
    ///          element. You can see the remaining results of the initial request by sending another
    ///             <code>ListVirtualServices</code> request with the returned <code>nextToken</code> value.
    ///          This value can be between 1 and 100. If you don't use this
    ///          parameter, <code>ListVirtualServices</code> returns up to 100 results and
    ///          a <code>nextToken</code> value if applicable.</p>
    public let limit: Int?
    /// <p>The name of the service mesh to list virtual services in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The <code>nextToken</code> value returned from a previous paginated
    ///             <code>ListVirtualServices</code> request where <code>limit</code> was used and the
    ///          results exceeded the value of that parameter. Pagination continues from the end of the
    ///          previous results that returned the <code>nextToken</code> value.</p>
    public let nextToken: String?

    public init (
        limit: Int? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        nextToken: String? = nil
    )
    {
        self.limit = limit
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.nextToken = nextToken
    }
}

struct ListVirtualServicesInputBody: Equatable {
}

extension ListVirtualServicesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVirtualServicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVirtualServicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVirtualServicesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVirtualServicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVirtualServicesOutputResponse(nextToken: \(String(describing: nextToken)), virtualServices: \(String(describing: virtualServices)))"}
}

extension ListVirtualServicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVirtualServicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.virtualServices = output.virtualServices
        } else {
            self.nextToken = nil
            self.virtualServices = nil
        }
    }
}

///
public struct ListVirtualServicesOutputResponse: Equatable {
    /// <p>The <code>nextToken</code> value to include in a future <code>ListVirtualServices</code>
    ///          request. When the results of a <code>ListVirtualServices</code> request exceed
    ///             <code>limit</code>, you can use this value to retrieve the next page of results. This
    ///          value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>The list of existing virtual services for the specified service mesh.</p>
    public let virtualServices: [VirtualServiceRef]?

    public init (
        nextToken: String? = nil,
        virtualServices: [VirtualServiceRef]? = nil
    )
    {
        self.nextToken = nextToken
        self.virtualServices = virtualServices
    }
}

struct ListVirtualServicesOutputResponseBody: Equatable {
    public let virtualServices: [VirtualServiceRef]?
    public let nextToken: String?
}

extension ListVirtualServicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case virtualServices
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServicesContainer = try containerValues.decodeIfPresent([VirtualServiceRef?].self, forKey: .virtualServices)
        var virtualServicesDecoded0:[VirtualServiceRef]? = nil
        if let virtualServicesContainer = virtualServicesContainer {
            virtualServicesDecoded0 = [VirtualServiceRef]()
            for structure0 in virtualServicesContainer {
                if let structure0 = structure0 {
                    virtualServicesDecoded0?.append(structure0)
                }
            }
        }
        virtualServices = virtualServicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Listener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionPool
        case healthCheck
        case outlierDetection
        case portMapping
        case timeout
        case tls
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionPool = connectionPool {
            try encodeContainer.encode(connectionPool, forKey: .connectionPool)
        }
        if let healthCheck = healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let outlierDetection = outlierDetection {
            try encodeContainer.encode(outlierDetection, forKey: .outlierDetection)
        }
        if let portMapping = portMapping {
            try encodeContainer.encode(portMapping, forKey: .portMapping)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tls = tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingDecoded = try containerValues.decodeIfPresent(PortMapping.self, forKey: .portMapping)
        portMapping = portMappingDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(ListenerTls.self, forKey: .tls)
        tls = tlsDecoded
        let healthCheckDecoded = try containerValues.decodeIfPresent(HealthCheckPolicy.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(ListenerTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
        let outlierDetectionDecoded = try containerValues.decodeIfPresent(OutlierDetection.self, forKey: .outlierDetection)
        outlierDetection = outlierDetectionDecoded
        let connectionPoolDecoded = try containerValues.decodeIfPresent(VirtualNodeConnectionPool.self, forKey: .connectionPool)
        connectionPool = connectionPoolDecoded
    }
}

extension Listener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Listener(connectionPool: \(String(describing: connectionPool)), healthCheck: \(String(describing: healthCheck)), outlierDetection: \(String(describing: outlierDetection)), portMapping: \(String(describing: portMapping)), timeout: \(String(describing: timeout)), tls: \(String(describing: tls)))"}
}

/// <p>An object that represents a listener for a virtual node.</p>
public struct Listener: Equatable {
    /// <p>The connection pool information for the listener.</p>
    public let connectionPool: VirtualNodeConnectionPool?
    /// <p>The health check information for the listener.</p>
    public let healthCheck: HealthCheckPolicy?
    /// <p>The outlier detection information for the listener.</p>
    public let outlierDetection: OutlierDetection?
    /// <p>The port mapping information for the listener.</p>
    public let portMapping: PortMapping?
    /// <p>An object that represents timeouts for different protocols.</p>
    public let timeout: ListenerTimeout?
    /// <p>A reference to an object that represents the Transport Layer Security (TLS) properties for a listener.</p>
    public let tls: ListenerTls?

    public init (
        connectionPool: VirtualNodeConnectionPool? = nil,
        healthCheck: HealthCheckPolicy? = nil,
        outlierDetection: OutlierDetection? = nil,
        portMapping: PortMapping? = nil,
        timeout: ListenerTimeout? = nil,
        tls: ListenerTls? = nil
    )
    {
        self.connectionPool = connectionPool
        self.healthCheck = healthCheck
        self.outlierDetection = outlierDetection
        self.portMapping = portMapping
        self.timeout = timeout
        self.tls = tls
    }
}

extension ListenerTimeout: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grpc
        case http
        case http2
        case sdkUnknown
        case tcp
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .grpc(grpc):
                if let grpc = grpc {
                    try container.encode(grpc, forKey: .grpc)
                }
            case let .http(http):
                if let http = http {
                    try container.encode(http, forKey: .http)
                }
            case let .http2(http2):
                if let http2 = http2 {
                    try container.encode(http2, forKey: .http2)
                }
            case let .tcp(tcp):
                if let tcp = tcp {
                    try container.encode(tcp, forKey: .tcp)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tcpDecoded = try values.decodeIfPresent(TcpTimeout.self, forKey: .tcp)
        if let tcp = tcpDecoded {
            self = .tcp(tcp)
            return
        }
        let httpDecoded = try values.decodeIfPresent(HttpTimeout.self, forKey: .http)
        if let http = httpDecoded {
            self = .http(http)
            return
        }
        let http2Decoded = try values.decodeIfPresent(HttpTimeout.self, forKey: .http2)
        if let http2 = http2Decoded {
            self = .http2(http2)
            return
        }
        let grpcDecoded = try values.decodeIfPresent(GrpcTimeout.self, forKey: .grpc)
        if let grpc = grpcDecoded {
            self = .grpc(grpc)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents timeouts for different protocols.</p>
public enum ListenerTimeout: Equatable {
    /// <p>An object that represents types of timeouts. </p>
    case tcp(TcpTimeout?)
    /// <p>An object that represents types of timeouts. </p>
    case http(HttpTimeout?)
    /// <p>An object that represents types of timeouts. </p>
    case http2(HttpTimeout?)
    /// <p>An object that represents types of timeouts. </p>
    case grpc(GrpcTimeout?)
    case sdkUnknown(String?)
}

extension ListenerTls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate
        case mode
        case validation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let validation = validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(ListenerTlsMode.self, forKey: .mode)
        mode = modeDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(ListenerTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
        let validationDecoded = try containerValues.decodeIfPresent(ListenerTlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension ListenerTls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerTls(certificate: \(String(describing: certificate)), mode: \(String(describing: mode)), validation: \(String(describing: validation)))"}
}

/// <p>An object that represents the Transport Layer Security (TLS) properties for a listener.</p>
public struct ListenerTls: Equatable {
    /// <p>A reference to an object that represents a listener's Transport Layer Security (TLS) certificate.</p>
    public let certificate: ListenerTlsCertificate?
    /// <p>Specify one of the following modes.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b/>STRICT – Listener only accepts connections with TLS
    ///                enabled. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b/>PERMISSIVE – Listener accepts connections with or
    ///                without TLS enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b/>DISABLED – Listener only accepts connections without
    ///                TLS. </p>
    ///             </li>
    ///          </ul>
    public let mode: ListenerTlsMode?
    /// <p>A reference to an object that represents a listener's Transport Layer Security (TLS) validation context.</p>
    public let validation: ListenerTlsValidationContext?

    public init (
        certificate: ListenerTlsCertificate? = nil,
        mode: ListenerTlsMode? = nil,
        validation: ListenerTlsValidationContext? = nil
    )
    {
        self.certificate = certificate
        self.mode = mode
        self.validation = validation
    }
}

extension ListenerTlsAcmCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension ListenerTlsAcmCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerTlsAcmCertificate(certificateArn: \(String(describing: certificateArn)))"}
}

/// <p>An object that represents an AWS Certicate Manager (ACM) certificate.</p>
public struct ListenerTlsAcmCertificate: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.</p>
    public let certificateArn: String?

    public init (
        certificateArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

extension ListenerTlsCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                if let acm = acm {
                    try container.encode(acm, forKey: .acm)
                }
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(ListenerTlsAcmCertificate.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(ListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(ListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents a listener's Transport Layer Security (TLS) certificate.</p>
public enum ListenerTlsCertificate: Equatable {
    /// <p>A reference to an object that represents an AWS Certicate Manager (ACM) certificate.</p>
    case acm(ListenerTlsAcmCertificate?)
    /// <p>A reference to an object that represents a local file certificate.</p>
    case file(ListenerTlsFileCertificate?)
    /// <p>A reference to an object that represents a listener's Secret Discovery Service
    ///          certificate.</p>
    case sds(ListenerTlsSdsCertificate?)
    case sdkUnknown(String?)
}

extension ListenerTlsFileCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateChain
        case privateKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
    }
}

extension ListenerTlsFileCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerTlsFileCertificate(certificateChain: \(String(describing: certificateChain)), privateKey: \(String(describing: privateKey)))"}
}

/// <p>An object that represents a local file certificate.
///          The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.</p>
public struct ListenerTlsFileCertificate: Equatable {
    /// <p>The certificate chain for the certificate.</p>
    public let certificateChain: String?
    /// <p>The private key for a certificate stored on the file system of the virtual node that the
    ///          proxy is running on.</p>
    public let privateKey: String?

    public init (
        certificateChain: String? = nil,
        privateKey: String? = nil
    )
    {
        self.certificateChain = certificateChain
        self.privateKey = privateKey
    }
}

public enum ListenerTlsMode {
    case disabled
    case permissive
    case strict
    case sdkUnknown(String)
}

extension ListenerTlsMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ListenerTlsMode] {
        return [
            .disabled,
            .permissive,
            .strict,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .permissive: return "PERMISSIVE"
        case .strict: return "STRICT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ListenerTlsMode(rawValue: rawValue) ?? ListenerTlsMode.sdkUnknown(rawValue)
    }
}

extension ListenerTlsSdsCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension ListenerTlsSdsCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerTlsSdsCertificate(secretName: \(String(describing: secretName)))"}
}

/// <p>An object that represents the listener's Secret Discovery Service certificate. The proxy
///          must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS
///             documentation</a> for more info.</p>
public struct ListenerTlsSdsCertificate: Equatable {
    /// <p>A reference to an object that represents the name of the secret requested from the
    ///          Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or
    ///          certificate chain.</p>
    public let secretName: String?

    public init (
        secretName: String? = nil
    )
    {
        self.secretName = secretName
    }
}

extension ListenerTlsValidationContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(ListenerTlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension ListenerTlsValidationContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListenerTlsValidationContext(subjectAlternativeNames: \(String(describing: subjectAlternativeNames)), trust: \(String(describing: trust)))"}
}

/// <p>An object that represents a listener's Transport Layer Security (TLS) validation context.</p>
public struct ListenerTlsValidationContext: Equatable {
    /// <p>A reference to an object that represents the SANs for a listener's Transport Layer Security (TLS) validation
    ///          context.</p>
    public let subjectAlternativeNames: SubjectAlternativeNames?
    /// <p>A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS)
    ///          certificate.</p>
    public let trust: ListenerTlsValidationContextTrust?

    public init (
        subjectAlternativeNames: SubjectAlternativeNames? = nil,
        trust: ListenerTlsValidationContextTrust? = nil
    )
    {
        self.subjectAlternativeNames = subjectAlternativeNames
        self.trust = trust
    }
}

extension ListenerTlsValidationContextTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(TlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(TlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents a listener's Transport Layer Security (TLS) validation context trust.</p>
public enum ListenerTlsValidationContextTrust: Equatable {
    /// <p>An object that represents a Transport Layer Security (TLS) validation context trust for a local file.</p>
    case file(TlsValidationContextFileTrust?)
    /// <p>A reference to an object that represents a listener's Transport Layer Security (TLS) Secret Discovery Service
    ///          validation context trust.</p>
    case sds(TlsValidationContextSdsTrust?)
    case sdkUnknown(String?)
}

extension Logging: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLog
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLog = accessLog {
            try encodeContainer.encode(accessLog, forKey: .accessLog)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogDecoded = try containerValues.decodeIfPresent(AccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
    }
}

extension Logging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Logging(accessLog: \(String(describing: accessLog)))"}
}

/// <p>An object that represents the logging information for a virtual node.</p>
public struct Logging: Equatable {
    /// <p>The access log configuration for a virtual node.</p>
    public let accessLog: AccessLog?

    public init (
        accessLog: AccessLog? = nil
    )
    {
        self.accessLog = accessLog
    }
}

extension MatchRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end
        case start
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .end)
        end = endDecoded
    }
}

extension MatchRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MatchRange(end: \(String(describing: end)), start: \(String(describing: start)))"}
}

/// <p>An object that represents the range of values to match on. The first character of the range is included in the range, though the last character is not. For example, if the range specified were 1-100, only values 1-99 would be matched.</p>
public struct MatchRange: Equatable {
    /// <p>The end of the range.</p>
    public let end: Int?
    /// <p>The start of the range.</p>
    public let start: Int?

    public init (
        end: Int? = nil,
        start: Int? = nil
    )
    {
        self.end = end
        self.start = start
    }
}

extension MeshData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meshName
        case metadata
        case spec
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(MeshSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MeshStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension MeshData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeshData(meshName: \(String(describing: meshName)), metadata: \(String(describing: metadata)), spec: \(String(describing: spec)), status: \(String(describing: status)))"}
}

/// <p>An object that represents a service mesh returned by a describe operation.</p>
public struct MeshData: Equatable {
    /// <p>The name of the service mesh.</p>
    public let meshName: String?
    /// <p>The associated metadata for the service mesh.</p>
    public let metadata: ResourceMetadata?
    /// <p>The associated specification for the service mesh.</p>
    public let spec: MeshSpec?
    /// <p>The status of the service mesh.</p>
    public let status: MeshStatus?

    public init (
        meshName: String? = nil,
        metadata: ResourceMetadata? = nil,
        spec: MeshSpec? = nil,
        status: MeshStatus? = nil
    )
    {
        self.meshName = meshName
        self.metadata = metadata
        self.spec = spec
        self.status = status
    }
}

extension MeshRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension MeshRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeshRef(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), version: \(String(describing: version)))"}
}

/// <p>An object that represents a service mesh returned by a list operation.</p>
public struct MeshRef: Equatable {
    /// <p>The full Amazon Resource Name (ARN) of the service mesh.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the service mesh.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        version: Int? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.version = version
    }
}

extension MeshSpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case egressFilter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let egressFilter = egressFilter {
            try encodeContainer.encode(egressFilter, forKey: .egressFilter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let egressFilterDecoded = try containerValues.decodeIfPresent(EgressFilter.self, forKey: .egressFilter)
        egressFilter = egressFilterDecoded
    }
}

extension MeshSpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeshSpec(egressFilter: \(String(describing: egressFilter)))"}
}

/// <p>An object that represents the specification of a service mesh.</p>
public struct MeshSpec: Equatable {
    /// <p>The egress filter rules for the service mesh.</p>
    public let egressFilter: EgressFilter?

    public init (
        egressFilter: EgressFilter? = nil
    )
    {
        self.egressFilter = egressFilter
    }
}

extension MeshStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MeshStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension MeshStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MeshStatus(status: \(String(describing: status)))"}
}

/// <p>An object that represents the status of a service mesh.</p>
public struct MeshStatus: Equatable {
    /// <p>The current mesh status.</p>
    public let status: MeshStatusCode?

    public init (
        status: MeshStatusCode? = nil
    )
    {
        self.status = status
    }
}

public enum MeshStatusCode {
    case active
    case deleted
    case inactive
    case sdkUnknown(String)
}

extension MeshStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MeshStatusCode] {
        return [
            .active,
            .deleted,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MeshStatusCode(rawValue: rawValue) ?? MeshStatusCode.sdkUnknown(rawValue)
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource doesn't exist. Check your request syntax and try again.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension OutlierDetection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baseEjectionDuration
        case interval
        case maxEjectionPercent
        case maxServerErrors
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baseEjectionDuration = baseEjectionDuration {
            try encodeContainer.encode(baseEjectionDuration, forKey: .baseEjectionDuration)
        }
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let maxEjectionPercent = maxEjectionPercent {
            try encodeContainer.encode(maxEjectionPercent, forKey: .maxEjectionPercent)
        }
        if let maxServerErrors = maxServerErrors {
            try encodeContainer.encode(maxServerErrors, forKey: .maxServerErrors)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxServerErrorsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxServerErrors)
        maxServerErrors = maxServerErrorsDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .interval)
        interval = intervalDecoded
        let baseEjectionDurationDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .baseEjectionDuration)
        baseEjectionDuration = baseEjectionDurationDecoded
        let maxEjectionPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxEjectionPercent)
        maxEjectionPercent = maxEjectionPercentDecoded
    }
}

extension OutlierDetection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OutlierDetection(baseEjectionDuration: \(String(describing: baseEjectionDuration)), interval: \(String(describing: interval)), maxEjectionPercent: \(String(describing: maxEjectionPercent)), maxServerErrors: \(String(describing: maxServerErrors)))"}
}

/// <p>An object that represents the outlier detection for a virtual node's listener.</p>
public struct OutlierDetection: Equatable {
    /// <p>The base amount of time for which a host is ejected.</p>
    public let baseEjectionDuration: Duration?
    /// <p>The time interval between ejection sweep analysis.</p>
    public let interval: Duration?
    /// <p>Maximum percentage of hosts in load balancing pool for upstream service that can be
    ///          ejected. Will eject at least one host regardless of the value.</p>
    public let maxEjectionPercent: Int?
    /// <p>Number of consecutive <code>5xx</code> errors required for ejection. </p>
    public let maxServerErrors: Int?

    public init (
        baseEjectionDuration: Duration? = nil,
        interval: Duration? = nil,
        maxEjectionPercent: Int? = nil,
        maxServerErrors: Int? = nil
    )
    {
        self.baseEjectionDuration = baseEjectionDuration
        self.interval = interval
        self.maxEjectionPercent = maxEjectionPercent
        self.maxServerErrors = maxServerErrors
    }
}

extension PortMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(PortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension PortMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PortMapping(port: \(String(describing: port)), protocol: \(String(describing: `protocol`)))"}
}

/// <p>An object that represents a port mapping.</p>
public struct PortMapping: Equatable {
    /// <p>The protocol used for the port mapping. Specify one protocol.</p>
    public let `protocol`: PortProtocol?
    /// <p>The port used for the port mapping.</p>
    public let port: Int

    public init (
        `protocol`: PortProtocol? = nil,
        port: Int = 0
    )
    {
        self.`protocol` = `protocol`
        self.port = port
    }
}

public enum PortProtocol {
    case grpc
    case http
    case http2
    case tcp
    case sdkUnknown(String)
}

extension PortProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PortProtocol] {
        return [
            .grpc,
            .http,
            .http2,
            .tcp,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .grpc: return "grpc"
        case .http: return "http"
        case .http2: return "http2"
        case .tcp: return "tcp"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PortProtocol(rawValue: rawValue) ?? PortProtocol.sdkUnknown(rawValue)
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You can't delete the specified resource because it's in use or required by another
///          resource.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshOwner
        case resourceOwner
        case uid
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let uid = uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let uidDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uid)
        uid = uidDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
    }
}

extension ResourceMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceMetadata(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), uid: \(String(describing: uid)), version: \(String(describing: version)))"}
}

/// <p>An object that represents metadata for a resource.</p>
public struct ResourceMetadata: Equatable {
    /// <p>The full Amazon Resource Name (ARN) for the resource.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The unique identifier for the resource.</p>
    public let uid: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        uid: String? = nil,
        version: Int? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.uid = uid
        self.version = version
    }
}

extension RouteData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meshName
        case metadata
        case routeName
        case spec
        case status
        case virtualRouterName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let routeName = routeName {
            try encodeContainer.encode(routeName, forKey: .routeName)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualRouterName = virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let routeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeName)
        routeName = routeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(RouteSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RouteStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension RouteData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RouteData(meshName: \(String(describing: meshName)), metadata: \(String(describing: metadata)), routeName: \(String(describing: routeName)), spec: \(String(describing: spec)), status: \(String(describing: status)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

/// <p>An object that represents a route returned by a describe operation.</p>
public struct RouteData: Equatable {
    /// <p>The name of the service mesh that the route resides in.</p>
    public let meshName: String?
    /// <p>The associated metadata for the route.</p>
    public let metadata: ResourceMetadata?
    /// <p>The name of the route.</p>
    public let routeName: String?
    /// <p>The specifications of the route.</p>
    public let spec: RouteSpec?
    /// <p>The status of the route.</p>
    public let status: RouteStatus?
    /// <p>The virtual router that the route is associated with.</p>
    public let virtualRouterName: String?

    public init (
        meshName: String? = nil,
        metadata: ResourceMetadata? = nil,
        routeName: String? = nil,
        spec: RouteSpec? = nil,
        status: RouteStatus? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.meshName = meshName
        self.metadata = metadata
        self.routeName = routeName
        self.spec = spec
        self.status = status
        self.virtualRouterName = virtualRouterName
    }
}

extension RouteRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case routeName
        case version
        case virtualRouterName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let routeName = routeName {
            try encodeContainer.encode(routeName, forKey: .routeName)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualRouterName = virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let routeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .routeName)
        routeName = routeNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension RouteRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RouteRef(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), routeName: \(String(describing: routeName)), version: \(String(describing: version)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

/// <p>An object that represents a route returned by a list operation.</p>
public struct RouteRef: Equatable {
    /// <p>The full Amazon Resource Name (ARN) for the route.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the service mesh that the route resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The name of the route.</p>
    public let routeName: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?
    /// <p>The virtual router that the route is associated with.</p>
    public let virtualRouterName: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        routeName: String? = nil,
        version: Int? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.routeName = routeName
        self.version = version
        self.virtualRouterName = virtualRouterName
    }
}

extension RouteSpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grpcRoute
        case http2Route
        case httpRoute
        case priority
        case tcpRoute
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grpcRoute = grpcRoute {
            try encodeContainer.encode(grpcRoute, forKey: .grpcRoute)
        }
        if let http2Route = http2Route {
            try encodeContainer.encode(http2Route, forKey: .http2Route)
        }
        if let httpRoute = httpRoute {
            try encodeContainer.encode(httpRoute, forKey: .httpRoute)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let tcpRoute = tcpRoute {
            try encodeContainer.encode(tcpRoute, forKey: .tcpRoute)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let priorityDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .priority)
        priority = priorityDecoded
        let httpRouteDecoded = try containerValues.decodeIfPresent(HttpRoute.self, forKey: .httpRoute)
        httpRoute = httpRouteDecoded
        let tcpRouteDecoded = try containerValues.decodeIfPresent(TcpRoute.self, forKey: .tcpRoute)
        tcpRoute = tcpRouteDecoded
        let http2RouteDecoded = try containerValues.decodeIfPresent(HttpRoute.self, forKey: .http2Route)
        http2Route = http2RouteDecoded
        let grpcRouteDecoded = try containerValues.decodeIfPresent(GrpcRoute.self, forKey: .grpcRoute)
        grpcRoute = grpcRouteDecoded
    }
}

extension RouteSpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RouteSpec(grpcRoute: \(String(describing: grpcRoute)), http2Route: \(String(describing: http2Route)), httpRoute: \(String(describing: httpRoute)), priority: \(String(describing: priority)), tcpRoute: \(String(describing: tcpRoute)))"}
}

/// <p>An object that represents a route specification. Specify one route type.</p>
public struct RouteSpec: Equatable {
    /// <p>An object that represents the specification of a gRPC route.</p>
    public let grpcRoute: GrpcRoute?
    /// <p>An object that represents the specification of an HTTP/2 route.</p>
    public let http2Route: HttpRoute?
    /// <p>An object that represents the specification of an HTTP route.</p>
    public let httpRoute: HttpRoute?
    /// <p>The priority for the route. Routes are matched based on the specified value, where 0 is
    ///          the highest priority.</p>
    public let priority: Int?
    /// <p>An object that represents the specification of a TCP route.</p>
    public let tcpRoute: TcpRoute?

    public init (
        grpcRoute: GrpcRoute? = nil,
        http2Route: HttpRoute? = nil,
        httpRoute: HttpRoute? = nil,
        priority: Int? = nil,
        tcpRoute: TcpRoute? = nil
    )
    {
        self.grpcRoute = grpcRoute
        self.http2Route = http2Route
        self.httpRoute = httpRoute
        self.priority = priority
        self.tcpRoute = tcpRoute
    }
}

extension RouteStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(RouteStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension RouteStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RouteStatus(status: \(String(describing: status)))"}
}

/// <p>An object that represents the current status of a route.</p>
public struct RouteStatus: Equatable {
    /// <p>The current status for the route.</p>
    public let status: RouteStatusCode?

    public init (
        status: RouteStatusCode? = nil
    )
    {
        self.status = status
    }
}

public enum RouteStatusCode {
    case active
    case deleted
    case inactive
    case sdkUnknown(String)
}

extension RouteStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RouteStatusCode] {
        return [
            .active,
            .deleted,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RouteStatusCode(rawValue: rawValue) ?? RouteStatusCode.sdkUnknown(rawValue)
    }
}

extension ServiceDiscovery: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case awsCloudMap
        case dns
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .awsCloudMap(awsCloudMap):
                if let awsCloudMap = awsCloudMap {
                    try container.encode(awsCloudMap, forKey: .awsCloudMap)
                }
            case let .dns(dns):
                if let dns = dns {
                    try container.encode(dns, forKey: .dns)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let dnsDecoded = try values.decodeIfPresent(DnsServiceDiscovery.self, forKey: .dns)
        if let dns = dnsDecoded {
            self = .dns(dns)
            return
        }
        let awsCloudMapDecoded = try values.decodeIfPresent(AwsCloudMapServiceDiscovery.self, forKey: .awsCloudMap)
        if let awsCloudMap = awsCloudMapDecoded {
            self = .awsCloudMap(awsCloudMap)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the service discovery information for a virtual node.</p>
public enum ServiceDiscovery: Equatable {
    /// <p>Specifies the DNS information for the virtual node.</p>
    case dns(DnsServiceDiscovery?)
    /// <p>Specifies any AWS Cloud Map information for the virtual node.</p>
    case awsCloudMap(AwsCloudMapServiceDiscovery?)
    case sdkUnknown(String?)
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has failed due to a temporary failure of the service.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SubjectAlternativeNameMatchers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exact
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exact = exact {
            var exactContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exact)
            for subjectalternativenamelist0 in exact {
                try exactContainer.encode(subjectalternativenamelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exactContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exact)
        var exactDecoded0:[String]? = nil
        if let exactContainer = exactContainer {
            exactDecoded0 = [String]()
            for string0 in exactContainer {
                if let string0 = string0 {
                    exactDecoded0?.append(string0)
                }
            }
        }
        exact = exactDecoded0
    }
}

extension SubjectAlternativeNameMatchers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubjectAlternativeNameMatchers(exact: \(String(describing: exact)))"}
}

/// <p>An object that represents the methods by which a subject alternative name on a peer
///          Transport Layer Security (TLS) certificate can be matched.</p>
public struct SubjectAlternativeNameMatchers: Equatable {
    /// <p>The values sent must match the specified values exactly.</p>
    public let exact: [String]?

    public init (
        exact: [String]? = nil
    )
    {
        self.exact = exact
    }
}

extension SubjectAlternativeNames: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case match
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let match = match {
            try encodeContainer.encode(match, forKey: .match)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let matchDecoded = try containerValues.decodeIfPresent(SubjectAlternativeNameMatchers.self, forKey: .match)
        match = matchDecoded
    }
}

extension SubjectAlternativeNames: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubjectAlternativeNames(match: \(String(describing: match)))"}
}

/// <p>An object that represents the subject alternative names secured by the
///          certificate.</p>
public struct SubjectAlternativeNames: Equatable {
    /// <p>An object that represents the criteria for determining a SANs match.</p>
    public let match: SubjectAlternativeNameMatchers?

    public init (
        match: SubjectAlternativeNameMatchers? = nil
    )
    {
        self.match = match
    }
}

extension TagRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension TagRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagRef(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Optional metadata that you apply to a resource to assist with categorization and
///          organization. Each tag consists of a key and an optional value, both of which you define.
///          Tag keys can have a maximum character length of 128 characters, and tag values can have
///             a maximum length of 256 characters.</p>
public struct TagRef: Equatable {
    /// <p>One part of a key-value pair that make up a tag. A <code>key</code> is a general label
    ///          that acts like a category for more specific tag values.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that make up a tag. A <code>value</code> acts as a
    ///          descriptor within a tag category (key).</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

///
public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to add tags to.</p>
    public let resourceArn: String?
    /// <p>The tags to add to the resource. A tag is an array of key-value pairs.
    ///          Tag keys can have a maximum character length of 128 characters, and tag values can have
    ///             a maximum length of 256 characters.</p>
    public let tags: [TagRef]?

    public init (
        resourceArn: String? = nil,
        tags: [TagRef]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [TagRef]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([TagRef?].self, forKey: .tags)
        var tagsDecoded0:[TagRef]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [TagRef]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case tooManyTagsException(TooManyTagsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

///
public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum TcpRetryPolicyEvent {
    case connectionError
    case sdkUnknown(String)
}

extension TcpRetryPolicyEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TcpRetryPolicyEvent] {
        return [
            .connectionError,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .connectionError: return "connection-error"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TcpRetryPolicyEvent(rawValue: rawValue) ?? TcpRetryPolicyEvent.sdkUnknown(rawValue)
    }
}

extension TcpRoute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action
        case timeout
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(TcpRouteAction.self, forKey: .action)
        action = actionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(TcpTimeout.self, forKey: .timeout)
        timeout = timeoutDecoded
    }
}

extension TcpRoute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TcpRoute(action: \(String(describing: action)), timeout: \(String(describing: timeout)))"}
}

/// <p>An object that represents a TCP route type.</p>
public struct TcpRoute: Equatable {
    /// <p>The action to take if a match is determined.</p>
    public let action: TcpRouteAction?
    /// <p>An object that represents types of timeouts. </p>
    public let timeout: TcpTimeout?

    public init (
        action: TcpRouteAction? = nil,
        timeout: TcpTimeout? = nil
    )
    {
        self.action = action
        self.timeout = timeout
    }
}

extension TcpRouteAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case weightedTargets
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let weightedTargets = weightedTargets {
            var weightedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weightedTargets)
            for weightedtargets0 in weightedTargets {
                try weightedTargetsContainer.encode(weightedtargets0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let weightedTargetsContainer = try containerValues.decodeIfPresent([WeightedTarget?].self, forKey: .weightedTargets)
        var weightedTargetsDecoded0:[WeightedTarget]? = nil
        if let weightedTargetsContainer = weightedTargetsContainer {
            weightedTargetsDecoded0 = [WeightedTarget]()
            for structure0 in weightedTargetsContainer {
                if let structure0 = structure0 {
                    weightedTargetsDecoded0?.append(structure0)
                }
            }
        }
        weightedTargets = weightedTargetsDecoded0
    }
}

extension TcpRouteAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TcpRouteAction(weightedTargets: \(String(describing: weightedTargets)))"}
}

/// <p>An object that represents the action to take if a match is determined.</p>
public struct TcpRouteAction: Equatable {
    /// <p>An object that represents the targets that traffic is routed to when a request matches the route.</p>
    public let weightedTargets: [WeightedTarget]?

    public init (
        weightedTargets: [WeightedTarget]? = nil
    )
    {
        self.weightedTargets = weightedTargets
    }
}

extension TcpTimeout: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case idle
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let idle = idle {
            try encodeContainer.encode(idle, forKey: .idle)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idleDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .idle)
        idle = idleDecoded
    }
}

extension TcpTimeout: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TcpTimeout(idle: \(String(describing: idle)))"}
}

/// <p>An object that represents types of timeouts. </p>
public struct TcpTimeout: Equatable {
    /// <p>An object that represents an idle timeout. An idle timeout bounds the amount of time that a connection may be idle. The default value is none.</p>
    public let idle: Duration?

    public init (
        idle: Duration? = nil
    )
    {
        self.idle = idle
    }
}

extension TlsValidationContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(TlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension TlsValidationContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsValidationContext(subjectAlternativeNames: \(String(describing: subjectAlternativeNames)), trust: \(String(describing: trust)))"}
}

/// <p>An object that represents how the proxy will validate its peer during Transport Layer Security (TLS)
///          negotiation.</p>
public struct TlsValidationContext: Equatable {
    /// <p>A reference to an object that represents the SANs for a Transport Layer Security (TLS) validation context.</p>
    public let subjectAlternativeNames: SubjectAlternativeNames?
    /// <p>A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS)
    ///          certificate.</p>
    public let trust: TlsValidationContextTrust?

    public init (
        subjectAlternativeNames: SubjectAlternativeNames? = nil,
        trust: TlsValidationContextTrust? = nil
    )
    {
        self.subjectAlternativeNames = subjectAlternativeNames
        self.trust = trust
    }
}

extension TlsValidationContextAcmTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArns = certificateAuthorityArns {
            var certificateAuthorityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateAuthorityArns)
            for certificateauthorityarns0 in certificateAuthorityArns {
                try certificateAuthorityArnsContainer.encode(certificateauthorityarns0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .certificateAuthorityArns)
        var certificateAuthorityArnsDecoded0:[String]? = nil
        if let certificateAuthorityArnsContainer = certificateAuthorityArnsContainer {
            certificateAuthorityArnsDecoded0 = [String]()
            for string0 in certificateAuthorityArnsContainer {
                if let string0 = string0 {
                    certificateAuthorityArnsDecoded0?.append(string0)
                }
            }
        }
        certificateAuthorityArns = certificateAuthorityArnsDecoded0
    }
}

extension TlsValidationContextAcmTrust: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsValidationContextAcmTrust(certificateAuthorityArns: \(String(describing: certificateAuthorityArns)))"}
}

/// <p>An object that represents a Transport Layer Security (TLS) validation context trust for an AWS Certicate Manager (ACM)
///          certificate.</p>
public struct TlsValidationContextAcmTrust: Equatable {
    /// <p>One or more ACM Amazon Resource Name (ARN)s.</p>
    public let certificateAuthorityArns: [String]?

    public init (
        certificateAuthorityArns: [String]? = nil
    )
    {
        self.certificateAuthorityArns = certificateAuthorityArns
    }
}

extension TlsValidationContextFileTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateChain
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

extension TlsValidationContextFileTrust: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsValidationContextFileTrust(certificateChain: \(String(describing: certificateChain)))"}
}

/// <p>An object that represents a Transport Layer Security (TLS) validation context trust for a local file.</p>
public struct TlsValidationContextFileTrust: Equatable {
    /// <p>The certificate trust chain for a certificate stored on the file system of the virtual
    ///          node that the proxy is running on.</p>
    public let certificateChain: String?

    public init (
        certificateChain: String? = nil
    )
    {
        self.certificateChain = certificateChain
    }
}

extension TlsValidationContextSdsTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension TlsValidationContextSdsTrust: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TlsValidationContextSdsTrust(secretName: \(String(describing: secretName)))"}
}

/// <p>An object that represents a Transport Layer Security (TLS) Secret Discovery Service validation context trust. The
///          proxy must be configured with a local SDS provider via a Unix Domain Socket. See App Mesh
///             <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS
///             documentation</a> for more info.</p>
public struct TlsValidationContextSdsTrust: Equatable {
    /// <p>A reference to an object that represents the name of the secret for a Transport Layer Security (TLS) Secret
    ///          Discovery Service validation context trust.</p>
    public let secretName: String?

    public init (
        secretName: String? = nil
    )
    {
        self.secretName = secretName
    }
}

extension TlsValidationContextTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                if let acm = acm {
                    try container.encode(acm, forKey: .acm)
                }
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(TlsValidationContextAcmTrust.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(TlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(TlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents a Transport Layer Security (TLS) validation context trust.</p>
public enum TlsValidationContextTrust: Equatable {
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an
    ///          AWS Certicate Manager (ACM) certificate.</p>
    case acm(TlsValidationContextAcmTrust?)
    /// <p>An object that represents a Transport Layer Security (TLS) validation context trust for a local file.</p>
    case file(TlsValidationContextFileTrust?)
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) Secret Discovery Service validation
    ///          context trust.</p>
    case sds(TlsValidationContextSdsTrust?)
    case sdkUnknown(String?)
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The maximum request rate permitted by the App Mesh APIs has been exceeded for your
///          account. For best results, use an increasing or variable sleep interval between
///          requests.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = true
    public var _isThrottling: Bool = true
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request exceeds the maximum allowed number of tags allowed per resource. The current
///          limit is 50 user tags per resource. You must reduce the number of tags in the request. None
///          of the tags in this request were applied.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagKeys
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

///
public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource to delete tags from.</p>
    public let resourceArn: String?
    /// <p>The keys of the tags to be removed.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagKeys
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

///
public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateGatewayRouteInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGatewayRouteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayRouteInput>
    public typealias MOutput = OperationOutput<UpdateGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayRouteOutputError>
}

extension UpdateGatewayRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayRouteInput(clientToken: \(String(describing: clientToken)), gatewayRouteName: \(String(describing: gatewayRouteName)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension UpdateGatewayRouteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateGatewayRouteInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGatewayRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayRouteInput>
    public typealias MOutput = OperationOutput<UpdateGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayRouteOutputError>
}

public struct UpdateGatewayRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGatewayRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGatewayRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGatewayRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGatewayRouteInput>
    public typealias MOutput = OperationOutput<UpdateGatewayRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGatewayRouteOutputError>
}

public struct UpdateGatewayRouteInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the gateway route to update.</p>
    public let gatewayRouteName: String?
    /// <p>The name of the service mesh that the gateway route resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The new gateway route specification to apply. This overwrites the existing data.</p>
    public let spec: GatewayRouteSpec?
    /// <p>The name of the virtual gateway that the gateway route is associated with.</p>
    public let virtualGatewayName: String?

    public init (
        clientToken: String? = nil,
        gatewayRouteName: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: GatewayRouteSpec? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.gatewayRouteName = gatewayRouteName
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualGatewayName = virtualGatewayName
    }
}

struct UpdateGatewayRouteInputBody: Equatable {
    public let spec: GatewayRouteSpec?
    public let clientToken: String?
}

extension UpdateGatewayRouteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(GatewayRouteSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateGatewayRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGatewayRouteOutputResponse(gatewayRoute: \(String(describing: gatewayRoute)))"}
}

extension UpdateGatewayRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: GatewayRouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.gatewayRoute = output
            } else {
                self.gatewayRoute = nil
            }
        } else {
            self.gatewayRoute = nil
        }
    }
}

public struct UpdateGatewayRouteOutputResponse: Equatable {
    /// <p>A full description of the gateway route that was updated.</p>
    public let gatewayRoute: GatewayRouteData?

    public init (
        gatewayRoute: GatewayRouteData? = nil
    )
    {
        self.gatewayRoute = gatewayRoute
    }
}

struct UpdateGatewayRouteOutputResponseBody: Equatable {
    public let gatewayRoute: GatewayRouteData?
}

extension UpdateGatewayRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gatewayRoute
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayRouteDecoded = try containerValues.decodeIfPresent(GatewayRouteData.self, forKey: .gatewayRoute)
        gatewayRoute = gatewayRouteDecoded
    }
}

public struct UpdateMeshInputBodyMiddleware: Middleware {
    public let id: String = "UpdateMeshInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMeshInput>
    public typealias MOutput = OperationOutput<UpdateMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMeshOutputError>
}

extension UpdateMeshInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMeshInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), spec: \(String(describing: spec)))"}
}

extension UpdateMeshInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateMeshInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateMeshInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMeshInput>
    public typealias MOutput = OperationOutput<UpdateMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMeshOutputError>
}

public struct UpdateMeshInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateMeshInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateMeshInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateMeshOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateMeshInput>
    public typealias MOutput = OperationOutput<UpdateMeshOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateMeshOutputError>
}

///
public struct UpdateMeshInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh to update.</p>
    public let meshName: String?
    /// <p>The service mesh specification to apply.</p>
    public let spec: MeshSpec?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        spec: MeshSpec? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.spec = spec
    }
}

struct UpdateMeshInputBody: Equatable {
    public let spec: MeshSpec?
    public let clientToken: String?
}

extension UpdateMeshInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(MeshSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateMeshOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMeshOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateMeshOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMeshOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateMeshOutputResponse(mesh: \(String(describing: mesh)))"}
}

extension UpdateMeshOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MeshData = try responseDecoder.decode(responseBody: unwrappedData)
                self.mesh = output
            } else {
                self.mesh = nil
            }
        } else {
            self.mesh = nil
        }
    }
}

///
public struct UpdateMeshOutputResponse: Equatable {
    /// <p>An object that represents a service mesh returned by a describe operation.</p>
    public let mesh: MeshData?

    public init (
        mesh: MeshData? = nil
    )
    {
        self.mesh = mesh
    }
}

struct UpdateMeshOutputResponseBody: Equatable {
    public let mesh: MeshData?
}

extension UpdateMeshOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case mesh
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshDecoded = try containerValues.decodeIfPresent(MeshData.self, forKey: .mesh)
        mesh = meshDecoded
    }
}

public struct UpdateRouteInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRouteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteInput>
    public typealias MOutput = OperationOutput<UpdateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteOutputError>
}

extension UpdateRouteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRouteInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), routeName: \(String(describing: routeName)), spec: \(String(describing: spec)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension UpdateRouteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateRouteInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRouteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteInput>
    public typealias MOutput = OperationOutput<UpdateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteOutputError>
}

public struct UpdateRouteInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRouteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRouteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRouteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRouteInput>
    public typealias MOutput = OperationOutput<UpdateRouteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRouteOutputError>
}

///
public struct UpdateRouteInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh that the route resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The name of the route to update.</p>
    public let routeName: String?
    /// <p>The new route specification to apply. This overwrites the existing data.</p>
    public let spec: RouteSpec?
    /// <p>The name of the virtual router that the route is associated with.</p>
    public let virtualRouterName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        routeName: String? = nil,
        spec: RouteSpec? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.routeName = routeName
        self.spec = spec
        self.virtualRouterName = virtualRouterName
    }
}

struct UpdateRouteInputBody: Equatable {
    public let spec: RouteSpec?
    public let clientToken: String?
}

extension UpdateRouteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(RouteSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateRouteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRouteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRouteOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRouteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRouteOutputResponse(route: \(String(describing: route)))"}
}

extension UpdateRouteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RouteData = try responseDecoder.decode(responseBody: unwrappedData)
                self.route = output
            } else {
                self.route = nil
            }
        } else {
            self.route = nil
        }
    }
}

///
public struct UpdateRouteOutputResponse: Equatable {
    /// <p>A full description of the route that was updated.</p>
    public let route: RouteData?

    public init (
        route: RouteData? = nil
    )
    {
        self.route = route
    }
}

struct UpdateRouteOutputResponseBody: Equatable {
    public let route: RouteData?
}

extension UpdateRouteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case route
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let routeDecoded = try containerValues.decodeIfPresent(RouteData.self, forKey: .route)
        route = routeDecoded
    }
}

public struct UpdateVirtualGatewayInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVirtualGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualGatewayInput>
    public typealias MOutput = OperationOutput<UpdateVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualGatewayOutputError>
}

extension UpdateVirtualGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualGatewayInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

extension UpdateVirtualGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateVirtualGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVirtualGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualGatewayInput>
    public typealias MOutput = OperationOutput<UpdateVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualGatewayOutputError>
}

public struct UpdateVirtualGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVirtualGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualGatewayInput>
    public typealias MOutput = OperationOutput<UpdateVirtualGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualGatewayOutputError>
}

public struct UpdateVirtualGatewayInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh that the virtual gateway resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The new virtual gateway specification to apply. This overwrites the existing
    ///          data.</p>
    public let spec: VirtualGatewaySpec?
    /// <p>The name of the virtual gateway to update.</p>
    public let virtualGatewayName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualGatewaySpec? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualGatewayName = virtualGatewayName
    }
}

struct UpdateVirtualGatewayInputBody: Equatable {
    public let spec: VirtualGatewaySpec?
    public let clientToken: String?
}

extension UpdateVirtualGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(VirtualGatewaySpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVirtualGatewayOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualGatewayOutputResponse(virtualGateway: \(String(describing: virtualGateway)))"}
}

extension UpdateVirtualGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualGatewayData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualGateway = output
            } else {
                self.virtualGateway = nil
            }
        } else {
            self.virtualGateway = nil
        }
    }
}

public struct UpdateVirtualGatewayOutputResponse: Equatable {
    /// <p>A full description of the virtual gateway that was updated.</p>
    public let virtualGateway: VirtualGatewayData?

    public init (
        virtualGateway: VirtualGatewayData? = nil
    )
    {
        self.virtualGateway = virtualGateway
    }
}

struct UpdateVirtualGatewayOutputResponseBody: Equatable {
    public let virtualGateway: VirtualGatewayData?
}

extension UpdateVirtualGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualGateway
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualGatewayDecoded = try containerValues.decodeIfPresent(VirtualGatewayData.self, forKey: .virtualGateway)
        virtualGateway = virtualGatewayDecoded
    }
}

public struct UpdateVirtualNodeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVirtualNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualNodeInput>
    public typealias MOutput = OperationOutput<UpdateVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualNodeOutputError>
}

extension UpdateVirtualNodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualNodeInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), virtualNodeName: \(String(describing: virtualNodeName)))"}
}

extension UpdateVirtualNodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateVirtualNodeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVirtualNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualNodeInput>
    public typealias MOutput = OperationOutput<UpdateVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualNodeOutputError>
}

public struct UpdateVirtualNodeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVirtualNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualNodeInput>
    public typealias MOutput = OperationOutput<UpdateVirtualNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualNodeOutputError>
}

///
public struct UpdateVirtualNodeInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh that the virtual node resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The new virtual node specification to apply. This overwrites the existing data.</p>
    public let spec: VirtualNodeSpec?
    /// <p>The name of the virtual node to update.</p>
    public let virtualNodeName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualNodeSpec? = nil,
        virtualNodeName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualNodeName = virtualNodeName
    }
}

struct UpdateVirtualNodeInputBody: Equatable {
    public let spec: VirtualNodeSpec?
    public let clientToken: String?
}

extension UpdateVirtualNodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(VirtualNodeSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualNodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualNodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVirtualNodeOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualNodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualNodeOutputResponse(virtualNode: \(String(describing: virtualNode)))"}
}

extension UpdateVirtualNodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualNodeData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualNode = output
            } else {
                self.virtualNode = nil
            }
        } else {
            self.virtualNode = nil
        }
    }
}

///
public struct UpdateVirtualNodeOutputResponse: Equatable {
    /// <p>A full description of the virtual node that was updated.</p>
    public let virtualNode: VirtualNodeData?

    public init (
        virtualNode: VirtualNodeData? = nil
    )
    {
        self.virtualNode = virtualNode
    }
}

struct UpdateVirtualNodeOutputResponseBody: Equatable {
    public let virtualNode: VirtualNodeData?
}

extension UpdateVirtualNodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualNode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(VirtualNodeData.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
    }
}

public struct UpdateVirtualRouterInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVirtualRouterInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualRouterInput>
    public typealias MOutput = OperationOutput<UpdateVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualRouterOutputError>
}

extension UpdateVirtualRouterInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualRouterInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

extension UpdateVirtualRouterInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateVirtualRouterInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVirtualRouterInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualRouterInput>
    public typealias MOutput = OperationOutput<UpdateVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualRouterOutputError>
}

public struct UpdateVirtualRouterInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVirtualRouterInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualRouterInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualRouterOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualRouterInput>
    public typealias MOutput = OperationOutput<UpdateVirtualRouterOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualRouterOutputError>
}

///
public struct UpdateVirtualRouterInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh that the virtual router resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The new virtual router specification to apply. This overwrites the existing data.</p>
    public let spec: VirtualRouterSpec?
    /// <p>The name of the virtual router to update.</p>
    public let virtualRouterName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualRouterSpec? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualRouterName = virtualRouterName
    }
}

struct UpdateVirtualRouterInputBody: Equatable {
    public let spec: VirtualRouterSpec?
    public let clientToken: String?
}

extension UpdateVirtualRouterInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(VirtualRouterSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualRouterOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualRouterOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVirtualRouterOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualRouterOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualRouterOutputResponse(virtualRouter: \(String(describing: virtualRouter)))"}
}

extension UpdateVirtualRouterOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualRouterData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualRouter = output
            } else {
                self.virtualRouter = nil
            }
        } else {
            self.virtualRouter = nil
        }
    }
}

///
public struct UpdateVirtualRouterOutputResponse: Equatable {
    /// <p>A full description of the virtual router that was updated.</p>
    public let virtualRouter: VirtualRouterData?

    public init (
        virtualRouter: VirtualRouterData? = nil
    )
    {
        self.virtualRouter = virtualRouter
    }
}

struct UpdateVirtualRouterOutputResponseBody: Equatable {
    public let virtualRouter: VirtualRouterData?
}

extension UpdateVirtualRouterOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualRouter
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterDecoded = try containerValues.decodeIfPresent(VirtualRouterData.self, forKey: .virtualRouter)
        virtualRouter = virtualRouterDecoded
    }
}

public struct UpdateVirtualServiceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVirtualServiceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualServiceInput>
    public typealias MOutput = OperationOutput<UpdateVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualServiceOutputError>
}

extension UpdateVirtualServiceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualServiceInput(clientToken: \(String(describing: clientToken)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), spec: \(String(describing: spec)), virtualServiceName: \(String(describing: virtualServiceName)))"}
}

extension UpdateVirtualServiceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
    }
}

public struct UpdateVirtualServiceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVirtualServiceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualServiceInput>
    public typealias MOutput = OperationOutput<UpdateVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualServiceOutputError>
}

public struct UpdateVirtualServiceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVirtualServiceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVirtualServiceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVirtualServiceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let meshOwner = input.operationInput.meshOwner {
            let meshOwnerQueryItem = URLQueryItem(name: "meshOwner".urlPercentEncoding(), value: String(meshOwner).urlPercentEncoding())
            input.builder.withQueryItem(meshOwnerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVirtualServiceInput>
    public typealias MOutput = OperationOutput<UpdateVirtualServiceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVirtualServiceOutputError>
}

///
public struct UpdateVirtualServiceInput: Equatable {
    /// <p>Unique, case-sensitive identifier that you provide to ensure the idempotency of the
    /// request. Up to 36 letters, numbers, hyphens, and underscores are allowed.</p>
    public var clientToken: String?
    /// <p>The name of the service mesh that the virtual service resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The new virtual service specification to apply. This overwrites the existing
    ///          data.</p>
    public let spec: VirtualServiceSpec?
    /// <p>The name of the virtual service to update.</p>
    public let virtualServiceName: String?

    public init (
        clientToken: String? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        spec: VirtualServiceSpec? = nil,
        virtualServiceName: String? = nil
    )
    {
        self.clientToken = clientToken
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.spec = spec
        self.virtualServiceName = virtualServiceName
    }
}

struct UpdateVirtualServiceInputBody: Equatable {
    public let spec: VirtualServiceSpec?
    public let clientToken: String?
}

extension UpdateVirtualServiceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case spec
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let specDecoded = try containerValues.decodeIfPresent(VirtualServiceSpec.self, forKey: .spec)
        spec = specDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateVirtualServiceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVirtualServiceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVirtualServiceOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVirtualServiceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVirtualServiceOutputResponse(virtualService: \(String(describing: virtualService)))"}
}

extension UpdateVirtualServiceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VirtualServiceData = try responseDecoder.decode(responseBody: unwrappedData)
                self.virtualService = output
            } else {
                self.virtualService = nil
            }
        } else {
            self.virtualService = nil
        }
    }
}

///
public struct UpdateVirtualServiceOutputResponse: Equatable {
    /// <p>A full description of the virtual service that was updated.</p>
    public let virtualService: VirtualServiceData?

    public init (
        virtualService: VirtualServiceData? = nil
    )
    {
        self.virtualService = virtualService
    }
}

struct UpdateVirtualServiceOutputResponseBody: Equatable {
    public let virtualService: VirtualServiceData?
}

extension UpdateVirtualServiceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case virtualService
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceDecoded = try containerValues.decodeIfPresent(VirtualServiceData.self, forKey: .virtualService)
        virtualService = virtualServiceDecoded
    }
}

extension VirtualGatewayAccessLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(VirtualGatewayFileAccessLog.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The access log configuration for a virtual gateway.</p>
public enum VirtualGatewayAccessLog: Equatable {
    /// <p>The file object to send virtual gateway access logs to.</p>
    case file(VirtualGatewayFileAccessLog?)
    case sdkUnknown(String?)
}

extension VirtualGatewayBackendDefaults: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientPolicy
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientPolicy = clientPolicy {
            try encodeContainer.encode(clientPolicy, forKey: .clientPolicy)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientPolicyDecoded = try containerValues.decodeIfPresent(VirtualGatewayClientPolicy.self, forKey: .clientPolicy)
        clientPolicy = clientPolicyDecoded
    }
}

extension VirtualGatewayBackendDefaults: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayBackendDefaults(clientPolicy: \(String(describing: clientPolicy)))"}
}

/// <p>An object that represents the default properties for a backend.</p>
public struct VirtualGatewayBackendDefaults: Equatable {
    /// <p>A reference to an object that represents a client policy.</p>
    public let clientPolicy: VirtualGatewayClientPolicy?

    public init (
        clientPolicy: VirtualGatewayClientPolicy? = nil
    )
    {
        self.clientPolicy = clientPolicy
    }
}

extension VirtualGatewayClientPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tls
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tls = tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tlsDecoded = try containerValues.decodeIfPresent(VirtualGatewayClientPolicyTls.self, forKey: .tls)
        tls = tlsDecoded
    }
}

extension VirtualGatewayClientPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayClientPolicy(tls: \(String(describing: tls)))"}
}

/// <p>An object that represents a client policy.</p>
public struct VirtualGatewayClientPolicy: Equatable {
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) client policy.</p>
    public let tls: VirtualGatewayClientPolicyTls?

    public init (
        tls: VirtualGatewayClientPolicyTls? = nil
    )
    {
        self.tls = tls
    }
}

extension VirtualGatewayClientPolicyTls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate
        case enforce
        case ports
        case validation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let enforce = enforce {
            try encodeContainer.encode(enforce, forKey: .enforce)
        }
        if let ports = ports {
            var portsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ports)
            for portset0 in ports {
                try portsContainer.encode(portset0)
            }
        }
        if let validation = validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enforceDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enforce)
        enforce = enforceDecoded
        let portsContainer = try containerValues.decodeIfPresent(Set<Int>.self, forKey: .ports)
        var portsDecoded0:Set<Int>? = nil
        if let portsContainer = portsContainer {
            portsDecoded0 = Set<Int>()
            for integer0 in portsContainer {
                portsDecoded0?.insert(integer0)
            }
        }
        ports = portsDecoded0
        let certificateDecoded = try containerValues.decodeIfPresent(VirtualGatewayClientTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
        let validationDecoded = try containerValues.decodeIfPresent(VirtualGatewayTlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
    }
}

extension VirtualGatewayClientPolicyTls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayClientPolicyTls(certificate: \(String(describing: certificate)), enforce: \(String(describing: enforce)), ports: \(String(describing: ports)), validation: \(String(describing: validation)))"}
}

/// <p>An object that represents a Transport Layer Security (TLS) client policy.</p>
public struct VirtualGatewayClientPolicyTls: Equatable {
    /// <p>A reference to an object that represents a virtual gateway's client's Transport Layer Security (TLS)
    ///          certificate.</p>
    public let certificate: VirtualGatewayClientTlsCertificate?
    /// <p>Whether the policy is enforced. The default is <code>True</code>, if a value isn't
    ///          specified.</p>
    public let enforce: Bool?
    /// <p>One or more ports that the policy is enforced for.</p>
    public let ports: Set<Int>?
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) validation context.</p>
    public let validation: VirtualGatewayTlsValidationContext?

    public init (
        certificate: VirtualGatewayClientTlsCertificate? = nil,
        enforce: Bool? = nil,
        ports: Set<Int>? = nil,
        validation: VirtualGatewayTlsValidationContext? = nil
    )
    {
        self.certificate = certificate
        self.enforce = enforce
        self.ports = ports
        self.validation = validation
    }
}

extension VirtualGatewayClientTlsCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(VirtualGatewayListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(VirtualGatewayListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the virtual gateway's client's Transport Layer Security (TLS) certificate.</p>
public enum VirtualGatewayClientTlsCertificate: Equatable {
    /// <p>An object that represents a local file certificate.
    ///          The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.</p>
    case file(VirtualGatewayListenerTlsFileCertificate?)
    /// <p>A reference to an object that represents a virtual gateway's client's Secret Discovery
    ///          Service certificate.</p>
    case sds(VirtualGatewayListenerTlsSdsCertificate?)
    case sdkUnknown(String?)
}

extension VirtualGatewayConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grpc
        case http
        case http2
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .grpc(grpc):
                if let grpc = grpc {
                    try container.encode(grpc, forKey: .grpc)
                }
            case let .http(http):
                if let http = http {
                    try container.encode(http, forKey: .http)
                }
            case let .http2(http2):
                if let http2 = http2 {
                    try container.encode(http2, forKey: .http2)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let httpDecoded = try values.decodeIfPresent(VirtualGatewayHttpConnectionPool.self, forKey: .http)
        if let http = httpDecoded {
            self = .http(http)
            return
        }
        let http2Decoded = try values.decodeIfPresent(VirtualGatewayHttp2ConnectionPool.self, forKey: .http2)
        if let http2 = http2Decoded {
            self = .http2(http2)
            return
        }
        let grpcDecoded = try values.decodeIfPresent(VirtualGatewayGrpcConnectionPool.self, forKey: .grpc)
        if let grpc = grpcDecoded {
            self = .grpc(grpc)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the type of virtual gateway connection pool.</p>
///          <p>Only one protocol is used at a time and should be the same protocol as the one chosen
///          under port mapping.</p>
///          <p>If not present the default value for <code>maxPendingRequests</code> is
///             <code>2147483647</code>.</p>
public enum VirtualGatewayConnectionPool: Equatable {
    /// <p>An object that represents a type of connection pool.</p>
    case http(VirtualGatewayHttpConnectionPool?)
    /// <p>An object that represents a type of connection pool.</p>
    case http2(VirtualGatewayHttp2ConnectionPool?)
    /// <p>An object that represents a type of connection pool. </p>
    case grpc(VirtualGatewayGrpcConnectionPool?)
    case sdkUnknown(String?)
}

extension VirtualGatewayData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualGatewayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualGatewayName = virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualGatewaySpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VirtualGatewayStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualGatewayData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayData(meshName: \(String(describing: meshName)), metadata: \(String(describing: metadata)), spec: \(String(describing: spec)), status: \(String(describing: status)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

/// <p>An object that represents a virtual gateway returned by a describe operation.</p>
public struct VirtualGatewayData: Equatable {
    /// <p>The name of the service mesh that the virtual gateway resides in.</p>
    public let meshName: String?
    /// <p>An object that represents metadata for a resource.</p>
    public let metadata: ResourceMetadata?
    /// <p>The specifications of the virtual gateway.</p>
    public let spec: VirtualGatewaySpec?
    /// <p>The current status of the virtual gateway.</p>
    public let status: VirtualGatewayStatus?
    /// <p>The name of the virtual gateway.</p>
    public let virtualGatewayName: String?

    public init (
        meshName: String? = nil,
        metadata: ResourceMetadata? = nil,
        spec: VirtualGatewaySpec? = nil,
        status: VirtualGatewayStatus? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.meshName = meshName
        self.metadata = metadata
        self.spec = spec
        self.status = status
        self.virtualGatewayName = virtualGatewayName
    }
}

extension VirtualGatewayFileAccessLog: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case path
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
    }
}

extension VirtualGatewayFileAccessLog: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayFileAccessLog(path: \(String(describing: path)))"}
}

/// <p>An object that represents an access log file.</p>
public struct VirtualGatewayFileAccessLog: Equatable {
    /// <p>The file path to write access logs to. You can use <code>/dev/stdout</code> to send
    ///          access logs to standard out and configure your Envoy container to use a log driver, such as
    ///             <code>awslogs</code>, to export the access logs to a log storage service such as Amazon
    ///          CloudWatch Logs. You can also specify a path in the Envoy container's file system to write
    ///          the files to disk.</p>
    public let path: String?

    public init (
        path: String? = nil
    )
    {
        self.path = path
    }
}

extension VirtualGatewayGrpcConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decode(Int.self, forKey: .maxRequests)
        maxRequests = maxRequestsDecoded
    }
}

extension VirtualGatewayGrpcConnectionPool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayGrpcConnectionPool(maxRequests: \(String(describing: maxRequests)))"}
}

/// <p>An object that represents a type of connection pool.</p>
public struct VirtualGatewayGrpcConnectionPool: Equatable {
    /// <p>Maximum number of inflight requests Envoy can concurrently support across hosts in
    ///          upstream cluster.</p>
    public let maxRequests: Int

    public init (
        maxRequests: Int = 0
    )
    {
        self.maxRequests = maxRequests
    }
}

extension VirtualGatewayHealthCheckPolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case healthyThreshold
        case intervalMillis
        case path
        case port
        case `protocol` = "protocol"
        case timeoutMillis
        case unhealthyThreshold
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if healthyThreshold != 0 {
            try encodeContainer.encode(healthyThreshold, forKey: .healthyThreshold)
        }
        if let intervalMillis = intervalMillis {
            try encodeContainer.encode(intervalMillis, forKey: .intervalMillis)
        }
        if let path = path {
            try encodeContainer.encode(path, forKey: .path)
        }
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let timeoutMillis = timeoutMillis {
            try encodeContainer.encode(timeoutMillis, forKey: .timeoutMillis)
        }
        if unhealthyThreshold != 0 {
            try encodeContainer.encode(unhealthyThreshold, forKey: .unhealthyThreshold)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeoutMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeoutMillis)
        timeoutMillis = timeoutMillisDecoded
        let intervalMillisDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .intervalMillis)
        intervalMillis = intervalMillisDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VirtualGatewayPortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let pathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .path)
        path = pathDecoded
        let healthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .healthyThreshold)
        healthyThreshold = healthyThresholdDecoded
        let unhealthyThresholdDecoded = try containerValues.decode(Int.self, forKey: .unhealthyThreshold)
        unhealthyThreshold = unhealthyThresholdDecoded
    }
}

extension VirtualGatewayHealthCheckPolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayHealthCheckPolicy(healthyThreshold: \(String(describing: healthyThreshold)), intervalMillis: \(String(describing: intervalMillis)), path: \(String(describing: path)), port: \(String(describing: port)), protocol: \(String(describing: `protocol`)), timeoutMillis: \(String(describing: timeoutMillis)), unhealthyThreshold: \(String(describing: unhealthyThreshold)))"}
}

/// <p>An object that represents the health check policy for a virtual gateway's
///          listener.</p>
public struct VirtualGatewayHealthCheckPolicy: Equatable {
    /// <p>The protocol for the health check request. If you specify <code>grpc</code>, then your
    ///          service must conform to the <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md">GRPC Health
    ///             Checking Protocol</a>.</p>
    public let `protocol`: VirtualGatewayPortProtocol?
    /// <p>The number of consecutive successful health checks that must occur before declaring the
    ///          listener healthy.</p>
    public let healthyThreshold: Int
    /// <p>The time period in milliseconds between each health check execution.</p>
    public let intervalMillis: Int?
    /// <p>The destination path for the health check request. This value is only used if the
    ///          specified protocol is HTTP or HTTP/2. For any other protocol, this value is ignored.</p>
    public let path: String?
    /// <p>The destination port for the health check request. This port must match the port defined
    ///          in the <a>PortMapping</a> for the listener.</p>
    public let port: Int
    /// <p>The amount of time to wait when receiving a response from the health check, in
    ///          milliseconds.</p>
    public let timeoutMillis: Int?
    /// <p>The number of consecutive failed health checks that must occur before declaring a
    ///          virtual gateway unhealthy.</p>
    public let unhealthyThreshold: Int

    public init (
        `protocol`: VirtualGatewayPortProtocol? = nil,
        healthyThreshold: Int = 0,
        intervalMillis: Int? = nil,
        path: String? = nil,
        port: Int = 0,
        timeoutMillis: Int? = nil,
        unhealthyThreshold: Int = 0
    )
    {
        self.`protocol` = `protocol`
        self.healthyThreshold = healthyThreshold
        self.intervalMillis = intervalMillis
        self.path = path
        self.port = port
        self.timeoutMillis = timeoutMillis
        self.unhealthyThreshold = unhealthyThreshold
    }
}

extension VirtualGatewayHttp2ConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decode(Int.self, forKey: .maxRequests)
        maxRequests = maxRequestsDecoded
    }
}

extension VirtualGatewayHttp2ConnectionPool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayHttp2ConnectionPool(maxRequests: \(String(describing: maxRequests)))"}
}

/// <p>An object that represents a type of connection pool.</p>
public struct VirtualGatewayHttp2ConnectionPool: Equatable {
    /// <p>Maximum number of inflight requests Envoy can concurrently support across hosts in
    ///          upstream cluster.</p>
    public let maxRequests: Int

    public init (
        maxRequests: Int = 0
    )
    {
        self.maxRequests = maxRequests
    }
}

extension VirtualGatewayHttpConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxConnections
        case maxPendingRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
        if maxPendingRequests != 0 {
            try encodeContainer.encode(maxPendingRequests, forKey: .maxPendingRequests)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsDecoded = try containerValues.decode(Int.self, forKey: .maxConnections)
        maxConnections = maxConnectionsDecoded
        let maxPendingRequestsDecoded = try containerValues.decode(Int.self, forKey: .maxPendingRequests)
        maxPendingRequests = maxPendingRequestsDecoded
    }
}

extension VirtualGatewayHttpConnectionPool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayHttpConnectionPool(maxConnections: \(String(describing: maxConnections)), maxPendingRequests: \(String(describing: maxPendingRequests)))"}
}

/// <p>An object that represents a type of connection pool.</p>
public struct VirtualGatewayHttpConnectionPool: Equatable {
    /// <p>Maximum number of outbound TCP connections Envoy can establish concurrently with all
    ///          hosts in upstream cluster.</p>
    public let maxConnections: Int
    /// <p>Number of overflowing requests after <code>max_connections</code> Envoy will queue to
    ///          upstream cluster.</p>
    public let maxPendingRequests: Int

    public init (
        maxConnections: Int = 0,
        maxPendingRequests: Int = 0
    )
    {
        self.maxConnections = maxConnections
        self.maxPendingRequests = maxPendingRequests
    }
}

extension VirtualGatewayListener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectionPool
        case healthCheck
        case portMapping
        case tls
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionPool = connectionPool {
            try encodeContainer.encode(connectionPool, forKey: .connectionPool)
        }
        if let healthCheck = healthCheck {
            try encodeContainer.encode(healthCheck, forKey: .healthCheck)
        }
        if let portMapping = portMapping {
            try encodeContainer.encode(portMapping, forKey: .portMapping)
        }
        if let tls = tls {
            try encodeContainer.encode(tls, forKey: .tls)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthCheckDecoded = try containerValues.decodeIfPresent(VirtualGatewayHealthCheckPolicy.self, forKey: .healthCheck)
        healthCheck = healthCheckDecoded
        let portMappingDecoded = try containerValues.decodeIfPresent(VirtualGatewayPortMapping.self, forKey: .portMapping)
        portMapping = portMappingDecoded
        let tlsDecoded = try containerValues.decodeIfPresent(VirtualGatewayListenerTls.self, forKey: .tls)
        tls = tlsDecoded
        let connectionPoolDecoded = try containerValues.decodeIfPresent(VirtualGatewayConnectionPool.self, forKey: .connectionPool)
        connectionPool = connectionPoolDecoded
    }
}

extension VirtualGatewayListener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayListener(connectionPool: \(String(describing: connectionPool)), healthCheck: \(String(describing: healthCheck)), portMapping: \(String(describing: portMapping)), tls: \(String(describing: tls)))"}
}

/// <p>An object that represents a listener for a virtual gateway.</p>
public struct VirtualGatewayListener: Equatable {
    /// <p>The connection pool information for the virtual gateway listener.</p>
    public let connectionPool: VirtualGatewayConnectionPool?
    /// <p>The health check information for the listener.</p>
    public let healthCheck: VirtualGatewayHealthCheckPolicy?
    /// <p>The port mapping information for the listener.</p>
    public let portMapping: VirtualGatewayPortMapping?
    /// <p>A reference to an object that represents the Transport Layer Security (TLS) properties for the listener.</p>
    public let tls: VirtualGatewayListenerTls?

    public init (
        connectionPool: VirtualGatewayConnectionPool? = nil,
        healthCheck: VirtualGatewayHealthCheckPolicy? = nil,
        portMapping: VirtualGatewayPortMapping? = nil,
        tls: VirtualGatewayListenerTls? = nil
    )
    {
        self.connectionPool = connectionPool
        self.healthCheck = healthCheck
        self.portMapping = portMapping
        self.tls = tls
    }
}

extension VirtualGatewayListenerTls: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificate
        case mode
        case validation
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let validation = validation {
            try encodeContainer.encode(validation, forKey: .validation)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(VirtualGatewayListenerTlsMode.self, forKey: .mode)
        mode = modeDecoded
        let validationDecoded = try containerValues.decodeIfPresent(VirtualGatewayListenerTlsValidationContext.self, forKey: .validation)
        validation = validationDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(VirtualGatewayListenerTlsCertificate.self, forKey: .certificate)
        certificate = certificateDecoded
    }
}

extension VirtualGatewayListenerTls: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayListenerTls(certificate: \(String(describing: certificate)), mode: \(String(describing: mode)), validation: \(String(describing: validation)))"}
}

/// <p>An object that represents the Transport Layer Security (TLS) properties for a listener.</p>
public struct VirtualGatewayListenerTls: Equatable {
    /// <p>An object that represents a Transport Layer Security (TLS) certificate.</p>
    public let certificate: VirtualGatewayListenerTlsCertificate?
    /// <p>Specify one of the following modes.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b/>STRICT – Listener only accepts connections with TLS
    ///                enabled. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b/>PERMISSIVE – Listener accepts connections with or
    ///                without TLS enabled.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b/>DISABLED – Listener only accepts connections without
    ///                TLS. </p>
    ///             </li>
    ///          </ul>
    public let mode: VirtualGatewayListenerTlsMode?
    /// <p>A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation
    ///          context.</p>
    public let validation: VirtualGatewayListenerTlsValidationContext?

    public init (
        certificate: VirtualGatewayListenerTlsCertificate? = nil,
        mode: VirtualGatewayListenerTlsMode? = nil,
        validation: VirtualGatewayListenerTlsValidationContext? = nil
    )
    {
        self.certificate = certificate
        self.mode = mode
        self.validation = validation
    }
}

extension VirtualGatewayListenerTlsAcmCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension VirtualGatewayListenerTlsAcmCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayListenerTlsAcmCertificate(certificateArn: \(String(describing: certificateArn)))"}
}

/// <p>An object that represents an AWS Certicate Manager (ACM) certificate.</p>
public struct VirtualGatewayListenerTlsAcmCertificate: Equatable {
    /// <p>The Amazon Resource Name (ARN) for the certificate. The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.</p>
    public let certificateArn: String?

    public init (
        certificateArn: String? = nil
    )
    {
        self.certificateArn = certificateArn
    }
}

extension VirtualGatewayListenerTlsCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                if let acm = acm {
                    try container.encode(acm, forKey: .acm)
                }
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(VirtualGatewayListenerTlsAcmCertificate.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(VirtualGatewayListenerTlsFileCertificate.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(VirtualGatewayListenerTlsSdsCertificate.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents a listener's Transport Layer Security (TLS) certificate.</p>
public enum VirtualGatewayListenerTlsCertificate: Equatable {
    /// <p>A reference to an object that represents an AWS Certicate Manager (ACM) certificate.</p>
    case acm(VirtualGatewayListenerTlsAcmCertificate?)
    /// <p>A reference to an object that represents a local file certificate.</p>
    case file(VirtualGatewayListenerTlsFileCertificate?)
    /// <p>A reference to an object that represents a virtual gateway's listener's Secret Discovery
    ///          Service certificate.</p>
    case sds(VirtualGatewayListenerTlsSdsCertificate?)
    case sdkUnknown(String?)
}

extension VirtualGatewayListenerTlsFileCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateChain
        case privateKey
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
    }
}

extension VirtualGatewayListenerTlsFileCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayListenerTlsFileCertificate(certificateChain: \(String(describing: certificateChain)), privateKey: \(String(describing: privateKey)))"}
}

/// <p>An object that represents a local file certificate.
///          The certificate must meet specific requirements and you must have proxy authorization enabled. For more information, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html#virtual-node-tls-prerequisites">Transport Layer Security (TLS)</a>.</p>
public struct VirtualGatewayListenerTlsFileCertificate: Equatable {
    /// <p>The certificate chain for the certificate.</p>
    public let certificateChain: String?
    /// <p>The private key for a certificate stored on the file system of the mesh endpoint that
    ///          the proxy is running on.</p>
    public let privateKey: String?

    public init (
        certificateChain: String? = nil,
        privateKey: String? = nil
    )
    {
        self.certificateChain = certificateChain
        self.privateKey = privateKey
    }
}

public enum VirtualGatewayListenerTlsMode {
    case disabled
    case permissive
    case strict
    case sdkUnknown(String)
}

extension VirtualGatewayListenerTlsMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualGatewayListenerTlsMode] {
        return [
            .disabled,
            .permissive,
            .strict,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .disabled: return "DISABLED"
        case .permissive: return "PERMISSIVE"
        case .strict: return "STRICT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualGatewayListenerTlsMode(rawValue: rawValue) ?? VirtualGatewayListenerTlsMode.sdkUnknown(rawValue)
    }
}

extension VirtualGatewayListenerTlsSdsCertificate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension VirtualGatewayListenerTlsSdsCertificate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayListenerTlsSdsCertificate(secretName: \(String(describing: secretName)))"}
}

/// <p>An object that represents the virtual gateway's listener's Secret Discovery Service
///          certificate.The proxy must be configured with a local SDS provider via a Unix Domain
///          Socket. See App Mesh <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS
///             documentation</a> for more info. </p>
public struct VirtualGatewayListenerTlsSdsCertificate: Equatable {
    /// <p>A reference to an object that represents the name of the secret secret requested from
    ///          the Secret Discovery Service provider representing Transport Layer Security (TLS) materials like a certificate or
    ///          certificate chain.</p>
    public let secretName: String?

    public init (
        secretName: String? = nil
    )
    {
        self.secretName = secretName
    }
}

extension VirtualGatewayListenerTlsValidationContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(VirtualGatewayListenerTlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension VirtualGatewayListenerTlsValidationContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayListenerTlsValidationContext(subjectAlternativeNames: \(String(describing: subjectAlternativeNames)), trust: \(String(describing: trust)))"}
}

/// <p>An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation
///          context.</p>
public struct VirtualGatewayListenerTlsValidationContext: Equatable {
    /// <p>A reference to an object that represents the SANs for a virtual gateway listener's Transport Layer Security (TLS)
    ///          validation context.</p>
    public let subjectAlternativeNames: SubjectAlternativeNames?
    /// <p>A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS)
    ///          certificate.</p>
    public let trust: VirtualGatewayListenerTlsValidationContextTrust?

    public init (
        subjectAlternativeNames: SubjectAlternativeNames? = nil,
        trust: VirtualGatewayListenerTlsValidationContextTrust? = nil
    )
    {
        self.subjectAlternativeNames = subjectAlternativeNames
        self.trust = trust
    }
}

extension VirtualGatewayListenerTlsValidationContextTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let fileDecoded = try values.decodeIfPresent(VirtualGatewayTlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(VirtualGatewayTlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents a virtual gateway's listener's Transport Layer Security (TLS) validation context
///          trust.</p>
public enum VirtualGatewayListenerTlsValidationContextTrust: Equatable {
    /// <p>An object that represents a Transport Layer Security (TLS) validation context trust for a local file.</p>
    case file(VirtualGatewayTlsValidationContextFileTrust?)
    /// <p>A reference to an object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret
    ///          Discovery Service validation context trust.</p>
    case sds(VirtualGatewayTlsValidationContextSdsTrust?)
    case sdkUnknown(String?)
}

extension VirtualGatewayLogging: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case accessLog
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessLog = accessLog {
            try encodeContainer.encode(accessLog, forKey: .accessLog)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessLogDecoded = try containerValues.decodeIfPresent(VirtualGatewayAccessLog.self, forKey: .accessLog)
        accessLog = accessLogDecoded
    }
}

extension VirtualGatewayLogging: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayLogging(accessLog: \(String(describing: accessLog)))"}
}

/// <p>An object that represents logging information.</p>
public struct VirtualGatewayLogging: Equatable {
    /// <p>The access log configuration.</p>
    public let accessLog: VirtualGatewayAccessLog?

    public init (
        accessLog: VirtualGatewayAccessLog? = nil
    )
    {
        self.accessLog = accessLog
    }
}

extension VirtualGatewayPortMapping: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case port
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let `protocol` = `protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decode(Int.self, forKey: .port)
        port = portDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(VirtualGatewayPortProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension VirtualGatewayPortMapping: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayPortMapping(port: \(String(describing: port)), protocol: \(String(describing: `protocol`)))"}
}

/// <p>An object that represents a port mapping.</p>
public struct VirtualGatewayPortMapping: Equatable {
    /// <p>The protocol used for the port mapping.</p>
    public let `protocol`: VirtualGatewayPortProtocol?
    /// <p>The port used for the port mapping. Specify one protocol.</p>
    public let port: Int

    public init (
        `protocol`: VirtualGatewayPortProtocol? = nil,
        port: Int = 0
    )
    {
        self.`protocol` = `protocol`
        self.port = port
    }
}

public enum VirtualGatewayPortProtocol {
    case grpc
    case http
    case http2
    case sdkUnknown(String)
}

extension VirtualGatewayPortProtocol : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualGatewayPortProtocol] {
        return [
            .grpc,
            .http,
            .http2,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .grpc: return "grpc"
        case .http: return "http"
        case .http2: return "http2"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualGatewayPortProtocol(rawValue: rawValue) ?? VirtualGatewayPortProtocol.sdkUnknown(rawValue)
    }
}

extension VirtualGatewayRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualGatewayName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualGatewayName = virtualGatewayName {
            try encodeContainer.encode(virtualGatewayName, forKey: .virtualGatewayName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualGatewayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualGatewayName)
        virtualGatewayName = virtualGatewayNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VirtualGatewayRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayRef(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), version: \(String(describing: version)), virtualGatewayName: \(String(describing: virtualGatewayName)))"}
}

/// <p>An object that represents a virtual gateway returned by a list operation.</p>
public struct VirtualGatewayRef: Equatable {
    /// <p>The full Amazon Resource Name (ARN) for the resource.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the service mesh that the resource resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?
    /// <p>The name of the resource.</p>
    public let virtualGatewayName: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        version: Int? = nil,
        virtualGatewayName: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.version = version
        self.virtualGatewayName = virtualGatewayName
    }
}

extension VirtualGatewaySpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendDefaults
        case listeners
        case logging
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendDefaults = backendDefaults {
            try encodeContainer.encode(backendDefaults, forKey: .backendDefaults)
        }
        if let listeners = listeners {
            var listenersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listeners)
            for virtualgatewaylisteners0 in listeners {
                try listenersContainer.encode(virtualgatewaylisteners0)
            }
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backendDefaultsDecoded = try containerValues.decodeIfPresent(VirtualGatewayBackendDefaults.self, forKey: .backendDefaults)
        backendDefaults = backendDefaultsDecoded
        let listenersContainer = try containerValues.decodeIfPresent([VirtualGatewayListener?].self, forKey: .listeners)
        var listenersDecoded0:[VirtualGatewayListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [VirtualGatewayListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let loggingDecoded = try containerValues.decodeIfPresent(VirtualGatewayLogging.self, forKey: .logging)
        logging = loggingDecoded
    }
}

extension VirtualGatewaySpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewaySpec(backendDefaults: \(String(describing: backendDefaults)), listeners: \(String(describing: listeners)), logging: \(String(describing: logging)))"}
}

/// <p>An object that represents the specification of a service mesh resource.</p>
public struct VirtualGatewaySpec: Equatable {
    /// <p>A reference to an object that represents the defaults for backends.</p>
    public let backendDefaults: VirtualGatewayBackendDefaults?
    /// <p>The listeners that the mesh endpoint is expected to receive inbound traffic from. You
    ///          can specify one listener.</p>
    public let listeners: [VirtualGatewayListener]?
    /// <p>An object that represents logging information.</p>
    public let logging: VirtualGatewayLogging?

    public init (
        backendDefaults: VirtualGatewayBackendDefaults? = nil,
        listeners: [VirtualGatewayListener]? = nil,
        logging: VirtualGatewayLogging? = nil
    )
    {
        self.backendDefaults = backendDefaults
        self.listeners = listeners
        self.logging = logging
    }
}

extension VirtualGatewayStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(VirtualGatewayStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualGatewayStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayStatus(status: \(String(describing: status)))"}
}

/// <p>An object that represents the status of the mesh resource.</p>
public struct VirtualGatewayStatus: Equatable {
    /// <p>The current status.</p>
    public let status: VirtualGatewayStatusCode?

    public init (
        status: VirtualGatewayStatusCode? = nil
    )
    {
        self.status = status
    }
}

public enum VirtualGatewayStatusCode {
    case active
    case deleted
    case inactive
    case sdkUnknown(String)
}

extension VirtualGatewayStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualGatewayStatusCode] {
        return [
            .active,
            .deleted,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualGatewayStatusCode(rawValue: rawValue) ?? VirtualGatewayStatusCode.sdkUnknown(rawValue)
    }
}

extension VirtualGatewayTlsValidationContext: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subjectAlternativeNames
        case trust
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subjectAlternativeNames = subjectAlternativeNames {
            try encodeContainer.encode(subjectAlternativeNames, forKey: .subjectAlternativeNames)
        }
        if let trust = trust {
            try encodeContainer.encode(trust, forKey: .trust)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustDecoded = try containerValues.decodeIfPresent(VirtualGatewayTlsValidationContextTrust.self, forKey: .trust)
        trust = trustDecoded
        let subjectAlternativeNamesDecoded = try containerValues.decodeIfPresent(SubjectAlternativeNames.self, forKey: .subjectAlternativeNames)
        subjectAlternativeNames = subjectAlternativeNamesDecoded
    }
}

extension VirtualGatewayTlsValidationContext: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayTlsValidationContext(subjectAlternativeNames: \(String(describing: subjectAlternativeNames)), trust: \(String(describing: trust)))"}
}

/// <p>An object that represents a Transport Layer Security (TLS) validation context.</p>
public struct VirtualGatewayTlsValidationContext: Equatable {
    /// <p>A reference to an object that represents the SANs for a virtual gateway's listener's
    ///          Transport Layer Security (TLS) validation context.</p>
    public let subjectAlternativeNames: SubjectAlternativeNames?
    /// <p>A reference to where to retrieve the trust chain when validating a peer’s Transport Layer Security (TLS)
    ///          certificate.</p>
    public let trust: VirtualGatewayTlsValidationContextTrust?

    public init (
        subjectAlternativeNames: SubjectAlternativeNames? = nil,
        trust: VirtualGatewayTlsValidationContextTrust? = nil
    )
    {
        self.subjectAlternativeNames = subjectAlternativeNames
        self.trust = trust
    }
}

extension VirtualGatewayTlsValidationContextAcmTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateAuthorityArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateAuthorityArns = certificateAuthorityArns {
            var certificateAuthorityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .certificateAuthorityArns)
            for virtualgatewaycertificateauthorityarns0 in certificateAuthorityArns {
                try certificateAuthorityArnsContainer.encode(virtualgatewaycertificateauthorityarns0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .certificateAuthorityArns)
        var certificateAuthorityArnsDecoded0:[String]? = nil
        if let certificateAuthorityArnsContainer = certificateAuthorityArnsContainer {
            certificateAuthorityArnsDecoded0 = [String]()
            for string0 in certificateAuthorityArnsContainer {
                if let string0 = string0 {
                    certificateAuthorityArnsDecoded0?.append(string0)
                }
            }
        }
        certificateAuthorityArns = certificateAuthorityArnsDecoded0
    }
}

extension VirtualGatewayTlsValidationContextAcmTrust: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayTlsValidationContextAcmTrust(certificateAuthorityArns: \(String(describing: certificateAuthorityArns)))"}
}

/// <p>An object that represents a Transport Layer Security (TLS) validation context trust for an AWS Certicate Manager (ACM)
///          certificate.</p>
public struct VirtualGatewayTlsValidationContextAcmTrust: Equatable {
    /// <p>One or more ACM Amazon Resource Name (ARN)s.</p>
    public let certificateAuthorityArns: [String]?

    public init (
        certificateAuthorityArns: [String]? = nil
    )
    {
        self.certificateAuthorityArns = certificateAuthorityArns
    }
}

extension VirtualGatewayTlsValidationContextFileTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case certificateChain
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateChain = certificateChain {
            try encodeContainer.encode(certificateChain, forKey: .certificateChain)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateChainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificateChain)
        certificateChain = certificateChainDecoded
    }
}

extension VirtualGatewayTlsValidationContextFileTrust: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayTlsValidationContextFileTrust(certificateChain: \(String(describing: certificateChain)))"}
}

/// <p>An object that represents a Transport Layer Security (TLS) validation context trust for a local file.</p>
public struct VirtualGatewayTlsValidationContextFileTrust: Equatable {
    /// <p>The certificate trust chain for a certificate stored on the file system of the virtual
    ///          node that the proxy is running on.</p>
    public let certificateChain: String?

    public init (
        certificateChain: String? = nil
    )
    {
        self.certificateChain = certificateChain
    }
}

extension VirtualGatewayTlsValidationContextSdsTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case secretName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension VirtualGatewayTlsValidationContextSdsTrust: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualGatewayTlsValidationContextSdsTrust(secretName: \(String(describing: secretName)))"}
}

/// <p>An object that represents a virtual gateway's listener's Transport Layer Security (TLS) Secret Discovery Service
///          validation context trust. The proxy must be configured with a local SDS provider via a Unix
///          Domain Socket. See App Mesh <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/tls.html">TLS
///             documentation</a> for more info.</p>
public struct VirtualGatewayTlsValidationContextSdsTrust: Equatable {
    /// <p>A reference to an object that represents the name of the secret for a virtual gateway's
    ///          Transport Layer Security (TLS) Secret Discovery Service validation context trust.</p>
    public let secretName: String?

    public init (
        secretName: String? = nil
    )
    {
        self.secretName = secretName
    }
}

extension VirtualGatewayTlsValidationContextTrust: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case acm
        case file
        case sdkUnknown
        case sds
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .acm(acm):
                if let acm = acm {
                    try container.encode(acm, forKey: .acm)
                }
            case let .file(file):
                if let file = file {
                    try container.encode(file, forKey: .file)
                }
            case let .sds(sds):
                if let sds = sds {
                    try container.encode(sds, forKey: .sds)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let acmDecoded = try values.decodeIfPresent(VirtualGatewayTlsValidationContextAcmTrust.self, forKey: .acm)
        if let acm = acmDecoded {
            self = .acm(acm)
            return
        }
        let fileDecoded = try values.decodeIfPresent(VirtualGatewayTlsValidationContextFileTrust.self, forKey: .file)
        if let file = fileDecoded {
            self = .file(file)
            return
        }
        let sdsDecoded = try values.decodeIfPresent(VirtualGatewayTlsValidationContextSdsTrust.self, forKey: .sds)
        if let sds = sdsDecoded {
            self = .sds(sds)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents a Transport Layer Security (TLS) validation context trust.</p>
public enum VirtualGatewayTlsValidationContextTrust: Equatable {
    /// <p>A reference to an object that represents a Transport Layer Security (TLS) validation context trust for an
    ///          AWS Certicate Manager (ACM) certificate.</p>
    case acm(VirtualGatewayTlsValidationContextAcmTrust?)
    /// <p>An object that represents a Transport Layer Security (TLS) validation context trust for a local file.</p>
    case file(VirtualGatewayTlsValidationContextFileTrust?)
    /// <p>A reference to an object that represents a virtual gateway's Transport Layer Security (TLS) Secret Discovery
    ///          Service validation context trust.</p>
    case sds(VirtualGatewayTlsValidationContextSdsTrust?)
    case sdkUnknown(String?)
}

extension VirtualNodeConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case grpc
        case http
        case http2
        case sdkUnknown
        case tcp
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .grpc(grpc):
                if let grpc = grpc {
                    try container.encode(grpc, forKey: .grpc)
                }
            case let .http(http):
                if let http = http {
                    try container.encode(http, forKey: .http)
                }
            case let .http2(http2):
                if let http2 = http2 {
                    try container.encode(http2, forKey: .http2)
                }
            case let .tcp(tcp):
                if let tcp = tcp {
                    try container.encode(tcp, forKey: .tcp)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let tcpDecoded = try values.decodeIfPresent(VirtualNodeTcpConnectionPool.self, forKey: .tcp)
        if let tcp = tcpDecoded {
            self = .tcp(tcp)
            return
        }
        let httpDecoded = try values.decodeIfPresent(VirtualNodeHttpConnectionPool.self, forKey: .http)
        if let http = httpDecoded {
            self = .http(http)
            return
        }
        let http2Decoded = try values.decodeIfPresent(VirtualNodeHttp2ConnectionPool.self, forKey: .http2)
        if let http2 = http2Decoded {
            self = .http2(http2)
            return
        }
        let grpcDecoded = try values.decodeIfPresent(VirtualNodeGrpcConnectionPool.self, forKey: .grpc)
        if let grpc = grpcDecoded {
            self = .grpc(grpc)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the type of virtual node connection pool.</p>
///          <p>Only one protocol is used at a time and should be the same protocol as the one chosen
///          under port mapping.</p>
///          <p>If not present the default value for <code>maxPendingRequests</code> is
///             <code>2147483647</code>.</p>
///          <p/>
public enum VirtualNodeConnectionPool: Equatable {
    /// <p>An object that represents a type of connection pool.</p>
    case tcp(VirtualNodeTcpConnectionPool?)
    /// <p>An object that represents a type of connection pool.</p>
    case http(VirtualNodeHttpConnectionPool?)
    /// <p>An object that represents a type of connection pool.</p>
    case http2(VirtualNodeHttp2ConnectionPool?)
    /// <p>An object that represents a type of connection pool.</p>
    case grpc(VirtualNodeGrpcConnectionPool?)
    case sdkUnknown(String?)
}

extension VirtualNodeData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualNodeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualNodeName = virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualNodeSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VirtualNodeStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualNodeData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeData(meshName: \(String(describing: meshName)), metadata: \(String(describing: metadata)), spec: \(String(describing: spec)), status: \(String(describing: status)), virtualNodeName: \(String(describing: virtualNodeName)))"}
}

/// <p>An object that represents a virtual node returned by a describe operation.</p>
public struct VirtualNodeData: Equatable {
    /// <p>The name of the service mesh that the virtual node resides in.</p>
    public let meshName: String?
    /// <p>The associated metadata for the virtual node.</p>
    public let metadata: ResourceMetadata?
    /// <p>The specifications of the virtual node.</p>
    public let spec: VirtualNodeSpec?
    /// <p>The current status for the virtual node.</p>
    public let status: VirtualNodeStatus?
    /// <p>The name of the virtual node.</p>
    public let virtualNodeName: String?

    public init (
        meshName: String? = nil,
        metadata: ResourceMetadata? = nil,
        spec: VirtualNodeSpec? = nil,
        status: VirtualNodeStatus? = nil,
        virtualNodeName: String? = nil
    )
    {
        self.meshName = meshName
        self.metadata = metadata
        self.spec = spec
        self.status = status
        self.virtualNodeName = virtualNodeName
    }
}

extension VirtualNodeGrpcConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decode(Int.self, forKey: .maxRequests)
        maxRequests = maxRequestsDecoded
    }
}

extension VirtualNodeGrpcConnectionPool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeGrpcConnectionPool(maxRequests: \(String(describing: maxRequests)))"}
}

/// <p>An object that represents a type of connection pool.</p>
public struct VirtualNodeGrpcConnectionPool: Equatable {
    /// <p>Maximum number of inflight requests Envoy can concurrently support across hosts in
    ///          upstream cluster.</p>
    public let maxRequests: Int

    public init (
        maxRequests: Int = 0
    )
    {
        self.maxRequests = maxRequests
    }
}

extension VirtualNodeHttp2ConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxRequests != 0 {
            try encodeContainer.encode(maxRequests, forKey: .maxRequests)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxRequestsDecoded = try containerValues.decode(Int.self, forKey: .maxRequests)
        maxRequests = maxRequestsDecoded
    }
}

extension VirtualNodeHttp2ConnectionPool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeHttp2ConnectionPool(maxRequests: \(String(describing: maxRequests)))"}
}

/// <p>An object that represents a type of connection pool.</p>
public struct VirtualNodeHttp2ConnectionPool: Equatable {
    /// <p>Maximum number of inflight requests Envoy can concurrently support across hosts in
    ///          upstream cluster.</p>
    public let maxRequests: Int

    public init (
        maxRequests: Int = 0
    )
    {
        self.maxRequests = maxRequests
    }
}

extension VirtualNodeHttpConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxConnections
        case maxPendingRequests
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
        if maxPendingRequests != 0 {
            try encodeContainer.encode(maxPendingRequests, forKey: .maxPendingRequests)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsDecoded = try containerValues.decode(Int.self, forKey: .maxConnections)
        maxConnections = maxConnectionsDecoded
        let maxPendingRequestsDecoded = try containerValues.decode(Int.self, forKey: .maxPendingRequests)
        maxPendingRequests = maxPendingRequestsDecoded
    }
}

extension VirtualNodeHttpConnectionPool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeHttpConnectionPool(maxConnections: \(String(describing: maxConnections)), maxPendingRequests: \(String(describing: maxPendingRequests)))"}
}

/// <p>An object that represents a type of connection pool.</p>
public struct VirtualNodeHttpConnectionPool: Equatable {
    /// <p>Maximum number of outbound TCP connections Envoy can establish concurrently with all
    ///          hosts in upstream cluster.</p>
    public let maxConnections: Int
    /// <p>Number of overflowing requests after <code>max_connections</code> Envoy will queue to
    ///          upstream cluster.</p>
    public let maxPendingRequests: Int

    public init (
        maxConnections: Int = 0,
        maxPendingRequests: Int = 0
    )
    {
        self.maxConnections = maxConnections
        self.maxPendingRequests = maxPendingRequests
    }
}

extension VirtualNodeRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualNodeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualNodeName = virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VirtualNodeRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeRef(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), version: \(String(describing: version)), virtualNodeName: \(String(describing: virtualNodeName)))"}
}

/// <p>An object that represents a virtual node returned by a list operation.</p>
public struct VirtualNodeRef: Equatable {
    /// <p>The full Amazon Resource Name (ARN) for the virtual node.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the service mesh that the virtual node resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?
    /// <p>The name of the virtual node.</p>
    public let virtualNodeName: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        version: Int? = nil,
        virtualNodeName: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.version = version
        self.virtualNodeName = virtualNodeName
    }
}

extension VirtualNodeServiceProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualNodeName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualNodeName = virtualNodeName {
            try encodeContainer.encode(virtualNodeName, forKey: .virtualNodeName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualNodeName)
        virtualNodeName = virtualNodeNameDecoded
    }
}

extension VirtualNodeServiceProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeServiceProvider(virtualNodeName: \(String(describing: virtualNodeName)))"}
}

/// <p>An object that represents a virtual node service provider.</p>
public struct VirtualNodeServiceProvider: Equatable {
    /// <p>The name of the virtual node that is acting as a service provider.</p>
    public let virtualNodeName: String?

    public init (
        virtualNodeName: String? = nil
    )
    {
        self.virtualNodeName = virtualNodeName
    }
}

extension VirtualNodeSpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backendDefaults
        case backends
        case listeners
        case logging
        case serviceDiscovery
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backendDefaults = backendDefaults {
            try encodeContainer.encode(backendDefaults, forKey: .backendDefaults)
        }
        if let backends = backends {
            var backendsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .backends)
            for backends0 in backends {
                try backendsContainer.encode(backends0)
            }
        }
        if let listeners = listeners {
            var listenersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listeners)
            for listeners0 in listeners {
                try listenersContainer.encode(listeners0)
            }
        }
        if let logging = logging {
            try encodeContainer.encode(logging, forKey: .logging)
        }
        if let serviceDiscovery = serviceDiscovery {
            try encodeContainer.encode(serviceDiscovery, forKey: .serviceDiscovery)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDiscoveryDecoded = try containerValues.decodeIfPresent(ServiceDiscovery.self, forKey: .serviceDiscovery)
        serviceDiscovery = serviceDiscoveryDecoded
        let listenersContainer = try containerValues.decodeIfPresent([Listener?].self, forKey: .listeners)
        var listenersDecoded0:[Listener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [Listener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
        let backendsContainer = try containerValues.decodeIfPresent([Backend?].self, forKey: .backends)
        var backendsDecoded0:[Backend]? = nil
        if let backendsContainer = backendsContainer {
            backendsDecoded0 = [Backend]()
            for union0 in backendsContainer {
                if let union0 = union0 {
                    backendsDecoded0?.append(union0)
                }
            }
        }
        backends = backendsDecoded0
        let backendDefaultsDecoded = try containerValues.decodeIfPresent(BackendDefaults.self, forKey: .backendDefaults)
        backendDefaults = backendDefaultsDecoded
        let loggingDecoded = try containerValues.decodeIfPresent(Logging.self, forKey: .logging)
        logging = loggingDecoded
    }
}

extension VirtualNodeSpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeSpec(backendDefaults: \(String(describing: backendDefaults)), backends: \(String(describing: backends)), listeners: \(String(describing: listeners)), logging: \(String(describing: logging)), serviceDiscovery: \(String(describing: serviceDiscovery)))"}
}

/// <p>An object that represents the specification of a virtual node.</p>
public struct VirtualNodeSpec: Equatable {
    /// <p>A reference to an object that represents the defaults for backends.</p>
    public let backendDefaults: BackendDefaults?
    /// <p>The backends that the virtual node is expected to send outbound traffic to.</p>
    public let backends: [Backend]?
    /// <p>The listener that the virtual node is expected to receive inbound traffic from. You can
    ///          specify one listener.</p>
    public let listeners: [Listener]?
    /// <p>The inbound and outbound access logging information for the virtual node.</p>
    public let logging: Logging?
    /// <p>The service discovery information for the virtual node. If your virtual node does not
    ///          expect ingress traffic, you can omit this parameter. If you specify a
    ///          <code>listener</code>, then you must specify service discovery information.</p>
    public let serviceDiscovery: ServiceDiscovery?

    public init (
        backendDefaults: BackendDefaults? = nil,
        backends: [Backend]? = nil,
        listeners: [Listener]? = nil,
        logging: Logging? = nil,
        serviceDiscovery: ServiceDiscovery? = nil
    )
    {
        self.backendDefaults = backendDefaults
        self.backends = backends
        self.listeners = listeners
        self.logging = logging
        self.serviceDiscovery = serviceDiscovery
    }
}

extension VirtualNodeStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(VirtualNodeStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualNodeStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeStatus(status: \(String(describing: status)))"}
}

/// <p>An object that represents the current status of the virtual node.</p>
public struct VirtualNodeStatus: Equatable {
    /// <p>The current status of the virtual node.</p>
    public let status: VirtualNodeStatusCode?

    public init (
        status: VirtualNodeStatusCode? = nil
    )
    {
        self.status = status
    }
}

public enum VirtualNodeStatusCode {
    case active
    case deleted
    case inactive
    case sdkUnknown(String)
}

extension VirtualNodeStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualNodeStatusCode] {
        return [
            .active,
            .deleted,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualNodeStatusCode(rawValue: rawValue) ?? VirtualNodeStatusCode.sdkUnknown(rawValue)
    }
}

extension VirtualNodeTcpConnectionPool: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxConnections
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxConnections != 0 {
            try encodeContainer.encode(maxConnections, forKey: .maxConnections)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxConnectionsDecoded = try containerValues.decode(Int.self, forKey: .maxConnections)
        maxConnections = maxConnectionsDecoded
    }
}

extension VirtualNodeTcpConnectionPool: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualNodeTcpConnectionPool(maxConnections: \(String(describing: maxConnections)))"}
}

/// <p>An object that represents a type of connection pool.</p>
public struct VirtualNodeTcpConnectionPool: Equatable {
    /// <p>Maximum number of outbound TCP connections Envoy can establish concurrently with all
    ///          hosts in upstream cluster.</p>
    public let maxConnections: Int

    public init (
        maxConnections: Int = 0
    )
    {
        self.maxConnections = maxConnections
    }
}

extension VirtualRouterData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualRouterName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualRouterName = virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualRouterSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VirtualRouterStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualRouterData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualRouterData(meshName: \(String(describing: meshName)), metadata: \(String(describing: metadata)), spec: \(String(describing: spec)), status: \(String(describing: status)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

/// <p>An object that represents a virtual router returned by a describe operation.</p>
public struct VirtualRouterData: Equatable {
    /// <p>The name of the service mesh that the virtual router resides in.</p>
    public let meshName: String?
    /// <p>The associated metadata for the virtual router.</p>
    public let metadata: ResourceMetadata?
    /// <p>The specifications of the virtual router.</p>
    public let spec: VirtualRouterSpec?
    /// <p>The current status of the virtual router.</p>
    public let status: VirtualRouterStatus?
    /// <p>The name of the virtual router.</p>
    public let virtualRouterName: String?

    public init (
        meshName: String? = nil,
        metadata: ResourceMetadata? = nil,
        spec: VirtualRouterSpec? = nil,
        status: VirtualRouterStatus? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.meshName = meshName
        self.metadata = metadata
        self.spec = spec
        self.status = status
        self.virtualRouterName = virtualRouterName
    }
}

extension VirtualRouterListener: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case portMapping
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portMapping = portMapping {
            try encodeContainer.encode(portMapping, forKey: .portMapping)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portMappingDecoded = try containerValues.decodeIfPresent(PortMapping.self, forKey: .portMapping)
        portMapping = portMappingDecoded
    }
}

extension VirtualRouterListener: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualRouterListener(portMapping: \(String(describing: portMapping)))"}
}

/// <p>An object that represents a virtual router listener.</p>
public struct VirtualRouterListener: Equatable {
    /// <p>An object that represents a port mapping.</p>
    public let portMapping: PortMapping?

    public init (
        portMapping: PortMapping? = nil
    )
    {
        self.portMapping = portMapping
    }
}

extension VirtualRouterRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualRouterName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualRouterName = virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VirtualRouterRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualRouterRef(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), version: \(String(describing: version)), virtualRouterName: \(String(describing: virtualRouterName)))"}
}

/// <p>An object that represents a virtual router returned by a list operation.</p>
public struct VirtualRouterRef: Equatable {
    /// <p>The full Amazon Resource Name (ARN) for the virtual router.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the service mesh that the virtual router resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?
    /// <p>The name of the virtual router.</p>
    public let virtualRouterName: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        version: Int? = nil,
        virtualRouterName: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.version = version
        self.virtualRouterName = virtualRouterName
    }
}

extension VirtualRouterServiceProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualRouterName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualRouterName = virtualRouterName {
            try encodeContainer.encode(virtualRouterName, forKey: .virtualRouterName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualRouterNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualRouterName)
        virtualRouterName = virtualRouterNameDecoded
    }
}

extension VirtualRouterServiceProvider: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualRouterServiceProvider(virtualRouterName: \(String(describing: virtualRouterName)))"}
}

/// <p>An object that represents a virtual node service provider.</p>
public struct VirtualRouterServiceProvider: Equatable {
    /// <p>The name of the virtual router that is acting as a service provider.</p>
    public let virtualRouterName: String?

    public init (
        virtualRouterName: String? = nil
    )
    {
        self.virtualRouterName = virtualRouterName
    }
}

extension VirtualRouterSpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case listeners
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let listeners = listeners {
            var listenersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listeners)
            for virtualrouterlisteners0 in listeners {
                try listenersContainer.encode(virtualrouterlisteners0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listenersContainer = try containerValues.decodeIfPresent([VirtualRouterListener?].self, forKey: .listeners)
        var listenersDecoded0:[VirtualRouterListener]? = nil
        if let listenersContainer = listenersContainer {
            listenersDecoded0 = [VirtualRouterListener]()
            for structure0 in listenersContainer {
                if let structure0 = structure0 {
                    listenersDecoded0?.append(structure0)
                }
            }
        }
        listeners = listenersDecoded0
    }
}

extension VirtualRouterSpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualRouterSpec(listeners: \(String(describing: listeners)))"}
}

/// <p>An object that represents the specification of a virtual router.</p>
public struct VirtualRouterSpec: Equatable {
    /// <p>The listeners that the virtual router is expected to receive inbound traffic from. You
    ///          can specify one listener.</p>
    public let listeners: [VirtualRouterListener]?

    public init (
        listeners: [VirtualRouterListener]? = nil
    )
    {
        self.listeners = listeners
    }
}

extension VirtualRouterStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(VirtualRouterStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualRouterStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualRouterStatus(status: \(String(describing: status)))"}
}

/// <p>An object that represents the status of a virtual router. </p>
public struct VirtualRouterStatus: Equatable {
    /// <p>The current status of the virtual router.</p>
    public let status: VirtualRouterStatusCode?

    public init (
        status: VirtualRouterStatusCode? = nil
    )
    {
        self.status = status
    }
}

public enum VirtualRouterStatusCode {
    case active
    case deleted
    case inactive
    case sdkUnknown(String)
}

extension VirtualRouterStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualRouterStatusCode] {
        return [
            .active,
            .deleted,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualRouterStatusCode(rawValue: rawValue) ?? VirtualRouterStatusCode.sdkUnknown(rawValue)
    }
}

extension VirtualServiceBackend: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientPolicy
        case virtualServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientPolicy = clientPolicy {
            try encodeContainer.encode(clientPolicy, forKey: .clientPolicy)
        }
        if let virtualServiceName = virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let clientPolicyDecoded = try containerValues.decodeIfPresent(ClientPolicy.self, forKey: .clientPolicy)
        clientPolicy = clientPolicyDecoded
    }
}

extension VirtualServiceBackend: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualServiceBackend(clientPolicy: \(String(describing: clientPolicy)), virtualServiceName: \(String(describing: virtualServiceName)))"}
}

/// <p>An object that represents a virtual service backend for a virtual node.</p>
public struct VirtualServiceBackend: Equatable {
    /// <p>A reference to an object that represents the client policy for a backend.</p>
    public let clientPolicy: ClientPolicy?
    /// <p>The name of the virtual service that is acting as a virtual node backend.</p>
    public let virtualServiceName: String?

    public init (
        clientPolicy: ClientPolicy? = nil,
        virtualServiceName: String? = nil
    )
    {
        self.clientPolicy = clientPolicy
        self.virtualServiceName = virtualServiceName
    }
}

extension VirtualServiceData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case meshName
        case metadata
        case spec
        case status
        case virtualServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let metadata = metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let spec = spec {
            try encodeContainer.encode(spec, forKey: .spec)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let virtualServiceName = virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let specDecoded = try containerValues.decodeIfPresent(VirtualServiceSpec.self, forKey: .spec)
        spec = specDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(ResourceMetadata.self, forKey: .metadata)
        metadata = metadataDecoded
        let statusDecoded = try containerValues.decodeIfPresent(VirtualServiceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualServiceData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualServiceData(meshName: \(String(describing: meshName)), metadata: \(String(describing: metadata)), spec: \(String(describing: spec)), status: \(String(describing: status)), virtualServiceName: \(String(describing: virtualServiceName)))"}
}

/// <p>An object that represents a virtual service returned by a describe operation.</p>
public struct VirtualServiceData: Equatable {
    /// <p>The name of the service mesh that the virtual service resides in.</p>
    public let meshName: String?
    /// <p>An object that represents metadata for a resource.</p>
    public let metadata: ResourceMetadata?
    /// <p>The specifications of the virtual service.</p>
    public let spec: VirtualServiceSpec?
    /// <p>The current status of the virtual service.</p>
    public let status: VirtualServiceStatus?
    /// <p>The name of the virtual service.</p>
    public let virtualServiceName: String?

    public init (
        meshName: String? = nil,
        metadata: ResourceMetadata? = nil,
        spec: VirtualServiceSpec? = nil,
        status: VirtualServiceStatus? = nil,
        virtualServiceName: String? = nil
    )
    {
        self.meshName = meshName
        self.metadata = metadata
        self.spec = spec
        self.status = status
        self.virtualServiceName = virtualServiceName
    }
}

extension VirtualServiceProvider: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sdkUnknown
        case virtualNode
        case virtualRouter
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .virtualNode(virtualNode):
                if let virtualNode = virtualNode {
                    try container.encode(virtualNode, forKey: .virtualNode)
                }
            case let .virtualRouter(virtualRouter):
                if let virtualRouter = virtualRouter {
                    try container.encode(virtualRouter, forKey: .virtualRouter)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try values.decodeIfPresent(VirtualNodeServiceProvider.self, forKey: .virtualNode)
        if let virtualNode = virtualNodeDecoded {
            self = .virtualNode(virtualNode)
            return
        }
        let virtualRouterDecoded = try values.decodeIfPresent(VirtualRouterServiceProvider.self, forKey: .virtualRouter)
        if let virtualRouter = virtualRouterDecoded {
            self = .virtualRouter(virtualRouter)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>An object that represents the provider for a virtual service.</p>
public enum VirtualServiceProvider: Equatable {
    /// <p>The virtual node associated with a virtual service.</p>
    case virtualNode(VirtualNodeServiceProvider?)
    /// <p>The virtual router associated with a virtual service.</p>
    case virtualRouter(VirtualRouterServiceProvider?)
    case sdkUnknown(String?)
}

extension VirtualServiceRef: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case lastUpdatedAt
        case meshName
        case meshOwner
        case resourceOwner
        case version
        case virtualServiceName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let lastUpdatedAt = lastUpdatedAt {
            try encodeContainer.encode(lastUpdatedAt.timeIntervalSince1970, forKey: .lastUpdatedAt)
        }
        if let meshName = meshName {
            try encodeContainer.encode(meshName, forKey: .meshName)
        }
        if let meshOwner = meshOwner {
            try encodeContainer.encode(meshOwner, forKey: .meshOwner)
        }
        if let resourceOwner = resourceOwner {
            try encodeContainer.encode(resourceOwner, forKey: .resourceOwner)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let virtualServiceName = virtualServiceName {
            try encodeContainer.encode(virtualServiceName, forKey: .virtualServiceName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let meshNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshName)
        meshName = meshNameDecoded
        let virtualServiceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualServiceName)
        virtualServiceName = virtualServiceNameDecoded
        let meshOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .meshOwner)
        meshOwner = meshOwnerDecoded
        let resourceOwnerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceOwner)
        resourceOwner = resourceOwnerDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .version)
        version = versionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension VirtualServiceRef: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualServiceRef(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), lastUpdatedAt: \(String(describing: lastUpdatedAt)), meshName: \(String(describing: meshName)), meshOwner: \(String(describing: meshOwner)), resourceOwner: \(String(describing: resourceOwner)), version: \(String(describing: version)), virtualServiceName: \(String(describing: virtualServiceName)))"}
}

/// <p>An object that represents a virtual service returned by a list operation.</p>
public struct VirtualServiceRef: Equatable {
    /// <p>The full Amazon Resource Name (ARN) for the virtual service.</p>
    public let arn: String?
    /// <p>The Unix epoch timestamp in seconds for when the resource was created.</p>
    public let createdAt: Date?
    /// <p>The Unix epoch timestamp in seconds for when the resource was last updated.</p>
    public let lastUpdatedAt: Date?
    /// <p>The name of the service mesh that the virtual service resides in.</p>
    public let meshName: String?
    /// <p>The AWS IAM account ID of the service mesh owner. If the account ID is not your own, then it's
    ///                the ID of the account that shared the mesh with your account. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let meshOwner: String?
    /// <p>The AWS IAM account ID of the resource owner. If the account ID is not your own, then it's
    ///                the ID of the mesh owner or of another account that the mesh is shared with. For more information about mesh sharing, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/sharing.html">Working with shared meshes</a>.</p>
    public let resourceOwner: String?
    /// <p>The version of the resource. Resources are created at version 1, and this version is incremented each time that they're updated.</p>
    public let version: Int?
    /// <p>The name of the virtual service.</p>
    public let virtualServiceName: String?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        lastUpdatedAt: Date? = nil,
        meshName: String? = nil,
        meshOwner: String? = nil,
        resourceOwner: String? = nil,
        version: Int? = nil,
        virtualServiceName: String? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.meshName = meshName
        self.meshOwner = meshOwner
        self.resourceOwner = resourceOwner
        self.version = version
        self.virtualServiceName = virtualServiceName
    }
}

extension VirtualServiceSpec: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case provider
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let providerDecoded = try containerValues.decodeIfPresent(VirtualServiceProvider.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension VirtualServiceSpec: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualServiceSpec(provider: \(String(describing: provider)))"}
}

/// <p>An object that represents the specification of a virtual service.</p>
public struct VirtualServiceSpec: Equatable {
    /// <p>The App Mesh object that is acting as the provider for a virtual service. You can specify
    ///          a single virtual node or virtual router.</p>
    public let provider: VirtualServiceProvider?

    public init (
        provider: VirtualServiceProvider? = nil
    )
    {
        self.provider = provider
    }
}

extension VirtualServiceStatus: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(VirtualServiceStatusCode.self, forKey: .status)
        status = statusDecoded
    }
}

extension VirtualServiceStatus: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VirtualServiceStatus(status: \(String(describing: status)))"}
}

/// <p>An object that represents the status of a virtual service.</p>
public struct VirtualServiceStatus: Equatable {
    /// <p>The current status of the virtual service.</p>
    public let status: VirtualServiceStatusCode?

    public init (
        status: VirtualServiceStatusCode? = nil
    )
    {
        self.status = status
    }
}

public enum VirtualServiceStatusCode {
    case active
    case deleted
    case inactive
    case sdkUnknown(String)
}

extension VirtualServiceStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [VirtualServiceStatusCode] {
        return [
            .active,
            .deleted,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .deleted: return "DELETED"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = VirtualServiceStatusCode(rawValue: rawValue) ?? VirtualServiceStatusCode.sdkUnknown(rawValue)
    }
}

extension WeightedTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case virtualNode
        case weight
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let virtualNode = virtualNode {
            try encodeContainer.encode(virtualNode, forKey: .virtualNode)
        }
        if weight != 0 {
            try encodeContainer.encode(weight, forKey: .weight)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let virtualNodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .virtualNode)
        virtualNode = virtualNodeDecoded
        let weightDecoded = try containerValues.decode(Int.self, forKey: .weight)
        weight = weightDecoded
    }
}

extension WeightedTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WeightedTarget(virtualNode: \(String(describing: virtualNode)), weight: \(String(describing: weight)))"}
}

/// <p>An object that represents a target and its relative weight. Traffic is distributed
///          across targets according to their relative weight. For example, a weighted target with a
///          relative weight of 50 receives five times as much traffic as one with a relative weight of
///          10. The total weight for all targets combined must be less than or equal to 100.</p>
public struct WeightedTarget: Equatable {
    /// <p>The virtual node to associate with the weighted target.</p>
    public let virtualNode: String?
    /// <p>The relative weight of the weighted target.</p>
    public let weight: Int

    public init (
        virtualNode: String? = nil,
        weight: Int = 0
    )
    {
        self.virtualNode = virtualNode
        self.weight = weight
    }
}
