// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class AppMeshClient {
    let client: SdkHttpClient
    let config: AppMeshClientConfiguration
    let serviceName = "App Mesh"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: AppMeshClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class AppMeshClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> AppMeshClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try AppMeshClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension AppMeshClient: AppMeshClientProtocol {
    /// <p>Creates a gateway route.</p>
    ///          <p>A gateway route is attached to a virtual gateway and routes traffic to an existing
    ///          virtual service. If a route matches a request, it can distribute traffic to a target
    ///          virtual service.</p>
    ///          <p>For more information about gateway routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/gateway-routes.html">Gateway routes</a>.</p>
    public func createGatewayRoute(input: CreateGatewayRouteInput, completion: @escaping (SdkResult<CreateGatewayRouteOutputResponse, CreateGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateGatewayRouteInput, CreateGatewayRouteOutputResponse, CreateGatewayRouteOutputError>(id: "createGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateGatewayRouteOutputResponse>, SdkError<CreateGatewayRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateGatewayRouteInput, CreateGatewayRouteOutputResponse, CreateGatewayRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateGatewayRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a service mesh.</p>
    ///          <p> A service mesh is a logical boundary for network traffic between services that are
    ///          represented by resources within the mesh. After you create your service mesh, you can
    ///          create virtual services, virtual nodes, virtual routers, and routes to distribute traffic
    ///          between the applications in your mesh.</p>
    ///          <p>For more information about service meshes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/meshes.html">Service meshes</a>.</p>
    public func createMesh(input: CreateMeshInput, completion: @escaping (SdkResult<CreateMeshOutputResponse, CreateMeshOutputError>) -> Void)
    {
        let urlPath = "/v20190125/meshes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateMeshInput, CreateMeshOutputResponse, CreateMeshOutputError>(id: "createMesh")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateMeshOutputResponse>, SdkError<CreateMeshOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateMeshInput, CreateMeshOutputResponse, CreateMeshOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateMeshInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a route that is associated with a virtual router.</p>
    ///          <p> You can route several different protocols and define a retry policy for a route.
    ///          Traffic can be routed to one or more virtual nodes.</p>
    ///          <p>For more information about routes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/routes.html">Routes</a>.</p>
    public func createRoute(input: CreateRouteInput, completion: @escaping (SdkResult<CreateRouteOutputResponse, CreateRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateRouteInput, CreateRouteOutputResponse, CreateRouteOutputError>(id: "createRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateRouteOutputResponse>, SdkError<CreateRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateRouteInput, CreateRouteOutputResponse, CreateRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a virtual gateway.</p>
    ///          <p>A virtual gateway allows resources outside your mesh to communicate to resources that
    ///          are inside your mesh. The virtual gateway represents an Envoy proxy running in an Amazon ECS
    ///          task, in a Kubernetes service, or on an Amazon EC2 instance. Unlike a virtual node, which
    ///          represents an Envoy running with an application, a virtual gateway represents Envoy
    ///          deployed by itself.</p>
    ///          <p>For more information about virtual gateways, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_gateways.html">Virtual gateways</a>. </p>
    public func createVirtualGateway(input: CreateVirtualGatewayInput, completion: @escaping (SdkResult<CreateVirtualGatewayOutputResponse, CreateVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualGatewayInput, CreateVirtualGatewayOutputResponse, CreateVirtualGatewayOutputError>(id: "createVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateVirtualGatewayOutputResponse>, SdkError<CreateVirtualGatewayOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateVirtualGatewayInput, CreateVirtualGatewayOutputResponse, CreateVirtualGatewayOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a virtual node within a service mesh.</p>
    ///          <p> A virtual node acts as a logical pointer to a particular task group, such as an Amazon ECS
    ///          service or a Kubernetes deployment. When you create a virtual node, you can specify the
    ///          service discovery information for your task group, and whether the proxy running in a task
    ///          group will communicate with other proxies using Transport Layer Security (TLS).</p>
    ///          <p>You define a <code>listener</code> for any inbound traffic that your virtual node
    ///          expects. Any virtual service that your virtual node expects to communicate to is specified
    ///          as a <code>backend</code>.</p>
    ///          <p>The response metadata for your new virtual node contains the <code>arn</code> that is
    ///          associated with the virtual node. Set this value to the full ARN; for example,
    ///             <code>arn:aws:appmesh:us-west-2:123456789012:myMesh/default/virtualNode/myApp</code>)
    ///          as the <code>APPMESH_RESOURCE_ARN</code> environment variable for your task group's Envoy
    ///          proxy container in your task definition or pod spec. This is then mapped to the
    ///             <code>node.id</code> and <code>node.cluster</code> Envoy parameters.</p>
    ///          <note>
    ///             <p>By default, App Mesh uses the name of the resource you specified in
    ///                <code>APPMESH_RESOURCE_ARN</code> when Envoy is referring to itself in metrics and
    ///             traces. You can override this behavior by setting the
    ///                <code>APPMESH_RESOURCE_CLUSTER</code> environment variable with your own name.</p>
    ///             <p>AWS Cloud Map is not available in the eu-south-1 Region.</p>
    ///          </note>
    ///          <p>For more information about virtual nodes, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_nodes.html">Virtual nodes</a>. You must be using <code>1.15.0</code> or later of the Envoy image when
    ///          setting these variables. For more information about App Mesh Envoy variables, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/envoy.html">Envoy image</a> in
    ///          the AWS App Mesh User Guide.</p>
    public func createVirtualNode(input: CreateVirtualNodeInput, completion: @escaping (SdkResult<CreateVirtualNodeOutputResponse, CreateVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualNodeInput, CreateVirtualNodeOutputResponse, CreateVirtualNodeOutputError>(id: "createVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateVirtualNodeOutputResponse>, SdkError<CreateVirtualNodeOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateVirtualNodeInput, CreateVirtualNodeOutputResponse, CreateVirtualNodeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualNodeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a virtual router within a service mesh.</p>
    ///          <p>Specify a <code>listener</code> for any inbound traffic that your virtual router
    ///          receives. Create a virtual router for each protocol and port that you need to route.
    ///          Virtual routers handle traffic for one or more virtual services within your mesh. After you
    ///          create your virtual router, create and associate routes for your virtual router that direct
    ///          incoming requests to different virtual nodes.</p>
    ///          <p>For more information about virtual routers, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_routers.html">Virtual routers</a>.</p>
    public func createVirtualRouter(input: CreateVirtualRouterInput, completion: @escaping (SdkResult<CreateVirtualRouterOutputResponse, CreateVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualRouterInput, CreateVirtualRouterOutputResponse, CreateVirtualRouterOutputError>(id: "createVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateVirtualRouterOutputResponse>, SdkError<CreateVirtualRouterOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateVirtualRouterInput, CreateVirtualRouterOutputResponse, CreateVirtualRouterOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualRouterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a virtual service within a service mesh.</p>
    ///          <p>A virtual service is an abstraction of a real service that is provided by a virtual node
    ///          directly or indirectly by means of a virtual router. Dependent services call your virtual
    ///          service by its <code>virtualServiceName</code>, and those requests are routed to the
    ///          virtual node or virtual router that is specified as the provider for the virtual
    ///          service.</p>
    ///          <p>For more information about virtual services, see <a href="https://docs.aws.amazon.com/app-mesh/latest/userguide/virtual_services.html">Virtual services</a>.</p>
    public func createVirtualService(input: CreateVirtualServiceInput, completion: @escaping (SdkResult<CreateVirtualServiceOutputResponse, CreateVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateVirtualServiceInput, CreateVirtualServiceOutputResponse, CreateVirtualServiceOutputError>(id: "createVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<CreateVirtualServiceOutputResponse>, SdkError<CreateVirtualServiceOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateVirtualServiceInput, CreateVirtualServiceOutputResponse, CreateVirtualServiceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateVirtualServiceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing gateway route.</p>
    public func deleteGatewayRoute(input: DeleteGatewayRouteInput, completion: @escaping (SdkResult<DeleteGatewayRouteOutputResponse, DeleteGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        guard let gatewayRouteName = input.gatewayRouteName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component gatewayRouteName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes/\(gatewayRouteName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteGatewayRouteInput, DeleteGatewayRouteOutputResponse, DeleteGatewayRouteOutputError>(id: "deleteGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteGatewayRouteInput, DeleteGatewayRouteOutputResponse, DeleteGatewayRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing service mesh.</p>
    ///          <p>You must delete all resources (virtual services, routes, virtual routers, and virtual
    ///          nodes) in the service mesh before you can delete the mesh itself.</p>
    public func deleteMesh(input: DeleteMeshInput, completion: @escaping (SdkResult<DeleteMeshOutputResponse, DeleteMeshOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteMeshInput, DeleteMeshOutputResponse, DeleteMeshOutputError>(id: "deleteMesh")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteMeshInput, DeleteMeshOutputResponse, DeleteMeshOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing route.</p>
    public func deleteRoute(input: DeleteRouteInput, completion: @escaping (SdkResult<DeleteRouteOutputResponse, DeleteRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        guard let routeName = input.routeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes/\(routeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteRouteInput, DeleteRouteOutputResponse, DeleteRouteOutputError>(id: "deleteRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteRouteInput, DeleteRouteOutputResponse, DeleteRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing virtual gateway. You cannot delete a virtual gateway if any gateway
    ///          routes are associated to it.</p>
    public func deleteVirtualGateway(input: DeleteVirtualGatewayInput, completion: @escaping (SdkResult<DeleteVirtualGatewayOutputResponse, DeleteVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways/\(virtualGatewayName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualGatewayInput, DeleteVirtualGatewayOutputResponse, DeleteVirtualGatewayOutputError>(id: "deleteVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteVirtualGatewayInput, DeleteVirtualGatewayOutputResponse, DeleteVirtualGatewayOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing virtual node.</p>
    ///          <p>You must delete any virtual services that list a virtual node as a service provider
    ///          before you can delete the virtual node itself.</p>
    public func deleteVirtualNode(input: DeleteVirtualNodeInput, completion: @escaping (SdkResult<DeleteVirtualNodeOutputResponse, DeleteVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualNodeName = input.virtualNodeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualNodeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes/\(virtualNodeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualNodeInput, DeleteVirtualNodeOutputResponse, DeleteVirtualNodeOutputError>(id: "deleteVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteVirtualNodeInput, DeleteVirtualNodeOutputResponse, DeleteVirtualNodeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing virtual router.</p>
    ///          <p>You must delete any routes associated with the virtual router before you can delete the
    ///          router itself.</p>
    public func deleteVirtualRouter(input: DeleteVirtualRouterInput, completion: @escaping (SdkResult<DeleteVirtualRouterOutputResponse, DeleteVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters/\(virtualRouterName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualRouterInput, DeleteVirtualRouterOutputResponse, DeleteVirtualRouterOutputError>(id: "deleteVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteVirtualRouterInput, DeleteVirtualRouterOutputResponse, DeleteVirtualRouterOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an existing virtual service.</p>
    public func deleteVirtualService(input: DeleteVirtualServiceInput, completion: @escaping (SdkResult<DeleteVirtualServiceOutputResponse, DeleteVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualServiceName = input.virtualServiceName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualServiceName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices/\(virtualServiceName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteVirtualServiceInput, DeleteVirtualServiceOutputResponse, DeleteVirtualServiceOutputError>(id: "deleteVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteVirtualServiceInput, DeleteVirtualServiceOutputResponse, DeleteVirtualServiceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an existing gateway route.</p>
    public func describeGatewayRoute(input: DescribeGatewayRouteInput, completion: @escaping (SdkResult<DescribeGatewayRouteOutputResponse, DescribeGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        guard let gatewayRouteName = input.gatewayRouteName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component gatewayRouteName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes/\(gatewayRouteName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeGatewayRouteInput, DescribeGatewayRouteOutputResponse, DescribeGatewayRouteOutputError>(id: "describeGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeGatewayRouteInput, DescribeGatewayRouteOutputResponse, DescribeGatewayRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an existing service mesh.</p>
    public func describeMesh(input: DescribeMeshInput, completion: @escaping (SdkResult<DescribeMeshOutputResponse, DescribeMeshOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeMeshInput, DescribeMeshOutputResponse, DescribeMeshOutputError>(id: "describeMesh")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeMeshInput, DescribeMeshOutputResponse, DescribeMeshOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an existing route.</p>
    public func describeRoute(input: DescribeRouteInput, completion: @escaping (SdkResult<DescribeRouteOutputResponse, DescribeRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        guard let routeName = input.routeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes/\(routeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeRouteInput, DescribeRouteOutputResponse, DescribeRouteOutputError>(id: "describeRoute")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeRouteInput, DescribeRouteOutputResponse, DescribeRouteOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an existing virtual gateway.</p>
    public func describeVirtualGateway(input: DescribeVirtualGatewayInput, completion: @escaping (SdkResult<DescribeVirtualGatewayOutputResponse, DescribeVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways/\(virtualGatewayName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualGatewayInput, DescribeVirtualGatewayOutputResponse, DescribeVirtualGatewayOutputError>(id: "describeVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeVirtualGatewayInput, DescribeVirtualGatewayOutputResponse, DescribeVirtualGatewayOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an existing virtual node.</p>
    public func describeVirtualNode(input: DescribeVirtualNodeInput, completion: @escaping (SdkResult<DescribeVirtualNodeOutputResponse, DescribeVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualNodeName = input.virtualNodeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualNodeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes/\(virtualNodeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualNodeInput, DescribeVirtualNodeOutputResponse, DescribeVirtualNodeOutputError>(id: "describeVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeVirtualNodeInput, DescribeVirtualNodeOutputResponse, DescribeVirtualNodeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an existing virtual router.</p>
    public func describeVirtualRouter(input: DescribeVirtualRouterInput, completion: @escaping (SdkResult<DescribeVirtualRouterOutputResponse, DescribeVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters/\(virtualRouterName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualRouterInput, DescribeVirtualRouterOutputResponse, DescribeVirtualRouterOutputError>(id: "describeVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeVirtualRouterInput, DescribeVirtualRouterOutputResponse, DescribeVirtualRouterOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Describes an existing virtual service.</p>
    public func describeVirtualService(input: DescribeVirtualServiceInput, completion: @escaping (SdkResult<DescribeVirtualServiceOutputResponse, DescribeVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualServiceName = input.virtualServiceName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualServiceName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices/\(virtualServiceName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "describeVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DescribeVirtualServiceInput, DescribeVirtualServiceOutputResponse, DescribeVirtualServiceOutputError>(id: "describeVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DescribeVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DescribeVirtualServiceInput, DescribeVirtualServiceOutputResponse, DescribeVirtualServiceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing gateway routes that are associated to a virtual
    ///          gateway.</p>
    public func listGatewayRoutes(input: ListGatewayRoutesInput, completion: @escaping (SdkResult<ListGatewayRoutesOutputResponse, ListGatewayRoutesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listGatewayRoutes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListGatewayRoutesInput, ListGatewayRoutesOutputResponse, ListGatewayRoutesOutputError>(id: "listGatewayRoutes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListGatewayRoutesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListGatewayRoutesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListGatewayRoutesInput, ListGatewayRoutesOutputResponse, ListGatewayRoutesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing service meshes.</p>
    public func listMeshes(input: ListMeshesInput, completion: @escaping (SdkResult<ListMeshesOutputResponse, ListMeshesOutputError>) -> Void)
    {
        let urlPath = "/v20190125/meshes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listMeshes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListMeshesInput, ListMeshesOutputResponse, ListMeshesOutputError>(id: "listMeshes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListMeshesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListMeshesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListMeshesInput, ListMeshesOutputResponse, ListMeshesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing routes in a service mesh.</p>
    public func listRoutes(input: ListRoutesInput, completion: @escaping (SdkResult<ListRoutesOutputResponse, ListRoutesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listRoutes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListRoutesInput, ListRoutesOutputResponse, ListRoutesOutputError>(id: "listRoutes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListRoutesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListRoutesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListRoutesInput, ListRoutesOutputResponse, ListRoutesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>List the tags for an App Mesh resource.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        let urlPath = "/v20190125/tags"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing virtual gateways in a service mesh.</p>
    public func listVirtualGateways(input: ListVirtualGatewaysInput, completion: @escaping (SdkResult<ListVirtualGatewaysOutputResponse, ListVirtualGatewaysOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualGateways")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualGatewaysInput, ListVirtualGatewaysOutputResponse, ListVirtualGatewaysOutputError>(id: "listVirtualGateways")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualGatewaysInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualGatewaysInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVirtualGatewaysInput, ListVirtualGatewaysOutputResponse, ListVirtualGatewaysOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing virtual nodes.</p>
    public func listVirtualNodes(input: ListVirtualNodesInput, completion: @escaping (SdkResult<ListVirtualNodesOutputResponse, ListVirtualNodesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualNodes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualNodesInput, ListVirtualNodesOutputResponse, ListVirtualNodesOutputError>(id: "listVirtualNodes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualNodesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualNodesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVirtualNodesInput, ListVirtualNodesOutputResponse, ListVirtualNodesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing virtual routers in a service mesh.</p>
    public func listVirtualRouters(input: ListVirtualRoutersInput, completion: @escaping (SdkResult<ListVirtualRoutersOutputResponse, ListVirtualRoutersOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualRouters")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualRoutersInput, ListVirtualRoutersOutputResponse, ListVirtualRoutersOutputError>(id: "listVirtualRouters")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualRoutersInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualRoutersInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVirtualRoutersInput, ListVirtualRoutersOutputResponse, ListVirtualRoutersOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of existing virtual services in a service mesh.</p>
    public func listVirtualServices(input: ListVirtualServicesInput, completion: @escaping (SdkResult<ListVirtualServicesOutputResponse, ListVirtualServicesOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listVirtualServices")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListVirtualServicesInput, ListVirtualServicesOutputResponse, ListVirtualServicesOutputError>(id: "listVirtualServices")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualServicesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListVirtualServicesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListVirtualServicesInput, ListVirtualServicesOutputResponse, ListVirtualServicesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Associates the specified tags to a resource with the specified <code>resourceArn</code>.
    ///          If existing tags on a resource aren't specified in the request parameters, they aren't
    ///          changed. When a resource is deleted, the tags associated with that resource are also
    ///          deleted.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        let urlPath = "/v20190125/tag"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes specified tags from a resource.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        let urlPath = "/v20190125/untag"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing gateway route that is associated to a specified virtual gateway in a
    ///          service mesh.</p>
    public func updateGatewayRoute(input: UpdateGatewayRouteInput, completion: @escaping (SdkResult<UpdateGatewayRouteOutputResponse, UpdateGatewayRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        guard let gatewayRouteName = input.gatewayRouteName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component gatewayRouteName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateway/\(virtualGatewayName)/gatewayRoutes/\(gatewayRouteName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateGatewayRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateGatewayRouteInput, UpdateGatewayRouteOutputResponse, UpdateGatewayRouteOutputError>(id: "updateGatewayRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateGatewayRouteOutputResponse>, SdkError<UpdateGatewayRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateGatewayRouteInput, UpdateGatewayRouteOutputResponse, UpdateGatewayRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateGatewayRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing service mesh.</p>
    public func updateMesh(input: UpdateMeshInput, completion: @escaping (SdkResult<UpdateMeshOutputResponse, UpdateMeshOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateMesh")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateMeshInput, UpdateMeshOutputResponse, UpdateMeshOutputError>(id: "updateMesh")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateMeshOutputResponse>, SdkError<UpdateMeshOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateMeshInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateMeshInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateMeshInput, UpdateMeshOutputResponse, UpdateMeshOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateMeshInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing route for a specified service mesh and virtual router.</p>
    public func updateRoute(input: UpdateRouteInput, completion: @escaping (SdkResult<UpdateRouteOutputResponse, UpdateRouteOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        guard let routeName = input.routeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component routeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouter/\(virtualRouterName)/routes/\(routeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateRoute")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateRouteInput, UpdateRouteOutputResponse, UpdateRouteOutputError>(id: "updateRoute")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateRouteOutputResponse>, SdkError<UpdateRouteOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateRouteInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateRouteInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateRouteInput, UpdateRouteOutputResponse, UpdateRouteOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateRouteInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing virtual gateway in a specified service mesh.</p>
    public func updateVirtualGateway(input: UpdateVirtualGatewayInput, completion: @escaping (SdkResult<UpdateVirtualGatewayOutputResponse, UpdateVirtualGatewayOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualGatewayName = input.virtualGatewayName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualGatewayName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualGateways/\(virtualGatewayName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualGateway")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualGatewayInput, UpdateVirtualGatewayOutputResponse, UpdateVirtualGatewayOutputError>(id: "updateVirtualGateway")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateVirtualGatewayOutputResponse>, SdkError<UpdateVirtualGatewayOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualGatewayInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualGatewayInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateVirtualGatewayInput, UpdateVirtualGatewayOutputResponse, UpdateVirtualGatewayOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualGatewayInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing virtual node in a specified service mesh.</p>
    public func updateVirtualNode(input: UpdateVirtualNodeInput, completion: @escaping (SdkResult<UpdateVirtualNodeOutputResponse, UpdateVirtualNodeOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualNodeName = input.virtualNodeName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualNodeName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualNodes/\(virtualNodeName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualNode")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualNodeInput, UpdateVirtualNodeOutputResponse, UpdateVirtualNodeOutputError>(id: "updateVirtualNode")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateVirtualNodeOutputResponse>, SdkError<UpdateVirtualNodeOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualNodeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualNodeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateVirtualNodeInput, UpdateVirtualNodeOutputResponse, UpdateVirtualNodeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualNodeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing virtual router in a specified service mesh.</p>
    public func updateVirtualRouter(input: UpdateVirtualRouterInput, completion: @escaping (SdkResult<UpdateVirtualRouterOutputResponse, UpdateVirtualRouterOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualRouterName = input.virtualRouterName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualRouterName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualRouters/\(virtualRouterName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualRouter")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualRouterInput, UpdateVirtualRouterOutputResponse, UpdateVirtualRouterOutputError>(id: "updateVirtualRouter")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateVirtualRouterOutputResponse>, SdkError<UpdateVirtualRouterOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualRouterInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualRouterInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateVirtualRouterInput, UpdateVirtualRouterOutputResponse, UpdateVirtualRouterOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualRouterInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Updates an existing virtual service in a specified service mesh.</p>
    public func updateVirtualService(input: UpdateVirtualServiceInput, completion: @escaping (SdkResult<UpdateVirtualServiceOutputResponse, UpdateVirtualServiceOutputError>) -> Void)
    {
        guard let meshName = input.meshName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component meshName unexpectedly nil"))))
            return
        }
        guard let virtualServiceName = input.virtualServiceName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component virtualServiceName unexpectedly nil"))))
            return
        }
        let urlPath = "/v20190125/meshes/\(meshName)/virtualServices/\(virtualServiceName)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "updateVirtualService")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "appmesh.\(config.region).amazonaws.com")
                      .withSigningName(value: "appmesh")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UpdateVirtualServiceInput, UpdateVirtualServiceOutputResponse, UpdateVirtualServiceOutputError>(id: "updateVirtualService")
        operation.addDefaultOperationMiddlewares()
        operation.initializeStep.intercept(position: .before, id: "IdempotencyTokenMiddleware") { (context, input, next) -> Result<OperationOutput<UpdateVirtualServiceOutputResponse>, SdkError<UpdateVirtualServiceOutputError>> in
            let idempotencyTokenGenerator = context.getIdempotencyTokenGenerator()
            var copiedInput = input
            if input.clientToken == nil {
                copiedInput.clientToken = idempotencyTokenGenerator.generateToken()
            }
            return next.handle(context: context, input: copiedInput)
        }
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualServiceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualServiceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UpdateVirtualServiceInput, UpdateVirtualServiceOutputResponse, UpdateVirtualServiceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: UpdateVirtualServiceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
