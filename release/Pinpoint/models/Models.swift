// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ADMChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientId = "ClientId"
        case clientSecret = "ClientSecret"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientId = clientId {
            try encodeContainer.encode(clientId, forKey: .clientId)
        }
        if let clientSecret = clientSecret {
            try encodeContainer.encode(clientSecret, forKey: .clientSecret)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientId)
        clientId = clientIdDecoded
        let clientSecretDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSecret)
        clientSecret = clientSecretDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension ADMChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ADMChannelRequest(clientId: \(String(describing: clientId)), clientSecret: \(String(describing: clientSecret)), enabled: \(String(describing: enabled)))"}
}

/// <p>Specifies the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
public struct ADMChannelRequest: Equatable {
    /// <p>The Client ID that you received from Amazon to send messages by using ADM.</p>
    public let clientId: String?
    /// <p>The Client Secret that you received from Amazon to send messages by using ADM.</p>
    public let clientSecret: String?
    /// <p>Specifies whether to enable the ADM channel for the application.</p>
    public let enabled: Bool

    public init (
        clientId: String? = nil,
        clientSecret: String? = nil,
        enabled: Bool = false
    )
    {
        self.clientId = clientId
        self.clientSecret = clientSecret
        self.enabled = enabled
    }
}

extension ADMChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension ADMChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ADMChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
public struct ADMChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the ADM channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time when the ADM channel was enabled.</p>
    public let creationDate: String?
    /// <p>Specifies whether the ADM channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>(Deprecated) An identifier for the ADM channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the ADM channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the ADM channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the ADM channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the ADM channel, this value is ADM.</p>
    public let platform: String?
    /// <p>The current version of the ADM channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

extension ADMMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case consolidationKey = "ConsolidationKey"
        case data = "Data"
        case expiresAfter = "ExpiresAfter"
        case iconReference = "IconReference"
        case imageIconUrl = "ImageIconUrl"
        case imageUrl = "ImageUrl"
        case mD5 = "MD5"
        case rawContent = "RawContent"
        case silentPush = "SilentPush"
        case smallImageIconUrl = "SmallImageIconUrl"
        case sound = "Sound"
        case substitutions = "Substitutions"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let consolidationKey = consolidationKey {
            try encodeContainer.encode(consolidationKey, forKey: .consolidationKey)
        }
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .data)
            for (dictKey0, mapof__string0) in data {
                try dataContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let expiresAfter = expiresAfter {
            try encodeContainer.encode(expiresAfter, forKey: .expiresAfter)
        }
        if let iconReference = iconReference {
            try encodeContainer.encode(iconReference, forKey: .iconReference)
        }
        if let imageIconUrl = imageIconUrl {
            try encodeContainer.encode(imageIconUrl, forKey: .imageIconUrl)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let mD5 = mD5 {
            try encodeContainer.encode(mD5, forKey: .mD5)
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if silentPush != false {
            try encodeContainer.encode(silentPush, forKey: .silentPush)
        }
        if let smallImageIconUrl = smallImageIconUrl {
            try encodeContainer.encode(smallImageIconUrl, forKey: .smallImageIconUrl)
        }
        if let sound = sound {
            try encodeContainer.encode(sound, forKey: .sound)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let consolidationKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .consolidationKey)
        consolidationKey = consolidationKeyDecoded
        let dataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .data)
        var dataDecoded0: [String:String]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [String:String]()
            for (key0, __string0) in dataContainer {
                if let __string0 = __string0 {
                    dataDecoded0?[key0] = __string0
                }
            }
        }
        data = dataDecoded0
        let expiresAfterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .expiresAfter)
        expiresAfter = expiresAfterDecoded
        let iconReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iconReference)
        iconReference = iconReferenceDecoded
        let imageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageIconUrl)
        imageIconUrl = imageIconUrlDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let mD5Decoded = try containerValues.decodeIfPresent(String.self, forKey: .mD5)
        mD5 = mD5Decoded
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let silentPushDecoded = try containerValues.decode(Bool.self, forKey: .silentPush)
        silentPush = silentPushDecoded
        let smallImageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smallImageIconUrl)
        smallImageIconUrl = smallImageIconUrlDecoded
        let soundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sound)
        sound = soundDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension ADMMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ADMMessage(action: \(String(describing: action)), body: \(String(describing: body)), consolidationKey: \(String(describing: consolidationKey)), data: \(String(describing: data)), expiresAfter: \(String(describing: expiresAfter)), iconReference: \(String(describing: iconReference)), imageIconUrl: \(String(describing: imageIconUrl)), imageUrl: \(String(describing: imageUrl)), mD5: \(String(describing: mD5)), rawContent: \(String(describing: rawContent)), silentPush: \(String(describing: silentPush)), smallImageIconUrl: \(String(describing: smallImageIconUrl)), sound: \(String(describing: sound)), substitutions: \(String(describing: substitutions)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the ADM (Amazon Device Messaging) channel.</p>
public struct ADMMessage: Equatable {
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The body of the notification message.</p>
    public let body: String?
    /// <p>An arbitrary string that indicates that multiple messages are logically the same and that Amazon Device Messaging (ADM) can drop previously enqueued messages in favor of this message.</p>
    public let consolidationKey: String?
    /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    public let data: [String:String]?
    /// <p>The amount of time, in seconds, that ADM should store the message if the recipient's device is offline. Amazon Pinpoint specifies this value in the expiresAfter parameter when it sends the notification message to ADM.</p>
    public let expiresAfter: String?
    /// <p>The icon image name of the asset saved in your app.</p>
    public let iconReference: String?
    /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
    public let imageIconUrl: String?
    /// <p>The URL of an image to display in the push notification.</p>
    public let imageUrl: String?
    /// <p>The base64-encoded, MD5 checksum of the value specified by the Data property. ADM uses the MD5 value to verify the integrity of the data.</p>
    public let mD5: String?
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    public let rawContent: String?
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
    public let silentPush: Bool
    /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
    public let smallImageIconUrl: String?
    /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    public let sound: String?
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The title to display above the notification message on the recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        consolidationKey: String? = nil,
        data: [String:String]? = nil,
        expiresAfter: String? = nil,
        iconReference: String? = nil,
        imageIconUrl: String? = nil,
        imageUrl: String? = nil,
        mD5: String? = nil,
        rawContent: String? = nil,
        silentPush: Bool = false,
        smallImageIconUrl: String? = nil,
        sound: String? = nil,
        substitutions: [String:[String]]? = nil,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.consolidationKey = consolidationKey
        self.data = data
        self.expiresAfter = expiresAfter
        self.iconReference = iconReference
        self.imageIconUrl = imageIconUrl
        self.imageUrl = imageUrl
        self.mD5 = mD5
        self.rawContent = rawContent
        self.silentPush = silentPush
        self.smallImageIconUrl = smallImageIconUrl
        self.sound = sound
        self.substitutions = substitutions
        self.title = title
        self.url = url
    }
}

extension APNSChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case certificate = "Certificate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case privateKey = "PrivateKey"
        case teamId = "TeamId"
        case tokenKey = "TokenKey"
        case tokenKeyId = "TokenKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let teamId = teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let tokenKey = tokenKey {
            try encodeContainer.encode(tokenKey, forKey: .tokenKey)
        }
        if let tokenKeyId = tokenKeyId {
            try encodeContainer.encode(tokenKeyId, forKey: .tokenKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let tokenKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKey)
        tokenKey = tokenKeyDecoded
        let tokenKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKeyId)
        tokenKeyId = tokenKeyIdDecoded
    }
}

extension APNSChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSChannelRequest(bundleId: \(String(describing: bundleId)), certificate: \(String(describing: certificate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), privateKey: \(String(describing: privateKey)), teamId: \(String(describing: teamId)), tokenKey: \(String(describing: tokenKey)), tokenKeyId: \(String(describing: tokenKeyId)))"}
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
public struct APNSChannelRequest: Equatable {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    public let bundleId: String?
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
    public let certificate: String?
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether to enable the APNs channel for the application.</p>
    public let enabled: Bool
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
    public let privateKey: String?
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    public let teamId: String?
    /// <p>The authentication key to use for APNs tokens.</p>
    public let tokenKey: String?
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
    public let tokenKeyId: String?

    public init (
        bundleId: String? = nil,
        certificate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        privateKey: String? = nil,
        teamId: String? = nil,
        tokenKey: String? = nil,
        tokenKeyId: String? = nil
    )
    {
        self.bundleId = bundleId
        self.certificate = certificate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.privateKey = privateKey
        self.teamId = teamId
        self.tokenKey = tokenKey
        self.tokenKeyId = tokenKeyId
    }
}

extension APNSChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case hasTokenKey = "HasTokenKey"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if hasTokenKey != false {
            try encodeContainer.encode(hasTokenKey, forKey: .hasTokenKey)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let hasTokenKeyDecoded = try containerValues.decode(Bool.self, forKey: .hasTokenKey)
        hasTokenKey = hasTokenKeyDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension APNSChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), hasTokenKey: \(String(describing: hasTokenKey)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
public struct APNSChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the APNs channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time when the APNs channel was enabled.</p>
    public let creationDate: String?
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether the APNs channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>Specifies whether the APNs channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    public let hasTokenKey: Bool
    /// <p>(Deprecated) An identifier for the APNs channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the APNs channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the APNs channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the APNs channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the APNs channel, this value is APNS.</p>
    public let platform: String?
    /// <p>The current version of the APNs channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        hasTokenKey: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.hasTokenKey = hasTokenKey
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

extension APNSMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aPNSPushType = "APNSPushType"
        case action = "Action"
        case badge = "Badge"
        case body = "Body"
        case category = "Category"
        case collapseId = "CollapseId"
        case data = "Data"
        case mediaUrl = "MediaUrl"
        case preferredAuthenticationMethod = "PreferredAuthenticationMethod"
        case priority = "Priority"
        case rawContent = "RawContent"
        case silentPush = "SilentPush"
        case sound = "Sound"
        case substitutions = "Substitutions"
        case threadId = "ThreadId"
        case timeToLive = "TimeToLive"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aPNSPushType = aPNSPushType {
            try encodeContainer.encode(aPNSPushType, forKey: .aPNSPushType)
        }
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if badge != 0 {
            try encodeContainer.encode(badge, forKey: .badge)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let category = category {
            try encodeContainer.encode(category, forKey: .category)
        }
        if let collapseId = collapseId {
            try encodeContainer.encode(collapseId, forKey: .collapseId)
        }
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .data)
            for (dictKey0, mapof__string0) in data {
                try dataContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let mediaUrl = mediaUrl {
            try encodeContainer.encode(mediaUrl, forKey: .mediaUrl)
        }
        if let preferredAuthenticationMethod = preferredAuthenticationMethod {
            try encodeContainer.encode(preferredAuthenticationMethod, forKey: .preferredAuthenticationMethod)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if silentPush != false {
            try encodeContainer.encode(silentPush, forKey: .silentPush)
        }
        if let sound = sound {
            try encodeContainer.encode(sound, forKey: .sound)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let threadId = threadId {
            try encodeContainer.encode(threadId, forKey: .threadId)
        }
        if timeToLive != 0 {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSPushTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aPNSPushType)
        aPNSPushType = aPNSPushTypeDecoded
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let badgeDecoded = try containerValues.decode(Int.self, forKey: .badge)
        badge = badgeDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .category)
        category = categoryDecoded
        let collapseIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .collapseId)
        collapseId = collapseIdDecoded
        let dataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .data)
        var dataDecoded0: [String:String]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [String:String]()
            for (key0, __string0) in dataContainer {
                if let __string0 = __string0 {
                    dataDecoded0?[key0] = __string0
                }
            }
        }
        data = dataDecoded0
        let mediaUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaUrl)
        mediaUrl = mediaUrlDecoded
        let preferredAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredAuthenticationMethod)
        preferredAuthenticationMethod = preferredAuthenticationMethodDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .priority)
        priority = priorityDecoded
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let silentPushDecoded = try containerValues.decode(Bool.self, forKey: .silentPush)
        silentPush = silentPushDecoded
        let soundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sound)
        sound = soundDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let threadIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .threadId)
        threadId = threadIdDecoded
        let timeToLiveDecoded = try containerValues.decode(Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension APNSMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSMessage(aPNSPushType: \(String(describing: aPNSPushType)), action: \(String(describing: action)), badge: \(String(describing: badge)), body: \(String(describing: body)), category: \(String(describing: category)), collapseId: \(String(describing: collapseId)), data: \(String(describing: data)), mediaUrl: \(String(describing: mediaUrl)), preferredAuthenticationMethod: \(String(describing: preferredAuthenticationMethod)), priority: \(String(describing: priority)), rawContent: \(String(describing: rawContent)), silentPush: \(String(describing: silentPush)), sound: \(String(describing: sound)), substitutions: \(String(describing: substitutions)), threadId: \(String(describing: threadId)), timeToLive: \(String(describing: timeToLive)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the APNs (Apple Push Notification service) channel.</p>
public struct APNSMessage: Equatable {
    /// <p>The type of push notification to send. Valid values are:</p> <ul><li><p>alert - For a standard notification that's displayed on recipients' devices and prompts a recipient to interact with the notification.</p></li> <li><p>background - For a silent notification that delivers content in the background and isn't displayed on recipients' devices.</p></li> <li><p>complication - For a notification that contains update information for an app’s complication timeline.</p></li> <li><p>fileprovider - For a notification that signals changes to a File Provider extension.</p></li> <li><p>mdm - For a notification that tells managed devices to contact the MDM server.</p></li> <li><p>voip - For a notification that provides information about an incoming VoIP call.</p></li></ul> <p>Amazon Pinpoint specifies this value in the apns-push-type request header when it sends the notification message to APNs. If you don't specify a value for this property, Amazon Pinpoint sets the value to alert or background automatically, based on the value that you specify for the SilentPush or RawContent property of the message.</p> <p>For more information about the apns-push-type request header, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns">Sending Notification Requests to APNs</a> on the Apple Developer website.</p>
    public let aPNSPushType: String?
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The key that indicates whether and how to modify the badge of your app's icon when the recipient receives the push notification. If this key isn't included in the dictionary, the badge doesn't change. To remove the badge, set this value to 0.</p>
    public let badge: Int
    /// <p>The body of the notification message.</p>
    public let body: String?
    /// <p>The key that indicates the notification type for the push notification. This key is a value that's defined by the identifier property of one of your app's registered categories.</p>
    public let category: String?
    /// <p>An arbitrary identifier that, if assigned to multiple messages, APNs uses to coalesce the messages into a single push notification instead of delivering each message individually. This value can't exceed 64 bytes.</p> <p>Amazon Pinpoint specifies this value in the apns-collapse-id request header when it sends the notification message to APNs.</p>
    public let collapseId: String?
    /// <p>The JSON payload to use for a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    public let data: [String:String]?
    /// <p>The URL of an image or video to display in the push notification.</p>
    public let mediaUrl: String?
    /// <p>The authentication method that you want Amazon Pinpoint to use when authenticating with APNs, CERTIFICATE or TOKEN.</p>
    public let preferredAuthenticationMethod: String?
    /// <p>para>5 - Low priority, the notification might be delayed, delivered as part of a group, or throttled.</p>/listitem> <li><p>10 - High priority, the notification is sent immediately. This is the default value. A high priority notification should trigger an alert, play a sound, or badge your app's icon on the recipient's device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the apns-priority request header when it sends the notification message to APNs.</p> <p>The equivalent values for Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), are normal, for 5, and high, for 10. If you specify an FCM value for this property, Amazon Pinpoint accepts and converts the value to the corresponding APNs value.</p>
    public let priority: String?
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. The value of the content-available key has to be an integer, and can only be 0 or 1. If you're sending a standard notification, set the value of content-available to 0. If you're sending a silent (background) notification, set the value of content-available to 1. Additionally, silent notification payloads can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p></note>
    public let rawContent: String?
    /// <p>Specifies whether the notification is a silent push notification. A silent (or background) push notification isn't displayed on recipients' devices. You can use silent push notifications to make small updates to your app, or to display messages in an in-app message center.</p> <p>Amazon Pinpoint uses this property to determine the correct value for the apns-push-type request header when it sends the notification message to APNs. If you specify a value of true for this property, Amazon Pinpoint sets the value for the apns-push-type header field to background.</p> <note><p>If you specify the raw content of an APNs push notification, the message payload has to include the content-available key. For silent (background) notifications, set the value of content-available to 1. Additionally, the message payload for a silent notification can't include the alert, badge, or sound keys. For more information, see <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/generating_a_remote_notification">Generating a Remote Notification</a> and <a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app">Pushing Background Updates to Your App</a> on the Apple Developer website.</p> <p>Apple has indicated that they will throttle "excessive" background notifications based on current traffic volumes. To prevent your notifications being throttled, Apple recommends that you send no more than 3 silent push notifications to each recipient per hour.</p></note>
    public let silentPush: Bool
    /// <p>The key for the sound to play when the recipient receives the push notification. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
    public let sound: String?
    /// <p>The default message variables to use in the notification message. You can override these default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The key that represents your app-specific identifier for grouping notifications. If you provide a Notification Content app extension, you can use this value to group your notifications together.</p>
    public let threadId: String?
    /// <p>The amount of time, in seconds, that APNs should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If this value is 0, APNs treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>Amazon Pinpoint specifies this value in the apns-expiration request header when it sends the notification message to APNs.</p>
    public let timeToLive: Int
    /// <p>The title to display above the notification message on the recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        aPNSPushType: String? = nil,
        action: Action? = nil,
        badge: Int = 0,
        body: String? = nil,
        category: String? = nil,
        collapseId: String? = nil,
        data: [String:String]? = nil,
        mediaUrl: String? = nil,
        preferredAuthenticationMethod: String? = nil,
        priority: String? = nil,
        rawContent: String? = nil,
        silentPush: Bool = false,
        sound: String? = nil,
        substitutions: [String:[String]]? = nil,
        threadId: String? = nil,
        timeToLive: Int = 0,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.aPNSPushType = aPNSPushType
        self.action = action
        self.badge = badge
        self.body = body
        self.category = category
        self.collapseId = collapseId
        self.data = data
        self.mediaUrl = mediaUrl
        self.preferredAuthenticationMethod = preferredAuthenticationMethod
        self.priority = priority
        self.rawContent = rawContent
        self.silentPush = silentPush
        self.sound = sound
        self.substitutions = substitutions
        self.threadId = threadId
        self.timeToLive = timeToLive
        self.title = title
        self.url = url
    }
}

extension APNSPushNotificationTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case mediaUrl = "MediaUrl"
        case rawContent = "RawContent"
        case sound = "Sound"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let mediaUrl = mediaUrl {
            try encodeContainer.encode(mediaUrl, forKey: .mediaUrl)
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if let sound = sound {
            try encodeContainer.encode(sound, forKey: .sound)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let mediaUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaUrl)
        mediaUrl = mediaUrlDecoded
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let soundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sound)
        sound = soundDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension APNSPushNotificationTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSPushNotificationTemplate(action: \(String(describing: action)), body: \(String(describing: body)), mediaUrl: \(String(describing: mediaUrl)), rawContent: \(String(describing: rawContent)), sound: \(String(describing: sound)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies channel-specific content and settings for a message template that can be used in push notifications that are sent through the APNs (Apple Push Notification service) channel.</p>
public struct APNSPushNotificationTemplate: Equatable {
    /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The message body to use in push notifications that are based on the message template.</p>
    public let body: String?
    /// <p>The URL of an image or video to display in push notifications that are based on the message template.</p>
    public let mediaUrl: String?
    /// <p>The raw, JSON-formatted string to use as the payload for push notifications that are based on the message template. If specified, this value overrides all other content for the message template.</p>
    public let rawContent: String?
    /// <p>The key for the sound to play when the recipient receives a push notification that's based on the message template. The value for this key is the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
    public let sound: String?
    /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        mediaUrl: String? = nil,
        rawContent: String? = nil,
        sound: String? = nil,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.mediaUrl = mediaUrl
        self.rawContent = rawContent
        self.sound = sound
        self.title = title
        self.url = url
    }
}

extension APNSSandboxChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case certificate = "Certificate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case privateKey = "PrivateKey"
        case teamId = "TeamId"
        case tokenKey = "TokenKey"
        case tokenKeyId = "TokenKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let teamId = teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let tokenKey = tokenKey {
            try encodeContainer.encode(tokenKey, forKey: .tokenKey)
        }
        if let tokenKeyId = tokenKeyId {
            try encodeContainer.encode(tokenKeyId, forKey: .tokenKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let tokenKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKey)
        tokenKey = tokenKeyDecoded
        let tokenKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKeyId)
        tokenKeyId = tokenKeyIdDecoded
    }
}

extension APNSSandboxChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSSandboxChannelRequest(bundleId: \(String(describing: bundleId)), certificate: \(String(describing: certificate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), privateKey: \(String(describing: privateKey)), teamId: \(String(describing: teamId)), tokenKey: \(String(describing: tokenKey)), tokenKeyId: \(String(describing: tokenKeyId)))"}
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
public struct APNSSandboxChannelRequest: Equatable {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    public let bundleId: String?
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
    public let certificate: String?
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether to enable the APNs sandbox channel for the application.</p>
    public let enabled: Bool
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
    public let privateKey: String?
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    public let teamId: String?
    /// <p>The authentication key to use for APNs tokens.</p>
    public let tokenKey: String?
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
    public let tokenKeyId: String?

    public init (
        bundleId: String? = nil,
        certificate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        privateKey: String? = nil,
        teamId: String? = nil,
        tokenKey: String? = nil,
        tokenKeyId: String? = nil
    )
    {
        self.bundleId = bundleId
        self.certificate = certificate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.privateKey = privateKey
        self.teamId = teamId
        self.tokenKey = tokenKey
        self.tokenKeyId = tokenKeyId
    }
}

extension APNSSandboxChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case hasTokenKey = "HasTokenKey"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if hasTokenKey != false {
            try encodeContainer.encode(hasTokenKey, forKey: .hasTokenKey)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let hasTokenKeyDecoded = try containerValues.decode(Bool.self, forKey: .hasTokenKey)
        hasTokenKey = hasTokenKeyDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension APNSSandboxChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSSandboxChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), hasTokenKey: \(String(describing: hasTokenKey)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
public struct APNSSandboxChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the APNs sandbox channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time when the APNs sandbox channel was enabled.</p>
    public let creationDate: String?
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether the APNs sandbox channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>Specifies whether the APNs sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    public let hasTokenKey: Bool
    /// <p>(Deprecated) An identifier for the APNs sandbox channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the APNs sandbox channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the APNs sandbox channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the APNs sandbox channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the APNs sandbox channel, this value is APNS_SANDBOX.</p>
    public let platform: String?
    /// <p>The current version of the APNs sandbox channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        hasTokenKey: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.hasTokenKey = hasTokenKey
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

extension APNSVoipChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case certificate = "Certificate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case privateKey = "PrivateKey"
        case teamId = "TeamId"
        case tokenKey = "TokenKey"
        case tokenKeyId = "TokenKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let teamId = teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let tokenKey = tokenKey {
            try encodeContainer.encode(tokenKey, forKey: .tokenKey)
        }
        if let tokenKeyId = tokenKeyId {
            try encodeContainer.encode(tokenKeyId, forKey: .tokenKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let tokenKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKey)
        tokenKey = tokenKeyDecoded
        let tokenKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKeyId)
        tokenKeyId = tokenKeyIdDecoded
    }
}

extension APNSVoipChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSVoipChannelRequest(bundleId: \(String(describing: bundleId)), certificate: \(String(describing: certificate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), privateKey: \(String(describing: privateKey)), teamId: \(String(describing: teamId)), tokenKey: \(String(describing: tokenKey)), tokenKeyId: \(String(describing: tokenKeyId)))"}
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
public struct APNSVoipChannelRequest: Equatable {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    public let bundleId: String?
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with APNs by using an APNs certificate.</p>
    public let certificate: String?
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with APNs, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether to enable the APNs VoIP channel for the application.</p>
    public let enabled: Bool
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with APNs.</p>
    public let privateKey: String?
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    public let teamId: String?
    /// <p>The authentication key to use for APNs tokens.</p>
    public let tokenKey: String?
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with APNs by using APNs tokens.</p>
    public let tokenKeyId: String?

    public init (
        bundleId: String? = nil,
        certificate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        privateKey: String? = nil,
        teamId: String? = nil,
        tokenKey: String? = nil,
        tokenKeyId: String? = nil
    )
    {
        self.bundleId = bundleId
        self.certificate = certificate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.privateKey = privateKey
        self.teamId = teamId
        self.tokenKey = tokenKey
        self.tokenKeyId = tokenKeyId
    }
}

extension APNSVoipChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case hasTokenKey = "HasTokenKey"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if hasTokenKey != false {
            try encodeContainer.encode(hasTokenKey, forKey: .hasTokenKey)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let hasTokenKeyDecoded = try containerValues.decode(Bool.self, forKey: .hasTokenKey)
        hasTokenKey = hasTokenKeyDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension APNSVoipChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSVoipChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), hasTokenKey: \(String(describing: hasTokenKey)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
public struct APNSVoipChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the APNs VoIP channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time when the APNs VoIP channel was enabled.</p>
    public let creationDate: String?
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with APNs for this channel, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether the APNs VoIP channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>Specifies whether the APNs VoIP channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    public let hasTokenKey: Bool
    /// <p>(Deprecated) An identifier for the APNs VoIP channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the APNs VoIP channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the APNs VoIP channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the APNs VoIP channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP channel, this value is APNS_VOIP.</p>
    public let platform: String?
    /// <p>The current version of the APNs VoIP channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        hasTokenKey: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.hasTokenKey = hasTokenKey
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

extension APNSVoipSandboxChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bundleId = "BundleId"
        case certificate = "Certificate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case privateKey = "PrivateKey"
        case teamId = "TeamId"
        case tokenKey = "TokenKey"
        case tokenKeyId = "TokenKeyId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bundleId = bundleId {
            try encodeContainer.encode(bundleId, forKey: .bundleId)
        }
        if let certificate = certificate {
            try encodeContainer.encode(certificate, forKey: .certificate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let privateKey = privateKey {
            try encodeContainer.encode(privateKey, forKey: .privateKey)
        }
        if let teamId = teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let tokenKey = tokenKey {
            try encodeContainer.encode(tokenKey, forKey: .tokenKey)
        }
        if let tokenKeyId = tokenKeyId {
            try encodeContainer.encode(tokenKeyId, forKey: .tokenKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bundleIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bundleId)
        bundleId = bundleIdDecoded
        let certificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .certificate)
        certificate = certificateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let privateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateKey)
        privateKey = privateKeyDecoded
        let teamIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let tokenKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKey)
        tokenKey = tokenKeyDecoded
        let tokenKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tokenKeyId)
        tokenKeyId = tokenKeyIdDecoded
    }
}

extension APNSVoipSandboxChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSVoipSandboxChannelRequest(bundleId: \(String(describing: bundleId)), certificate: \(String(describing: certificate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), privateKey: \(String(describing: privateKey)), teamId: \(String(describing: teamId)), tokenKey: \(String(describing: tokenKey)), tokenKeyId: \(String(describing: tokenKeyId)))"}
}

/// <p>Specifies the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
public struct APNSVoipSandboxChannelRequest: Equatable {
    /// <p>The bundle identifier that's assigned to your iOS app. This identifier is used for APNs tokens.</p>
    public let bundleId: String?
    /// <p>The APNs client certificate that you received from Apple, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using an APNs certificate.</p>
    public let certificate: String?
    /// <p>The default authentication method that you want Amazon Pinpoint to use when authenticating with the APNs sandbox environment for this channel, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>The private key for the APNs client certificate that you want Amazon Pinpoint to use to communicate with the APNs sandbox environment.</p>
    public let privateKey: String?
    /// <p>The identifier that's assigned to your Apple developer account team. This identifier is used for APNs tokens.</p>
    public let teamId: String?
    /// <p>The authentication key to use for APNs tokens.</p>
    public let tokenKey: String?
    /// <p>The key identifier that's assigned to your APNs signing key, if you want Amazon Pinpoint to communicate with the APNs sandbox environment by using APNs tokens.</p>
    public let tokenKeyId: String?

    public init (
        bundleId: String? = nil,
        certificate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        privateKey: String? = nil,
        teamId: String? = nil,
        tokenKey: String? = nil,
        tokenKeyId: String? = nil
    )
    {
        self.bundleId = bundleId
        self.certificate = certificate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.privateKey = privateKey
        self.teamId = teamId
        self.tokenKey = tokenKey
        self.tokenKeyId = tokenKeyId
    }
}

extension APNSVoipSandboxChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case defaultAuthenticationMethod = "DefaultAuthenticationMethod"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case hasTokenKey = "HasTokenKey"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultAuthenticationMethod = defaultAuthenticationMethod {
            try encodeContainer.encode(defaultAuthenticationMethod, forKey: .defaultAuthenticationMethod)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if hasTokenKey != false {
            try encodeContainer.encode(hasTokenKey, forKey: .hasTokenKey)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultAuthenticationMethodDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultAuthenticationMethod)
        defaultAuthenticationMethod = defaultAuthenticationMethodDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let hasTokenKeyDecoded = try containerValues.decode(Bool.self, forKey: .hasTokenKey)
        hasTokenKey = hasTokenKeyDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension APNSVoipSandboxChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "APNSVoipSandboxChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), defaultAuthenticationMethod: \(String(describing: defaultAuthenticationMethod)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), hasTokenKey: \(String(describing: hasTokenKey)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
public struct APNSVoipSandboxChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the APNs VoIP sandbox channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time when the APNs VoIP sandbox channel was enabled.</p>
    public let creationDate: String?
    /// <p>The default authentication method that Amazon Pinpoint uses to authenticate with the APNs sandbox environment for this channel, key or certificate.</p>
    public let defaultAuthenticationMethod: String?
    /// <p>Specifies whether the APNs VoIP sandbox channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>Specifies whether the APNs VoIP sandbox channel is configured to communicate with APNs by using APNs tokens. To provide an authentication key for APNs tokens, set the TokenKey property of the channel.</p>
    public let hasTokenKey: Bool
    /// <p>(Deprecated) An identifier for the APNs VoIP sandbox channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the APNs VoIP sandbox channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the APNs VoIP sandbox channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the APNs VoIP sandbox channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the APNs VoIP sandbox channel, this value is APNS_VOIP_SANDBOX.</p>
    public let platform: String?
    /// <p>The current version of the APNs VoIP sandbox channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        defaultAuthenticationMethod: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        hasTokenKey: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.defaultAuthenticationMethod = defaultAuthenticationMethod
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.hasTokenKey = hasTokenKey
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

public enum Action {
    case deepLink
    case openApp
    case url
    case sdkUnknown(String)
}

extension Action : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Action] {
        return [
            .deepLink,
            .openApp,
            .url,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deepLink: return "DEEP_LINK"
        case .openApp: return "OPEN_APP"
        case .url: return "URL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Action(rawValue: rawValue) ?? Action.sdkUnknown(rawValue)
    }
}

extension ActivitiesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofactivityresponse0 in item {
                try itemContainer.encode(listofactivityresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([ActivityResponse?].self, forKey: .item)
        var itemDecoded0:[ActivityResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [ActivityResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ActivitiesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivitiesResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about the activities that were performed by a campaign.</p>
public struct ActivitiesResponse: Equatable {
    /// <p>An array of responses, one for each activity that was performed by the campaign.</p>
    public let item: [ActivityResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [ActivityResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

extension Activity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cUSTOM = "CUSTOM"
        case conditionalSplit = "ConditionalSplit"
        case description = "Description"
        case eMAIL = "EMAIL"
        case holdout = "Holdout"
        case multiCondition = "MultiCondition"
        case pUSH = "PUSH"
        case randomSplit = "RandomSplit"
        case sMS = "SMS"
        case wait = "Wait"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cUSTOM = cUSTOM {
            try encodeContainer.encode(cUSTOM, forKey: .cUSTOM)
        }
        if let conditionalSplit = conditionalSplit {
            try encodeContainer.encode(conditionalSplit, forKey: .conditionalSplit)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eMAIL = eMAIL {
            try encodeContainer.encode(eMAIL, forKey: .eMAIL)
        }
        if let holdout = holdout {
            try encodeContainer.encode(holdout, forKey: .holdout)
        }
        if let multiCondition = multiCondition {
            try encodeContainer.encode(multiCondition, forKey: .multiCondition)
        }
        if let pUSH = pUSH {
            try encodeContainer.encode(pUSH, forKey: .pUSH)
        }
        if let randomSplit = randomSplit {
            try encodeContainer.encode(randomSplit, forKey: .randomSplit)
        }
        if let sMS = sMS {
            try encodeContainer.encode(sMS, forKey: .sMS)
        }
        if let wait = wait {
            try encodeContainer.encode(wait, forKey: .wait)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cUSTOMDecoded = try containerValues.decodeIfPresent(CustomMessageActivity.self, forKey: .cUSTOM)
        cUSTOM = cUSTOMDecoded
        let conditionalSplitDecoded = try containerValues.decodeIfPresent(ConditionalSplitActivity.self, forKey: .conditionalSplit)
        conditionalSplit = conditionalSplitDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eMAILDecoded = try containerValues.decodeIfPresent(EmailMessageActivity.self, forKey: .eMAIL)
        eMAIL = eMAILDecoded
        let holdoutDecoded = try containerValues.decodeIfPresent(HoldoutActivity.self, forKey: .holdout)
        holdout = holdoutDecoded
        let multiConditionDecoded = try containerValues.decodeIfPresent(MultiConditionalSplitActivity.self, forKey: .multiCondition)
        multiCondition = multiConditionDecoded
        let pUSHDecoded = try containerValues.decodeIfPresent(PushMessageActivity.self, forKey: .pUSH)
        pUSH = pUSHDecoded
        let randomSplitDecoded = try containerValues.decodeIfPresent(RandomSplitActivity.self, forKey: .randomSplit)
        randomSplit = randomSplitDecoded
        let sMSDecoded = try containerValues.decodeIfPresent(SMSMessageActivity.self, forKey: .sMS)
        sMS = sMSDecoded
        let waitDecoded = try containerValues.decodeIfPresent(WaitActivity.self, forKey: .wait)
        wait = waitDecoded
    }
}

extension Activity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Activity(cUSTOM: \(String(describing: cUSTOM)), conditionalSplit: \(String(describing: conditionalSplit)), description: \(String(describing: description)), eMAIL: \(String(describing: eMAIL)), holdout: \(String(describing: holdout)), multiCondition: \(String(describing: multiCondition)), pUSH: \(String(describing: pUSH)), randomSplit: \(String(describing: randomSplit)), sMS: \(String(describing: sMS)), wait: \(String(describing: wait)))"}
}

/// <p>Specifies the configuration and other settings for an activity in a journey.</p>
public struct Activity: Equatable {
    /// <p>The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.</p>
    public let cUSTOM: CustomMessageActivity?
    /// <p>The settings for a yes/no split activity. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify.</p>
    public let conditionalSplit: ConditionalSplitActivity?
    /// <p>The custom description of the activity.</p>
    public let description: String?
    /// <p>The settings for an email activity. This type of activity sends an email message to participants.</p>
    public let eMAIL: EmailMessageActivity?
    /// <p>The settings for a holdout activity. This type of activity stops a journey for a specified percentage of participants.</p>
    public let holdout: HoldoutActivity?
    /// <p>The settings for a multivariate split activity. This type of activity sends participants down one of as many as five paths (including a default <i>Else</i> path) in a journey, based on conditions that you specify.</p>
    public let multiCondition: MultiConditionalSplitActivity?
    /// <p>The settings for a push notification activity. This type of activity sends a push notification to participants.</p>
    public let pUSH: PushMessageActivity?
    /// <p>The settings for a random split activity. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.</p>
    public let randomSplit: RandomSplitActivity?
    /// <p>The settings for an SMS activity. This type of activity sends a text message to participants.</p>
    public let sMS: SMSMessageActivity?
    /// <p>The settings for a wait activity. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p>
    public let wait: WaitActivity?

    public init (
        cUSTOM: CustomMessageActivity? = nil,
        conditionalSplit: ConditionalSplitActivity? = nil,
        description: String? = nil,
        eMAIL: EmailMessageActivity? = nil,
        holdout: HoldoutActivity? = nil,
        multiCondition: MultiConditionalSplitActivity? = nil,
        pUSH: PushMessageActivity? = nil,
        randomSplit: RandomSplitActivity? = nil,
        sMS: SMSMessageActivity? = nil,
        wait: WaitActivity? = nil
    )
    {
        self.cUSTOM = cUSTOM
        self.conditionalSplit = conditionalSplit
        self.description = description
        self.eMAIL = eMAIL
        self.holdout = holdout
        self.multiCondition = multiCondition
        self.pUSH = pUSH
        self.randomSplit = randomSplit
        self.sMS = sMS
        self.wait = wait
    }
}

extension ActivityResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case campaignId = "CampaignId"
        case end = "End"
        case id = "Id"
        case result = "Result"
        case scheduledStart = "ScheduledStart"
        case start = "Start"
        case state = "State"
        case successfulEndpointCount = "SuccessfulEndpointCount"
        case timezonesCompletedCount = "TimezonesCompletedCount"
        case timezonesTotalCount = "TimezonesTotalCount"
        case totalEndpointCount = "TotalEndpointCount"
        case treatmentId = "TreatmentId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let campaignId = campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let result = result {
            try encodeContainer.encode(result, forKey: .result)
        }
        if let scheduledStart = scheduledStart {
            try encodeContainer.encode(scheduledStart, forKey: .scheduledStart)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if successfulEndpointCount != 0 {
            try encodeContainer.encode(successfulEndpointCount, forKey: .successfulEndpointCount)
        }
        if timezonesCompletedCount != 0 {
            try encodeContainer.encode(timezonesCompletedCount, forKey: .timezonesCompletedCount)
        }
        if timezonesTotalCount != 0 {
            try encodeContainer.encode(timezonesTotalCount, forKey: .timezonesTotalCount)
        }
        if totalEndpointCount != 0 {
            try encodeContainer.encode(totalEndpointCount, forKey: .totalEndpointCount)
        }
        if let treatmentId = treatmentId {
            try encodeContainer.encode(treatmentId, forKey: .treatmentId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let campaignIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let resultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .result)
        result = resultDecoded
        let scheduledStartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .scheduledStart)
        scheduledStart = scheduledStartDecoded
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let successfulEndpointCountDecoded = try containerValues.decode(Int.self, forKey: .successfulEndpointCount)
        successfulEndpointCount = successfulEndpointCountDecoded
        let timezonesCompletedCountDecoded = try containerValues.decode(Int.self, forKey: .timezonesCompletedCount)
        timezonesCompletedCount = timezonesCompletedCountDecoded
        let timezonesTotalCountDecoded = try containerValues.decode(Int.self, forKey: .timezonesTotalCount)
        timezonesTotalCount = timezonesTotalCountDecoded
        let totalEndpointCountDecoded = try containerValues.decode(Int.self, forKey: .totalEndpointCount)
        totalEndpointCount = totalEndpointCountDecoded
        let treatmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentId)
        treatmentId = treatmentIdDecoded
    }
}

extension ActivityResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ActivityResponse(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)), end: \(String(describing: end)), id: \(String(describing: id)), result: \(String(describing: result)), scheduledStart: \(String(describing: scheduledStart)), start: \(String(describing: start)), state: \(String(describing: state)), successfulEndpointCount: \(String(describing: successfulEndpointCount)), timezonesCompletedCount: \(String(describing: timezonesCompletedCount)), timezonesTotalCount: \(String(describing: timezonesTotalCount)), totalEndpointCount: \(String(describing: totalEndpointCount)), treatmentId: \(String(describing: treatmentId)))"}
}

/// <p>Provides information about an activity that was performed by a campaign.</p>
public struct ActivityResponse: Equatable {
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign that the activity applies to.</p>
    public let campaignId: String?
    /// <p>The actual time, in ISO 8601 format, when the activity was marked CANCELLED or COMPLETED.</p>
    public let end: String?
    /// <p>The unique identifier for the activity.</p>
    public let id: String?
    /// <p>Specifies whether the activity succeeded. Possible values are SUCCESS and FAIL.</p>
    public let result: String?
    /// <p>The scheduled start time, in ISO 8601 format, for the activity.</p>
    public let scheduledStart: String?
    /// <p>The actual start time, in ISO 8601 format, of the activity.</p>
    public let start: String?
    /// <p>The current status of the activity. Possible values are: PENDING, INITIALIZING, RUNNING, PAUSED, CANCELLED, and COMPLETED.</p>
    public let state: String?
    /// <p>The total number of endpoints that the campaign successfully delivered messages to.</p>
    public let successfulEndpointCount: Int
    /// <p>The total number of time zones that were completed.</p>
    public let timezonesCompletedCount: Int
    /// <p>The total number of unique time zones that are in the segment for the campaign.</p>
    public let timezonesTotalCount: Int
    /// <p>The total number of endpoints that the campaign attempted to deliver messages to.</p>
    public let totalEndpointCount: Int
    /// <p>The unique identifier for the campaign treatment that the activity applies to. A treatment is a variation of a campaign that's used for A/B testing of a campaign.</p>
    public let treatmentId: String?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil,
        end: String? = nil,
        id: String? = nil,
        result: String? = nil,
        scheduledStart: String? = nil,
        start: String? = nil,
        state: String? = nil,
        successfulEndpointCount: Int = 0,
        timezonesCompletedCount: Int = 0,
        timezonesTotalCount: Int = 0,
        totalEndpointCount: Int = 0,
        treatmentId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.end = end
        self.id = id
        self.result = result
        self.scheduledStart = scheduledStart
        self.start = start
        self.state = state
        self.successfulEndpointCount = successfulEndpointCount
        self.timezonesCompletedCount = timezonesCompletedCount
        self.timezonesTotalCount = timezonesTotalCount
        self.totalEndpointCount = totalEndpointCount
        self.treatmentId = treatmentId
    }
}

extension AddressConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bodyOverride = "BodyOverride"
        case channelType = "ChannelType"
        case context = "Context"
        case rawContent = "RawContent"
        case substitutions = "Substitutions"
        case titleOverride = "TitleOverride"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bodyOverride = bodyOverride {
            try encodeContainer.encode(bodyOverride, forKey: .bodyOverride)
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .context)
            for (dictKey0, mapof__string0) in context {
                try contextContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let titleOverride = titleOverride {
            try encodeContainer.encode(titleOverride, forKey: .titleOverride)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bodyOverride)
        bodyOverride = bodyOverrideDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let titleOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .titleOverride)
        titleOverride = titleOverrideDecoded
    }
}

extension AddressConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddressConfiguration(bodyOverride: \(String(describing: bodyOverride)), channelType: \(String(describing: channelType)), context: \(String(describing: context)), rawContent: \(String(describing: rawContent)), substitutions: \(String(describing: substitutions)), titleOverride: \(String(describing: titleOverride)))"}
}

/// <p>Specifies address-based configuration settings for a message that's sent directly to an endpoint.</p>
public struct AddressConfiguration: Equatable {
    /// <p>The message body to use instead of the default message body. This value overrides the default message body.</p>
    public let bodyOverride: String?
    /// <p>The channel to use when sending the message.</p>
    public let channelType: ChannelType?
    /// <p>An object that maps custom attributes to attributes for the address and is attached to the message. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
    public let context: [String:String]?
    /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
    public let rawContent: String?
    /// <p>A map of the message variables to merge with the variables specified by properties of the DefaultMessage object. The variables specified in this map take precedence over all other variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The message title to use instead of the default message title. This value overrides the default message title.</p>
    public let titleOverride: String?

    public init (
        bodyOverride: String? = nil,
        channelType: ChannelType? = nil,
        context: [String:String]? = nil,
        rawContent: String? = nil,
        substitutions: [String:[String]]? = nil,
        titleOverride: String? = nil
    )
    {
        self.bodyOverride = bodyOverride
        self.channelType = channelType
        self.context = context
        self.rawContent = rawContent
        self.substitutions = substitutions
        self.titleOverride = titleOverride
    }
}

extension AndroidPushNotificationTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case imageIconUrl = "ImageIconUrl"
        case imageUrl = "ImageUrl"
        case rawContent = "RawContent"
        case smallImageIconUrl = "SmallImageIconUrl"
        case sound = "Sound"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let imageIconUrl = imageIconUrl {
            try encodeContainer.encode(imageIconUrl, forKey: .imageIconUrl)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if let smallImageIconUrl = smallImageIconUrl {
            try encodeContainer.encode(smallImageIconUrl, forKey: .smallImageIconUrl)
        }
        if let sound = sound {
            try encodeContainer.encode(sound, forKey: .sound)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let imageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageIconUrl)
        imageIconUrl = imageIconUrlDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let smallImageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smallImageIconUrl)
        smallImageIconUrl = smallImageIconUrlDecoded
        let soundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sound)
        sound = soundDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension AndroidPushNotificationTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AndroidPushNotificationTemplate(action: \(String(describing: action)), body: \(String(describing: body)), imageIconUrl: \(String(describing: imageIconUrl)), imageUrl: \(String(describing: imageUrl)), rawContent: \(String(describing: rawContent)), smallImageIconUrl: \(String(describing: smallImageIconUrl)), sound: \(String(describing: sound)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies channel-specific content and settings for a message template that can be used in push notifications that are sent through the ADM (Amazon Device Messaging), Baidu (Baidu Cloud Push), or GCM (Firebase Cloud Messaging, formerly Google Cloud Messaging) channel.</p>
public struct AndroidPushNotificationTemplate: Equatable {
    /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The message body to use in a push notification that's based on the message template.</p>
    public let body: String?
    /// <p>The URL of the large icon image to display in the content view of a push notification that's based on the message template.</p>
    public let imageIconUrl: String?
    /// <p>The URL of an image to display in a push notification that's based on the message template.</p>
    public let imageUrl: String?
    /// <p>The raw, JSON-formatted string to use as the payload for a push notification that's based on the message template. If specified, this value overrides all other content for the message template.</p>
    public let rawContent: String?
    /// <p>The URL of the small icon image to display in the status bar and the content view of a push notification that's based on the message template.</p>
    public let smallImageIconUrl: String?
    /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    public let sound: String?
    /// <p>The title to use in a push notification that's based on the message template. This title appears above the notification message on a recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        imageIconUrl: String? = nil,
        imageUrl: String? = nil,
        rawContent: String? = nil,
        smallImageIconUrl: String? = nil,
        sound: String? = nil,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.imageIconUrl = imageIconUrl
        self.imageUrl = imageUrl
        self.rawContent = rawContent
        self.smallImageIconUrl = smallImageIconUrl
        self.sound = sound
        self.title = title
        self.url = url
    }
}

extension ApplicationDateRangeKpiResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case endTime = "EndTime"
        case kpiName = "KpiName"
        case kpiResult = "KpiResult"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let kpiName = kpiName {
            try encodeContainer.encode(kpiName, forKey: .kpiName)
        }
        if let kpiResult = kpiResult {
            try encodeContainer.encode(kpiResult, forKey: .kpiResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let kpiNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kpiName)
        kpiName = kpiNameDecoded
        let kpiResultDecoded = try containerValues.decodeIfPresent(BaseKpiResult.self, forKey: .kpiResult)
        kpiResult = kpiResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension ApplicationDateRangeKpiResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationDateRangeKpiResponse(applicationId: \(String(describing: applicationId)), endTime: \(String(describing: endTime)), kpiName: \(String(describing: kpiName)), kpiResult: \(String(describing: kpiResult)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to an application, and provides information about that query.</p>
public struct ApplicationDateRangeKpiResponse: Equatable {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    public let applicationId: String?
    /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    public let endTime: Date?
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let kpiName: String?
    /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
    public let kpiResult: BaseKpiResult?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Application Metrics resource because the resource returns all results in a single page.</p>
    public let nextToken: String?
    /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    public let startTime: Date?

    public init (
        applicationId: String? = nil,
        endTime: Date? = nil,
        kpiName: String? = nil,
        kpiResult: BaseKpiResult? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.endTime = endTime
        self.kpiName = kpiName
        self.kpiResult = kpiResult
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension ApplicationResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case id = "Id"
        case name = "Name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ApplicationResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationResponse(arn: \(String(describing: arn)), id: \(String(describing: id)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about an application.</p>
public struct ApplicationResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application.</p>
    public let arn: String?
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let id: String?
    /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
    public let name: String?
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the application. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?

    public init (
        arn: String? = nil,
        id: String? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.arn = arn
        self.id = id
        self.name = name
        self.tags = tags
    }
}

extension ApplicationSettingsResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case campaignHook = "CampaignHook"
        case lastModifiedDate = "LastModifiedDate"
        case limits = "Limits"
        case quietTime = "QuietTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let campaignHook = campaignHook {
            try encodeContainer.encode(campaignHook, forKey: .campaignHook)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let limits = limits {
            try encodeContainer.encode(limits, forKey: .limits)
        }
        if let quietTime = quietTime {
            try encodeContainer.encode(quietTime, forKey: .quietTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let campaignHookDecoded = try containerValues.decodeIfPresent(CampaignHook.self, forKey: .campaignHook)
        campaignHook = campaignHookDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(CampaignLimits.self, forKey: .limits)
        limits = limitsDecoded
        let quietTimeDecoded = try containerValues.decodeIfPresent(QuietTime.self, forKey: .quietTime)
        quietTime = quietTimeDecoded
    }
}

extension ApplicationSettingsResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationSettingsResource(applicationId: \(String(describing: applicationId)), campaignHook: \(String(describing: campaignHook)), lastModifiedDate: \(String(describing: lastModifiedDate)), limits: \(String(describing: limits)), quietTime: \(String(describing: quietTime)))"}
}

/// <p>Provides information about an application, including the default settings for an application.</p>
public struct ApplicationSettingsResource: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p>
    public let campaignHook: CampaignHook?
    /// <p>The date and time, in ISO 8601 format, when the application's settings were last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The default sending limits for campaigns in the application.</p>
    public let limits: CampaignLimits?
    /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p>
    public let quietTime: QuietTime?

    public init (
        applicationId: String? = nil,
        campaignHook: CampaignHook? = nil,
        lastModifiedDate: String? = nil,
        limits: CampaignLimits? = nil,
        quietTime: QuietTime? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignHook = campaignHook
        self.lastModifiedDate = lastModifiedDate
        self.limits = limits
        self.quietTime = quietTime
    }
}

extension ApplicationsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofapplicationresponse0 in item {
                try itemContainer.encode(listofapplicationresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([ApplicationResponse?].self, forKey: .item)
        var itemDecoded0:[ApplicationResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [ApplicationResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ApplicationsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationsResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about all of your applications.</p>
public struct ApplicationsResponse: Equatable {
    /// <p>An array of responses, one for each application that was returned.</p>
    public let item: [ApplicationResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [ApplicationResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

extension AttributeDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeType = "AttributeType"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType.rawValue, forKey: .attributeType)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for listof__string0 in values {
                try valuesContainer.encode(listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeTypeDecoded = try containerValues.decodeIfPresent(AttributeType.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension AttributeDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributeDimension(attributeType: \(String(describing: attributeType)), values: \(String(describing: values)))"}
}

/// <p>Specifies attribute-based criteria for including or excluding endpoints from a segment.</p>
public struct AttributeDimension: Equatable {
    /// <p>The type of segment dimension to use. Valid values are: <ul><li>INCLUSIVE - endpoints that have attributes matching the values are included in the segment.</li><li>EXCLUSIVE - endpoints that have attributes matching the values are excluded in the segment.</li><li>CONTAINS - endpoints that have attributes' substrings match the values are included in the segment.</li><li>BEFORE - endpoints with attributes read as ISO_INSTANT datetimes before the value are included in the segment.</li><li>AFTER - endpoints with attributes read as ISO_INSTANT datetimes after the value are included in the segment.</li><li>ON - endpoints with attributes read as ISO_INSTANT dates on the value are included in the segment. Time is ignored in this comparison.</li><li>BETWEEN - endpoints with attributes read as ISO_INSTANT datetimes between the values are included in the segment.</li></p>
    public let attributeType: AttributeType?
    /// <p>The criteria values to use for the segment dimension. Depending on the value of the AttributeType property, endpoints are included or excluded from the segment if their attribute values match the criteria values.</p>
    public let values: [String]?

    public init (
        attributeType: AttributeType? = nil,
        values: [String]? = nil
    )
    {
        self.attributeType = attributeType
        self.values = values
    }
}

public enum AttributeType {
    case after
    case before
    case between
    case contains
    case exclusive
    case inclusive
    case on
    case sdkUnknown(String)
}

extension AttributeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AttributeType] {
        return [
            .after,
            .before,
            .between,
            .contains,
            .exclusive,
            .inclusive,
            .on,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .after: return "AFTER"
        case .before: return "BEFORE"
        case .between: return "BETWEEN"
        case .contains: return "CONTAINS"
        case .exclusive: return "EXCLUSIVE"
        case .inclusive: return "INCLUSIVE"
        case .on: return "ON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AttributeType(rawValue: rawValue) ?? AttributeType.sdkUnknown(rawValue)
    }
}

extension AttributesResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case attributeType = "AttributeType"
        case attributes = "Attributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let attributeType = attributeType {
            try encodeContainer.encode(attributeType, forKey: .attributeType)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for listof__string0 in attributes {
                try attributesContainer.encode(listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let attributeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeType)
        attributeType = attributeTypeDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributes)
        var attributesDecoded0:[String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String]()
            for string0 in attributesContainer {
                if let string0 = string0 {
                    attributesDecoded0?.append(string0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AttributesResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AttributesResource(applicationId: \(String(describing: applicationId)), attributeType: \(String(describing: attributeType)), attributes: \(String(describing: attributes)))"}
}

/// <p>Provides information about the type and the names of attributes that were removed from all the endpoints that are associated with an application.</p>
public struct AttributesResource: Equatable {
    /// <p>The unique identifier for the application.</p>
    public let applicationId: String?
    /// <p>The type of attribute or attributes that were removed from the endpoints. Valid values are:</p> <ul><li><p>endpoint-custom-attributes - Custom attributes that describe endpoints.</p></li> <li><p>endpoint-metric-attributes - Custom metrics that your app reports to Amazon Pinpoint for endpoints.</p></li> <li><p>endpoint-user-attributes - Custom attributes that describe users.</p></li></ul>
    public let attributeType: String?
    /// <p>An array that specifies the names of the attributes that were removed from the endpoints.</p>
    public let attributes: [String]?

    public init (
        applicationId: String? = nil,
        attributeType: String? = nil,
        attributes: [String]? = nil
    )
    {
        self.applicationId = applicationId
        self.attributeType = attributeType
        self.attributes = attributes
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension BaiduChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKey = "ApiKey"
        case enabled = "Enabled"
        case secretKey = "SecretKey"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let secretKey = secretKey {
            try encodeContainer.encode(secretKey, forKey: .secretKey)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let secretKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .secretKey)
        secretKey = secretKeyDecoded
    }
}

extension BaiduChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BaiduChannelRequest(apiKey: \(String(describing: apiKey)), enabled: \(String(describing: enabled)), secretKey: \(String(describing: secretKey)))"}
}

/// <p>Specifies the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
public struct BaiduChannelRequest: Equatable {
    /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
    public let apiKey: String?
    /// <p>Specifies whether to enable the Baidu channel for the application.</p>
    public let enabled: Bool
    /// <p>The secret key that you received from the Baidu Cloud Push service to communicate with the service.</p>
    public let secretKey: String?

    public init (
        apiKey: String? = nil,
        enabled: Bool = false,
        secretKey: String? = nil
    )
    {
        self.apiKey = apiKey
        self.enabled = enabled
        self.secretKey = secretKey
    }
}

extension BaiduChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case credential = "Credential"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let credential = credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let credentialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credential)
        credential = credentialDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension BaiduChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BaiduChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), credential: \(String(describing: credential)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
public struct BaiduChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the Baidu channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time when the Baidu channel was enabled.</p>
    public let creationDate: String?
    /// <p>The API key that you received from the Baidu Cloud Push service to communicate with the service.</p>
    public let credential: String?
    /// <p>Specifies whether the Baidu channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>(Deprecated) An identifier for the Baidu channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the Baidu channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the Baidu channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the Baidu channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the Baidu channel, this value is BAIDU.</p>
    public let platform: String?
    /// <p>The current version of the Baidu channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        credential: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.credential = credential
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

extension BaiduMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case data = "Data"
        case iconReference = "IconReference"
        case imageIconUrl = "ImageIconUrl"
        case imageUrl = "ImageUrl"
        case rawContent = "RawContent"
        case silentPush = "SilentPush"
        case smallImageIconUrl = "SmallImageIconUrl"
        case sound = "Sound"
        case substitutions = "Substitutions"
        case timeToLive = "TimeToLive"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .data)
            for (dictKey0, mapof__string0) in data {
                try dataContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let iconReference = iconReference {
            try encodeContainer.encode(iconReference, forKey: .iconReference)
        }
        if let imageIconUrl = imageIconUrl {
            try encodeContainer.encode(imageIconUrl, forKey: .imageIconUrl)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if silentPush != false {
            try encodeContainer.encode(silentPush, forKey: .silentPush)
        }
        if let smallImageIconUrl = smallImageIconUrl {
            try encodeContainer.encode(smallImageIconUrl, forKey: .smallImageIconUrl)
        }
        if let sound = sound {
            try encodeContainer.encode(sound, forKey: .sound)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeToLive != 0 {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let dataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .data)
        var dataDecoded0: [String:String]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [String:String]()
            for (key0, __string0) in dataContainer {
                if let __string0 = __string0 {
                    dataDecoded0?[key0] = __string0
                }
            }
        }
        data = dataDecoded0
        let iconReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iconReference)
        iconReference = iconReferenceDecoded
        let imageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageIconUrl)
        imageIconUrl = imageIconUrlDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let silentPushDecoded = try containerValues.decode(Bool.self, forKey: .silentPush)
        silentPush = silentPushDecoded
        let smallImageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smallImageIconUrl)
        smallImageIconUrl = smallImageIconUrlDecoded
        let soundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sound)
        sound = soundDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let timeToLiveDecoded = try containerValues.decode(Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension BaiduMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BaiduMessage(action: \(String(describing: action)), body: \(String(describing: body)), data: \(String(describing: data)), iconReference: \(String(describing: iconReference)), imageIconUrl: \(String(describing: imageIconUrl)), imageUrl: \(String(describing: imageUrl)), rawContent: \(String(describing: rawContent)), silentPush: \(String(describing: silentPush)), smallImageIconUrl: \(String(describing: smallImageIconUrl)), sound: \(String(describing: sound)), substitutions: \(String(describing: substitutions)), timeToLive: \(String(describing: timeToLive)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the Baidu (Baidu Cloud Push) channel.</p>
public struct BaiduMessage: Equatable {
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The body of the notification message.</p>
    public let body: String?
    /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    public let data: [String:String]?
    /// <p>The icon image name of the asset saved in your app.</p>
    public let iconReference: String?
    /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
    public let imageIconUrl: String?
    /// <p>The URL of an image to display in the push notification.</p>
    public let imageUrl: String?
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    public let rawContent: String?
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
    public let silentPush: Bool
    /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
    public let smallImageIconUrl: String?
    /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    public let sound: String?
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The amount of time, in seconds, that the Baidu Cloud Push service should store the message if the recipient's device is offline. The default value and maximum supported time is 604,800 seconds (7 days).</p>
    public let timeToLive: Int
    /// <p>The title to display above the notification message on the recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        data: [String:String]? = nil,
        iconReference: String? = nil,
        imageIconUrl: String? = nil,
        imageUrl: String? = nil,
        rawContent: String? = nil,
        silentPush: Bool = false,
        smallImageIconUrl: String? = nil,
        sound: String? = nil,
        substitutions: [String:[String]]? = nil,
        timeToLive: Int = 0,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.data = data
        self.iconReference = iconReference
        self.imageIconUrl = imageIconUrl
        self.imageUrl = imageUrl
        self.rawContent = rawContent
        self.silentPush = silentPush
        self.smallImageIconUrl = smallImageIconUrl
        self.sound = sound
        self.substitutions = substitutions
        self.timeToLive = timeToLive
        self.title = title
        self.url = url
    }
}

extension BaseKpiResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rows = "Rows"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for listofresultrow0 in rows {
                try rowsContainer.encode(listofresultrow0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([ResultRow?].self, forKey: .rows)
        var rowsDecoded0:[ResultRow]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [ResultRow]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
    }
}

extension BaseKpiResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BaseKpiResult(rows: \(String(describing: rows)))"}
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
public struct BaseKpiResult: Equatable {
    /// <p>An array of objects that provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
    public let rows: [ResultRow]?

    public init (
        rows: [ResultRow]? = nil
    )
    {
        self.rows = rows
    }
}

extension CampaignCustomMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
    }
}

extension CampaignCustomMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignCustomMessage(data: \(String(describing: data)))"}
}

/// <p>Specifies the contents of a message that's sent through a custom channel to recipients of a campaign.</p>
public struct CampaignCustomMessage: Equatable {
    /// <p>The raw, JSON-formatted string to use as the payload for the message. The maximum size is 5 KB.</p>
    public let data: String?

    public init (
        data: String? = nil
    )
    {
        self.data = data
    }
}

extension CampaignDateRangeKpiResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case campaignId = "CampaignId"
        case endTime = "EndTime"
        case kpiName = "KpiName"
        case kpiResult = "KpiResult"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let campaignId = campaignId {
            try encodeContainer.encode(campaignId, forKey: .campaignId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let kpiName = kpiName {
            try encodeContainer.encode(kpiName, forKey: .kpiName)
        }
        if let kpiResult = kpiResult {
            try encodeContainer.encode(kpiResult, forKey: .kpiResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let campaignIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .campaignId)
        campaignId = campaignIdDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let kpiNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kpiName)
        kpiName = kpiNameDecoded
        let kpiResultDecoded = try containerValues.decodeIfPresent(BaseKpiResult.self, forKey: .kpiResult)
        kpiResult = kpiResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension CampaignDateRangeKpiResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignDateRangeKpiResponse(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)), endTime: \(String(describing: endTime)), kpiName: \(String(describing: kpiName)), kpiResult: \(String(describing: kpiResult)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to a campaign, and provides information about that query.</p>
public struct CampaignDateRangeKpiResponse: Equatable {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign that the metric applies to.</p>
    public let campaignId: String?
    /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    public let endTime: Date?
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let kpiName: String?
    /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
    public let kpiResult: BaseKpiResult?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Campaign Metrics resource because the resource returns all results in a single page.</p>
    public let nextToken: String?
    /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    public let startTime: Date?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil,
        endTime: Date? = nil,
        kpiName: String? = nil,
        kpiResult: BaseKpiResult? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.endTime = endTime
        self.kpiName = kpiName
        self.kpiResult = kpiResult
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension CampaignEmailMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case fromAddress = "FromAddress"
        case htmlBody = "HtmlBody"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if let htmlBody = htmlBody {
            try encodeContainer.encode(htmlBody, forKey: .htmlBody)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let htmlBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .htmlBody)
        htmlBody = htmlBodyDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
    }
}

extension CampaignEmailMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignEmailMessage(body: \(String(describing: body)), fromAddress: \(String(describing: fromAddress)), htmlBody: \(String(describing: htmlBody)), title: \(String(describing: title)))"}
}

/// <p>Specifies the content and "From" address for an email message that's sent to recipients of a campaign.</p>
public struct CampaignEmailMessage: Equatable {
    /// <p>The body of the email for recipients whose email clients don't render HTML content.</p>
    public let body: String?
    /// <p>The verified email address to send the email from. The default address is the FromAddress specified for the email channel for the application.</p>
    public let fromAddress: String?
    /// <p>The body of the email, in HTML format, for recipients whose email clients render HTML content.</p>
    public let htmlBody: String?
    /// <p>The subject line, or title, of the email.</p>
    public let title: String?

    public init (
        body: String? = nil,
        fromAddress: String? = nil,
        htmlBody: String? = nil,
        title: String? = nil
    )
    {
        self.body = body
        self.fromAddress = fromAddress
        self.htmlBody = htmlBody
        self.title = title
    }
}

extension CampaignEventFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case filterType = "FilterType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let filterType = filterType {
            try encodeContainer.encode(filterType.rawValue, forKey: .filterType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(EventDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let filterTypeDecoded = try containerValues.decodeIfPresent(FilterType.self, forKey: .filterType)
        filterType = filterTypeDecoded
    }
}

extension CampaignEventFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignEventFilter(dimensions: \(String(describing: dimensions)), filterType: \(String(describing: filterType)))"}
}

/// <p>Specifies the settings for events that cause a campaign to be sent.</p>
public struct CampaignEventFilter: Equatable {
    /// <p>The dimension settings of the event filter for the campaign.</p>
    public let dimensions: EventDimensions?
    /// <p>The type of event that causes the campaign to be sent. Valid values are: SYSTEM, sends the campaign when a system event occurs; and, ENDPOINT, sends the campaign when an endpoint event (<link  linkend="apps-application-id-events">Events</link> resource) occurs.</p>
    public let filterType: FilterType?

    public init (
        dimensions: EventDimensions? = nil,
        filterType: FilterType? = nil
    )
    {
        self.dimensions = dimensions
        self.filterType = filterType
    }
}

extension CampaignHook: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case lambdaFunctionName = "LambdaFunctionName"
        case mode = "Mode"
        case webUrl = "WebUrl"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lambdaFunctionName = lambdaFunctionName {
            try encodeContainer.encode(lambdaFunctionName, forKey: .lambdaFunctionName)
        }
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
        if let webUrl = webUrl {
            try encodeContainer.encode(webUrl, forKey: .webUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lambdaFunctionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lambdaFunctionName)
        lambdaFunctionName = lambdaFunctionNameDecoded
        let modeDecoded = try containerValues.decodeIfPresent(Mode.self, forKey: .mode)
        mode = modeDecoded
        let webUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .webUrl)
        webUrl = webUrlDecoded
    }
}

extension CampaignHook: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignHook(lambdaFunctionName: \(String(describing: lambdaFunctionName)), mode: \(String(describing: mode)), webUrl: \(String(describing: webUrl)))"}
}

/// <p>Specifies settings for invoking an AWS Lambda function that customizes a segment for a campaign.</p>
public struct CampaignHook: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to customize a segment for a campaign.</p>
    public let lambdaFunctionName: String?
    /// <p>The mode that Amazon Pinpoint uses to invoke the AWS Lambda function. Possible values are:</p> <ul><li><p>FILTER - Invoke the function to customize the segment that's used by a campaign.</p></li> <li><p>DELIVERY - (Deprecated) Previously, invoked the function to send a campaign through a custom channel. This functionality is not supported anymore. To send a campaign through a custom channel, use the CustomDeliveryConfiguration and CampaignCustomMessage objects of the campaign.</p></li></ul>
    public let mode: Mode?
    /// <p>The web URL that Amazon Pinpoint calls to invoke the AWS Lambda function over HTTPS.</p>
    public let webUrl: String?

    public init (
        lambdaFunctionName: String? = nil,
        mode: Mode? = nil,
        webUrl: String? = nil
    )
    {
        self.lambdaFunctionName = lambdaFunctionName
        self.mode = mode
        self.webUrl = webUrl
    }
}

extension CampaignLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case daily = "Daily"
        case maximumDuration = "MaximumDuration"
        case messagesPerSecond = "MessagesPerSecond"
        case total = "Total"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if daily != 0 {
            try encodeContainer.encode(daily, forKey: .daily)
        }
        if maximumDuration != 0 {
            try encodeContainer.encode(maximumDuration, forKey: .maximumDuration)
        }
        if messagesPerSecond != 0 {
            try encodeContainer.encode(messagesPerSecond, forKey: .messagesPerSecond)
        }
        if total != 0 {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dailyDecoded = try containerValues.decode(Int.self, forKey: .daily)
        daily = dailyDecoded
        let maximumDurationDecoded = try containerValues.decode(Int.self, forKey: .maximumDuration)
        maximumDuration = maximumDurationDecoded
        let messagesPerSecondDecoded = try containerValues.decode(Int.self, forKey: .messagesPerSecond)
        messagesPerSecond = messagesPerSecondDecoded
        let totalDecoded = try containerValues.decode(Int.self, forKey: .total)
        total = totalDecoded
    }
}

extension CampaignLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignLimits(daily: \(String(describing: daily)), maximumDuration: \(String(describing: maximumDuration)), messagesPerSecond: \(String(describing: messagesPerSecond)), total: \(String(describing: total)))"}
}

/// <p>For a campaign, specifies limits on the messages that the campaign can send. For an application, specifies the default limits for messages that campaigns in the application can send.</p>
public struct CampaignLimits: Equatable {
    /// <p>The maximum number of messages that a campaign can send to a single endpoint during a 24-hour period. For an application, this value specifies the default limit for the number of messages that campaigns and journeys can send to a single endpoint during a 24-hour period. The maximum value is 100.</p>
    public let daily: Int
    /// <p>The maximum amount of time, in seconds, that a campaign can attempt to deliver a message after the scheduled start time for the campaign. The minimum value is 60 seconds.</p>
    public let maximumDuration: Int
    /// <p>The maximum number of messages that a campaign can send each second. For an application, this value specifies the default limit for the number of messages that campaigns can send each second. The minimum value is 50. The maximum value is 20,000.</p>
    public let messagesPerSecond: Int
    /// <p>The maximum number of messages that a campaign can send to a single endpoint during the course of the campaign. If a campaign recurs, this setting applies to all runs of the campaign. The maximum value is 100.</p>
    public let total: Int

    public init (
        daily: Int = 0,
        maximumDuration: Int = 0,
        messagesPerSecond: Int = 0,
        total: Int = 0
    )
    {
        self.daily = daily
        self.maximumDuration = maximumDuration
        self.messagesPerSecond = messagesPerSecond
        self.total = total
    }
}

extension CampaignResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalTreatments = "AdditionalTreatments"
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case creationDate = "CreationDate"
        case customDeliveryConfiguration = "CustomDeliveryConfiguration"
        case defaultState = "DefaultState"
        case description = "Description"
        case holdoutPercent = "HoldoutPercent"
        case hook = "Hook"
        case id = "Id"
        case isPaused = "IsPaused"
        case lastModifiedDate = "LastModifiedDate"
        case limits = "Limits"
        case messageConfiguration = "MessageConfiguration"
        case name = "Name"
        case schedule = "Schedule"
        case segmentId = "SegmentId"
        case segmentVersion = "SegmentVersion"
        case state = "State"
        case templateConfiguration = "TemplateConfiguration"
        case treatmentDescription = "TreatmentDescription"
        case treatmentName = "TreatmentName"
        case version = "Version"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalTreatments = additionalTreatments {
            var additionalTreatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalTreatments)
            for listoftreatmentresource0 in additionalTreatments {
                try additionalTreatmentsContainer.encode(listoftreatmentresource0)
            }
        }
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let customDeliveryConfiguration = customDeliveryConfiguration {
            try encodeContainer.encode(customDeliveryConfiguration, forKey: .customDeliveryConfiguration)
        }
        if let defaultState = defaultState {
            try encodeContainer.encode(defaultState, forKey: .defaultState)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if holdoutPercent != 0 {
            try encodeContainer.encode(holdoutPercent, forKey: .holdoutPercent)
        }
        if let hook = hook {
            try encodeContainer.encode(hook, forKey: .hook)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isPaused != false {
            try encodeContainer.encode(isPaused, forKey: .isPaused)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let limits = limits {
            try encodeContainer.encode(limits, forKey: .limits)
        }
        if let messageConfiguration = messageConfiguration {
            try encodeContainer.encode(messageConfiguration, forKey: .messageConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
        if segmentVersion != 0 {
            try encodeContainer.encode(segmentVersion, forKey: .segmentVersion)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let templateConfiguration = templateConfiguration {
            try encodeContainer.encode(templateConfiguration, forKey: .templateConfiguration)
        }
        if let treatmentDescription = treatmentDescription {
            try encodeContainer.encode(treatmentDescription, forKey: .treatmentDescription)
        }
        if let treatmentName = treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalTreatmentsContainer = try containerValues.decodeIfPresent([TreatmentResource?].self, forKey: .additionalTreatments)
        var additionalTreatmentsDecoded0:[TreatmentResource]? = nil
        if let additionalTreatmentsContainer = additionalTreatmentsContainer {
            additionalTreatmentsDecoded0 = [TreatmentResource]()
            for structure0 in additionalTreatmentsContainer {
                if let structure0 = structure0 {
                    additionalTreatmentsDecoded0?.append(structure0)
                }
            }
        }
        additionalTreatments = additionalTreatmentsDecoded0
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let customDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(CustomDeliveryConfiguration.self, forKey: .customDeliveryConfiguration)
        customDeliveryConfiguration = customDeliveryConfigurationDecoded
        let defaultStateDecoded = try containerValues.decodeIfPresent(CampaignState.self, forKey: .defaultState)
        defaultState = defaultStateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let holdoutPercentDecoded = try containerValues.decode(Int.self, forKey: .holdoutPercent)
        holdoutPercent = holdoutPercentDecoded
        let hookDecoded = try containerValues.decodeIfPresent(CampaignHook.self, forKey: .hook)
        hook = hookDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isPausedDecoded = try containerValues.decode(Bool.self, forKey: .isPaused)
        isPaused = isPausedDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(CampaignLimits.self, forKey: .limits)
        limits = limitsDecoded
        let messageConfigurationDecoded = try containerValues.decodeIfPresent(MessageConfiguration.self, forKey: .messageConfiguration)
        messageConfiguration = messageConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
        let segmentVersionDecoded = try containerValues.decode(Int.self, forKey: .segmentVersion)
        segmentVersion = segmentVersionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CampaignState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateConfigurationDecoded = try containerValues.decodeIfPresent(TemplateConfiguration.self, forKey: .templateConfiguration)
        templateConfiguration = templateConfigurationDecoded
        let treatmentDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentDescription)
        treatmentDescription = treatmentDescriptionDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension CampaignResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignResponse(additionalTreatments: \(String(describing: additionalTreatments)), applicationId: \(String(describing: applicationId)), arn: \(String(describing: arn)), creationDate: \(String(describing: creationDate)), customDeliveryConfiguration: \(String(describing: customDeliveryConfiguration)), defaultState: \(String(describing: defaultState)), description: \(String(describing: description)), holdoutPercent: \(String(describing: holdoutPercent)), hook: \(String(describing: hook)), id: \(String(describing: id)), isPaused: \(String(describing: isPaused)), lastModifiedDate: \(String(describing: lastModifiedDate)), limits: \(String(describing: limits)), messageConfiguration: \(String(describing: messageConfiguration)), name: \(String(describing: name)), schedule: \(String(describing: schedule)), segmentId: \(String(describing: segmentId)), segmentVersion: \(String(describing: segmentVersion)), state: \(String(describing: state)), templateConfiguration: \(String(describing: templateConfiguration)), treatmentDescription: \(String(describing: treatmentDescription)), treatmentName: \(String(describing: treatmentName)), version: \(String(describing: version)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
public struct CampaignResponse: Equatable {
    /// <p>An array of responses, one for each treatment that you defined for the campaign, in addition to the default treatment.</p>
    public let additionalTreatments: [TreatmentResource]?
    /// <p>The unique identifier for the application that the campaign applies to.</p>
    public let applicationId: String?
    /// <p>The Amazon Resource Name (ARN) of the campaign.</p>
    public let arn: String?
    /// <p>The date, in ISO 8601 format, when the campaign was created.</p>
    public let creationDate: String?
    /// <p>The delivery configuration settings for sending the campaign through a custom channel.</p>
    public let customDeliveryConfiguration: CustomDeliveryConfiguration?
    /// <p>The current status of the campaign's default treatment. This value exists only for campaigns that have more than one treatment.</p>
    public let defaultState: CampaignState?
    /// <p>The custom description of the campaign.</p>
    public let description: String?
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    public let holdoutPercent: Int
    /// <p>The settings for the AWS Lambda function to use as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    public let hook: CampaignHook?
    /// <p>The unique identifier for the campaign.</p>
    public let id: String?
    /// <p>Specifies whether the campaign is paused. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    public let isPaused: Bool
    /// <p>The date, in ISO 8601 format, when the campaign was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The messaging limits for the campaign.</p>
    public let limits: CampaignLimits?
    /// <p>The message configuration settings for the campaign.</p>
    public let messageConfiguration: MessageConfiguration?
    /// <p>The name of the campaign.</p>
    public let name: String?
    /// <p>The schedule settings for the campaign.</p>
    public let schedule: Schedule?
    /// <p>The unique identifier for the segment that's associated with the campaign.</p>
    public let segmentId: String?
    /// <p>The version number of the segment that's associated with the campaign.</p>
    public let segmentVersion: Int
    /// <p>The current status of the campaign.</p>
    public let state: CampaignState?
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>The message template that’s used for the campaign.</p>
    public let templateConfiguration: TemplateConfiguration?
    /// <p>The custom description of the default treatment for the campaign.</p>
    public let treatmentDescription: String?
    /// <p>The custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    public let treatmentName: String?
    /// <p>The version number of the campaign.</p>
    public let version: Int

    public init (
        additionalTreatments: [TreatmentResource]? = nil,
        applicationId: String? = nil,
        arn: String? = nil,
        creationDate: String? = nil,
        customDeliveryConfiguration: CustomDeliveryConfiguration? = nil,
        defaultState: CampaignState? = nil,
        description: String? = nil,
        holdoutPercent: Int = 0,
        hook: CampaignHook? = nil,
        id: String? = nil,
        isPaused: Bool = false,
        lastModifiedDate: String? = nil,
        limits: CampaignLimits? = nil,
        messageConfiguration: MessageConfiguration? = nil,
        name: String? = nil,
        schedule: Schedule? = nil,
        segmentId: String? = nil,
        segmentVersion: Int = 0,
        state: CampaignState? = nil,
        tags: [String:String]? = nil,
        templateConfiguration: TemplateConfiguration? = nil,
        treatmentDescription: String? = nil,
        treatmentName: String? = nil,
        version: Int = 0
    )
    {
        self.additionalTreatments = additionalTreatments
        self.applicationId = applicationId
        self.arn = arn
        self.creationDate = creationDate
        self.customDeliveryConfiguration = customDeliveryConfiguration
        self.defaultState = defaultState
        self.description = description
        self.holdoutPercent = holdoutPercent
        self.hook = hook
        self.id = id
        self.isPaused = isPaused
        self.lastModifiedDate = lastModifiedDate
        self.limits = limits
        self.messageConfiguration = messageConfiguration
        self.name = name
        self.schedule = schedule
        self.segmentId = segmentId
        self.segmentVersion = segmentVersion
        self.state = state
        self.tags = tags
        self.templateConfiguration = templateConfiguration
        self.treatmentDescription = treatmentDescription
        self.treatmentName = treatmentName
        self.version = version
    }
}

extension CampaignSmsMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case entityId = "EntityId"
        case messageType = "MessageType"
        case originationNumber = "OriginationNumber"
        case senderId = "SenderId"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let originationNumber = originationNumber {
            try encodeContainer.encode(originationNumber, forKey: .originationNumber)
        }
        if let senderId = senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let originationNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originationNumber)
        originationNumber = originationNumberDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension CampaignSmsMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignSmsMessage(body: \(String(describing: body)), entityId: \(String(describing: entityId)), messageType: \(String(describing: messageType)), originationNumber: \(String(describing: originationNumber)), senderId: \(String(describing: senderId)), templateId: \(String(describing: templateId)))"}
}

/// <p>Specifies the content and settings for an SMS message that's sent to recipients of a campaign.</p>
public struct CampaignSmsMessage: Equatable {
    /// <p>The body of the SMS message.</p>
    public let body: String?
    /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
    public let entityId: String?
    /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
    public let messageType: MessageType?
    /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
    public let originationNumber: String?
    /// <p>The sender ID to display on recipients' devices when they receive the SMS message.</p>
    public let senderId: String?
    /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
    public let templateId: String?

    public init (
        body: String? = nil,
        entityId: String? = nil,
        messageType: MessageType? = nil,
        originationNumber: String? = nil,
        senderId: String? = nil,
        templateId: String? = nil
    )
    {
        self.body = body
        self.entityId = entityId
        self.messageType = messageType
        self.originationNumber = originationNumber
        self.senderId = senderId
        self.templateId = templateId
    }
}

extension CampaignState: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignStatus = "CampaignStatus"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignStatus = campaignStatus {
            try encodeContainer.encode(campaignStatus.rawValue, forKey: .campaignStatus)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignStatusDecoded = try containerValues.decodeIfPresent(CampaignStatus.self, forKey: .campaignStatus)
        campaignStatus = campaignStatusDecoded
    }
}

extension CampaignState: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignState(campaignStatus: \(String(describing: campaignStatus)))"}
}

/// <p>Provides information about the status of a campaign.</p>
public struct CampaignState: Equatable {
    /// <p>The current status of the campaign, or the current status of a treatment that belongs to an A/B test campaign.</p> <p>If a campaign uses A/B testing, the campaign has a status of COMPLETED only if all campaign treatments have a status of COMPLETED. If you delete the segment that's associated with a campaign, the campaign fails and has a status of DELETED.</p>
    public let campaignStatus: CampaignStatus?

    public init (
        campaignStatus: CampaignStatus? = nil
    )
    {
        self.campaignStatus = campaignStatus
    }
}

public enum CampaignStatus {
    case completed
    case deleted
    case executing
    case invalid
    case paused
    case pendingNextRun
    case scheduled
    case sdkUnknown(String)
}

extension CampaignStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CampaignStatus] {
        return [
            .completed,
            .deleted,
            .executing,
            .invalid,
            .paused,
            .pendingNextRun,
            .scheduled,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .deleted: return "DELETED"
        case .executing: return "EXECUTING"
        case .invalid: return "INVALID"
        case .paused: return "PAUSED"
        case .pendingNextRun: return "PENDING_NEXT_RUN"
        case .scheduled: return "SCHEDULED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CampaignStatus(rawValue: rawValue) ?? CampaignStatus.sdkUnknown(rawValue)
    }
}

extension CampaignsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofcampaignresponse0 in item {
                try itemContainer.encode(listofcampaignresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([CampaignResponse?].self, forKey: .item)
        var itemDecoded0:[CampaignResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [CampaignResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension CampaignsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CampaignsResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about the configuration and other settings for all the campaigns that are associated with an application.</p>
public struct CampaignsResponse: Equatable {
    /// <p>An array of responses, one for each campaign that's associated with the application.</p>
    public let item: [CampaignResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [CampaignResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

extension ChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension ChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the general settings and status of a channel for an application.</p>
public struct ChannelResponse: Equatable {
    /// <p>The unique identifier for the application.</p>
    public let applicationId: String?
    /// <p>The date and time, in ISO 8601 format, when the channel was enabled.</p>
    public let creationDate: String?
    /// <p>Specifies whether the channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>(Deprecated) An identifier for the channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time, in ISO 8601 format, when the channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The current version of the channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.version = version
    }
}

public enum ChannelType {
    case adm
    case apns
    case apnsSandbox
    case apnsVoip
    case apnsVoipSandbox
    case baidu
    case custom
    case email
    case gcm
    case push
    case sms
    case voice
    case sdkUnknown(String)
}

extension ChannelType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ChannelType] {
        return [
            .adm,
            .apns,
            .apnsSandbox,
            .apnsVoip,
            .apnsVoipSandbox,
            .baidu,
            .custom,
            .email,
            .gcm,
            .push,
            .sms,
            .voice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adm: return "ADM"
        case .apns: return "APNS"
        case .apnsSandbox: return "APNS_SANDBOX"
        case .apnsVoip: return "APNS_VOIP"
        case .apnsVoipSandbox: return "APNS_VOIP_SANDBOX"
        case .baidu: return "BAIDU"
        case .custom: return "CUSTOM"
        case .email: return "EMAIL"
        case .gcm: return "GCM"
        case .push: return "PUSH"
        case .sms: return "SMS"
        case .voice: return "VOICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
    }
}

extension ChannelsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channels = "Channels"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channels = channels {
            var channelsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .channels)
            for (dictKey0, mapofchannelresponse0) in channels {
                try channelsContainer.encode(mapofchannelresponse0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([String: ChannelResponse?].self, forKey: .channels)
        var channelsDecoded0: [String:ChannelResponse]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [String:ChannelResponse]()
            for (key0, channelresponse0) in channelsContainer {
                if let channelresponse0 = channelresponse0 {
                    channelsDecoded0?[key0] = channelresponse0
                }
            }
        }
        channels = channelsDecoded0
    }
}

extension ChannelsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ChannelsResponse(channels: \(String(describing: channels)))"}
}

/// <p>Provides information about the general settings and status of all channels for an application, including channels that aren't enabled for the application.</p>
public struct ChannelsResponse: Equatable {
    /// <p>A map that contains a multipart response for each channel. For each item in this object, the ChannelType is the key and the Channel is the value.</p>
    public let channels: [String:ChannelResponse]?

    public init (
        channels: [String:ChannelResponse]? = nil
    )
    {
        self.channels = channels
    }
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case conditions = "Conditions"
        case `operator` = "Operator"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conditions = conditions {
            var conditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .conditions)
            for listofsimplecondition0 in conditions {
                try conditionsContainer.encode(listofsimplecondition0)
            }
        }
        if let `operator` = `operator` {
            try encodeContainer.encode(`operator`.rawValue, forKey: .`operator`)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionsContainer = try containerValues.decodeIfPresent([SimpleCondition?].self, forKey: .conditions)
        var conditionsDecoded0:[SimpleCondition]? = nil
        if let conditionsContainer = conditionsContainer {
            conditionsDecoded0 = [SimpleCondition]()
            for structure0 in conditionsContainer {
                if let structure0 = structure0 {
                    conditionsDecoded0?.append(structure0)
                }
            }
        }
        conditions = conditionsDecoded0
        let operatorDecoded = try containerValues.decodeIfPresent(Operator.self, forKey: .operator)
        `operator` = operatorDecoded
    }
}

extension Condition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Condition(conditions: \(String(describing: conditions)), operator: \(String(describing: `operator`)))"}
}

/// <p>Specifies the conditions to evaluate for an activity in a journey, and how to evaluate those conditions.</p>
public struct Condition: Equatable {
    /// <p>Specifies how to handle multiple conditions for the activity. For example, if you specify two conditions for an activity, whether both or only one of the conditions must be met for the activity to be performed.</p>
    public let `operator`: Operator?
    /// <p>The conditions to evaluate for the activity.</p>
    public let conditions: [SimpleCondition]?

    public init (
        `operator`: Operator? = nil,
        conditions: [SimpleCondition]? = nil
    )
    {
        self.`operator` = `operator`
        self.conditions = conditions
    }
}

extension ConditionalSplitActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case evaluationWaitTime = "EvaluationWaitTime"
        case falseActivity = "FalseActivity"
        case trueActivity = "TrueActivity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let evaluationWaitTime = evaluationWaitTime {
            try encodeContainer.encode(evaluationWaitTime, forKey: .evaluationWaitTime)
        }
        if let falseActivity = falseActivity {
            try encodeContainer.encode(falseActivity, forKey: .falseActivity)
        }
        if let trueActivity = trueActivity {
            try encodeContainer.encode(trueActivity, forKey: .trueActivity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(Condition.self, forKey: .condition)
        condition = conditionDecoded
        let evaluationWaitTimeDecoded = try containerValues.decodeIfPresent(WaitTime.self, forKey: .evaluationWaitTime)
        evaluationWaitTime = evaluationWaitTimeDecoded
        let falseActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .falseActivity)
        falseActivity = falseActivityDecoded
        let trueActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .trueActivity)
        trueActivity = trueActivityDecoded
    }
}

extension ConditionalSplitActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConditionalSplitActivity(condition: \(String(describing: condition)), evaluationWaitTime: \(String(describing: evaluationWaitTime)), falseActivity: \(String(describing: falseActivity)), trueActivity: \(String(describing: trueActivity)))"}
}

/// <p>Specifies the settings for a yes/no split activity in a journey. This type of activity sends participants down one of two paths in a journey, based on conditions that you specify.</p> <note><p>To create yes/no split activities that send participants down different paths based on push notification events (such as Open or Received events), your mobile app has to specify the User ID and Endpoint ID values. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/integrate.html">Integrating Amazon Pinpoint with your application</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p></note>
public struct ConditionalSplitActivity: Equatable {
    /// <p>The conditions that define the paths for the activity, and the relationship between the conditions.</p>
    public let condition: Condition?
    /// <p>The amount of time to wait before determining whether the conditions are met, or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
    public let evaluationWaitTime: WaitTime?
    /// <p>The unique identifier for the activity to perform if the conditions aren't met.</p>
    public let falseActivity: String?
    /// <p>The unique identifier for the activity to perform if the conditions are met.</p>
    public let trueActivity: String?

    public init (
        condition: Condition? = nil,
        evaluationWaitTime: WaitTime? = nil,
        falseActivity: String? = nil,
        trueActivity: String? = nil
    )
    {
        self.condition = condition
        self.evaluationWaitTime = evaluationWaitTime
        self.falseActivity = falseActivity
        self.trueActivity = trueActivity
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

public struct CreateAppInputBodyMiddleware: Middleware {
    public let id: String = "CreateAppInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let createApplicationRequest = input.operationInput.createApplicationRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(createApplicationRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

extension CreateAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppInput(createApplicationRequest: \(String(describing: createApplicationRequest)))"}
}

extension CreateAppInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createApplicationRequest = "CreateApplicationRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createApplicationRequest = createApplicationRequest {
            try encodeContainer.encode(createApplicationRequest, forKey: .createApplicationRequest)
        }
    }
}

public struct CreateAppInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

public struct CreateAppInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAppInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAppInput>
    public typealias MOutput = OperationOutput<CreateAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAppOutputError>
}

public struct CreateAppInput: Equatable {
    /// <p>Specifies the display name of an application and the tags to associate with the application.</p>
    public let createApplicationRequest: CreateApplicationRequest?

    public init (
        createApplicationRequest: CreateApplicationRequest? = nil
    )
    {
        self.createApplicationRequest = createApplicationRequest
    }
}

struct CreateAppInputBody: Equatable {
    public let createApplicationRequest: CreateApplicationRequest?
}

extension CreateAppInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createApplicationRequest = "CreateApplicationRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createApplicationRequestDecoded = try containerValues.decodeIfPresent(CreateApplicationRequest.self, forKey: .createApplicationRequest)
        createApplicationRequest = createApplicationRequestDecoded
    }
}

extension CreateAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAppOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAppOutputResponse(applicationResponse: \(String(describing: applicationResponse)))"}
}

extension CreateAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ApplicationResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.applicationResponse = output
            } else {
                self.applicationResponse = nil
            }
        } else {
            self.applicationResponse = nil
        }
    }
}

public struct CreateAppOutputResponse: Equatable {
    /// <p>Provides information about an application.</p>
    public let applicationResponse: ApplicationResponse?

    public init (
        applicationResponse: ApplicationResponse? = nil
    )
    {
        self.applicationResponse = applicationResponse
    }
}

struct CreateAppOutputResponseBody: Equatable {
    public let applicationResponse: ApplicationResponse?
}

extension CreateAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationResponse = "ApplicationResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationResponseDecoded = try containerValues.decodeIfPresent(ApplicationResponse.self, forKey: .applicationResponse)
        applicationResponse = applicationResponseDecoded
    }
}

extension CreateApplicationRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationRequest(name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

/// <p>Specifies the display name of an application and the tags to associate with the application.</p>
public struct CreateApplicationRequest: Equatable {
    /// <p>The display name of the application. This name is displayed as the <b>Project name</b> on the Amazon Pinpoint console.</p>
    public let name: String?
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the application. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?

    public init (
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.name = name
        self.tags = tags
    }
}

public struct CreateCampaignInputBodyMiddleware: Middleware {
    public let id: String = "CreateCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeCampaignRequest = input.operationInput.writeCampaignRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeCampaignRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCampaignOutputError>
}

extension CreateCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCampaignInput(applicationId: \(String(describing: applicationId)), writeCampaignRequest: \(String(describing: writeCampaignRequest)))"}
}

extension CreateCampaignInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeCampaignRequest = "WriteCampaignRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeCampaignRequest = writeCampaignRequest {
            try encodeContainer.encode(writeCampaignRequest, forKey: .writeCampaignRequest)
        }
    }
}

public struct CreateCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCampaignOutputError>
}

public struct CreateCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCampaignInput>
    public typealias MOutput = OperationOutput<CreateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCampaignOutputError>
}

public struct CreateCampaignInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the configuration and other settings for a campaign.</p>
    public let writeCampaignRequest: WriteCampaignRequest?

    public init (
        applicationId: String? = nil,
        writeCampaignRequest: WriteCampaignRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeCampaignRequest = writeCampaignRequest
    }
}

struct CreateCampaignInputBody: Equatable {
    public let writeCampaignRequest: WriteCampaignRequest?
}

extension CreateCampaignInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeCampaignRequest = "WriteCampaignRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeCampaignRequestDecoded = try containerValues.decodeIfPresent(WriteCampaignRequest.self, forKey: .writeCampaignRequest)
        writeCampaignRequest = writeCampaignRequestDecoded
    }
}

extension CreateCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCampaignOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCampaignOutputResponse(campaignResponse: \(String(describing: campaignResponse)))"}
}

extension CreateCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignResponse = output
            } else {
                self.campaignResponse = nil
            }
        } else {
            self.campaignResponse = nil
        }
    }
}

public struct CreateCampaignOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
    public let campaignResponse: CampaignResponse?

    public init (
        campaignResponse: CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

struct CreateCampaignOutputResponseBody: Equatable {
    public let campaignResponse: CampaignResponse?
}

extension CreateCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignResponse = "CampaignResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignResponseDecoded = try containerValues.decodeIfPresent(CampaignResponse.self, forKey: .campaignResponse)
        campaignResponse = campaignResponseDecoded
    }
}

public struct CreateEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let emailTemplateRequest = input.operationInput.emailTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(emailTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailTemplateOutputError>
}

extension CreateEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailTemplateInput(emailTemplateRequest: \(String(describing: emailTemplateRequest)), templateName: \(String(describing: templateName)))"}
}

extension CreateEmailTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailTemplateRequest = "EmailTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailTemplateRequest = emailTemplateRequest {
            try encodeContainer.encode(emailTemplateRequest, forKey: .emailTemplateRequest)
        }
    }
}

public struct CreateEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailTemplateOutputError>
}

public struct CreateEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEmailTemplateInput>
    public typealias MOutput = OperationOutput<CreateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEmailTemplateOutputError>
}

public struct CreateEmailTemplateInput: Equatable {
    /// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the email channel.</p>
    public let emailTemplateRequest: EmailTemplateRequest?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?

    public init (
        emailTemplateRequest: EmailTemplateRequest? = nil,
        templateName: String? = nil
    )
    {
        self.emailTemplateRequest = emailTemplateRequest
        self.templateName = templateName
    }
}

struct CreateEmailTemplateInputBody: Equatable {
    public let emailTemplateRequest: EmailTemplateRequest?
}

extension CreateEmailTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailTemplateRequest = "EmailTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailTemplateRequestDecoded = try containerValues.decodeIfPresent(EmailTemplateRequest.self, forKey: .emailTemplateRequest)
        emailTemplateRequest = emailTemplateRequestDecoded
    }
}

extension CreateEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEmailTemplateOutputResponse(createTemplateMessageBody: \(String(describing: createTemplateMessageBody)))"}
}

extension CreateEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CreateTemplateMessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.createTemplateMessageBody = output
            } else {
                self.createTemplateMessageBody = nil
            }
        } else {
            self.createTemplateMessageBody = nil
        }
    }
}

public struct CreateEmailTemplateOutputResponse: Equatable {
    /// <p>Provides information about a request to create a message template.</p>
    public let createTemplateMessageBody: CreateTemplateMessageBody?

    public init (
        createTemplateMessageBody: CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

struct CreateEmailTemplateOutputResponseBody: Equatable {
    public let createTemplateMessageBody: CreateTemplateMessageBody?
}

extension CreateEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createTemplateMessageBody = "CreateTemplateMessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTemplateMessageBodyDecoded = try containerValues.decodeIfPresent(CreateTemplateMessageBody.self, forKey: .createTemplateMessageBody)
        createTemplateMessageBody = createTemplateMessageBodyDecoded
    }
}

public struct CreateExportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateExportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let exportJobRequest = input.operationInput.exportJobRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(exportJobRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExportJobInput>
    public typealias MOutput = OperationOutput<CreateExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExportJobOutputError>
}

extension CreateExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExportJobInput(applicationId: \(String(describing: applicationId)), exportJobRequest: \(String(describing: exportJobRequest)))"}
}

extension CreateExportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportJobRequest = "ExportJobRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportJobRequest = exportJobRequest {
            try encodeContainer.encode(exportJobRequest, forKey: .exportJobRequest)
        }
    }
}

public struct CreateExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExportJobInput>
    public typealias MOutput = OperationOutput<CreateExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExportJobOutputError>
}

public struct CreateExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExportJobInput>
    public typealias MOutput = OperationOutput<CreateExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExportJobOutputError>
}

public struct CreateExportJobInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the settings for a job that exports endpoint definitions to an Amazon Simple Storage Service (Amazon S3) bucket.</p>
    public let exportJobRequest: ExportJobRequest?

    public init (
        applicationId: String? = nil,
        exportJobRequest: ExportJobRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.exportJobRequest = exportJobRequest
    }
}

struct CreateExportJobInputBody: Equatable {
    public let exportJobRequest: ExportJobRequest?
}

extension CreateExportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportJobRequest = "ExportJobRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobRequestDecoded = try containerValues.decodeIfPresent(ExportJobRequest.self, forKey: .exportJobRequest)
        exportJobRequest = exportJobRequestDecoded
    }
}

extension CreateExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExportJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExportJobOutputResponse(exportJobResponse: \(String(describing: exportJobResponse)))"}
}

extension CreateExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ExportJobResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.exportJobResponse = output
            } else {
                self.exportJobResponse = nil
            }
        } else {
            self.exportJobResponse = nil
        }
    }
}

public struct CreateExportJobOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.</p>
    public let exportJobResponse: ExportJobResponse?

    public init (
        exportJobResponse: ExportJobResponse? = nil
    )
    {
        self.exportJobResponse = exportJobResponse
    }
}

struct CreateExportJobOutputResponseBody: Equatable {
    public let exportJobResponse: ExportJobResponse?
}

extension CreateExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportJobResponse = "ExportJobResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobResponseDecoded = try containerValues.decodeIfPresent(ExportJobResponse.self, forKey: .exportJobResponse)
        exportJobResponse = exportJobResponseDecoded
    }
}

public struct CreateImportJobInputBodyMiddleware: Middleware {
    public let id: String = "CreateImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let importJobRequest = input.operationInput.importJobRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(importJobRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImportJobInput>
    public typealias MOutput = OperationOutput<CreateImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImportJobOutputError>
}

extension CreateImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImportJobInput(applicationId: \(String(describing: applicationId)), importJobRequest: \(String(describing: importJobRequest)))"}
}

extension CreateImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case importJobRequest = "ImportJobRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let importJobRequest = importJobRequest {
            try encodeContainer.encode(importJobRequest, forKey: .importJobRequest)
        }
    }
}

public struct CreateImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "CreateImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImportJobInput>
    public typealias MOutput = OperationOutput<CreateImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImportJobOutputError>
}

public struct CreateImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateImportJobInput>
    public typealias MOutput = OperationOutput<CreateImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateImportJobOutputError>
}

public struct CreateImportJobInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the settings for a job that imports endpoint definitions from an Amazon Simple Storage Service (Amazon S3) bucket.</p>
    public let importJobRequest: ImportJobRequest?

    public init (
        applicationId: String? = nil,
        importJobRequest: ImportJobRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.importJobRequest = importJobRequest
    }
}

struct CreateImportJobInputBody: Equatable {
    public let importJobRequest: ImportJobRequest?
}

extension CreateImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importJobRequest = "ImportJobRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobRequestDecoded = try containerValues.decodeIfPresent(ImportJobRequest.self, forKey: .importJobRequest)
        importJobRequest = importJobRequestDecoded
    }
}

extension CreateImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateImportJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateImportJobOutputResponse(importJobResponse: \(String(describing: importJobResponse)))"}
}

extension CreateImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ImportJobResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.importJobResponse = output
            } else {
                self.importJobResponse = nil
            }
        } else {
            self.importJobResponse = nil
        }
    }
}

public struct CreateImportJobOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.</p>
    public let importJobResponse: ImportJobResponse?

    public init (
        importJobResponse: ImportJobResponse? = nil
    )
    {
        self.importJobResponse = importJobResponse
    }
}

struct CreateImportJobOutputResponseBody: Equatable {
    public let importJobResponse: ImportJobResponse?
}

extension CreateImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importJobResponse = "ImportJobResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobResponseDecoded = try containerValues.decodeIfPresent(ImportJobResponse.self, forKey: .importJobResponse)
        importJobResponse = importJobResponseDecoded
    }
}

public struct CreateJourneyInputBodyMiddleware: Middleware {
    public let id: String = "CreateJourneyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeJourneyRequest = input.operationInput.writeJourneyRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeJourneyRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJourneyInput>
    public typealias MOutput = OperationOutput<CreateJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJourneyOutputError>
}

extension CreateJourneyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJourneyInput(applicationId: \(String(describing: applicationId)), writeJourneyRequest: \(String(describing: writeJourneyRequest)))"}
}

extension CreateJourneyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeJourneyRequest = "WriteJourneyRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeJourneyRequest = writeJourneyRequest {
            try encodeContainer.encode(writeJourneyRequest, forKey: .writeJourneyRequest)
        }
    }
}

public struct CreateJourneyInputHeadersMiddleware: Middleware {
    public let id: String = "CreateJourneyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJourneyInput>
    public typealias MOutput = OperationOutput<CreateJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJourneyOutputError>
}

public struct CreateJourneyInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateJourneyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateJourneyInput>
    public typealias MOutput = OperationOutput<CreateJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateJourneyOutputError>
}

public struct CreateJourneyInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the configuration and other settings for a journey.</p>
    public let writeJourneyRequest: WriteJourneyRequest?

    public init (
        applicationId: String? = nil,
        writeJourneyRequest: WriteJourneyRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeJourneyRequest = writeJourneyRequest
    }
}

struct CreateJourneyInputBody: Equatable {
    public let writeJourneyRequest: WriteJourneyRequest?
}

extension CreateJourneyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeJourneyRequest = "WriteJourneyRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeJourneyRequestDecoded = try containerValues.decodeIfPresent(WriteJourneyRequest.self, forKey: .writeJourneyRequest)
        writeJourneyRequest = writeJourneyRequestDecoded
    }
}

extension CreateJourneyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateJourneyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateJourneyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateJourneyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateJourneyOutputResponse(journeyResponse: \(String(describing: journeyResponse)))"}
}

extension CreateJourneyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyResponse = output
            } else {
                self.journeyResponse = nil
            }
        } else {
            self.journeyResponse = nil
        }
    }
}

public struct CreateJourneyOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a journey.</p>
    public let journeyResponse: JourneyResponse?

    public init (
        journeyResponse: JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

struct CreateJourneyOutputResponseBody: Equatable {
    public let journeyResponse: JourneyResponse?
}

extension CreateJourneyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyResponse = "JourneyResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyResponseDecoded = try containerValues.decodeIfPresent(JourneyResponse.self, forKey: .journeyResponse)
        journeyResponse = journeyResponseDecoded
    }
}

public struct CreatePushTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreatePushTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pushNotificationTemplateRequest = input.operationInput.pushNotificationTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(pushNotificationTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePushTemplateInput>
    public typealias MOutput = OperationOutput<CreatePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePushTemplateOutputError>
}

extension CreatePushTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePushTemplateInput(pushNotificationTemplateRequest: \(String(describing: pushNotificationTemplateRequest)), templateName: \(String(describing: templateName)))"}
}

extension CreatePushTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pushNotificationTemplateRequest = "PushNotificationTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pushNotificationTemplateRequest = pushNotificationTemplateRequest {
            try encodeContainer.encode(pushNotificationTemplateRequest, forKey: .pushNotificationTemplateRequest)
        }
    }
}

public struct CreatePushTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreatePushTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePushTemplateInput>
    public typealias MOutput = OperationOutput<CreatePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePushTemplateOutputError>
}

public struct CreatePushTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreatePushTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreatePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreatePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreatePushTemplateInput>
    public typealias MOutput = OperationOutput<CreatePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreatePushTemplateOutputError>
}

public struct CreatePushTemplateInput: Equatable {
    /// <p>Specifies the content and settings for a message template that can be used in messages that are sent through a push notification channel.</p>
    public let pushNotificationTemplateRequest: PushNotificationTemplateRequest?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?

    public init (
        pushNotificationTemplateRequest: PushNotificationTemplateRequest? = nil,
        templateName: String? = nil
    )
    {
        self.pushNotificationTemplateRequest = pushNotificationTemplateRequest
        self.templateName = templateName
    }
}

struct CreatePushTemplateInputBody: Equatable {
    public let pushNotificationTemplateRequest: PushNotificationTemplateRequest?
}

extension CreatePushTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pushNotificationTemplateRequest = "PushNotificationTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushNotificationTemplateRequestDecoded = try containerValues.decodeIfPresent(PushNotificationTemplateRequest.self, forKey: .pushNotificationTemplateRequest)
        pushNotificationTemplateRequest = pushNotificationTemplateRequestDecoded
    }
}

extension CreatePushTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePushTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePushTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePushTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreatePushTemplateOutputResponse(createTemplateMessageBody: \(String(describing: createTemplateMessageBody)))"}
}

extension CreatePushTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CreateTemplateMessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.createTemplateMessageBody = output
            } else {
                self.createTemplateMessageBody = nil
            }
        } else {
            self.createTemplateMessageBody = nil
        }
    }
}

public struct CreatePushTemplateOutputResponse: Equatable {
    /// <p>Provides information about a request to create a message template.</p>
    public let createTemplateMessageBody: CreateTemplateMessageBody?

    public init (
        createTemplateMessageBody: CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

struct CreatePushTemplateOutputResponseBody: Equatable {
    public let createTemplateMessageBody: CreateTemplateMessageBody?
}

extension CreatePushTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createTemplateMessageBody = "CreateTemplateMessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTemplateMessageBodyDecoded = try containerValues.decodeIfPresent(CreateTemplateMessageBody.self, forKey: .createTemplateMessageBody)
        createTemplateMessageBody = createTemplateMessageBodyDecoded
    }
}

public struct CreateRecommenderConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "CreateRecommenderConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let createRecommenderConfiguration = input.operationInput.createRecommenderConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(createRecommenderConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<CreateRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecommenderConfigurationOutputError>
}

extension CreateRecommenderConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecommenderConfigurationInput(createRecommenderConfiguration: \(String(describing: createRecommenderConfiguration)))"}
}

extension CreateRecommenderConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createRecommenderConfiguration = "CreateRecommenderConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createRecommenderConfiguration = createRecommenderConfiguration {
            try encodeContainer.encode(createRecommenderConfiguration, forKey: .createRecommenderConfiguration)
        }
    }
}

public struct CreateRecommenderConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateRecommenderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<CreateRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecommenderConfigurationOutputError>
}

public struct CreateRecommenderConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateRecommenderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<CreateRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateRecommenderConfigurationOutputError>
}

public struct CreateRecommenderConfigurationInput: Equatable {
    /// <p>Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.</p>
    public let createRecommenderConfiguration: CreateRecommenderConfigurationShape?

    public init (
        createRecommenderConfiguration: CreateRecommenderConfigurationShape? = nil
    )
    {
        self.createRecommenderConfiguration = createRecommenderConfiguration
    }
}

struct CreateRecommenderConfigurationInputBody: Equatable {
    public let createRecommenderConfiguration: CreateRecommenderConfigurationShape?
}

extension CreateRecommenderConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createRecommenderConfiguration = "CreateRecommenderConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createRecommenderConfigurationDecoded = try containerValues.decodeIfPresent(CreateRecommenderConfigurationShape.self, forKey: .createRecommenderConfiguration)
        createRecommenderConfiguration = createRecommenderConfigurationDecoded
    }
}

extension CreateRecommenderConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecommenderConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateRecommenderConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecommenderConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecommenderConfigurationOutputResponse(recommenderConfigurationResponse: \(String(describing: recommenderConfigurationResponse)))"}
}

extension CreateRecommenderConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RecommenderConfigurationResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.recommenderConfigurationResponse = output
            } else {
                self.recommenderConfigurationResponse = nil
            }
        } else {
            self.recommenderConfigurationResponse = nil
        }
    }
}

public struct CreateRecommenderConfigurationOutputResponse: Equatable {
    /// <p>Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.</p>
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?

    public init (
        recommenderConfigurationResponse: RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

struct CreateRecommenderConfigurationOutputResponseBody: Equatable {
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?
}

extension CreateRecommenderConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recommenderConfigurationResponse = "RecommenderConfigurationResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderConfigurationResponseDecoded = try containerValues.decodeIfPresent(RecommenderConfigurationResponse.self, forKey: .recommenderConfigurationResponse)
        recommenderConfigurationResponse = recommenderConfigurationResponseDecoded
    }
}

extension CreateRecommenderConfigurationShape: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case description = "Description"
        case name = "Name"
        case recommendationProviderIdType = "RecommendationProviderIdType"
        case recommendationProviderRoleArn = "RecommendationProviderRoleArn"
        case recommendationProviderUri = "RecommendationProviderUri"
        case recommendationTransformerUri = "RecommendationTransformerUri"
        case recommendationsDisplayName = "RecommendationsDisplayName"
        case recommendationsPerMessage = "RecommendationsPerMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapof__string0) in attributes {
                try attributesContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationProviderIdType = recommendationProviderIdType {
            try encodeContainer.encode(recommendationProviderIdType, forKey: .recommendationProviderIdType)
        }
        if let recommendationProviderRoleArn = recommendationProviderRoleArn {
            try encodeContainer.encode(recommendationProviderRoleArn, forKey: .recommendationProviderRoleArn)
        }
        if let recommendationProviderUri = recommendationProviderUri {
            try encodeContainer.encode(recommendationProviderUri, forKey: .recommendationProviderUri)
        }
        if let recommendationTransformerUri = recommendationTransformerUri {
            try encodeContainer.encode(recommendationTransformerUri, forKey: .recommendationTransformerUri)
        }
        if let recommendationsDisplayName = recommendationsDisplayName {
            try encodeContainer.encode(recommendationsDisplayName, forKey: .recommendationsDisplayName)
        }
        if recommendationsPerMessage != 0 {
            try encodeContainer.encode(recommendationsPerMessage, forKey: .recommendationsPerMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, __string0) in attributesContainer {
                if let __string0 = __string0 {
                    attributesDecoded0?[key0] = __string0
                }
            }
        }
        attributes = attributesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recommendationProviderIdTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderIdType)
        recommendationProviderIdType = recommendationProviderIdTypeDecoded
        let recommendationProviderRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderRoleArn)
        recommendationProviderRoleArn = recommendationProviderRoleArnDecoded
        let recommendationProviderUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderUri)
        recommendationProviderUri = recommendationProviderUriDecoded
        let recommendationTransformerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationTransformerUri)
        recommendationTransformerUri = recommendationTransformerUriDecoded
        let recommendationsDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationsDisplayName)
        recommendationsDisplayName = recommendationsDisplayNameDecoded
        let recommendationsPerMessageDecoded = try containerValues.decode(Int.self, forKey: .recommendationsPerMessage)
        recommendationsPerMessage = recommendationsPerMessageDecoded
    }
}

extension CreateRecommenderConfigurationShape: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRecommenderConfigurationShape(attributes: \(String(describing: attributes)), description: \(String(describing: description)), name: \(String(describing: name)), recommendationProviderIdType: \(String(describing: recommendationProviderIdType)), recommendationProviderRoleArn: \(String(describing: recommendationProviderRoleArn)), recommendationProviderUri: \(String(describing: recommendationProviderUri)), recommendationTransformerUri: \(String(describing: recommendationTransformerUri)), recommendationsDisplayName: \(String(describing: recommendationsDisplayName)), recommendationsPerMessage: \(String(describing: recommendationsPerMessage)))"}
}

/// <p>Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.</p>
public struct CreateRecommenderConfigurationShape: Equatable {
    /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
    public let attributes: [String:String]?
    /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
    public let description: String?
    /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
    public let name: String?
    /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
    public let recommendationProviderIdType: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
    public let recommendationProviderRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
    public let recommendationProviderUri: String?
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
    public let recommendationTransformerUri: String?
    /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
    public let recommendationsDisplayName: String?
    /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    public let recommendationsPerMessage: Int

    public init (
        attributes: [String:String]? = nil,
        description: String? = nil,
        name: String? = nil,
        recommendationProviderIdType: String? = nil,
        recommendationProviderRoleArn: String? = nil,
        recommendationProviderUri: String? = nil,
        recommendationTransformerUri: String? = nil,
        recommendationsDisplayName: String? = nil,
        recommendationsPerMessage: Int = 0
    )
    {
        self.attributes = attributes
        self.description = description
        self.name = name
        self.recommendationProviderIdType = recommendationProviderIdType
        self.recommendationProviderRoleArn = recommendationProviderRoleArn
        self.recommendationProviderUri = recommendationProviderUri
        self.recommendationTransformerUri = recommendationTransformerUri
        self.recommendationsDisplayName = recommendationsDisplayName
        self.recommendationsPerMessage = recommendationsPerMessage
    }
}

public struct CreateSegmentInputBodyMiddleware: Middleware {
    public let id: String = "CreateSegmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeSegmentRequest = input.operationInput.writeSegmentRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeSegmentRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSegmentInput>
    public typealias MOutput = OperationOutput<CreateSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSegmentOutputError>
}

extension CreateSegmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSegmentInput(applicationId: \(String(describing: applicationId)), writeSegmentRequest: \(String(describing: writeSegmentRequest)))"}
}

extension CreateSegmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeSegmentRequest = "WriteSegmentRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeSegmentRequest = writeSegmentRequest {
            try encodeContainer.encode(writeSegmentRequest, forKey: .writeSegmentRequest)
        }
    }
}

public struct CreateSegmentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSegmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSegmentInput>
    public typealias MOutput = OperationOutput<CreateSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSegmentOutputError>
}

public struct CreateSegmentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSegmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSegmentInput>
    public typealias MOutput = OperationOutput<CreateSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSegmentOutputError>
}

public struct CreateSegmentInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the configuration, dimension, and other settings for a segment. A WriteSegmentRequest object can include a Dimensions object or a SegmentGroups object, but not both.</p>
    public let writeSegmentRequest: WriteSegmentRequest?

    public init (
        applicationId: String? = nil,
        writeSegmentRequest: WriteSegmentRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeSegmentRequest = writeSegmentRequest
    }
}

struct CreateSegmentInputBody: Equatable {
    public let writeSegmentRequest: WriteSegmentRequest?
}

extension CreateSegmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeSegmentRequest = "WriteSegmentRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeSegmentRequestDecoded = try containerValues.decodeIfPresent(WriteSegmentRequest.self, forKey: .writeSegmentRequest)
        writeSegmentRequest = writeSegmentRequestDecoded
    }
}

extension CreateSegmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSegmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSegmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSegmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSegmentOutputResponse(segmentResponse: \(String(describing: segmentResponse)))"}
}

extension CreateSegmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SegmentResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.segmentResponse = output
            } else {
                self.segmentResponse = nil
            }
        } else {
            self.segmentResponse = nil
        }
    }
}

public struct CreateSegmentOutputResponse: Equatable {
    /// <p>Provides information about the configuration, dimension, and other settings for a segment.</p>
    public let segmentResponse: SegmentResponse?

    public init (
        segmentResponse: SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

struct CreateSegmentOutputResponseBody: Equatable {
    public let segmentResponse: SegmentResponse?
}

extension CreateSegmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case segmentResponse = "SegmentResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentResponseDecoded = try containerValues.decodeIfPresent(SegmentResponse.self, forKey: .segmentResponse)
        segmentResponse = segmentResponseDecoded
    }
}

public struct CreateSmsTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateSmsTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sMSTemplateRequest = input.operationInput.sMSTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(sMSTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSmsTemplateInput>
    public typealias MOutput = OperationOutput<CreateSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSmsTemplateOutputError>
}

extension CreateSmsTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSmsTemplateInput(sMSTemplateRequest: \(String(describing: sMSTemplateRequest)), templateName: \(String(describing: templateName)))"}
}

extension CreateSmsTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sMSTemplateRequest = "SMSTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sMSTemplateRequest = sMSTemplateRequest {
            try encodeContainer.encode(sMSTemplateRequest, forKey: .sMSTemplateRequest)
        }
    }
}

public struct CreateSmsTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSmsTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSmsTemplateInput>
    public typealias MOutput = OperationOutput<CreateSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSmsTemplateOutputError>
}

public struct CreateSmsTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSmsTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSmsTemplateInput>
    public typealias MOutput = OperationOutput<CreateSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSmsTemplateOutputError>
}

public struct CreateSmsTemplateInput: Equatable {
    /// <p>Specifies the content and settings for a message template that can be used in text messages that are sent through the SMS channel.</p>
    public let sMSTemplateRequest: SMSTemplateRequest?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?

    public init (
        sMSTemplateRequest: SMSTemplateRequest? = nil,
        templateName: String? = nil
    )
    {
        self.sMSTemplateRequest = sMSTemplateRequest
        self.templateName = templateName
    }
}

struct CreateSmsTemplateInputBody: Equatable {
    public let sMSTemplateRequest: SMSTemplateRequest?
}

extension CreateSmsTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSTemplateRequest = "SMSTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSTemplateRequestDecoded = try containerValues.decodeIfPresent(SMSTemplateRequest.self, forKey: .sMSTemplateRequest)
        sMSTemplateRequest = sMSTemplateRequestDecoded
    }
}

extension CreateSmsTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSmsTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSmsTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSmsTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSmsTemplateOutputResponse(createTemplateMessageBody: \(String(describing: createTemplateMessageBody)))"}
}

extension CreateSmsTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CreateTemplateMessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.createTemplateMessageBody = output
            } else {
                self.createTemplateMessageBody = nil
            }
        } else {
            self.createTemplateMessageBody = nil
        }
    }
}

public struct CreateSmsTemplateOutputResponse: Equatable {
    /// <p>Provides information about a request to create a message template.</p>
    public let createTemplateMessageBody: CreateTemplateMessageBody?

    public init (
        createTemplateMessageBody: CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

struct CreateSmsTemplateOutputResponseBody: Equatable {
    public let createTemplateMessageBody: CreateTemplateMessageBody?
}

extension CreateSmsTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createTemplateMessageBody = "CreateTemplateMessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTemplateMessageBodyDecoded = try containerValues.decodeIfPresent(CreateTemplateMessageBody.self, forKey: .createTemplateMessageBody)
        createTemplateMessageBody = createTemplateMessageBodyDecoded
    }
}

extension CreateTemplateMessageBody: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case message = "Message"
        case requestID = "RequestID"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let requestID = requestID {
            try encodeContainer.encode(requestID, forKey: .requestID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension CreateTemplateMessageBody: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTemplateMessageBody(arn: \(String(describing: arn)), message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

/// <p>Provides information about a request to create a message template.</p>
public struct CreateTemplateMessageBody: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the message template that was created.</p>
    public let arn: String?
    /// <p>The message that's returned from the API for the request to create the message template.</p>
    public let message: String?
    /// <p>The unique identifier for the request to create the message template.</p>
    public let requestID: String?

    public init (
        arn: String? = nil,
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.arn = arn
        self.message = message
        self.requestID = requestID
    }
}

public struct CreateVoiceTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateVoiceTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let voiceTemplateRequest = input.operationInput.voiceTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(voiceTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVoiceTemplateInput>
    public typealias MOutput = OperationOutput<CreateVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVoiceTemplateOutputError>
}

extension CreateVoiceTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVoiceTemplateInput(templateName: \(String(describing: templateName)), voiceTemplateRequest: \(String(describing: voiceTemplateRequest)))"}
}

extension CreateVoiceTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case voiceTemplateRequest = "VoiceTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceTemplateRequest = voiceTemplateRequest {
            try encodeContainer.encode(voiceTemplateRequest, forKey: .voiceTemplateRequest)
        }
    }
}

public struct CreateVoiceTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateVoiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVoiceTemplateInput>
    public typealias MOutput = OperationOutput<CreateVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVoiceTemplateOutputError>
}

public struct CreateVoiceTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateVoiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateVoiceTemplateInput>
    public typealias MOutput = OperationOutput<CreateVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateVoiceTemplateOutputError>
}

public struct CreateVoiceTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the voice channel.</p>
    public let voiceTemplateRequest: VoiceTemplateRequest?

    public init (
        templateName: String? = nil,
        voiceTemplateRequest: VoiceTemplateRequest? = nil
    )
    {
        self.templateName = templateName
        self.voiceTemplateRequest = voiceTemplateRequest
    }
}

struct CreateVoiceTemplateInputBody: Equatable {
    public let voiceTemplateRequest: VoiceTemplateRequest?
}

extension CreateVoiceTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case voiceTemplateRequest = "VoiceTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceTemplateRequestDecoded = try containerValues.decodeIfPresent(VoiceTemplateRequest.self, forKey: .voiceTemplateRequest)
        voiceTemplateRequest = voiceTemplateRequestDecoded
    }
}

extension CreateVoiceTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateVoiceTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateVoiceTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateVoiceTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateVoiceTemplateOutputResponse(createTemplateMessageBody: \(String(describing: createTemplateMessageBody)))"}
}

extension CreateVoiceTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CreateTemplateMessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.createTemplateMessageBody = output
            } else {
                self.createTemplateMessageBody = nil
            }
        } else {
            self.createTemplateMessageBody = nil
        }
    }
}

public struct CreateVoiceTemplateOutputResponse: Equatable {
    /// <p>Provides information about a request to create a message template.</p>
    public let createTemplateMessageBody: CreateTemplateMessageBody?

    public init (
        createTemplateMessageBody: CreateTemplateMessageBody? = nil
    )
    {
        self.createTemplateMessageBody = createTemplateMessageBody
    }
}

struct CreateVoiceTemplateOutputResponseBody: Equatable {
    public let createTemplateMessageBody: CreateTemplateMessageBody?
}

extension CreateVoiceTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createTemplateMessageBody = "CreateTemplateMessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createTemplateMessageBodyDecoded = try containerValues.decodeIfPresent(CreateTemplateMessageBody.self, forKey: .createTemplateMessageBody)
        createTemplateMessageBody = createTemplateMessageBodyDecoded
    }
}

extension CustomDeliveryConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryUri = "DeliveryUri"
        case endpointTypes = "EndpointTypes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryUri = deliveryUri {
            try encodeContainer.encode(deliveryUri, forKey: .deliveryUri)
        }
        if let endpointTypes = endpointTypes {
            var endpointTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointTypes)
            for listof__endpointtypeselement0 in endpointTypes {
                try endpointTypesContainer.encode(listof__endpointtypeselement0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryUri)
        deliveryUri = deliveryUriDecoded
        let endpointTypesContainer = try containerValues.decodeIfPresent([__EndpointTypesElement?].self, forKey: .endpointTypes)
        var endpointTypesDecoded0:[__EndpointTypesElement]? = nil
        if let endpointTypesContainer = endpointTypesContainer {
            endpointTypesDecoded0 = [__EndpointTypesElement]()
            for string0 in endpointTypesContainer {
                if let string0 = string0 {
                    endpointTypesDecoded0?.append(string0)
                }
            }
        }
        endpointTypes = endpointTypesDecoded0
    }
}

extension CustomDeliveryConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomDeliveryConfiguration(deliveryUri: \(String(describing: deliveryUri)), endpointTypes: \(String(describing: endpointTypes)))"}
}

/// <p>Specifies the delivery configuration settings for sending a campaign or campaign treatment through a custom channel. This object is required if you use the CampaignCustomMessage object to define the message to send for the campaign or campaign treatment.</p>
public struct CustomDeliveryConfiguration: Equatable {
    /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
    public let deliveryUri: String?
    /// <p>The types of endpoints to send the campaign or treatment to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
    public let endpointTypes: [__EndpointTypesElement]?

    public init (
        deliveryUri: String? = nil,
        endpointTypes: [__EndpointTypesElement]? = nil
    )
    {
        self.deliveryUri = deliveryUri
        self.endpointTypes = endpointTypes
    }
}

extension CustomMessageActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryUri = "DeliveryUri"
        case endpointTypes = "EndpointTypes"
        case messageConfig = "MessageConfig"
        case nextActivity = "NextActivity"
        case templateName = "TemplateName"
        case templateVersion = "TemplateVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryUri = deliveryUri {
            try encodeContainer.encode(deliveryUri, forKey: .deliveryUri)
        }
        if let endpointTypes = endpointTypes {
            var endpointTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endpointTypes)
            for listof__endpointtypeselement0 in endpointTypes {
                try endpointTypesContainer.encode(listof__endpointtypeselement0.rawValue)
            }
        }
        if let messageConfig = messageConfig {
            try encodeContainer.encode(messageConfig, forKey: .messageConfig)
        }
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateVersion = templateVersion {
            try encodeContainer.encode(templateVersion, forKey: .templateVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryUri)
        deliveryUri = deliveryUriDecoded
        let endpointTypesContainer = try containerValues.decodeIfPresent([__EndpointTypesElement?].self, forKey: .endpointTypes)
        var endpointTypesDecoded0:[__EndpointTypesElement]? = nil
        if let endpointTypesContainer = endpointTypesContainer {
            endpointTypesDecoded0 = [__EndpointTypesElement]()
            for string0 in endpointTypesContainer {
                if let string0 = string0 {
                    endpointTypesDecoded0?.append(string0)
                }
            }
        }
        endpointTypes = endpointTypesDecoded0
        let messageConfigDecoded = try containerValues.decodeIfPresent(JourneyCustomMessage.self, forKey: .messageConfig)
        messageConfig = messageConfigDecoded
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
    }
}

extension CustomMessageActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomMessageActivity(deliveryUri: \(String(describing: deliveryUri)), endpointTypes: \(String(describing: endpointTypes)), messageConfig: \(String(describing: messageConfig)), nextActivity: \(String(describing: nextActivity)), templateName: \(String(describing: templateName)), templateVersion: \(String(describing: templateVersion)))"}
}

/// <p>The settings for a custom message activity. This type of activity calls an AWS Lambda function or web hook that sends messages to participants.</p>
public struct CustomMessageActivity: Equatable {
    /// <p>The destination to send the campaign or treatment to. This value can be one of the following:</p> <ul><li><p>The name or Amazon Resource Name (ARN) of an AWS Lambda function to invoke to handle delivery of the campaign or treatment.</p></li> <li><p>The URL for a web application or service that supports HTTPS and can receive the message. The URL has to be a full URL, including the HTTPS protocol.</p></li></ul>
    public let deliveryUri: String?
    /// <p>The types of endpoints to send the custom message to. Each valid value maps to a type of channel that you can associate with an endpoint by using the ChannelType property of an endpoint.</p>
    public let endpointTypes: [__EndpointTypesElement]?
    /// <p>Specifies the message data included in a custom channel message that's sent to participants in a journey.</p>
    public let messageConfig: JourneyCustomMessage?
    /// <p>The unique identifier for the next activity to perform, after Amazon Pinpoint calls the AWS Lambda function or web hook.</p>
    public let nextActivity: String?
    /// <p>The name of the custom message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    public let templateVersion: String?

    public init (
        deliveryUri: String? = nil,
        endpointTypes: [__EndpointTypesElement]? = nil,
        messageConfig: JourneyCustomMessage? = nil,
        nextActivity: String? = nil,
        templateName: String? = nil,
        templateVersion: String? = nil
    )
    {
        self.deliveryUri = deliveryUri
        self.endpointTypes = endpointTypes
        self.messageConfig = messageConfig
        self.nextActivity = nextActivity
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

extension DefaultMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case substitutions = "Substitutions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
    }
}

extension DefaultMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultMessage(body: \(String(describing: body)), substitutions: \(String(describing: substitutions)))"}
}

/// <p>Specifies the default message for all channels.</p>
public struct DefaultMessage: Equatable {
    /// <p>The default body of the message.</p>
    public let body: String?
    /// <p>The default message variables to use in the message. You can override these default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?

    public init (
        body: String? = nil,
        substitutions: [String:[String]]? = nil
    )
    {
        self.body = body
        self.substitutions = substitutions
    }
}

extension DefaultPushNotificationMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case data = "Data"
        case silentPush = "SilentPush"
        case substitutions = "Substitutions"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .data)
            for (dictKey0, mapof__string0) in data {
                try dataContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if silentPush != false {
            try encodeContainer.encode(silentPush, forKey: .silentPush)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let dataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .data)
        var dataDecoded0: [String:String]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [String:String]()
            for (key0, __string0) in dataContainer {
                if let __string0 = __string0 {
                    dataDecoded0?[key0] = __string0
                }
            }
        }
        data = dataDecoded0
        let silentPushDecoded = try containerValues.decode(Bool.self, forKey: .silentPush)
        silentPush = silentPushDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DefaultPushNotificationMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultPushNotificationMessage(action: \(String(describing: action)), body: \(String(describing: body)), data: \(String(describing: data)), silentPush: \(String(describing: silentPush)), substitutions: \(String(describing: substitutions)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies the default settings and content for a push notification that's sent directly to an endpoint.</p>
public struct DefaultPushNotificationMessage: Equatable {
    /// <p>The default action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The default body of the notification message.</p>
    public let body: String?
    /// <p>The JSON data payload to use for the default push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    public let data: [String:String]?
    /// <p>Specifies whether the default notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or delivering messages to an in-app notification center.</p>
    public let silentPush: Bool
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The default title to display above the notification message on a recipient's device.</p>
    public let title: String?
    /// <p>The default URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        data: [String:String]? = nil,
        silentPush: Bool = false,
        substitutions: [String:[String]]? = nil,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.data = data
        self.silentPush = silentPush
        self.substitutions = substitutions
        self.title = title
        self.url = url
    }
}

extension DefaultPushNotificationTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case sound = "Sound"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let sound = sound {
            try encodeContainer.encode(sound, forKey: .sound)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let soundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sound)
        sound = soundDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension DefaultPushNotificationTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DefaultPushNotificationTemplate(action: \(String(describing: action)), body: \(String(describing: body)), sound: \(String(describing: sound)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies the default settings and content for a message template that can be used in messages that are sent through a push notification channel.</p>
public struct DefaultPushNotificationTemplate: Equatable {
    /// <p>The action to occur if a recipient taps a push notification that's based on the message template. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of the iOS and Android platforms.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The message body to use in push notifications that are based on the message template.</p>
    public let body: String?
    /// <p>The sound to play when a recipient receives a push notification that's based on the message template. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p> <p>For an iOS platform, this value is the key for the name of a sound file in your app's main bundle or the Library/Sounds folder in your app's data container. If the sound file can't be found or you specify default for the value, the system plays the default alert sound.</p>
    public let sound: String?
    /// <p>The title to use in push notifications that are based on the message template. This title appears above the notification message on a recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps a push notification that's based on the message template and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        sound: String? = nil,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.sound = sound
        self.title = title
        self.url = url
    }
}

extension DeleteAdmChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAdmChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteAdmChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAdmChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAdmChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAdmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAdmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAdmChannelInput>
    public typealias MOutput = OperationOutput<DeleteAdmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAdmChannelOutputError>
}

public struct DeleteAdmChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAdmChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAdmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAdmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAdmChannelInput>
    public typealias MOutput = OperationOutput<DeleteAdmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAdmChannelOutputError>
}

public struct DeleteAdmChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteAdmChannelInputBody: Equatable {
}

extension DeleteAdmChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAdmChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAdmChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAdmChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAdmChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAdmChannelOutputResponse(aDMChannelResponse: \(String(describing: aDMChannelResponse)))"}
}

extension DeleteAdmChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ADMChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aDMChannelResponse = output
            } else {
                self.aDMChannelResponse = nil
            }
        } else {
            self.aDMChannelResponse = nil
        }
    }
}

public struct DeleteAdmChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
    public let aDMChannelResponse: ADMChannelResponse?

    public init (
        aDMChannelResponse: ADMChannelResponse? = nil
    )
    {
        self.aDMChannelResponse = aDMChannelResponse
    }
}

struct DeleteAdmChannelOutputResponseBody: Equatable {
    public let aDMChannelResponse: ADMChannelResponse?
}

extension DeleteAdmChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aDMChannelResponse = "ADMChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMChannelResponseDecoded = try containerValues.decodeIfPresent(ADMChannelResponse.self, forKey: .aDMChannelResponse)
        aDMChannelResponse = aDMChannelResponseDecoded
    }
}

extension DeleteApnsChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteApnsChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApnsChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApnsChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsChannelOutputError>
}

public struct DeleteApnsChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApnsChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsChannelOutputError>
}

public struct DeleteApnsChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApnsChannelInputBody: Equatable {
}

extension DeleteApnsChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApnsChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApnsChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApnsChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApnsChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsChannelOutputResponse(aPNSChannelResponse: \(String(describing: aPNSChannelResponse)))"}
}

extension DeleteApnsChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSChannelResponse = output
            } else {
                self.aPNSChannelResponse = nil
            }
        } else {
            self.aPNSChannelResponse = nil
        }
    }
}

public struct DeleteApnsChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
    public let aPNSChannelResponse: APNSChannelResponse?

    public init (
        aPNSChannelResponse: APNSChannelResponse? = nil
    )
    {
        self.aPNSChannelResponse = aPNSChannelResponse
    }
}

struct DeleteApnsChannelOutputResponseBody: Equatable {
    public let aPNSChannelResponse: APNSChannelResponse?
}

extension DeleteApnsChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSChannelResponse = "APNSChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSChannelResponseDecoded = try containerValues.decodeIfPresent(APNSChannelResponse.self, forKey: .aPNSChannelResponse)
        aPNSChannelResponse = aPNSChannelResponseDecoded
    }
}

extension DeleteApnsSandboxChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsSandboxChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteApnsSandboxChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApnsSandboxChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApnsSandboxChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsSandboxChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsSandboxChannelOutputError>
}

public struct DeleteApnsSandboxChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApnsSandboxChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsSandboxChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsSandboxChannelOutputError>
}

public struct DeleteApnsSandboxChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApnsSandboxChannelInputBody: Equatable {
}

extension DeleteApnsSandboxChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApnsSandboxChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApnsSandboxChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApnsSandboxChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApnsSandboxChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsSandboxChannelOutputResponse(aPNSSandboxChannelResponse: \(String(describing: aPNSSandboxChannelResponse)))"}
}

extension DeleteApnsSandboxChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSSandboxChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSSandboxChannelResponse = output
            } else {
                self.aPNSSandboxChannelResponse = nil
            }
        } else {
            self.aPNSSandboxChannelResponse = nil
        }
    }
}

public struct DeleteApnsSandboxChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
    public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse?

    public init (
        aPNSSandboxChannelResponse: APNSSandboxChannelResponse? = nil
    )
    {
        self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
    }
}

struct DeleteApnsSandboxChannelOutputResponseBody: Equatable {
    public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse?
}

extension DeleteApnsSandboxChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSSandboxChannelResponseDecoded = try containerValues.decodeIfPresent(APNSSandboxChannelResponse.self, forKey: .aPNSSandboxChannelResponse)
        aPNSSandboxChannelResponse = aPNSSandboxChannelResponseDecoded
    }
}

extension DeleteApnsVoipChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsVoipChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteApnsVoipChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApnsVoipChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApnsVoipChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsVoipChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsVoipChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsVoipChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsVoipChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsVoipChannelOutputError>
}

public struct DeleteApnsVoipChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApnsVoipChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsVoipChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsVoipChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsVoipChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsVoipChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsVoipChannelOutputError>
}

public struct DeleteApnsVoipChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApnsVoipChannelInputBody: Equatable {
}

extension DeleteApnsVoipChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApnsVoipChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApnsVoipChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApnsVoipChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApnsVoipChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsVoipChannelOutputResponse(aPNSVoipChannelResponse: \(String(describing: aPNSVoipChannelResponse)))"}
}

extension DeleteApnsVoipChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSVoipChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSVoipChannelResponse = output
            } else {
                self.aPNSVoipChannelResponse = nil
            }
        } else {
            self.aPNSVoipChannelResponse = nil
        }
    }
}

public struct DeleteApnsVoipChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
    public let aPNSVoipChannelResponse: APNSVoipChannelResponse?

    public init (
        aPNSVoipChannelResponse: APNSVoipChannelResponse? = nil
    )
    {
        self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
    }
}

struct DeleteApnsVoipChannelOutputResponseBody: Equatable {
    public let aPNSVoipChannelResponse: APNSVoipChannelResponse?
}

extension DeleteApnsVoipChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipChannelResponseDecoded = try containerValues.decodeIfPresent(APNSVoipChannelResponse.self, forKey: .aPNSVoipChannelResponse)
        aPNSVoipChannelResponse = aPNSVoipChannelResponseDecoded
    }
}

extension DeleteApnsVoipSandboxChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsVoipSandboxChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteApnsVoipSandboxChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteApnsVoipSandboxChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApnsVoipSandboxChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsVoipSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsVoipSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsVoipSandboxChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsVoipSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsVoipSandboxChannelOutputError>
}

public struct DeleteApnsVoipSandboxChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApnsVoipSandboxChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApnsVoipSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApnsVoipSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApnsVoipSandboxChannelInput>
    public typealias MOutput = OperationOutput<DeleteApnsVoipSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApnsVoipSandboxChannelOutputError>
}

public struct DeleteApnsVoipSandboxChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteApnsVoipSandboxChannelInputBody: Equatable {
}

extension DeleteApnsVoipSandboxChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteApnsVoipSandboxChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApnsVoipSandboxChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApnsVoipSandboxChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApnsVoipSandboxChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApnsVoipSandboxChannelOutputResponse(aPNSVoipSandboxChannelResponse: \(String(describing: aPNSVoipSandboxChannelResponse)))"}
}

extension DeleteApnsVoipSandboxChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSVoipSandboxChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSVoipSandboxChannelResponse = output
            } else {
                self.aPNSVoipSandboxChannelResponse = nil
            }
        } else {
            self.aPNSVoipSandboxChannelResponse = nil
        }
    }
}

public struct DeleteApnsVoipSandboxChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
    public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse?

    public init (
        aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse? = nil
    )
    {
        self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
    }
}

struct DeleteApnsVoipSandboxChannelOutputResponseBody: Equatable {
    public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse?
}

extension DeleteApnsVoipSandboxChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipSandboxChannelResponseDecoded = try containerValues.decodeIfPresent(APNSVoipSandboxChannelResponse.self, forKey: .aPNSVoipSandboxChannelResponse)
        aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponseDecoded
    }
}

extension DeleteAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteAppInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAppInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

public struct DeleteAppInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAppInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAppInput>
    public typealias MOutput = OperationOutput<DeleteAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAppOutputError>
}

public struct DeleteAppInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteAppInputBody: Equatable {
}

extension DeleteAppInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAppOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAppOutputResponse(applicationResponse: \(String(describing: applicationResponse)))"}
}

extension DeleteAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ApplicationResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.applicationResponse = output
            } else {
                self.applicationResponse = nil
            }
        } else {
            self.applicationResponse = nil
        }
    }
}

public struct DeleteAppOutputResponse: Equatable {
    /// <p>Provides information about an application.</p>
    public let applicationResponse: ApplicationResponse?

    public init (
        applicationResponse: ApplicationResponse? = nil
    )
    {
        self.applicationResponse = applicationResponse
    }
}

struct DeleteAppOutputResponseBody: Equatable {
    public let applicationResponse: ApplicationResponse?
}

extension DeleteAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationResponse = "ApplicationResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationResponseDecoded = try containerValues.decodeIfPresent(ApplicationResponse.self, forKey: .applicationResponse)
        applicationResponse = applicationResponseDecoded
    }
}

extension DeleteBaiduChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBaiduChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteBaiduChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteBaiduChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBaiduChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBaiduChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBaiduChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBaiduChannelInput>
    public typealias MOutput = OperationOutput<DeleteBaiduChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBaiduChannelOutputError>
}

public struct DeleteBaiduChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBaiduChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBaiduChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBaiduChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBaiduChannelInput>
    public typealias MOutput = OperationOutput<DeleteBaiduChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBaiduChannelOutputError>
}

public struct DeleteBaiduChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteBaiduChannelInputBody: Equatable {
}

extension DeleteBaiduChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteBaiduChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBaiduChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBaiduChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBaiduChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBaiduChannelOutputResponse(baiduChannelResponse: \(String(describing: baiduChannelResponse)))"}
}

extension DeleteBaiduChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: BaiduChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.baiduChannelResponse = output
            } else {
                self.baiduChannelResponse = nil
            }
        } else {
            self.baiduChannelResponse = nil
        }
    }
}

public struct DeleteBaiduChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
    public let baiduChannelResponse: BaiduChannelResponse?

    public init (
        baiduChannelResponse: BaiduChannelResponse? = nil
    )
    {
        self.baiduChannelResponse = baiduChannelResponse
    }
}

struct DeleteBaiduChannelOutputResponseBody: Equatable {
    public let baiduChannelResponse: BaiduChannelResponse?
}

extension DeleteBaiduChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baiduChannelResponse = "BaiduChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baiduChannelResponseDecoded = try containerValues.decodeIfPresent(BaiduChannelResponse.self, forKey: .baiduChannelResponse)
        baiduChannelResponse = baiduChannelResponseDecoded
    }
}

extension DeleteCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCampaignInput(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)))"}
}

extension DeleteCampaignInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCampaignOutputError>
}

public struct DeleteCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCampaignInput>
    public typealias MOutput = OperationOutput<DeleteCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCampaignOutputError>
}

public struct DeleteCampaignInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign.</p>
    public let campaignId: String?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
    }
}

struct DeleteCampaignInputBody: Equatable {
}

extension DeleteCampaignInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCampaignOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCampaignOutputResponse(campaignResponse: \(String(describing: campaignResponse)))"}
}

extension DeleteCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignResponse = output
            } else {
                self.campaignResponse = nil
            }
        } else {
            self.campaignResponse = nil
        }
    }
}

public struct DeleteCampaignOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
    public let campaignResponse: CampaignResponse?

    public init (
        campaignResponse: CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

struct DeleteCampaignOutputResponseBody: Equatable {
    public let campaignResponse: CampaignResponse?
}

extension DeleteCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignResponse = "CampaignResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignResponseDecoded = try containerValues.decodeIfPresent(CampaignResponse.self, forKey: .campaignResponse)
        campaignResponse = campaignResponseDecoded
    }
}

extension DeleteEmailChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteEmailChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEmailChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEmailChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailChannelInput>
    public typealias MOutput = OperationOutput<DeleteEmailChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailChannelOutputError>
}

public struct DeleteEmailChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEmailChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailChannelInput>
    public typealias MOutput = OperationOutput<DeleteEmailChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailChannelOutputError>
}

public struct DeleteEmailChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteEmailChannelInputBody: Equatable {
}

extension DeleteEmailChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEmailChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailChannelOutputResponse(emailChannelResponse: \(String(describing: emailChannelResponse)))"}
}

extension DeleteEmailChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EmailChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.emailChannelResponse = output
            } else {
                self.emailChannelResponse = nil
            }
        } else {
            self.emailChannelResponse = nil
        }
    }
}

public struct DeleteEmailChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the email channel for an application.</p>
    public let emailChannelResponse: EmailChannelResponse?

    public init (
        emailChannelResponse: EmailChannelResponse? = nil
    )
    {
        self.emailChannelResponse = emailChannelResponse
    }
}

struct DeleteEmailChannelOutputResponseBody: Equatable {
    public let emailChannelResponse: EmailChannelResponse?
}

extension DeleteEmailChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailChannelResponse = "EmailChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailChannelResponseDecoded = try containerValues.decodeIfPresent(EmailChannelResponse.self, forKey: .emailChannelResponse)
        emailChannelResponse = emailChannelResponseDecoded
    }
}

extension DeleteEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension DeleteEmailTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailTemplateOutputError>
}

public struct DeleteEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEmailTemplateInput>
    public typealias MOutput = OperationOutput<DeleteEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEmailTemplateOutputError>
}

public struct DeleteEmailTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct DeleteEmailTemplateInputBody: Equatable {
}

extension DeleteEmailTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEmailTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension DeleteEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct DeleteEmailTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct DeleteEmailTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension DeleteEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

extension DeleteEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointInput(applicationId: \(String(describing: applicationId)), endpointId: \(String(describing: endpointId)))"}
}

extension DeleteEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEndpointInput>
    public typealias MOutput = OperationOutput<DeleteEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEndpointOutputError>
}

public struct DeleteEndpointInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the endpoint.</p>
    public let endpointId: String?

    public init (
        applicationId: String? = nil,
        endpointId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointId = endpointId
    }
}

struct DeleteEndpointInputBody: Equatable {
}

extension DeleteEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEndpointOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEndpointOutputResponse(endpointResponse: \(String(describing: endpointResponse)))"}
}

extension DeleteEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EndpointResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.endpointResponse = output
            } else {
                self.endpointResponse = nil
            }
        } else {
            self.endpointResponse = nil
        }
    }
}

public struct DeleteEndpointOutputResponse: Equatable {
    /// <p>Provides information about the channel type and other settings for an endpoint.</p>
    public let endpointResponse: EndpointResponse?

    public init (
        endpointResponse: EndpointResponse? = nil
    )
    {
        self.endpointResponse = endpointResponse
    }
}

struct DeleteEndpointOutputResponseBody: Equatable {
    public let endpointResponse: EndpointResponse?
}

extension DeleteEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointResponse = "EndpointResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointResponseDecoded = try containerValues.decodeIfPresent(EndpointResponse.self, forKey: .endpointResponse)
        endpointResponse = endpointResponseDecoded
    }
}

extension DeleteEventStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventStreamInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteEventStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEventStreamInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventStreamInput>
    public typealias MOutput = OperationOutput<DeleteEventStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventStreamOutputError>
}

public struct DeleteEventStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventStreamInput>
    public typealias MOutput = OperationOutput<DeleteEventStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventStreamOutputError>
}

public struct DeleteEventStreamInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteEventStreamInputBody: Equatable {
}

extension DeleteEventStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEventStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventStreamOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventStreamOutputResponse(eventStream: \(String(describing: eventStream)))"}
}

extension DeleteEventStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EventStream = try responseDecoder.decode(responseBody: unwrappedData)
                self.eventStream = output
            } else {
                self.eventStream = nil
            }
        } else {
            self.eventStream = nil
        }
    }
}

public struct DeleteEventStreamOutputResponse: Equatable {
    /// <p>Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.</p>
    public let eventStream: EventStream?

    public init (
        eventStream: EventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

struct DeleteEventStreamOutputResponseBody: Equatable {
    public let eventStream: EventStream?
}

extension DeleteEventStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventStream = "EventStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventStreamDecoded = try containerValues.decodeIfPresent(EventStream.self, forKey: .eventStream)
        eventStream = eventStreamDecoded
    }
}

extension DeleteGcmChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGcmChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteGcmChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGcmChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGcmChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGcmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGcmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGcmChannelInput>
    public typealias MOutput = OperationOutput<DeleteGcmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGcmChannelOutputError>
}

public struct DeleteGcmChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGcmChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGcmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGcmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGcmChannelInput>
    public typealias MOutput = OperationOutput<DeleteGcmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGcmChannelOutputError>
}

public struct DeleteGcmChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteGcmChannelInputBody: Equatable {
}

extension DeleteGcmChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGcmChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGcmChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGcmChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGcmChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGcmChannelOutputResponse(gCMChannelResponse: \(String(describing: gCMChannelResponse)))"}
}

extension DeleteGcmChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: GCMChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.gCMChannelResponse = output
            } else {
                self.gCMChannelResponse = nil
            }
        } else {
            self.gCMChannelResponse = nil
        }
    }
}

public struct DeleteGcmChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
    public let gCMChannelResponse: GCMChannelResponse?

    public init (
        gCMChannelResponse: GCMChannelResponse? = nil
    )
    {
        self.gCMChannelResponse = gCMChannelResponse
    }
}

struct DeleteGcmChannelOutputResponseBody: Equatable {
    public let gCMChannelResponse: GCMChannelResponse?
}

extension DeleteGcmChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gCMChannelResponse = "GCMChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gCMChannelResponseDecoded = try containerValues.decodeIfPresent(GCMChannelResponse.self, forKey: .gCMChannelResponse)
        gCMChannelResponse = gCMChannelResponseDecoded
    }
}

extension DeleteJourneyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJourneyInput(applicationId: \(String(describing: applicationId)), journeyId: \(String(describing: journeyId)))"}
}

extension DeleteJourneyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteJourneyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteJourneyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJourneyInput>
    public typealias MOutput = OperationOutput<DeleteJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJourneyOutputError>
}

public struct DeleteJourneyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteJourneyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteJourneyInput>
    public typealias MOutput = OperationOutput<DeleteJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteJourneyOutputError>
}

public struct DeleteJourneyInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the journey.</p>
    public let journeyId: String?

    public init (
        applicationId: String? = nil,
        journeyId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
    }
}

struct DeleteJourneyInputBody: Equatable {
}

extension DeleteJourneyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteJourneyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJourneyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJourneyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJourneyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteJourneyOutputResponse(journeyResponse: \(String(describing: journeyResponse)))"}
}

extension DeleteJourneyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyResponse = output
            } else {
                self.journeyResponse = nil
            }
        } else {
            self.journeyResponse = nil
        }
    }
}

public struct DeleteJourneyOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a journey.</p>
    public let journeyResponse: JourneyResponse?

    public init (
        journeyResponse: JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

struct DeleteJourneyOutputResponseBody: Equatable {
    public let journeyResponse: JourneyResponse?
}

extension DeleteJourneyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyResponse = "JourneyResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyResponseDecoded = try containerValues.decodeIfPresent(JourneyResponse.self, forKey: .journeyResponse)
        journeyResponse = journeyResponseDecoded
    }
}

extension DeletePushTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePushTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension DeletePushTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeletePushTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeletePushTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePushTemplateInput>
    public typealias MOutput = OperationOutput<DeletePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePushTemplateOutputError>
}

public struct DeletePushTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeletePushTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeletePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeletePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeletePushTemplateInput>
    public typealias MOutput = OperationOutput<DeletePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeletePushTemplateOutputError>
}

public struct DeletePushTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct DeletePushTemplateInputBody: Equatable {
}

extension DeletePushTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeletePushTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePushTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePushTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePushTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeletePushTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension DeletePushTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct DeletePushTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct DeletePushTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension DeletePushTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

extension DeleteRecommenderConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecommenderConfigurationInput(recommenderId: \(String(describing: recommenderId)))"}
}

extension DeleteRecommenderConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteRecommenderConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteRecommenderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecommenderConfigurationOutputError>
}

public struct DeleteRecommenderConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteRecommenderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<DeleteRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteRecommenderConfigurationOutputError>
}

public struct DeleteRecommenderConfigurationInput: Equatable {
    /// <p>The unique identifier for the recommender model configuration. This identifier is displayed as the <b>Recommender ID</b> on the Amazon Pinpoint console.</p>
    public let recommenderId: String?

    public init (
        recommenderId: String? = nil
    )
    {
        self.recommenderId = recommenderId
    }
}

struct DeleteRecommenderConfigurationInputBody: Equatable {
}

extension DeleteRecommenderConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRecommenderConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecommenderConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecommenderConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecommenderConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRecommenderConfigurationOutputResponse(recommenderConfigurationResponse: \(String(describing: recommenderConfigurationResponse)))"}
}

extension DeleteRecommenderConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RecommenderConfigurationResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.recommenderConfigurationResponse = output
            } else {
                self.recommenderConfigurationResponse = nil
            }
        } else {
            self.recommenderConfigurationResponse = nil
        }
    }
}

public struct DeleteRecommenderConfigurationOutputResponse: Equatable {
    /// <p>Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.</p>
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?

    public init (
        recommenderConfigurationResponse: RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

struct DeleteRecommenderConfigurationOutputResponseBody: Equatable {
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?
}

extension DeleteRecommenderConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recommenderConfigurationResponse = "RecommenderConfigurationResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderConfigurationResponseDecoded = try containerValues.decodeIfPresent(RecommenderConfigurationResponse.self, forKey: .recommenderConfigurationResponse)
        recommenderConfigurationResponse = recommenderConfigurationResponseDecoded
    }
}

extension DeleteSegmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSegmentInput(applicationId: \(String(describing: applicationId)), segmentId: \(String(describing: segmentId)))"}
}

extension DeleteSegmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSegmentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSegmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSegmentInput>
    public typealias MOutput = OperationOutput<DeleteSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSegmentOutputError>
}

public struct DeleteSegmentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSegmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSegmentInput>
    public typealias MOutput = OperationOutput<DeleteSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSegmentOutputError>
}

public struct DeleteSegmentInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the segment.</p>
    public let segmentId: String?

    public init (
        applicationId: String? = nil,
        segmentId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
    }
}

struct DeleteSegmentInputBody: Equatable {
}

extension DeleteSegmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSegmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSegmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSegmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSegmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSegmentOutputResponse(segmentResponse: \(String(describing: segmentResponse)))"}
}

extension DeleteSegmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SegmentResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.segmentResponse = output
            } else {
                self.segmentResponse = nil
            }
        } else {
            self.segmentResponse = nil
        }
    }
}

public struct DeleteSegmentOutputResponse: Equatable {
    /// <p>Provides information about the configuration, dimension, and other settings for a segment.</p>
    public let segmentResponse: SegmentResponse?

    public init (
        segmentResponse: SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

struct DeleteSegmentOutputResponseBody: Equatable {
    public let segmentResponse: SegmentResponse?
}

extension DeleteSegmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case segmentResponse = "SegmentResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentResponseDecoded = try containerValues.decodeIfPresent(SegmentResponse.self, forKey: .segmentResponse)
        segmentResponse = segmentResponseDecoded
    }
}

extension DeleteSmsChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSmsChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteSmsChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSmsChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSmsChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSmsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSmsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSmsChannelInput>
    public typealias MOutput = OperationOutput<DeleteSmsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSmsChannelOutputError>
}

public struct DeleteSmsChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSmsChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSmsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSmsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSmsChannelInput>
    public typealias MOutput = OperationOutput<DeleteSmsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSmsChannelOutputError>
}

public struct DeleteSmsChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteSmsChannelInputBody: Equatable {
}

extension DeleteSmsChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSmsChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSmsChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSmsChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSmsChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSmsChannelOutputResponse(sMSChannelResponse: \(String(describing: sMSChannelResponse)))"}
}

extension DeleteSmsChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SMSChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.sMSChannelResponse = output
            } else {
                self.sMSChannelResponse = nil
            }
        } else {
            self.sMSChannelResponse = nil
        }
    }
}

public struct DeleteSmsChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the SMS channel for an application.</p>
    public let sMSChannelResponse: SMSChannelResponse?

    public init (
        sMSChannelResponse: SMSChannelResponse? = nil
    )
    {
        self.sMSChannelResponse = sMSChannelResponse
    }
}

struct DeleteSmsChannelOutputResponseBody: Equatable {
    public let sMSChannelResponse: SMSChannelResponse?
}

extension DeleteSmsChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSChannelResponse = "SMSChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSChannelResponseDecoded = try containerValues.decodeIfPresent(SMSChannelResponse.self, forKey: .sMSChannelResponse)
        sMSChannelResponse = sMSChannelResponseDecoded
    }
}

extension DeleteSmsTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSmsTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension DeleteSmsTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSmsTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSmsTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSmsTemplateInput>
    public typealias MOutput = OperationOutput<DeleteSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSmsTemplateOutputError>
}

public struct DeleteSmsTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSmsTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSmsTemplateInput>
    public typealias MOutput = OperationOutput<DeleteSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSmsTemplateOutputError>
}

public struct DeleteSmsTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct DeleteSmsTemplateInputBody: Equatable {
}

extension DeleteSmsTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSmsTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSmsTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSmsTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSmsTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSmsTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension DeleteSmsTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct DeleteSmsTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct DeleteSmsTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension DeleteSmsTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

extension DeleteUserEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserEndpointsInput(applicationId: \(String(describing: applicationId)), userId: \(String(describing: userId)))"}
}

extension DeleteUserEndpointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteUserEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteUserEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserEndpointsInput>
    public typealias MOutput = OperationOutput<DeleteUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserEndpointsOutputError>
}

public struct DeleteUserEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteUserEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteUserEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteUserEndpointsInput>
    public typealias MOutput = OperationOutput<DeleteUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteUserEndpointsOutputError>
}

public struct DeleteUserEndpointsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the user.</p>
    public let userId: String?

    public init (
        applicationId: String? = nil,
        userId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

struct DeleteUserEndpointsInputBody: Equatable {
}

extension DeleteUserEndpointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteUserEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteUserEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteUserEndpointsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteUserEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteUserEndpointsOutputResponse(endpointsResponse: \(String(describing: endpointsResponse)))"}
}

extension DeleteUserEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EndpointsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.endpointsResponse = output
            } else {
                self.endpointsResponse = nil
            }
        } else {
            self.endpointsResponse = nil
        }
    }
}

public struct DeleteUserEndpointsOutputResponse: Equatable {
    /// <p>Provides information about all the endpoints that are associated with a user ID.</p>
    public let endpointsResponse: EndpointsResponse?

    public init (
        endpointsResponse: EndpointsResponse? = nil
    )
    {
        self.endpointsResponse = endpointsResponse
    }
}

struct DeleteUserEndpointsOutputResponseBody: Equatable {
    public let endpointsResponse: EndpointsResponse?
}

extension DeleteUserEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointsResponse = "EndpointsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsResponseDecoded = try containerValues.decodeIfPresent(EndpointsResponse.self, forKey: .endpointsResponse)
        endpointsResponse = endpointsResponseDecoded
    }
}

extension DeleteVoiceChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVoiceChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension DeleteVoiceChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVoiceChannelInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVoiceChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVoiceChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVoiceChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVoiceChannelInput>
    public typealias MOutput = OperationOutput<DeleteVoiceChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVoiceChannelOutputError>
}

public struct DeleteVoiceChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVoiceChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVoiceChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVoiceChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVoiceChannelInput>
    public typealias MOutput = OperationOutput<DeleteVoiceChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVoiceChannelOutputError>
}

public struct DeleteVoiceChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct DeleteVoiceChannelInputBody: Equatable {
}

extension DeleteVoiceChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVoiceChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVoiceChannelOutputResponse(voiceChannelResponse: \(String(describing: voiceChannelResponse)))"}
}

extension DeleteVoiceChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VoiceChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.voiceChannelResponse = output
            } else {
                self.voiceChannelResponse = nil
            }
        } else {
            self.voiceChannelResponse = nil
        }
    }
}

public struct DeleteVoiceChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the voice channel for an application.</p>
    public let voiceChannelResponse: VoiceChannelResponse?

    public init (
        voiceChannelResponse: VoiceChannelResponse? = nil
    )
    {
        self.voiceChannelResponse = voiceChannelResponse
    }
}

struct DeleteVoiceChannelOutputResponseBody: Equatable {
    public let voiceChannelResponse: VoiceChannelResponse?
}

extension DeleteVoiceChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case voiceChannelResponse = "VoiceChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceChannelResponseDecoded = try containerValues.decodeIfPresent(VoiceChannelResponse.self, forKey: .voiceChannelResponse)
        voiceChannelResponse = voiceChannelResponseDecoded
    }
}

extension DeleteVoiceTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVoiceTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension DeleteVoiceTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteVoiceTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteVoiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVoiceTemplateInput>
    public typealias MOutput = OperationOutput<DeleteVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVoiceTemplateOutputError>
}

public struct DeleteVoiceTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteVoiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteVoiceTemplateInput>
    public typealias MOutput = OperationOutput<DeleteVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteVoiceTemplateOutputError>
}

public struct DeleteVoiceTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct DeleteVoiceTemplateInputBody: Equatable {
}

extension DeleteVoiceTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteVoiceTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteVoiceTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteVoiceTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteVoiceTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteVoiceTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension DeleteVoiceTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct DeleteVoiceTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct DeleteVoiceTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension DeleteVoiceTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

public enum DeliveryStatus {
    case duplicate
    case optOut
    case permanentFailure
    case successful
    case temporaryFailure
    case throttled
    case unknownFailure
    case sdkUnknown(String)
}

extension DeliveryStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeliveryStatus] {
        return [
            .duplicate,
            .optOut,
            .permanentFailure,
            .successful,
            .temporaryFailure,
            .throttled,
            .unknownFailure,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .duplicate: return "DUPLICATE"
        case .optOut: return "OPT_OUT"
        case .permanentFailure: return "PERMANENT_FAILURE"
        case .successful: return "SUCCESSFUL"
        case .temporaryFailure: return "TEMPORARY_FAILURE"
        case .throttled: return "THROTTLED"
        case .unknownFailure: return "UNKNOWN_FAILURE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeliveryStatus(rawValue: rawValue) ?? DeliveryStatus.sdkUnknown(rawValue)
    }
}

public enum DimensionType {
    case exclusive
    case inclusive
    case sdkUnknown(String)
}

extension DimensionType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DimensionType] {
        return [
            .exclusive,
            .inclusive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .exclusive: return "EXCLUSIVE"
        case .inclusive: return "INCLUSIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DimensionType(rawValue: rawValue) ?? DimensionType.sdkUnknown(rawValue)
    }
}

extension DirectMessageConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aDMMessage = "ADMMessage"
        case aPNSMessage = "APNSMessage"
        case baiduMessage = "BaiduMessage"
        case defaultMessage = "DefaultMessage"
        case defaultPushNotificationMessage = "DefaultPushNotificationMessage"
        case emailMessage = "EmailMessage"
        case gCMMessage = "GCMMessage"
        case sMSMessage = "SMSMessage"
        case voiceMessage = "VoiceMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aDMMessage = aDMMessage {
            try encodeContainer.encode(aDMMessage, forKey: .aDMMessage)
        }
        if let aPNSMessage = aPNSMessage {
            try encodeContainer.encode(aPNSMessage, forKey: .aPNSMessage)
        }
        if let baiduMessage = baiduMessage {
            try encodeContainer.encode(baiduMessage, forKey: .baiduMessage)
        }
        if let defaultMessage = defaultMessage {
            try encodeContainer.encode(defaultMessage, forKey: .defaultMessage)
        }
        if let defaultPushNotificationMessage = defaultPushNotificationMessage {
            try encodeContainer.encode(defaultPushNotificationMessage, forKey: .defaultPushNotificationMessage)
        }
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let gCMMessage = gCMMessage {
            try encodeContainer.encode(gCMMessage, forKey: .gCMMessage)
        }
        if let sMSMessage = sMSMessage {
            try encodeContainer.encode(sMSMessage, forKey: .sMSMessage)
        }
        if let voiceMessage = voiceMessage {
            try encodeContainer.encode(voiceMessage, forKey: .voiceMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMMessageDecoded = try containerValues.decodeIfPresent(ADMMessage.self, forKey: .aDMMessage)
        aDMMessage = aDMMessageDecoded
        let aPNSMessageDecoded = try containerValues.decodeIfPresent(APNSMessage.self, forKey: .aPNSMessage)
        aPNSMessage = aPNSMessageDecoded
        let baiduMessageDecoded = try containerValues.decodeIfPresent(BaiduMessage.self, forKey: .baiduMessage)
        baiduMessage = baiduMessageDecoded
        let defaultMessageDecoded = try containerValues.decodeIfPresent(DefaultMessage.self, forKey: .defaultMessage)
        defaultMessage = defaultMessageDecoded
        let defaultPushNotificationMessageDecoded = try containerValues.decodeIfPresent(DefaultPushNotificationMessage.self, forKey: .defaultPushNotificationMessage)
        defaultPushNotificationMessage = defaultPushNotificationMessageDecoded
        let emailMessageDecoded = try containerValues.decodeIfPresent(EmailMessage.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let gCMMessageDecoded = try containerValues.decodeIfPresent(GCMMessage.self, forKey: .gCMMessage)
        gCMMessage = gCMMessageDecoded
        let sMSMessageDecoded = try containerValues.decodeIfPresent(SMSMessage.self, forKey: .sMSMessage)
        sMSMessage = sMSMessageDecoded
        let voiceMessageDecoded = try containerValues.decodeIfPresent(VoiceMessage.self, forKey: .voiceMessage)
        voiceMessage = voiceMessageDecoded
    }
}

extension DirectMessageConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DirectMessageConfiguration(aDMMessage: \(String(describing: aDMMessage)), aPNSMessage: \(String(describing: aPNSMessage)), baiduMessage: \(String(describing: baiduMessage)), defaultMessage: \(String(describing: defaultMessage)), defaultPushNotificationMessage: \(String(describing: defaultPushNotificationMessage)), emailMessage: \(String(describing: emailMessage)), gCMMessage: \(String(describing: gCMMessage)), sMSMessage: \(String(describing: sMSMessage)), voiceMessage: \(String(describing: voiceMessage)))"}
}

/// <p>Specifies the settings and content for the default message and any default messages that you tailored for specific channels.</p>
public struct DirectMessageConfiguration: Equatable {
    /// <p>The default push notification message for the ADM (Amazon Device Messaging) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    public let aDMMessage: ADMMessage?
    /// <p>The default push notification message for the APNs (Apple Push Notification service) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    public let aPNSMessage: APNSMessage?
    /// <p>The default push notification message for the Baidu (Baidu Cloud Push) channel. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    public let baiduMessage: BaiduMessage?
    /// <p>The default message for all channels.</p>
    public let defaultMessage: DefaultMessage?
    /// <p>The default push notification message for all push notification channels.</p>
    public let defaultPushNotificationMessage: DefaultPushNotificationMessage?
    /// <p>The default message for the email channel. This message overrides the default message (DefaultMessage).</p>
    public let emailMessage: EmailMessage?
    /// <p>The default push notification message for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message overrides the default push notification message (DefaultPushNotificationMessage).</p>
    public let gCMMessage: GCMMessage?
    /// <p>The default message for the SMS channel. This message overrides the default message (DefaultMessage).</p>
    public let sMSMessage: SMSMessage?
    /// <p>The default message for the voice channel. This message overrides the default message (DefaultMessage).</p>
    public let voiceMessage: VoiceMessage?

    public init (
        aDMMessage: ADMMessage? = nil,
        aPNSMessage: APNSMessage? = nil,
        baiduMessage: BaiduMessage? = nil,
        defaultMessage: DefaultMessage? = nil,
        defaultPushNotificationMessage: DefaultPushNotificationMessage? = nil,
        emailMessage: EmailMessage? = nil,
        gCMMessage: GCMMessage? = nil,
        sMSMessage: SMSMessage? = nil,
        voiceMessage: VoiceMessage? = nil
    )
    {
        self.aDMMessage = aDMMessage
        self.aPNSMessage = aPNSMessage
        self.baiduMessage = baiduMessage
        self.defaultMessage = defaultMessage
        self.defaultPushNotificationMessage = defaultPushNotificationMessage
        self.emailMessage = emailMessage
        self.gCMMessage = gCMMessage
        self.sMSMessage = sMSMessage
        self.voiceMessage = voiceMessage
    }
}

public enum Duration {
    case day14
    case day30
    case day7
    case hr24
    case sdkUnknown(String)
}

extension Duration : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Duration] {
        return [
            .day14,
            .day30,
            .day7,
            .hr24,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .day14: return "DAY_14"
        case .day30: return "DAY_30"
        case .day7: return "DAY_7"
        case .hr24: return "HR_24"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Duration(rawValue: rawValue) ?? Duration.sdkUnknown(rawValue)
    }
}

extension EmailChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSet = "ConfigurationSet"
        case enabled = "Enabled"
        case fromAddress = "FromAddress"
        case identity = "Identity"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSet = configurationSet {
            try encodeContainer.encode(configurationSet, forKey: .configurationSet)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if let identity = identity {
            try encodeContainer.encode(identity, forKey: .identity)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSet)
        configurationSet = configurationSetDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let identityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identity)
        identity = identityDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension EmailChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailChannelRequest(configurationSet: \(String(describing: configurationSet)), enabled: \(String(describing: enabled)), fromAddress: \(String(describing: fromAddress)), identity: \(String(describing: identity)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Specifies the status and settings of the email channel for an application.</p>
public struct EmailChannelRequest: Equatable {
    /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that you want to apply to messages that you send through the channel.</p>
    public let configurationSet: String?
    /// <p>Specifies whether to enable the email channel for the application.</p>
    public let enabled: Bool
    /// <p>The verified email address that you want to send email from when you send email through the channel.</p>
    public let fromAddress: String?
    /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that you want to use when you send email through the channel.</p>
    public let identity: String?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that you want Amazon Pinpoint to use when it submits email-related event data for the channel.</p>
    public let roleArn: String?

    public init (
        configurationSet: String? = nil,
        enabled: Bool = false,
        fromAddress: String? = nil,
        identity: String? = nil,
        roleArn: String? = nil
    )
    {
        self.configurationSet = configurationSet
        self.enabled = enabled
        self.fromAddress = fromAddress
        self.identity = identity
        self.roleArn = roleArn
    }
}

extension EmailChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case configurationSet = "ConfigurationSet"
        case creationDate = "CreationDate"
        case enabled = "Enabled"
        case fromAddress = "FromAddress"
        case hasCredential = "HasCredential"
        case id = "Id"
        case identity = "Identity"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case messagesPerSecond = "MessagesPerSecond"
        case platform = "Platform"
        case roleArn = "RoleArn"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let configurationSet = configurationSet {
            try encodeContainer.encode(configurationSet, forKey: .configurationSet)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identity = identity {
            try encodeContainer.encode(identity, forKey: .identity)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if messagesPerSecond != 0 {
            try encodeContainer.encode(messagesPerSecond, forKey: .messagesPerSecond)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let configurationSetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSet)
        configurationSet = configurationSetDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let identityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .identity)
        identity = identityDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let messagesPerSecondDecoded = try containerValues.decode(Int.self, forKey: .messagesPerSecond)
        messagesPerSecond = messagesPerSecondDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension EmailChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailChannelResponse(applicationId: \(String(describing: applicationId)), configurationSet: \(String(describing: configurationSet)), creationDate: \(String(describing: creationDate)), enabled: \(String(describing: enabled)), fromAddress: \(String(describing: fromAddress)), hasCredential: \(String(describing: hasCredential)), id: \(String(describing: id)), identity: \(String(describing: identity)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), messagesPerSecond: \(String(describing: messagesPerSecond)), platform: \(String(describing: platform)), roleArn: \(String(describing: roleArn)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the email channel for an application.</p>
public struct EmailChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the email channel applies to.</p>
    public let applicationId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/ses/latest/APIReference/API_ConfigurationSet.html">Amazon SES configuration set</a> that's applied to messages that are sent through the channel.</p>
    public let configurationSet: String?
    /// <p>The date and time, in ISO 8601 format, when the email channel was enabled.</p>
    public let creationDate: String?
    /// <p>Specifies whether the email channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>The verified email address that email is sent from when you send email through the channel.</p>
    public let fromAddress: String?
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>(Deprecated) An identifier for the email channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>The Amazon Resource Name (ARN) of the identity, verified with Amazon Simple Email Service (Amazon SES), that's used when you send email through the channel.</p>
    public let identity: String?
    /// <p>Specifies whether the email channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the email channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time, in ISO 8601 format, when the email channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The maximum number of emails that can be sent through the channel each second.</p>
    public let messagesPerSecond: Int
    /// <p>The type of messaging or notification platform for the channel. For the email channel, this value is EMAIL.</p>
    public let platform: String?
    /// <p>The ARN of the AWS Identity and Access Management (IAM) role that Amazon Pinpoint uses to submit email-related event data for the channel.</p>
    public let roleArn: String?
    /// <p>The current version of the email channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        configurationSet: String? = nil,
        creationDate: String? = nil,
        enabled: Bool = false,
        fromAddress: String? = nil,
        hasCredential: Bool = false,
        id: String? = nil,
        identity: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        messagesPerSecond: Int = 0,
        platform: String? = nil,
        roleArn: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.configurationSet = configurationSet
        self.creationDate = creationDate
        self.enabled = enabled
        self.fromAddress = fromAddress
        self.hasCredential = hasCredential
        self.id = id
        self.identity = identity
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.messagesPerSecond = messagesPerSecond
        self.platform = platform
        self.roleArn = roleArn
        self.version = version
    }
}

extension EmailMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case feedbackForwardingAddress = "FeedbackForwardingAddress"
        case fromAddress = "FromAddress"
        case rawEmail = "RawEmail"
        case replyToAddresses = "ReplyToAddresses"
        case simpleEmail = "SimpleEmail"
        case substitutions = "Substitutions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let feedbackForwardingAddress = feedbackForwardingAddress {
            try encodeContainer.encode(feedbackForwardingAddress, forKey: .feedbackForwardingAddress)
        }
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
        if let rawEmail = rawEmail {
            try encodeContainer.encode(rawEmail, forKey: .rawEmail)
        }
        if let replyToAddresses = replyToAddresses {
            var replyToAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replyToAddresses)
            for listof__string0 in replyToAddresses {
                try replyToAddressesContainer.encode(listof__string0)
            }
        }
        if let simpleEmail = simpleEmail {
            try encodeContainer.encode(simpleEmail, forKey: .simpleEmail)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let feedbackForwardingAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .feedbackForwardingAddress)
        feedbackForwardingAddress = feedbackForwardingAddressDecoded
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
        let rawEmailDecoded = try containerValues.decodeIfPresent(RawEmail.self, forKey: .rawEmail)
        rawEmail = rawEmailDecoded
        let replyToAddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replyToAddresses)
        var replyToAddressesDecoded0:[String]? = nil
        if let replyToAddressesContainer = replyToAddressesContainer {
            replyToAddressesDecoded0 = [String]()
            for string0 in replyToAddressesContainer {
                if let string0 = string0 {
                    replyToAddressesDecoded0?.append(string0)
                }
            }
        }
        replyToAddresses = replyToAddressesDecoded0
        let simpleEmailDecoded = try containerValues.decodeIfPresent(SimpleEmail.self, forKey: .simpleEmail)
        simpleEmail = simpleEmailDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
    }
}

extension EmailMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailMessage(body: \(String(describing: body)), feedbackForwardingAddress: \(String(describing: feedbackForwardingAddress)), fromAddress: \(String(describing: fromAddress)), rawEmail: \(String(describing: rawEmail)), replyToAddresses: \(String(describing: replyToAddresses)), simpleEmail: \(String(describing: simpleEmail)), substitutions: \(String(describing: substitutions)))"}
}

/// <p>Specifies the default settings and content for a one-time email message that's sent directly to an endpoint.</p>
public struct EmailMessage: Equatable {
    /// <p>The body of the email message.</p>
    public let body: String?
    /// <p>The email address to forward bounces and complaints to, if feedback forwarding is enabled.</p>
    public let feedbackForwardingAddress: String?
    /// <p>The verified email address to send the email message from. The default value is the FromAddress specified for the email channel.</p>
    public let fromAddress: String?
    /// <p>The email message, represented as a raw MIME message.</p>
    public let rawEmail: RawEmail?
    /// <p>The reply-to email address(es) for the email message. If a recipient replies to the email, each reply-to address receives the reply.</p>
    public let replyToAddresses: [String]?
    /// <p>The email message, composed of a subject, a text part, and an HTML part.</p>
    public let simpleEmail: SimpleEmail?
    /// <p>The default message variables to use in the email message. You can override the default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?

    public init (
        body: String? = nil,
        feedbackForwardingAddress: String? = nil,
        fromAddress: String? = nil,
        rawEmail: RawEmail? = nil,
        replyToAddresses: [String]? = nil,
        simpleEmail: SimpleEmail? = nil,
        substitutions: [String:[String]]? = nil
    )
    {
        self.body = body
        self.feedbackForwardingAddress = feedbackForwardingAddress
        self.fromAddress = fromAddress
        self.rawEmail = rawEmail
        self.replyToAddresses = replyToAddresses
        self.simpleEmail = simpleEmail
        self.substitutions = substitutions
    }
}

extension EmailMessageActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageConfig = "MessageConfig"
        case nextActivity = "NextActivity"
        case templateName = "TemplateName"
        case templateVersion = "TemplateVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageConfig = messageConfig {
            try encodeContainer.encode(messageConfig, forKey: .messageConfig)
        }
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateVersion = templateVersion {
            try encodeContainer.encode(templateVersion, forKey: .templateVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageConfigDecoded = try containerValues.decodeIfPresent(JourneyEmailMessage.self, forKey: .messageConfig)
        messageConfig = messageConfigDecoded
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
    }
}

extension EmailMessageActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailMessageActivity(messageConfig: \(String(describing: messageConfig)), nextActivity: \(String(describing: nextActivity)), templateName: \(String(describing: templateName)), templateVersion: \(String(describing: templateVersion)))"}
}

/// <p>Specifies the settings for an email activity in a journey. This type of activity sends an email message to participants.</p>
public struct EmailMessageActivity: Equatable {
    /// <p>Specifies the sender address for an email message that's sent to participants in the journey.</p>
    public let messageConfig: JourneyEmailMessage?
    /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
    public let nextActivity: String?
    /// <p>The name of the email message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the email template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    public let templateVersion: String?

    public init (
        messageConfig: JourneyEmailMessage? = nil,
        nextActivity: String? = nil,
        templateName: String? = nil,
        templateVersion: String? = nil
    )
    {
        self.messageConfig = messageConfig
        self.nextActivity = nextActivity
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

extension EmailTemplateRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defaultSubstitutions = "DefaultSubstitutions"
        case htmlPart = "HtmlPart"
        case recommenderId = "RecommenderId"
        case subject = "Subject"
        case templateDescription = "TemplateDescription"
        case textPart = "TextPart"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let htmlPart = htmlPart {
            try encodeContainer.encode(htmlPart, forKey: .htmlPart)
        }
        if let recommenderId = recommenderId {
            try encodeContainer.encode(recommenderId, forKey: .recommenderId)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let textPart = textPart {
            try encodeContainer.encode(textPart, forKey: .textPart)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let htmlPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .htmlPart)
        htmlPart = htmlPartDecoded
        let recommenderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommenderId)
        recommenderId = recommenderIdDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let textPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .textPart)
        textPart = textPartDecoded
    }
}

extension EmailTemplateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailTemplateRequest(defaultSubstitutions: \(String(describing: defaultSubstitutions)), htmlPart: \(String(describing: htmlPart)), recommenderId: \(String(describing: recommenderId)), subject: \(String(describing: subject)), templateDescription: \(String(describing: templateDescription)), textPart: \(String(describing: textPart)), tags: \(String(describing: tags)))"}
}

/// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the email channel.</p>
public struct EmailTemplateRequest: Equatable {
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    public let defaultSubstitutions: String?
    /// <p>The message body, in HTML format, to use in email messages that are based on the message template. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
    public let htmlPart: String?
    /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
    public let recommenderId: String?
    /// <p>The subject line, or title, to use in email messages that are based on the message template.</p>
    public let subject: String?
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>A custom description of the message template.</p>
    public let templateDescription: String?
    /// <p>The message body, in plain text format, to use in email messages that are based on the message template. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
    public let textPart: String?

    public init (
        defaultSubstitutions: String? = nil,
        htmlPart: String? = nil,
        recommenderId: String? = nil,
        subject: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil,
        textPart: String? = nil
    )
    {
        self.defaultSubstitutions = defaultSubstitutions
        self.htmlPart = htmlPart
        self.recommenderId = recommenderId
        self.subject = subject
        self.tags = tags
        self.templateDescription = templateDescription
        self.textPart = textPart
    }
}

extension EmailTemplateResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationDate = "CreationDate"
        case defaultSubstitutions = "DefaultSubstitutions"
        case htmlPart = "HtmlPart"
        case lastModifiedDate = "LastModifiedDate"
        case recommenderId = "RecommenderId"
        case subject = "Subject"
        case templateDescription = "TemplateDescription"
        case templateName = "TemplateName"
        case templateType = "TemplateType"
        case textPart = "TextPart"
        case version = "Version"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let htmlPart = htmlPart {
            try encodeContainer.encode(htmlPart, forKey: .htmlPart)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let recommenderId = recommenderId {
            try encodeContainer.encode(recommenderId, forKey: .recommenderId)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
        if let textPart = textPart {
            try encodeContainer.encode(textPart, forKey: .textPart)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let htmlPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .htmlPart)
        htmlPart = htmlPartDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let recommenderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommenderId)
        recommenderId = recommenderIdDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subject)
        subject = subjectDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let textPartDecoded = try containerValues.decodeIfPresent(String.self, forKey: .textPart)
        textPart = textPartDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension EmailTemplateResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmailTemplateResponse(arn: \(String(describing: arn)), creationDate: \(String(describing: creationDate)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), htmlPart: \(String(describing: htmlPart)), lastModifiedDate: \(String(describing: lastModifiedDate)), recommenderId: \(String(describing: recommenderId)), subject: \(String(describing: subject)), templateDescription: \(String(describing: templateDescription)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)), textPart: \(String(describing: textPart)), version: \(String(describing: version)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through the email channel.</p>
public struct EmailTemplateResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    public let arn: String?
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    public let creationDate: String?
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    public let defaultSubstitutions: String?
    /// <p>The message body, in HTML format, that's used in email messages that are based on the message template.</p>
    public let htmlPart: String?
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The unique identifier for the recommender model that's used by the message template.</p>
    public let recommenderId: String?
    /// <p>The subject line, or title, that's used in email messages that are based on the message template.</p>
    public let subject: String?
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>The custom description of the message template.</p>
    public let templateDescription: String?
    /// <p>The name of the message template.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. For an email template, this value is EMAIL.</p>
    public let templateType: TemplateType?
    /// <p>The message body, in plain text format, that's used in email messages that are based on the message template.</p>
    public let textPart: String?
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        creationDate: String? = nil,
        defaultSubstitutions: String? = nil,
        htmlPart: String? = nil,
        lastModifiedDate: String? = nil,
        recommenderId: String? = nil,
        subject: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil,
        templateName: String? = nil,
        templateType: TemplateType? = nil,
        textPart: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.defaultSubstitutions = defaultSubstitutions
        self.htmlPart = htmlPart
        self.lastModifiedDate = lastModifiedDate
        self.recommenderId = recommenderId
        self.subject = subject
        self.tags = tags
        self.templateDescription = templateDescription
        self.templateName = templateName
        self.templateType = templateType
        self.textPart = textPart
        self.version = version
    }
}

extension EndpointBatchItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case attributes = "Attributes"
        case channelType = "ChannelType"
        case demographic = "Demographic"
        case effectiveDate = "EffectiveDate"
        case endpointStatus = "EndpointStatus"
        case id = "Id"
        case location = "Location"
        case metrics = "Metrics"
        case optOut = "OptOut"
        case requestId = "RequestId"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapoflistof__string0) in attributes {
                try attributesContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let demographic = demographic {
            try encodeContainer.encode(demographic, forKey: .demographic)
        }
        if let effectiveDate = effectiveDate {
            try encodeContainer.encode(effectiveDate, forKey: .effectiveDate)
        }
        if let endpointStatus = endpointStatus {
            try encodeContainer.encode(endpointStatus, forKey: .endpointStatus)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__double0) in metrics {
                try metricsContainer.encode(mapof__double0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let optOut = optOut {
            try encodeContainer.encode(optOut, forKey: .optOut)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .attributes)
        var attributesDecoded0: [String:[String]]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:[String]]()
            for (key0, listof__string0) in attributesContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                attributesDecoded0?[key0] = listof__string0Decoded0
            }
        }
        attributes = attributesDecoded0
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let demographicDecoded = try containerValues.decodeIfPresent(EndpointDemographic.self, forKey: .demographic)
        demographic = demographicDecoded
        let effectiveDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveDate)
        effectiveDate = effectiveDateDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(EndpointLocation.self, forKey: .location)
        location = locationDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: Double?].self, forKey: .metrics)
        var metricsDecoded0: [String:Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:Double]()
            for (key0, __double0) in metricsContainer {
                if let __double0 = __double0 {
                    metricsDecoded0?[key0] = __double0
                }
            }
        }
        metrics = metricsDecoded0
        let optOutDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optOut)
        optOut = optOutDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(EndpointUser.self, forKey: .user)
        user = userDecoded
    }
}

extension EndpointBatchItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointBatchItem(address: \(String(describing: address)), attributes: \(String(describing: attributes)), channelType: \(String(describing: channelType)), demographic: \(String(describing: demographic)), effectiveDate: \(String(describing: effectiveDate)), endpointStatus: \(String(describing: endpointStatus)), id: \(String(describing: id)), location: \(String(describing: location)), metrics: \(String(describing: metrics)), optOut: \(String(describing: optOut)), requestId: \(String(describing: requestId)), user: \(String(describing: user)))"}
}

/// <p>Specifies an endpoint to create or update and the settings and attributes to set or change for the endpoint.</p>
public struct EndpointBatchItem: Equatable {
    /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
    public let address: String?
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
    public let attributes: [String:[String]]?
    /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
    public let channelType: ChannelType?
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    public let demographic: EndpointDemographic?
    /// <p>The date and time, in ISO 8601 format, when the endpoint was created or updated.</p>
    public let effectiveDate: String?
    /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    public let endpointStatus: String?
    /// <p>The unique identifier for the endpoint in the context of the batch.</p>
    public let id: String?
    /// <p>The geographic information for the endpoint.</p>
    public let location: EndpointLocation?
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    public let metrics: [String:Double]?
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    public let optOut: String?
    /// <p>The unique identifier for the request to create or update the endpoint.</p>
    public let requestId: String?
    /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
    public let user: EndpointUser?

    public init (
        address: String? = nil,
        attributes: [String:[String]]? = nil,
        channelType: ChannelType? = nil,
        demographic: EndpointDemographic? = nil,
        effectiveDate: String? = nil,
        endpointStatus: String? = nil,
        id: String? = nil,
        location: EndpointLocation? = nil,
        metrics: [String:Double]? = nil,
        optOut: String? = nil,
        requestId: String? = nil,
        user: EndpointUser? = nil
    )
    {
        self.address = address
        self.attributes = attributes
        self.channelType = channelType
        self.demographic = demographic
        self.effectiveDate = effectiveDate
        self.endpointStatus = endpointStatus
        self.id = id
        self.location = location
        self.metrics = metrics
        self.optOut = optOut
        self.requestId = requestId
        self.user = user
    }
}

extension EndpointBatchRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofendpointbatchitem0 in item {
                try itemContainer.encode(listofendpointbatchitem0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([EndpointBatchItem?].self, forKey: .item)
        var itemDecoded0:[EndpointBatchItem]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [EndpointBatchItem]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
    }
}

extension EndpointBatchRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointBatchRequest(item: \(String(describing: item)))"}
}

/// <p>Specifies a batch of endpoints to create or update and the settings and attributes to set or change for each endpoint.</p>
public struct EndpointBatchRequest: Equatable {
    /// <p>An array that defines the endpoints to create or update and, for each endpoint, the property values to set or change. An array can contain a maximum of 100 items.</p>
    public let item: [EndpointBatchItem]?

    public init (
        item: [EndpointBatchItem]? = nil
    )
    {
        self.item = item
    }
}

extension EndpointDemographic: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appVersion = "AppVersion"
        case locale = "Locale"
        case make = "Make"
        case model = "Model"
        case modelVersion = "ModelVersion"
        case platform = "Platform"
        case platformVersion = "PlatformVersion"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let locale = locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let make = make {
            try encodeContainer.encode(make, forKey: .make)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let modelVersion = modelVersion {
            try encodeContainer.encode(modelVersion, forKey: .modelVersion)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let platformVersion = platformVersion {
            try encodeContainer.encode(platformVersion, forKey: .platformVersion)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let localeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .locale)
        locale = localeDecoded
        let makeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .make)
        make = makeDecoded
        let modelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .model)
        model = modelDecoded
        let modelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .modelVersion)
        modelVersion = modelVersionDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let platformVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platformVersion)
        platformVersion = platformVersionDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

extension EndpointDemographic: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointDemographic(appVersion: \(String(describing: appVersion)), locale: \(String(describing: locale)), make: \(String(describing: make)), model: \(String(describing: model)), modelVersion: \(String(describing: modelVersion)), platform: \(String(describing: platform)), platformVersion: \(String(describing: platformVersion)), timezone: \(String(describing: timezone)))"}
}

/// <p>Specifies demographic information about an endpoint, such as the applicable time zone and platform.</p>
public struct EndpointDemographic: Equatable {
    /// <p>The version of the app that's associated with the endpoint.</p>
    public let appVersion: String?
    /// <p>The locale of the endpoint, in the following format: the ISO 639-1 alpha-2 code, followed by an underscore (_), followed by an ISO 3166-1 alpha-2 value.</p>
    public let locale: String?
    /// <p>The manufacturer of the endpoint device, such as apple or samsung.</p>
    public let make: String?
    /// <p>The model name or number of the endpoint device, such as iPhone or SM-G900F.</p>
    public let model: String?
    /// <p>The model version of the endpoint device.</p>
    public let modelVersion: String?
    /// <p>The platform of the endpoint device, such as ios.</p>
    public let platform: String?
    /// <p>The platform version of the endpoint device.</p>
    public let platformVersion: String?
    /// <p>The time zone of the endpoint, specified as a tz database name value, such as America/Los_Angeles.</p>
    public let timezone: String?

    public init (
        appVersion: String? = nil,
        locale: String? = nil,
        make: String? = nil,
        model: String? = nil,
        modelVersion: String? = nil,
        platform: String? = nil,
        platformVersion: String? = nil,
        timezone: String? = nil
    )
    {
        self.appVersion = appVersion
        self.locale = locale
        self.make = make
        self.model = model
        self.modelVersion = modelVersion
        self.platform = platform
        self.platformVersion = platformVersion
        self.timezone = timezone
    }
}

extension EndpointItemResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if statusCode != 0 {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension EndpointItemResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointItemResponse(message: \(String(describing: message)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Provides the status code and message that result from processing data for an endpoint.</p>
public struct EndpointItemResponse: Equatable {
    /// <p>The custom message that's returned in the response as a result of processing the endpoint data.</p>
    public let message: String?
    /// <p>The status code that's returned in the response as a result of processing the endpoint data.</p>
    public let statusCode: Int

    public init (
        message: String? = nil,
        statusCode: Int = 0
    )
    {
        self.message = message
        self.statusCode = statusCode
    }
}

extension EndpointLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case city = "City"
        case country = "Country"
        case latitude = "Latitude"
        case longitude = "Longitude"
        case postalCode = "PostalCode"
        case region = "Region"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if latitude != 0.0 {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if longitude != 0.0 {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
        if let postalCode = postalCode {
            try encodeContainer.encode(postalCode, forKey: .postalCode)
        }
        if let region = region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .city)
        city = cityDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let latitudeDecoded = try containerValues.decode(Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decode(Double.self, forKey: .longitude)
        longitude = longitudeDecoded
        let postalCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .postalCode)
        postalCode = postalCodeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .region)
        region = regionDecoded
    }
}

extension EndpointLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointLocation(city: \(String(describing: city)), country: \(String(describing: country)), latitude: \(String(describing: latitude)), longitude: \(String(describing: longitude)), postalCode: \(String(describing: postalCode)), region: \(String(describing: region)))"}
}

/// <p>Specifies geographic information about an endpoint.</p>
public struct EndpointLocation: Equatable {
    /// <p>The name of the city where the endpoint is located.</p>
    public let city: String?
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the endpoint is located. For example, US for the United States.</p>
    public let country: String?
    /// <p>The latitude coordinate of the endpoint location, rounded to one decimal place.</p>
    public let latitude: Double
    /// <p>The longitude coordinate of the endpoint location, rounded to one decimal place.</p>
    public let longitude: Double
    /// <p>The postal or ZIP code for the area where the endpoint is located.</p>
    public let postalCode: String?
    /// <p>The name of the region where the endpoint is located. For locations in the United States, this value is the name of a state.</p>
    public let region: String?

    public init (
        city: String? = nil,
        country: String? = nil,
        latitude: Double = 0.0,
        longitude: Double = 0.0,
        postalCode: String? = nil,
        region: String? = nil
    )
    {
        self.city = city
        self.country = country
        self.latitude = latitude
        self.longitude = longitude
        self.postalCode = postalCode
        self.region = region
    }
}

extension EndpointMessageResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case deliveryStatus = "DeliveryStatus"
        case messageId = "MessageId"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case updatedToken = "UpdatedToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let deliveryStatus = deliveryStatus {
            try encodeContainer.encode(deliveryStatus.rawValue, forKey: .deliveryStatus)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if statusCode != 0 {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let updatedToken = updatedToken {
            try encodeContainer.encode(updatedToken, forKey: .updatedToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let deliveryStatusDecoded = try containerValues.decodeIfPresent(DeliveryStatus.self, forKey: .deliveryStatus)
        deliveryStatus = deliveryStatusDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let updatedTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedToken)
        updatedToken = updatedTokenDecoded
    }
}

extension EndpointMessageResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointMessageResult(address: \(String(describing: address)), deliveryStatus: \(String(describing: deliveryStatus)), messageId: \(String(describing: messageId)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), updatedToken: \(String(describing: updatedToken)))"}
}

/// <p>Provides information about the delivery status and results of sending a message directly to an endpoint.</p>
public struct EndpointMessageResult: Equatable {
    /// <p>The endpoint address that the message was delivered to.</p>
    public let address: String?
    /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>OPT_OUT - The user who's associated with the endpoint has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint. Amazon Pinpoint won't attempt to send the message again.</p></li>    <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
    public let deliveryStatus: DeliveryStatus?
    /// <p>The unique identifier for the message that was sent.</p>
    public let messageId: String?
    /// <p>The downstream service status code for delivering the message.</p>
    public let statusCode: Int
    /// <p>The status message for delivering the message.</p>
    public let statusMessage: String?
    /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
    public let updatedToken: String?

    public init (
        address: String? = nil,
        deliveryStatus: DeliveryStatus? = nil,
        messageId: String? = nil,
        statusCode: Int = 0,
        statusMessage: String? = nil,
        updatedToken: String? = nil
    )
    {
        self.address = address
        self.deliveryStatus = deliveryStatus
        self.messageId = messageId
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.updatedToken = updatedToken
    }
}

extension EndpointRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case attributes = "Attributes"
        case channelType = "ChannelType"
        case demographic = "Demographic"
        case effectiveDate = "EffectiveDate"
        case endpointStatus = "EndpointStatus"
        case location = "Location"
        case metrics = "Metrics"
        case optOut = "OptOut"
        case requestId = "RequestId"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapoflistof__string0) in attributes {
                try attributesContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let demographic = demographic {
            try encodeContainer.encode(demographic, forKey: .demographic)
        }
        if let effectiveDate = effectiveDate {
            try encodeContainer.encode(effectiveDate, forKey: .effectiveDate)
        }
        if let endpointStatus = endpointStatus {
            try encodeContainer.encode(endpointStatus, forKey: .endpointStatus)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__double0) in metrics {
                try metricsContainer.encode(mapof__double0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let optOut = optOut {
            try encodeContainer.encode(optOut, forKey: .optOut)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .attributes)
        var attributesDecoded0: [String:[String]]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:[String]]()
            for (key0, listof__string0) in attributesContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                attributesDecoded0?[key0] = listof__string0Decoded0
            }
        }
        attributes = attributesDecoded0
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let demographicDecoded = try containerValues.decodeIfPresent(EndpointDemographic.self, forKey: .demographic)
        demographic = demographicDecoded
        let effectiveDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveDate)
        effectiveDate = effectiveDateDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let locationDecoded = try containerValues.decodeIfPresent(EndpointLocation.self, forKey: .location)
        location = locationDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: Double?].self, forKey: .metrics)
        var metricsDecoded0: [String:Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:Double]()
            for (key0, __double0) in metricsContainer {
                if let __double0 = __double0 {
                    metricsDecoded0?[key0] = __double0
                }
            }
        }
        metrics = metricsDecoded0
        let optOutDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optOut)
        optOut = optOutDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(EndpointUser.self, forKey: .user)
        user = userDecoded
    }
}

extension EndpointRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointRequest(address: \(String(describing: address)), attributes: \(String(describing: attributes)), channelType: \(String(describing: channelType)), demographic: \(String(describing: demographic)), effectiveDate: \(String(describing: effectiveDate)), endpointStatus: \(String(describing: endpointStatus)), location: \(String(describing: location)), metrics: \(String(describing: metrics)), optOut: \(String(describing: optOut)), requestId: \(String(describing: requestId)), user: \(String(describing: user)))"}
}

/// <p>Specifies the channel type and other settings for an endpoint.</p>
public struct EndpointRequest: Equatable {
    /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For a push-notification channel, use the token provided by the push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. For the SMS channel, use a phone number in E.164 format, such as +12065550100. For the email channel, use an email address.</p>
    public let address: String?
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
    public let attributes: [String:[String]]?
    /// <p>The channel to use when sending messages or push notifications to the endpoint.</p>
    public let channelType: ChannelType?
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    public let demographic: EndpointDemographic?
    /// <p>The date and time, in ISO 8601 format, when the endpoint is updated.</p>
    public let effectiveDate: String?
    /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    public let endpointStatus: String?
    /// <p>The geographic information for the endpoint.</p>
    public let location: EndpointLocation?
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    public let metrics: [String:Double]?
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    public let optOut: String?
    /// <p>The unique identifier for the most recent request to update the endpoint.</p>
    public let requestId: String?
    /// <p>One or more custom attributes that describe the user who's associated with the endpoint.</p>
    public let user: EndpointUser?

    public init (
        address: String? = nil,
        attributes: [String:[String]]? = nil,
        channelType: ChannelType? = nil,
        demographic: EndpointDemographic? = nil,
        effectiveDate: String? = nil,
        endpointStatus: String? = nil,
        location: EndpointLocation? = nil,
        metrics: [String:Double]? = nil,
        optOut: String? = nil,
        requestId: String? = nil,
        user: EndpointUser? = nil
    )
    {
        self.address = address
        self.attributes = attributes
        self.channelType = channelType
        self.demographic = demographic
        self.effectiveDate = effectiveDate
        self.endpointStatus = endpointStatus
        self.location = location
        self.metrics = metrics
        self.optOut = optOut
        self.requestId = requestId
        self.user = user
    }
}

extension EndpointResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case applicationId = "ApplicationId"
        case attributes = "Attributes"
        case channelType = "ChannelType"
        case cohortId = "CohortId"
        case creationDate = "CreationDate"
        case demographic = "Demographic"
        case effectiveDate = "EffectiveDate"
        case endpointStatus = "EndpointStatus"
        case id = "Id"
        case location = "Location"
        case metrics = "Metrics"
        case optOut = "OptOut"
        case requestId = "RequestId"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapoflistof__string0) in attributes {
                try attributesContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let cohortId = cohortId {
            try encodeContainer.encode(cohortId, forKey: .cohortId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let demographic = demographic {
            try encodeContainer.encode(demographic, forKey: .demographic)
        }
        if let effectiveDate = effectiveDate {
            try encodeContainer.encode(effectiveDate, forKey: .effectiveDate)
        }
        if let endpointStatus = endpointStatus {
            try encodeContainer.encode(endpointStatus, forKey: .endpointStatus)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__double0) in metrics {
                try metricsContainer.encode(mapof__double0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let optOut = optOut {
            try encodeContainer.encode(optOut, forKey: .optOut)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .attributes)
        var attributesDecoded0: [String:[String]]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:[String]]()
            for (key0, listof__string0) in attributesContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                attributesDecoded0?[key0] = listof__string0Decoded0
            }
        }
        attributes = attributesDecoded0
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let cohortIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cohortId)
        cohortId = cohortIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let demographicDecoded = try containerValues.decodeIfPresent(EndpointDemographic.self, forKey: .demographic)
        demographic = demographicDecoded
        let effectiveDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveDate)
        effectiveDate = effectiveDateDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let locationDecoded = try containerValues.decodeIfPresent(EndpointLocation.self, forKey: .location)
        location = locationDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: Double?].self, forKey: .metrics)
        var metricsDecoded0: [String:Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:Double]()
            for (key0, __double0) in metricsContainer {
                if let __double0 = __double0 {
                    metricsDecoded0?[key0] = __double0
                }
            }
        }
        metrics = metricsDecoded0
        let optOutDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optOut)
        optOut = optOutDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(EndpointUser.self, forKey: .user)
        user = userDecoded
    }
}

extension EndpointResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointResponse(address: \(String(describing: address)), applicationId: \(String(describing: applicationId)), attributes: \(String(describing: attributes)), channelType: \(String(describing: channelType)), cohortId: \(String(describing: cohortId)), creationDate: \(String(describing: creationDate)), demographic: \(String(describing: demographic)), effectiveDate: \(String(describing: effectiveDate)), endpointStatus: \(String(describing: endpointStatus)), id: \(String(describing: id)), location: \(String(describing: location)), metrics: \(String(describing: metrics)), optOut: \(String(describing: optOut)), requestId: \(String(describing: requestId)), user: \(String(describing: user)))"}
}

/// <p>Provides information about the channel type and other settings for an endpoint.</p>
public struct EndpointResponse: Equatable {
    /// <p>The destination address for messages or push notifications that you send to the endpoint. The address varies by channel. For example, the address for a push-notification channel is typically the token provided by a push notification service, such as an Apple Push Notification service (APNs) device token or a Firebase Cloud Messaging (FCM) registration token. The address for the SMS channel is a phone number in E.164 format, such as +12065550100. The address for the email channel is an email address.</p>
    public let address: String?
    /// <p>The unique identifier for the application that's associated with the endpoint.</p>
    public let applicationId: String?
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. For example, the value of a custom attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments.</p>
    public let attributes: [String:[String]]?
    /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
    public let channelType: ChannelType?
    /// <p>A number from 0-99 that represents the cohort that the endpoint is assigned to. Endpoints are grouped into cohorts randomly, and each cohort contains approximately 1 percent of the endpoints for an application. Amazon Pinpoint assigns cohorts to the holdout or treatment allocations for campaigns.</p>
    public let cohortId: String?
    /// <p>The date and time, in ISO 8601 format, when the endpoint was created.</p>
    public let creationDate: String?
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    public let demographic: EndpointDemographic?
    /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
    public let effectiveDate: String?
    /// <p>Specifies whether messages or push notifications are sent to the endpoint. Possible values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    public let endpointStatus: String?
    /// <p>The unique identifier that you assigned to the endpoint. The identifier should be a globally unique identifier (GUID) to ensure that it doesn't conflict with other endpoint identifiers that are associated with the application.</p>
    public let id: String?
    /// <p>The geographic information for the endpoint.</p>
    public let location: EndpointLocation?
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    public let metrics: [String:Double]?
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    public let optOut: String?
    /// <p>The unique identifier for the most recent request to update the endpoint.</p>
    public let requestId: String?
    /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
    public let user: EndpointUser?

    public init (
        address: String? = nil,
        applicationId: String? = nil,
        attributes: [String:[String]]? = nil,
        channelType: ChannelType? = nil,
        cohortId: String? = nil,
        creationDate: String? = nil,
        demographic: EndpointDemographic? = nil,
        effectiveDate: String? = nil,
        endpointStatus: String? = nil,
        id: String? = nil,
        location: EndpointLocation? = nil,
        metrics: [String:Double]? = nil,
        optOut: String? = nil,
        requestId: String? = nil,
        user: EndpointUser? = nil
    )
    {
        self.address = address
        self.applicationId = applicationId
        self.attributes = attributes
        self.channelType = channelType
        self.cohortId = cohortId
        self.creationDate = creationDate
        self.demographic = demographic
        self.effectiveDate = effectiveDate
        self.endpointStatus = endpointStatus
        self.id = id
        self.location = location
        self.metrics = metrics
        self.optOut = optOut
        self.requestId = requestId
        self.user = user
    }
}

extension EndpointSendConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bodyOverride = "BodyOverride"
        case context = "Context"
        case rawContent = "RawContent"
        case substitutions = "Substitutions"
        case titleOverride = "TitleOverride"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bodyOverride = bodyOverride {
            try encodeContainer.encode(bodyOverride, forKey: .bodyOverride)
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .context)
            for (dictKey0, mapof__string0) in context {
                try contextContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let titleOverride = titleOverride {
            try encodeContainer.encode(titleOverride, forKey: .titleOverride)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .bodyOverride)
        bodyOverride = bodyOverrideDecoded
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let titleOverrideDecoded = try containerValues.decodeIfPresent(String.self, forKey: .titleOverride)
        titleOverride = titleOverrideDecoded
    }
}

extension EndpointSendConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointSendConfiguration(bodyOverride: \(String(describing: bodyOverride)), context: \(String(describing: context)), rawContent: \(String(describing: rawContent)), substitutions: \(String(describing: substitutions)), titleOverride: \(String(describing: titleOverride)))"}
}

/// <p>Specifies the content, including message variables and attributes, to use in a message that's sent directly to an endpoint.</p>
public struct EndpointSendConfiguration: Equatable {
    /// <p>The body of the message. If specified, this value overrides the default message body.</p>
    public let bodyOverride: String?
    /// <p>A map of custom attributes to attach to the message for the address. Attribute names are case sensitive.</p> <p>For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
    public let context: [String:String]?
    /// <p>The raw, JSON-formatted string to use as the payload for the message. If specified, this value overrides all other values for the message.</p>
    public let rawContent: String?
    /// <p>A map of the message variables to merge with the variables specified for the default message (DefaultMessage.Substitutions). The variables specified in this map take precedence over all other variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The title or subject line of the message. If specified, this value overrides the default message title or subject line.</p>
    public let titleOverride: String?

    public init (
        bodyOverride: String? = nil,
        context: [String:String]? = nil,
        rawContent: String? = nil,
        substitutions: [String:[String]]? = nil,
        titleOverride: String? = nil
    )
    {
        self.bodyOverride = bodyOverride
        self.context = context
        self.rawContent = rawContent
        self.substitutions = substitutions
        self.titleOverride = titleOverride
    }
}

extension EndpointUser: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case userAttributes = "UserAttributes"
        case userId = "UserId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userAttributes)
            for (dictKey0, mapoflistof__string0) in userAttributes {
                try userAttributesContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userId = userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userAttributesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .userAttributes)
        var userAttributesDecoded0: [String:[String]]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [String:[String]]()
            for (key0, listof__string0) in userAttributesContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                userAttributesDecoded0?[key0] = listof__string0Decoded0
            }
        }
        userAttributes = userAttributesDecoded0
        let userIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension EndpointUser: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointUser(userAttributes: \(String(describing: userAttributes)), userId: \(String(describing: userId)))"}
}

/// <p>Specifies data for one or more attributes that describe the user who's associated with an endpoint.</p>
public struct EndpointUser: Equatable {
    /// <p>One or more custom attributes that describe the user by associating a name with an array of values. For example, the value of an attribute named Interests might be: ["Science", "Music", "Travel"]. You can use these attributes as filter criteria when you create segments. Attribute names are case sensitive.</p> <p>An attribute name can contain up to 50 characters. An attribute value can contain up to 100 characters. When you define the name of a custom attribute, avoid using the following characters: number sign (#), colon (:), question mark (?), backslash (\), and slash (/). The Amazon Pinpoint console can't display attribute names that contain these characters. This restriction doesn't apply to attribute values.</p>
    public let userAttributes: [String:[String]]?
    /// <p>The unique identifier for the user.</p>
    public let userId: String?

    public init (
        userAttributes: [String:[String]]? = nil,
        userId: String? = nil
    )
    {
        self.userAttributes = userAttributes
        self.userId = userId
    }
}

extension EndpointsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofendpointresponse0 in item {
                try itemContainer.encode(listofendpointresponse0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([EndpointResponse?].self, forKey: .item)
        var itemDecoded0:[EndpointResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [EndpointResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
    }
}

extension EndpointsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EndpointsResponse(item: \(String(describing: item)))"}
}

/// <p>Provides information about all the endpoints that are associated with a user ID.</p>
public struct EndpointsResponse: Equatable {
    /// <p>An array of responses, one for each endpoint that's associated with the user ID.</p>
    public let item: [EndpointResponse]?

    public init (
        item: [EndpointResponse]? = nil
    )
    {
        self.item = item
    }
}

extension Event: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appPackageName = "AppPackageName"
        case appTitle = "AppTitle"
        case appVersionCode = "AppVersionCode"
        case attributes = "Attributes"
        case clientSdkVersion = "ClientSdkVersion"
        case eventType = "EventType"
        case metrics = "Metrics"
        case sdkName = "SdkName"
        case session = "Session"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appPackageName = appPackageName {
            try encodeContainer.encode(appPackageName, forKey: .appPackageName)
        }
        if let appTitle = appTitle {
            try encodeContainer.encode(appTitle, forKey: .appTitle)
        }
        if let appVersionCode = appVersionCode {
            try encodeContainer.encode(appVersionCode, forKey: .appVersionCode)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapof__string0) in attributes {
                try attributesContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let clientSdkVersion = clientSdkVersion {
            try encodeContainer.encode(clientSdkVersion, forKey: .clientSdkVersion)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__double0) in metrics {
                try metricsContainer.encode(mapof__double0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let sdkName = sdkName {
            try encodeContainer.encode(sdkName, forKey: .sdkName)
        }
        if let session = session {
            try encodeContainer.encode(session, forKey: .session)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appPackageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appPackageName)
        appPackageName = appPackageNameDecoded
        let appTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appTitle)
        appTitle = appTitleDecoded
        let appVersionCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appVersionCode)
        appVersionCode = appVersionCodeDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, __string0) in attributesContainer {
                if let __string0 = __string0 {
                    attributesDecoded0?[key0] = __string0
                }
            }
        }
        attributes = attributesDecoded0
        let clientSdkVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientSdkVersion)
        clientSdkVersion = clientSdkVersionDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: Double?].self, forKey: .metrics)
        var metricsDecoded0: [String:Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:Double]()
            for (key0, __double0) in metricsContainer {
                if let __double0 = __double0 {
                    metricsDecoded0?[key0] = __double0
                }
            }
        }
        metrics = metricsDecoded0
        let sdkNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sdkName)
        sdkName = sdkNameDecoded
        let sessionDecoded = try containerValues.decodeIfPresent(Session.self, forKey: .session)
        session = sessionDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timestamp)
        timestamp = timestampDecoded
    }
}

extension Event: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Event(appPackageName: \(String(describing: appPackageName)), appTitle: \(String(describing: appTitle)), appVersionCode: \(String(describing: appVersionCode)), attributes: \(String(describing: attributes)), clientSdkVersion: \(String(describing: clientSdkVersion)), eventType: \(String(describing: eventType)), metrics: \(String(describing: metrics)), sdkName: \(String(describing: sdkName)), session: \(String(describing: session)), timestamp: \(String(describing: timestamp)))"}
}

/// <p>Specifies information about an event that reports data to Amazon Pinpoint.</p>
public struct Event: Equatable {
    /// <p>The package name of the app that's recording the event.</p>
    public let appPackageName: String?
    /// <p>The title of the app that's recording the event.</p>
    public let appTitle: String?
    /// <p>The version number of the app that's recording the event.</p>
    public let appVersionCode: String?
    /// <p>One or more custom attributes that are associated with the event.</p>
    public let attributes: [String:String]?
    /// <p>The version of the SDK that's running on the client device.</p>
    public let clientSdkVersion: String?
    /// <p>The name of the event.</p>
    public let eventType: String?
    /// <p>One or more custom metrics that are associated with the event.</p>
    public let metrics: [String:Double]?
    /// <p>The name of the SDK that's being used to record the event.</p>
    public let sdkName: String?
    /// <p>Information about the session in which the event occurred.</p>
    public let session: Session?
    /// <p>The date and time, in ISO 8601 format, when the event occurred.</p>
    public let timestamp: String?

    public init (
        appPackageName: String? = nil,
        appTitle: String? = nil,
        appVersionCode: String? = nil,
        attributes: [String:String]? = nil,
        clientSdkVersion: String? = nil,
        eventType: String? = nil,
        metrics: [String:Double]? = nil,
        sdkName: String? = nil,
        session: Session? = nil,
        timestamp: String? = nil
    )
    {
        self.appPackageName = appPackageName
        self.appTitle = appTitle
        self.appVersionCode = appVersionCode
        self.attributes = attributes
        self.clientSdkVersion = clientSdkVersion
        self.eventType = eventType
        self.metrics = metrics
        self.sdkName = sdkName
        self.session = session
        self.timestamp = timestamp
    }
}

extension EventCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case messageActivity = "MessageActivity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let messageActivity = messageActivity {
            try encodeContainer.encode(messageActivity, forKey: .messageActivity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(EventDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let messageActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageActivity)
        messageActivity = messageActivityDecoded
    }
}

extension EventCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventCondition(dimensions: \(String(describing: dimensions)), messageActivity: \(String(describing: messageActivity)))"}
}

/// <p>Specifies the conditions to evaluate for an event that applies to an activity in a journey.</p>
public struct EventCondition: Equatable {
    /// <p>The dimensions for the event filter to use for the activity.</p>
    public let dimensions: EventDimensions?
    /// <p>The message identifier (message_id) for the message to use when determining whether message events meet the condition.</p>
    public let messageActivity: String?

    public init (
        dimensions: EventDimensions? = nil,
        messageActivity: String? = nil
    )
    {
        self.dimensions = dimensions
        self.messageActivity = messageActivity
    }
}

extension EventDimensions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case eventType = "EventType"
        case metrics = "Metrics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapofattributedimension0) in attributes {
                try attributesContainer.encode(mapofattributedimension0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapofmetricdimension0) in metrics {
                try metricsContainer.encode(mapofmetricdimension0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: AttributeDimension?].self, forKey: .attributes)
        var attributesDecoded0: [String:AttributeDimension]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:AttributeDimension]()
            for (key0, attributedimension0) in attributesContainer {
                if let attributedimension0 = attributedimension0 {
                    attributesDecoded0?[key0] = attributedimension0
                }
            }
        }
        attributes = attributesDecoded0
        let eventTypeDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: MetricDimension?].self, forKey: .metrics)
        var metricsDecoded0: [String:MetricDimension]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:MetricDimension]()
            for (key0, metricdimension0) in metricsContainer {
                if let metricdimension0 = metricdimension0 {
                    metricsDecoded0?[key0] = metricdimension0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension EventDimensions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDimensions(attributes: \(String(describing: attributes)), eventType: \(String(describing: eventType)), metrics: \(String(describing: metrics)))"}
}

/// <p>Specifies the dimensions for an event filter that determines when a campaign is sent or a journey activity is performed.</p>
public struct EventDimensions: Equatable {
    /// <p>One or more custom attributes that your application reports to Amazon Pinpoint. You can use these attributes as selection criteria when you create an event filter.</p>
    public let attributes: [String:AttributeDimension]?
    /// <p>The name of the event that causes the campaign to be sent or the journey activity to be performed. This can be a standard event that Amazon Pinpoint generates, such as _email.delivered. For campaigns, this can also be a custom event that's specific to your application. For information about standard events, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/event-streams.html">Streaming Amazon Pinpoint Events</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p>
    public let eventType: SetDimension?
    /// <p>One or more custom metrics that your application reports to Amazon Pinpoint. You can use these metrics as selection criteria when you create an event filter.</p>
    public let metrics: [String:MetricDimension]?

    public init (
        attributes: [String:AttributeDimension]? = nil,
        eventType: SetDimension? = nil,
        metrics: [String:MetricDimension]? = nil
    )
    {
        self.attributes = attributes
        self.eventType = eventType
        self.metrics = metrics
    }
}

extension EventFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case filterType = "FilterType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let filterType = filterType {
            try encodeContainer.encode(filterType.rawValue, forKey: .filterType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(EventDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let filterTypeDecoded = try containerValues.decodeIfPresent(FilterType.self, forKey: .filterType)
        filterType = filterTypeDecoded
    }
}

extension EventFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventFilter(dimensions: \(String(describing: dimensions)), filterType: \(String(describing: filterType)))"}
}

/// <p>Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.</p>
public struct EventFilter: Equatable {
    /// <p>The dimensions for the event filter to use for the campaign or the journey activity.</p>
    public let dimensions: EventDimensions?
    /// <p>The type of event that causes the campaign to be sent or the journey activity to be performed. Valid values are: SYSTEM, sends the campaign or performs the activity when a system event occurs; and, ENDPOINT, sends the campaign or performs the activity when an endpoint event (<link  linkend="apps-application-id-events">Events resource</link>) occurs.</p>
    public let filterType: FilterType?

    public init (
        dimensions: EventDimensions? = nil,
        filterType: FilterType? = nil
    )
    {
        self.dimensions = dimensions
        self.filterType = filterType
    }
}

extension EventItemResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case statusCode = "StatusCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if statusCode != 0 {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension EventItemResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventItemResponse(message: \(String(describing: message)), statusCode: \(String(describing: statusCode)))"}
}

/// <p>Provides the status code and message that result from processing an event.</p>
public struct EventItemResponse: Equatable {
    /// <p>A custom message that's returned in the response as a result of processing the event.</p>
    public let message: String?
    /// <p>The status code that's returned in the response as a result of processing the event. Possible values are: 202, for events that were accepted; and, 400, for events that weren't valid.</p>
    public let statusCode: Int

    public init (
        message: String? = nil,
        statusCode: Int = 0
    )
    {
        self.message = message
        self.statusCode = statusCode
    }
}

extension EventStartCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventFilter = "EventFilter"
        case segmentId = "SegmentId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventFilter = eventFilter {
            try encodeContainer.encode(eventFilter, forKey: .eventFilter)
        }
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventFilterDecoded = try containerValues.decodeIfPresent(EventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
    }
}

extension EventStartCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventStartCondition(eventFilter: \(String(describing: eventFilter)), segmentId: \(String(describing: segmentId)))"}
}

/// <p>Specifies the settings for an event that causes a journey activity to start.</p>
public struct EventStartCondition: Equatable {
    /// <p>Specifies the settings for an event that causes a campaign to be sent or a journey activity to be performed.</p>
    public let eventFilter: EventFilter?
    public let segmentId: String?

    public init (
        eventFilter: EventFilter? = nil,
        segmentId: String? = nil
    )
    {
        self.eventFilter = eventFilter
        self.segmentId = segmentId
    }
}

extension EventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case destinationStreamArn = "DestinationStreamArn"
        case externalId = "ExternalId"
        case lastModifiedDate = "LastModifiedDate"
        case lastUpdatedBy = "LastUpdatedBy"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let destinationStreamArn = destinationStreamArn {
            try encodeContainer.encode(destinationStreamArn, forKey: .destinationStreamArn)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let lastUpdatedBy = lastUpdatedBy {
            try encodeContainer.encode(lastUpdatedBy, forKey: .lastUpdatedBy)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let destinationStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationStreamArn)
        destinationStreamArn = destinationStreamArnDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let lastUpdatedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdatedBy)
        lastUpdatedBy = lastUpdatedByDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension EventStream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventStream(applicationId: \(String(describing: applicationId)), destinationStreamArn: \(String(describing: destinationStreamArn)), externalId: \(String(describing: externalId)), lastModifiedDate: \(String(describing: lastModifiedDate)), lastUpdatedBy: \(String(describing: lastUpdatedBy)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.</p>
public struct EventStream: Equatable {
    /// <p>The unique identifier for the application to publish event data for.</p>
    public let applicationId: String?
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
    ///                </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
    ///                </p>
    public let destinationStreamArn: String?
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when publishing event data, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    public let externalId: String?
    /// <p>The date, in ISO 8601 format, when the event stream was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The IAM user who last modified the event stream.</p>
    public let lastUpdatedBy: String?
    /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
    public let roleArn: String?

    public init (
        applicationId: String? = nil,
        destinationStreamArn: String? = nil,
        externalId: String? = nil,
        lastModifiedDate: String? = nil,
        lastUpdatedBy: String? = nil,
        roleArn: String? = nil
    )
    {
        self.applicationId = applicationId
        self.destinationStreamArn = destinationStreamArn
        self.externalId = externalId
        self.lastModifiedDate = lastModifiedDate
        self.lastUpdatedBy = lastUpdatedBy
        self.roleArn = roleArn
    }
}

extension EventsBatch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoint = "Endpoint"
        case events = "Events"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let events = events {
            var eventsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .events)
            for (dictKey0, mapofevent0) in events {
                try eventsContainer.encode(mapofevent0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(PublicEndpoint.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let eventsContainer = try containerValues.decodeIfPresent([String: Event?].self, forKey: .events)
        var eventsDecoded0: [String:Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [String:Event]()
            for (key0, event0) in eventsContainer {
                if let event0 = event0 {
                    eventsDecoded0?[key0] = event0
                }
            }
        }
        events = eventsDecoded0
    }
}

extension EventsBatch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventsBatch(endpoint: \(String(describing: endpoint)), events: \(String(describing: events)))"}
}

/// <p>Specifies a batch of endpoints and events to process.</p>
public struct EventsBatch: Equatable {
    /// <p>A set of properties and attributes that are associated with the endpoint.</p>
    public let endpoint: PublicEndpoint?
    /// <p>A set of properties that are associated with the event.</p>
    public let events: [String:Event]?

    public init (
        endpoint: PublicEndpoint? = nil,
        events: [String:Event]? = nil
    )
    {
        self.endpoint = endpoint
        self.events = events
    }
}

extension EventsRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchItem = "BatchItem"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchItem = batchItem {
            var batchItemContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .batchItem)
            for (dictKey0, mapofeventsbatch0) in batchItem {
                try batchItemContainer.encode(mapofeventsbatch0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchItemContainer = try containerValues.decodeIfPresent([String: EventsBatch?].self, forKey: .batchItem)
        var batchItemDecoded0: [String:EventsBatch]? = nil
        if let batchItemContainer = batchItemContainer {
            batchItemDecoded0 = [String:EventsBatch]()
            for (key0, eventsbatch0) in batchItemContainer {
                if let eventsbatch0 = eventsbatch0 {
                    batchItemDecoded0?[key0] = eventsbatch0
                }
            }
        }
        batchItem = batchItemDecoded0
    }
}

extension EventsRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventsRequest(batchItem: \(String(describing: batchItem)))"}
}

/// <p>Specifies a batch of events to process.</p>
public struct EventsRequest: Equatable {
    /// <p>The batch of events to process. For each item in a batch, the endpoint ID acts as a key that has an EventsBatch object as its value.</p>
    public let batchItem: [String:EventsBatch]?

    public init (
        batchItem: [String:EventsBatch]? = nil
    )
    {
        self.batchItem = batchItem
    }
}

extension EventsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case results = "Results"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let results = results {
            var resultsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .results)
            for (dictKey0, mapofitemresponse0) in results {
                try resultsContainer.encode(mapofitemresponse0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([String: ItemResponse?].self, forKey: .results)
        var resultsDecoded0: [String:ItemResponse]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [String:ItemResponse]()
            for (key0, itemresponse0) in resultsContainer {
                if let itemresponse0 = itemresponse0 {
                    resultsDecoded0?[key0] = itemresponse0
                }
            }
        }
        results = resultsDecoded0
    }
}

extension EventsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventsResponse(results: \(String(describing: results)))"}
}

/// <p>Provides information about endpoints and the events that they're associated with.</p>
public struct EventsResponse: Equatable {
    /// <p>A map that contains a multipart response for each endpoint. For each item in this object, the endpoint ID is the key and the item response is the value. If no item response exists, the value can also be one of the following: 202, the request was processed successfully; or 400, the payload wasn't valid or required fields were missing.</p>
    public let results: [String:ItemResponse]?

    public init (
        results: [String:ItemResponse]? = nil
    )
    {
        self.results = results
    }
}

extension ExportJobRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case s3UrlPrefix = "S3UrlPrefix"
        case segmentId = "SegmentId"
        case segmentVersion = "SegmentVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3UrlPrefix = s3UrlPrefix {
            try encodeContainer.encode(s3UrlPrefix, forKey: .s3UrlPrefix)
        }
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
        if segmentVersion != 0 {
            try encodeContainer.encode(segmentVersion, forKey: .segmentVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let s3UrlPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3UrlPrefix)
        s3UrlPrefix = s3UrlPrefixDecoded
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
        let segmentVersionDecoded = try containerValues.decode(Int.self, forKey: .segmentVersion)
        segmentVersion = segmentVersionDecoded
    }
}

extension ExportJobRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportJobRequest(roleArn: \(String(describing: roleArn)), s3UrlPrefix: \(String(describing: s3UrlPrefix)), segmentId: \(String(describing: segmentId)), segmentVersion: \(String(describing: segmentVersion)))"}
}

/// <p>Specifies the settings for a job that exports endpoint definitions to an Amazon Simple Storage Service (Amazon S3) bucket.</p>
public struct ExportJobRequest: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location where you want to export endpoint definitions to.</p>
    public let roleArn: String?
    /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where you want to export endpoint definitions to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
    public let s3UrlPrefix: String?
    /// <p>The identifier for the segment to export endpoint definitions from. If you don't specify this value, Amazon Pinpoint exports definitions for all the endpoints that are associated with the application.</p>
    public let segmentId: String?
    /// <p>The version of the segment to export endpoint definitions from, if specified.</p>
    public let segmentVersion: Int

    public init (
        roleArn: String? = nil,
        s3UrlPrefix: String? = nil,
        segmentId: String? = nil,
        segmentVersion: Int = 0
    )
    {
        self.roleArn = roleArn
        self.s3UrlPrefix = s3UrlPrefix
        self.segmentId = segmentId
        self.segmentVersion = segmentVersion
    }
}

extension ExportJobResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn = "RoleArn"
        case s3UrlPrefix = "S3UrlPrefix"
        case segmentId = "SegmentId"
        case segmentVersion = "SegmentVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3UrlPrefix = s3UrlPrefix {
            try encodeContainer.encode(s3UrlPrefix, forKey: .s3UrlPrefix)
        }
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
        if segmentVersion != 0 {
            try encodeContainer.encode(segmentVersion, forKey: .segmentVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let s3UrlPrefixDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3UrlPrefix)
        s3UrlPrefix = s3UrlPrefixDecoded
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
        let segmentVersionDecoded = try containerValues.decode(Int.self, forKey: .segmentVersion)
        segmentVersion = segmentVersionDecoded
    }
}

extension ExportJobResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportJobResource(roleArn: \(String(describing: roleArn)), s3UrlPrefix: \(String(describing: s3UrlPrefix)), segmentId: \(String(describing: segmentId)), segmentVersion: \(String(describing: segmentVersion)))"}
}

/// <p>Provides information about the resource settings for a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.</p>
public struct ExportJobResource: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location where the endpoint definitions were exported to.</p>
    public let roleArn: String?
    /// <p>The URL of the location in an Amazon Simple Storage Service (Amazon S3) bucket where the endpoint definitions were exported to. This location is typically a folder that contains multiple files. The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/.</p>
    public let s3UrlPrefix: String?
    /// <p>The identifier for the segment that the endpoint definitions were exported from. If this value isn't present, Amazon Pinpoint exported definitions for all the endpoints that are associated with the application.</p>
    public let segmentId: String?
    /// <p>The version of the segment that the endpoint definitions were exported from.</p>
    public let segmentVersion: Int

    public init (
        roleArn: String? = nil,
        s3UrlPrefix: String? = nil,
        segmentId: String? = nil,
        segmentVersion: Int = 0
    )
    {
        self.roleArn = roleArn
        self.s3UrlPrefix = s3UrlPrefix
        self.segmentId = segmentId
        self.segmentVersion = segmentVersion
    }
}

extension ExportJobResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case completedPieces = "CompletedPieces"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case definition = "Definition"
        case failedPieces = "FailedPieces"
        case failures = "Failures"
        case id = "Id"
        case jobStatus = "JobStatus"
        case totalFailures = "TotalFailures"
        case totalPieces = "TotalPieces"
        case totalProcessed = "TotalProcessed"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if completedPieces != 0 {
            try encodeContainer.encode(completedPieces, forKey: .completedPieces)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate, forKey: .completionDate)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if failedPieces != 0 {
            try encodeContainer.encode(failedPieces, forKey: .failedPieces)
        }
        if let failures = failures {
            var failuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failures)
            for listof__string0 in failures {
                try failuresContainer.encode(listof__string0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if totalFailures != 0 {
            try encodeContainer.encode(totalFailures, forKey: .totalFailures)
        }
        if totalPieces != 0 {
            try encodeContainer.encode(totalPieces, forKey: .totalPieces)
        }
        if totalProcessed != 0 {
            try encodeContainer.encode(totalProcessed, forKey: .totalProcessed)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let completedPiecesDecoded = try containerValues.decode(Int.self, forKey: .completedPieces)
        completedPieces = completedPiecesDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(ExportJobResource.self, forKey: .definition)
        definition = definitionDecoded
        let failedPiecesDecoded = try containerValues.decode(Int.self, forKey: .failedPieces)
        failedPieces = failedPiecesDecoded
        let failuresContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failures)
        var failuresDecoded0:[String]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [String]()
            for string0 in failuresContainer {
                if let string0 = string0 {
                    failuresDecoded0?.append(string0)
                }
            }
        }
        failures = failuresDecoded0
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let totalFailuresDecoded = try containerValues.decode(Int.self, forKey: .totalFailures)
        totalFailures = totalFailuresDecoded
        let totalPiecesDecoded = try containerValues.decode(Int.self, forKey: .totalPieces)
        totalPieces = totalPiecesDecoded
        let totalProcessedDecoded = try containerValues.decode(Int.self, forKey: .totalProcessed)
        totalProcessed = totalProcessedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ExportJobResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportJobResponse(applicationId: \(String(describing: applicationId)), completedPieces: \(String(describing: completedPieces)), completionDate: \(String(describing: completionDate)), creationDate: \(String(describing: creationDate)), definition: \(String(describing: definition)), failedPieces: \(String(describing: failedPieces)), failures: \(String(describing: failures)), id: \(String(describing: id)), jobStatus: \(String(describing: jobStatus)), totalFailures: \(String(describing: totalFailures)), totalPieces: \(String(describing: totalPieces)), totalProcessed: \(String(describing: totalProcessed)), type: \(String(describing: type)))"}
}

/// <p>Provides information about the status and settings of a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.</p>
public struct ExportJobResponse: Equatable {
    /// <p>The unique identifier for the application that's associated with the export job.</p>
    public let applicationId: String?
    /// <p>The number of pieces that were processed successfully (completed) by the export job, as of the time of the request.</p>
    public let completedPieces: Int
    /// <p>The date, in ISO 8601 format, when the export job was completed.</p>
    public let completionDate: String?
    /// <p>The date, in ISO 8601 format, when the export job was created.</p>
    public let creationDate: String?
    /// <p>The resource settings that apply to the export job.</p>
    public let definition: ExportJobResource?
    /// <p>The number of pieces that weren't processed successfully (failed) by the export job, as of the time of the request.</p>
    public let failedPieces: Int
    /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the export job, if any.</p>
    public let failures: [String]?
    /// <p>The unique identifier for the export job.</p>
    public let id: String?
    /// <p>The status of the export job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
    public let jobStatus: JobStatus?
    /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the export job, typically because an error, such as a syntax error, occurred.</p>
    public let totalFailures: Int
    /// <p>The total number of pieces that must be processed to complete the export job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the export job.</p>
    public let totalPieces: Int
    /// <p>The total number of endpoint definitions that were processed by the export job.</p>
    public let totalProcessed: Int
    /// <p>The job type. This value is EXPORT for export jobs.</p>
    public let type: String?

    public init (
        applicationId: String? = nil,
        completedPieces: Int = 0,
        completionDate: String? = nil,
        creationDate: String? = nil,
        definition: ExportJobResource? = nil,
        failedPieces: Int = 0,
        failures: [String]? = nil,
        id: String? = nil,
        jobStatus: JobStatus? = nil,
        totalFailures: Int = 0,
        totalPieces: Int = 0,
        totalProcessed: Int = 0,
        type: String? = nil
    )
    {
        self.applicationId = applicationId
        self.completedPieces = completedPieces
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.definition = definition
        self.failedPieces = failedPieces
        self.failures = failures
        self.id = id
        self.jobStatus = jobStatus
        self.totalFailures = totalFailures
        self.totalPieces = totalPieces
        self.totalProcessed = totalProcessed
        self.type = type
    }
}

extension ExportJobsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofexportjobresponse0 in item {
                try itemContainer.encode(listofexportjobresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([ExportJobResponse?].self, forKey: .item)
        var itemDecoded0:[ExportJobResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [ExportJobResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ExportJobsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportJobsResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about all the export jobs that are associated with an application or segment. An export job is a job that exports endpoint definitions to a file.</p>
public struct ExportJobsResponse: Equatable {
    /// <p>An array of responses, one for each export job that's associated with the application (Export Jobs resource) or segment (Segment Export Jobs resource).</p>
    public let item: [ExportJobResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [ExportJobResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

public enum FilterType {
    case endpoint
    case system
    case sdkUnknown(String)
}

extension FilterType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FilterType] {
        return [
            .endpoint,
            .system,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .endpoint: return "ENDPOINT"
        case .system: return "SYSTEM"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FilterType(rawValue: rawValue) ?? FilterType.sdkUnknown(rawValue)
    }
}

extension ForbiddenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ForbiddenException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension ForbiddenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct ForbiddenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct ForbiddenExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension ForbiddenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

public enum Format {
    case csv
    case json
    case sdkUnknown(String)
}

extension Format : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Format] {
        return [
            .csv,
            .json,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .csv: return "CSV"
        case .json: return "JSON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
    }
}

public enum Frequency {
    case daily
    case event
    case hourly
    case monthly
    case once
    case weekly
    case sdkUnknown(String)
}

extension Frequency : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Frequency] {
        return [
            .daily,
            .event,
            .hourly,
            .monthly,
            .once,
            .weekly,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .daily: return "DAILY"
        case .event: return "EVENT"
        case .hourly: return "HOURLY"
        case .monthly: return "MONTHLY"
        case .once: return "ONCE"
        case .weekly: return "WEEKLY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Frequency(rawValue: rawValue) ?? Frequency.sdkUnknown(rawValue)
    }
}

extension GCMChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case apiKey = "ApiKey"
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiKey = apiKey {
            try encodeContainer.encode(apiKey, forKey: .apiKey)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .apiKey)
        apiKey = apiKeyDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension GCMChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GCMChannelRequest(apiKey: \(String(describing: apiKey)), enabled: \(String(describing: enabled)))"}
}

/// <p>Specifies the status and settings of the GCM channel for an application. This channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
public struct GCMChannelRequest: Equatable {
    /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
    public let apiKey: String?
    /// <p>Specifies whether to enable the GCM channel for the application.</p>
    public let enabled: Bool

    public init (
        apiKey: String? = nil,
        enabled: Bool = false
    )
    {
        self.apiKey = apiKey
        self.enabled = enabled
    }
}

extension GCMChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case credential = "Credential"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let credential = credential {
            try encodeContainer.encode(credential, forKey: .credential)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let credentialDecoded = try containerValues.decodeIfPresent(String.self, forKey: .credential)
        credential = credentialDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension GCMChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GCMChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), credential: \(String(describing: credential)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
public struct GCMChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the GCM channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time when the GCM channel was enabled.</p>
    public let creationDate: String?
    /// <p>The Web API Key, also referred to as an <i>API_KEY</i> or <i>server key</i>, that you received from Google to communicate with Google services.</p>
    public let credential: String?
    /// <p>Specifies whether the GCM channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>(Deprecated) An identifier for the GCM channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the GCM channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the GCM channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time when the GCM channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the GCM channel, this value is GCM.</p>
    public let platform: String?
    /// <p>The current version of the GCM channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        credential: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.credential = credential
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

extension GCMMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case collapseKey = "CollapseKey"
        case data = "Data"
        case iconReference = "IconReference"
        case imageIconUrl = "ImageIconUrl"
        case imageUrl = "ImageUrl"
        case priority = "Priority"
        case rawContent = "RawContent"
        case restrictedPackageName = "RestrictedPackageName"
        case silentPush = "SilentPush"
        case smallImageIconUrl = "SmallImageIconUrl"
        case sound = "Sound"
        case substitutions = "Substitutions"
        case timeToLive = "TimeToLive"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let collapseKey = collapseKey {
            try encodeContainer.encode(collapseKey, forKey: .collapseKey)
        }
        if let data = data {
            var dataContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .data)
            for (dictKey0, mapof__string0) in data {
                try dataContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let iconReference = iconReference {
            try encodeContainer.encode(iconReference, forKey: .iconReference)
        }
        if let imageIconUrl = imageIconUrl {
            try encodeContainer.encode(imageIconUrl, forKey: .imageIconUrl)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let priority = priority {
            try encodeContainer.encode(priority, forKey: .priority)
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if let restrictedPackageName = restrictedPackageName {
            try encodeContainer.encode(restrictedPackageName, forKey: .restrictedPackageName)
        }
        if silentPush != false {
            try encodeContainer.encode(silentPush, forKey: .silentPush)
        }
        if let smallImageIconUrl = smallImageIconUrl {
            try encodeContainer.encode(smallImageIconUrl, forKey: .smallImageIconUrl)
        }
        if let sound = sound {
            try encodeContainer.encode(sound, forKey: .sound)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if timeToLive != 0 {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let collapseKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .collapseKey)
        collapseKey = collapseKeyDecoded
        let dataContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .data)
        var dataDecoded0: [String:String]? = nil
        if let dataContainer = dataContainer {
            dataDecoded0 = [String:String]()
            for (key0, __string0) in dataContainer {
                if let __string0 = __string0 {
                    dataDecoded0?[key0] = __string0
                }
            }
        }
        data = dataDecoded0
        let iconReferenceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iconReference)
        iconReference = iconReferenceDecoded
        let imageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageIconUrl)
        imageIconUrl = imageIconUrlDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let priorityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .priority)
        priority = priorityDecoded
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let restrictedPackageNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .restrictedPackageName)
        restrictedPackageName = restrictedPackageNameDecoded
        let silentPushDecoded = try containerValues.decode(Bool.self, forKey: .silentPush)
        silentPush = silentPushDecoded
        let smallImageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .smallImageIconUrl)
        smallImageIconUrl = smallImageIconUrlDecoded
        let soundDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sound)
        sound = soundDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let timeToLiveDecoded = try containerValues.decode(Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension GCMMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GCMMessage(action: \(String(describing: action)), body: \(String(describing: body)), collapseKey: \(String(describing: collapseKey)), data: \(String(describing: data)), iconReference: \(String(describing: iconReference)), imageIconUrl: \(String(describing: imageIconUrl)), imageUrl: \(String(describing: imageUrl)), priority: \(String(describing: priority)), rawContent: \(String(describing: rawContent)), restrictedPackageName: \(String(describing: restrictedPackageName)), silentPush: \(String(describing: silentPush)), smallImageIconUrl: \(String(describing: smallImageIconUrl)), sound: \(String(describing: sound)), substitutions: \(String(describing: substitutions)), timeToLive: \(String(describing: timeToLive)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies the settings for a one-time message that's sent directly to an endpoint through the GCM channel. The GCM channel enables Amazon Pinpoint to send messages to the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
public struct GCMMessage: Equatable {
    /// <p>The action to occur if the recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This action uses the deep-linking features of the Android platform.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The body of the notification message.</p>
    public let body: String?
    /// <p>An arbitrary string that identifies a group of messages that can be collapsed to ensure that only the last message is sent when delivery can resume. This helps avoid sending too many instances of the same messages when the recipient's device comes online again or becomes active.</p> <p>Amazon Pinpoint specifies this value in the Firebase Cloud Messaging (FCM) collapse_key parameter when it sends the notification message to FCM.</p>
    public let collapseKey: String?
    /// <p>The JSON data payload to use for the push notification, if the notification is a silent push notification. This payload is added to the data.pinpoint.jsonBody object of the notification.</p>
    public let data: [String:String]?
    /// <p>The icon image name of the asset saved in your app.</p>
    public let iconReference: String?
    /// <p>The URL of the large icon image to display in the content view of the push notification.</p>
    public let imageIconUrl: String?
    /// <p>The URL of an image to display in the push notification.</p>
    public let imageUrl: String?
    /// <p>para>normal - The notification might be delayed. Delivery is optimized for battery usage on the recipient's device. Use this value unless immediate delivery is required.</p>/listitem> <li><p>high - The notification is sent immediately and might wake a sleeping device.</p></li>/para> <p>Amazon Pinpoint specifies this value in the FCM priority parameter when it sends the notification message to FCM.</p> <p>The equivalent values for Apple Push Notification service (APNs) are 5, for normal, and 10, for high. If you specify an APNs value for this property, Amazon Pinpoint accepts and converts the value to the corresponding FCM value.</p>
    public let priority: String?
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    public let rawContent: String?
    /// <p>The package name of the application where registration tokens must match in order for the recipient to receive the message.</p>
    public let restrictedPackageName: String?
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration or supporting phone home functionality.</p>
    public let silentPush: Bool
    /// <p>The URL of the small icon image to display in the status bar and the content view of the push notification.</p>
    public let smallImageIconUrl: String?
    /// <p>The sound to play when the recipient receives the push notification. You can use the default stream or specify the file name of a sound resource that's bundled in your app. On an Android platform, the sound file must reside in /res/raw/.</p>
    public let sound: String?
    /// <p>The default message variables to use in the notification message. You can override the default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The amount of time, in seconds, that FCM should store and attempt to deliver the push notification, if the service is unable to deliver the notification the first time. If you don't specify this value, FCM defaults to the maximum value, which is 2,419,200 seconds (28 days).</p> <p>Amazon Pinpoint specifies this value in the FCM time_to_live parameter when it sends the notification message to FCM.</p>
    public let timeToLive: Int
    /// <p>The title to display above the notification message on the recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in the recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        collapseKey: String? = nil,
        data: [String:String]? = nil,
        iconReference: String? = nil,
        imageIconUrl: String? = nil,
        imageUrl: String? = nil,
        priority: String? = nil,
        rawContent: String? = nil,
        restrictedPackageName: String? = nil,
        silentPush: Bool = false,
        smallImageIconUrl: String? = nil,
        sound: String? = nil,
        substitutions: [String:[String]]? = nil,
        timeToLive: Int = 0,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.collapseKey = collapseKey
        self.data = data
        self.iconReference = iconReference
        self.imageIconUrl = imageIconUrl
        self.imageUrl = imageUrl
        self.priority = priority
        self.rawContent = rawContent
        self.restrictedPackageName = restrictedPackageName
        self.silentPush = silentPush
        self.smallImageIconUrl = smallImageIconUrl
        self.sound = sound
        self.substitutions = substitutions
        self.timeToLive = timeToLive
        self.title = title
        self.url = url
    }
}

extension GPSCoordinates: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latitude = "Latitude"
        case longitude = "Longitude"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if latitude != 0.0 {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if longitude != 0.0 {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latitudeDecoded = try containerValues.decode(Double.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decode(Double.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension GPSCoordinates: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GPSCoordinates(latitude: \(String(describing: latitude)), longitude: \(String(describing: longitude)))"}
}

/// <p>Specifies the GPS coordinates of a location.</p>
public struct GPSCoordinates: Equatable {
    /// <p>The latitude coordinate of the location.</p>
    public let latitude: Double
    /// <p>The longitude coordinate of the location.</p>
    public let longitude: Double

    public init (
        latitude: Double = 0.0,
        longitude: Double = 0.0
    )
    {
        self.latitude = latitude
        self.longitude = longitude
    }
}

extension GPSPointDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case coordinates = "Coordinates"
        case rangeInKilometers = "RangeInKilometers"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coordinates = coordinates {
            try encodeContainer.encode(coordinates, forKey: .coordinates)
        }
        if rangeInKilometers != 0.0 {
            try encodeContainer.encode(rangeInKilometers, forKey: .rangeInKilometers)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coordinatesDecoded = try containerValues.decodeIfPresent(GPSCoordinates.self, forKey: .coordinates)
        coordinates = coordinatesDecoded
        let rangeInKilometersDecoded = try containerValues.decode(Double.self, forKey: .rangeInKilometers)
        rangeInKilometers = rangeInKilometersDecoded
    }
}

extension GPSPointDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GPSPointDimension(coordinates: \(String(describing: coordinates)), rangeInKilometers: \(String(describing: rangeInKilometers)))"}
}

/// <p>Specifies GPS-based criteria for including or excluding endpoints from a segment.</p>
public struct GPSPointDimension: Equatable {
    /// <p>The GPS coordinates to measure distance from.</p>
    public let coordinates: GPSCoordinates?
    /// <p>The range, in kilometers, from the GPS coordinates.</p>
    public let rangeInKilometers: Double

    public init (
        coordinates: GPSCoordinates? = nil,
        rangeInKilometers: Double = 0.0
    )
    {
        self.coordinates = coordinates
        self.rangeInKilometers = rangeInKilometers
    }
}

extension GetAdmChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdmChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetAdmChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAdmChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetAdmChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdmChannelInput>
    public typealias MOutput = OperationOutput<GetAdmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdmChannelOutputError>
}

public struct GetAdmChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAdmChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAdmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAdmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAdmChannelInput>
    public typealias MOutput = OperationOutput<GetAdmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAdmChannelOutputError>
}

public struct GetAdmChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetAdmChannelInputBody: Equatable {
}

extension GetAdmChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAdmChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdmChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAdmChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdmChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAdmChannelOutputResponse(aDMChannelResponse: \(String(describing: aDMChannelResponse)))"}
}

extension GetAdmChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ADMChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aDMChannelResponse = output
            } else {
                self.aDMChannelResponse = nil
            }
        } else {
            self.aDMChannelResponse = nil
        }
    }
}

public struct GetAdmChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
    public let aDMChannelResponse: ADMChannelResponse?

    public init (
        aDMChannelResponse: ADMChannelResponse? = nil
    )
    {
        self.aDMChannelResponse = aDMChannelResponse
    }
}

struct GetAdmChannelOutputResponseBody: Equatable {
    public let aDMChannelResponse: ADMChannelResponse?
}

extension GetAdmChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aDMChannelResponse = "ADMChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMChannelResponseDecoded = try containerValues.decodeIfPresent(ADMChannelResponse.self, forKey: .aDMChannelResponse)
        aDMChannelResponse = aDMChannelResponseDecoded
    }
}

extension GetApnsChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetApnsChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApnsChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetApnsChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsChannelInput>
    public typealias MOutput = OperationOutput<GetApnsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsChannelOutputError>
}

public struct GetApnsChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApnsChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsChannelInput>
    public typealias MOutput = OperationOutput<GetApnsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsChannelOutputError>
}

public struct GetApnsChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApnsChannelInputBody: Equatable {
}

extension GetApnsChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApnsChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApnsChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApnsChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApnsChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsChannelOutputResponse(aPNSChannelResponse: \(String(describing: aPNSChannelResponse)))"}
}

extension GetApnsChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSChannelResponse = output
            } else {
                self.aPNSChannelResponse = nil
            }
        } else {
            self.aPNSChannelResponse = nil
        }
    }
}

public struct GetApnsChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
    public let aPNSChannelResponse: APNSChannelResponse?

    public init (
        aPNSChannelResponse: APNSChannelResponse? = nil
    )
    {
        self.aPNSChannelResponse = aPNSChannelResponse
    }
}

struct GetApnsChannelOutputResponseBody: Equatable {
    public let aPNSChannelResponse: APNSChannelResponse?
}

extension GetApnsChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSChannelResponse = "APNSChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSChannelResponseDecoded = try containerValues.decodeIfPresent(APNSChannelResponse.self, forKey: .aPNSChannelResponse)
        aPNSChannelResponse = aPNSChannelResponseDecoded
    }
}

extension GetApnsSandboxChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsSandboxChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetApnsSandboxChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApnsSandboxChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetApnsSandboxChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsSandboxChannelInput>
    public typealias MOutput = OperationOutput<GetApnsSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsSandboxChannelOutputError>
}

public struct GetApnsSandboxChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApnsSandboxChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsSandboxChannelInput>
    public typealias MOutput = OperationOutput<GetApnsSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsSandboxChannelOutputError>
}

public struct GetApnsSandboxChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApnsSandboxChannelInputBody: Equatable {
}

extension GetApnsSandboxChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApnsSandboxChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApnsSandboxChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApnsSandboxChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApnsSandboxChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsSandboxChannelOutputResponse(aPNSSandboxChannelResponse: \(String(describing: aPNSSandboxChannelResponse)))"}
}

extension GetApnsSandboxChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSSandboxChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSSandboxChannelResponse = output
            } else {
                self.aPNSSandboxChannelResponse = nil
            }
        } else {
            self.aPNSSandboxChannelResponse = nil
        }
    }
}

public struct GetApnsSandboxChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
    public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse?

    public init (
        aPNSSandboxChannelResponse: APNSSandboxChannelResponse? = nil
    )
    {
        self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
    }
}

struct GetApnsSandboxChannelOutputResponseBody: Equatable {
    public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse?
}

extension GetApnsSandboxChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSSandboxChannelResponseDecoded = try containerValues.decodeIfPresent(APNSSandboxChannelResponse.self, forKey: .aPNSSandboxChannelResponse)
        aPNSSandboxChannelResponse = aPNSSandboxChannelResponseDecoded
    }
}

extension GetApnsVoipChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsVoipChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetApnsVoipChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApnsVoipChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetApnsVoipChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsVoipChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsVoipChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsVoipChannelInput>
    public typealias MOutput = OperationOutput<GetApnsVoipChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsVoipChannelOutputError>
}

public struct GetApnsVoipChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApnsVoipChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsVoipChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsVoipChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsVoipChannelInput>
    public typealias MOutput = OperationOutput<GetApnsVoipChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsVoipChannelOutputError>
}

public struct GetApnsVoipChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApnsVoipChannelInputBody: Equatable {
}

extension GetApnsVoipChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApnsVoipChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApnsVoipChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApnsVoipChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApnsVoipChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsVoipChannelOutputResponse(aPNSVoipChannelResponse: \(String(describing: aPNSVoipChannelResponse)))"}
}

extension GetApnsVoipChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSVoipChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSVoipChannelResponse = output
            } else {
                self.aPNSVoipChannelResponse = nil
            }
        } else {
            self.aPNSVoipChannelResponse = nil
        }
    }
}

public struct GetApnsVoipChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
    public let aPNSVoipChannelResponse: APNSVoipChannelResponse?

    public init (
        aPNSVoipChannelResponse: APNSVoipChannelResponse? = nil
    )
    {
        self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
    }
}

struct GetApnsVoipChannelOutputResponseBody: Equatable {
    public let aPNSVoipChannelResponse: APNSVoipChannelResponse?
}

extension GetApnsVoipChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipChannelResponseDecoded = try containerValues.decodeIfPresent(APNSVoipChannelResponse.self, forKey: .aPNSVoipChannelResponse)
        aPNSVoipChannelResponse = aPNSVoipChannelResponseDecoded
    }
}

extension GetApnsVoipSandboxChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsVoipSandboxChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetApnsVoipSandboxChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApnsVoipSandboxChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetApnsVoipSandboxChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsVoipSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsVoipSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsVoipSandboxChannelInput>
    public typealias MOutput = OperationOutput<GetApnsVoipSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsVoipSandboxChannelOutputError>
}

public struct GetApnsVoipSandboxChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApnsVoipSandboxChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApnsVoipSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApnsVoipSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApnsVoipSandboxChannelInput>
    public typealias MOutput = OperationOutput<GetApnsVoipSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApnsVoipSandboxChannelOutputError>
}

public struct GetApnsVoipSandboxChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApnsVoipSandboxChannelInputBody: Equatable {
}

extension GetApnsVoipSandboxChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApnsVoipSandboxChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApnsVoipSandboxChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApnsVoipSandboxChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApnsVoipSandboxChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApnsVoipSandboxChannelOutputResponse(aPNSVoipSandboxChannelResponse: \(String(describing: aPNSVoipSandboxChannelResponse)))"}
}

extension GetApnsVoipSandboxChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSVoipSandboxChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSVoipSandboxChannelResponse = output
            } else {
                self.aPNSVoipSandboxChannelResponse = nil
            }
        } else {
            self.aPNSVoipSandboxChannelResponse = nil
        }
    }
}

public struct GetApnsVoipSandboxChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
    public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse?

    public init (
        aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse? = nil
    )
    {
        self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
    }
}

struct GetApnsVoipSandboxChannelOutputResponseBody: Equatable {
    public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse?
}

extension GetApnsVoipSandboxChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipSandboxChannelResponseDecoded = try containerValues.decodeIfPresent(APNSVoipSandboxChannelResponse.self, forKey: .aPNSVoipSandboxChannelResponse)
        aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponseDecoded
    }
}

extension GetAppInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetAppInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAppInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppInput>
    public typealias MOutput = OperationOutput<GetAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppOutputError>
}

public struct GetAppInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppInput>
    public typealias MOutput = OperationOutput<GetAppOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppOutputError>
}

public struct GetAppInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetAppInputBody: Equatable {
}

extension GetAppInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAppOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppOutputResponse(applicationResponse: \(String(describing: applicationResponse)))"}
}

extension GetAppOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ApplicationResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.applicationResponse = output
            } else {
                self.applicationResponse = nil
            }
        } else {
            self.applicationResponse = nil
        }
    }
}

public struct GetAppOutputResponse: Equatable {
    /// <p>Provides information about an application.</p>
    public let applicationResponse: ApplicationResponse?

    public init (
        applicationResponse: ApplicationResponse? = nil
    )
    {
        self.applicationResponse = applicationResponse
    }
}

struct GetAppOutputResponseBody: Equatable {
    public let applicationResponse: ApplicationResponse?
}

extension GetAppOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationResponse = "ApplicationResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationResponseDecoded = try containerValues.decodeIfPresent(ApplicationResponse.self, forKey: .applicationResponse)
        applicationResponse = applicationResponseDecoded
    }
}

extension GetApplicationDateRangeKpiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationDateRangeKpiInput(applicationId: \(String(describing: applicationId)), endTime: \(String(describing: endTime)), kpiName: \(String(describing: kpiName)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), startTime: \(String(describing: startTime)))"}
}

extension GetApplicationDateRangeKpiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApplicationDateRangeKpiInputHeadersMiddleware: Middleware {
    public let id: String = "GetApplicationDateRangeKpiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationDateRangeKpiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationDateRangeKpiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationDateRangeKpiInput>
    public typealias MOutput = OperationOutput<GetApplicationDateRangeKpiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationDateRangeKpiOutputError>
}

public struct GetApplicationDateRangeKpiInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApplicationDateRangeKpiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationDateRangeKpiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationDateRangeKpiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "end-time".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "start-time".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationDateRangeKpiInput>
    public typealias MOutput = OperationOutput<GetApplicationDateRangeKpiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationDateRangeKpiOutputError>
}

public struct GetApplicationDateRangeKpiInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The last date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-26T20:00:00Z for 8:00 PM UTC July 26, 2019.</p>
    public let endTime: Date?
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, to retrieve data for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. Examples are email-open-rate and successful-delivery-rate. For a list of valid values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let kpiName: String?
    /// <p>The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let nextToken: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The first date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-19T20:00:00Z for 8:00 PM UTC July 19, 2019. This value should also be fewer than 90 days from the current day.</p>
    public let startTime: Date?

    public init (
        applicationId: String? = nil,
        endTime: Date? = nil,
        kpiName: String? = nil,
        nextToken: String? = nil,
        pageSize: String? = nil,
        startTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.endTime = endTime
        self.kpiName = kpiName
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startTime = startTime
    }
}

struct GetApplicationDateRangeKpiInputBody: Equatable {
}

extension GetApplicationDateRangeKpiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApplicationDateRangeKpiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationDateRangeKpiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationDateRangeKpiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationDateRangeKpiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationDateRangeKpiOutputResponse(applicationDateRangeKpiResponse: \(String(describing: applicationDateRangeKpiResponse)))"}
}

extension GetApplicationDateRangeKpiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ApplicationDateRangeKpiResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.applicationDateRangeKpiResponse = output
            } else {
                self.applicationDateRangeKpiResponse = nil
            }
        } else {
            self.applicationDateRangeKpiResponse = nil
        }
    }
}

public struct GetApplicationDateRangeKpiOutputResponse: Equatable {
    /// <p>Provides the results of a query that retrieved the data for a standard metric that applies to an application, and provides information about that query.</p>
    public let applicationDateRangeKpiResponse: ApplicationDateRangeKpiResponse?

    public init (
        applicationDateRangeKpiResponse: ApplicationDateRangeKpiResponse? = nil
    )
    {
        self.applicationDateRangeKpiResponse = applicationDateRangeKpiResponse
    }
}

struct GetApplicationDateRangeKpiOutputResponseBody: Equatable {
    public let applicationDateRangeKpiResponse: ApplicationDateRangeKpiResponse?
}

extension GetApplicationDateRangeKpiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationDateRangeKpiResponse = "ApplicationDateRangeKpiResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationDateRangeKpiResponseDecoded = try containerValues.decodeIfPresent(ApplicationDateRangeKpiResponse.self, forKey: .applicationDateRangeKpiResponse)
        applicationDateRangeKpiResponse = applicationDateRangeKpiResponseDecoded
    }
}

extension GetApplicationSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationSettingsInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetApplicationSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetApplicationSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetApplicationSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationSettingsInput>
    public typealias MOutput = OperationOutput<GetApplicationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationSettingsOutputError>
}

public struct GetApplicationSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetApplicationSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetApplicationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetApplicationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetApplicationSettingsInput>
    public typealias MOutput = OperationOutput<GetApplicationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetApplicationSettingsOutputError>
}

public struct GetApplicationSettingsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetApplicationSettingsInputBody: Equatable {
}

extension GetApplicationSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetApplicationSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetApplicationSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetApplicationSettingsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetApplicationSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetApplicationSettingsOutputResponse(applicationSettingsResource: \(String(describing: applicationSettingsResource)))"}
}

extension GetApplicationSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ApplicationSettingsResource = try responseDecoder.decode(responseBody: unwrappedData)
                self.applicationSettingsResource = output
            } else {
                self.applicationSettingsResource = nil
            }
        } else {
            self.applicationSettingsResource = nil
        }
    }
}

public struct GetApplicationSettingsOutputResponse: Equatable {
    /// <p>Provides information about an application, including the default settings for an application.</p>
    public let applicationSettingsResource: ApplicationSettingsResource?

    public init (
        applicationSettingsResource: ApplicationSettingsResource? = nil
    )
    {
        self.applicationSettingsResource = applicationSettingsResource
    }
}

struct GetApplicationSettingsOutputResponseBody: Equatable {
    public let applicationSettingsResource: ApplicationSettingsResource?
}

extension GetApplicationSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSettingsResource = "ApplicationSettingsResource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSettingsResourceDecoded = try containerValues.decodeIfPresent(ApplicationSettingsResource.self, forKey: .applicationSettingsResource)
        applicationSettingsResource = applicationSettingsResourceDecoded
    }
}

extension GetAppsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppsInput(pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetAppsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAppsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAppsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppsInput>
    public typealias MOutput = OperationOutput<GetAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppsOutputError>
}

public struct GetAppsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAppsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAppsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAppsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAppsInput>
    public typealias MOutput = OperationOutput<GetAppsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAppsOutputError>
}

public struct GetAppsInput: Equatable {
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetAppsInputBody: Equatable {
}

extension GetAppsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAppsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAppsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAppsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAppsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAppsOutputResponse(applicationsResponse: \(String(describing: applicationsResponse)))"}
}

extension GetAppsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ApplicationsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.applicationsResponse = output
            } else {
                self.applicationsResponse = nil
            }
        } else {
            self.applicationsResponse = nil
        }
    }
}

public struct GetAppsOutputResponse: Equatable {
    /// <p>Provides information about all of your applications.</p>
    public let applicationsResponse: ApplicationsResponse?

    public init (
        applicationsResponse: ApplicationsResponse? = nil
    )
    {
        self.applicationsResponse = applicationsResponse
    }
}

struct GetAppsOutputResponseBody: Equatable {
    public let applicationsResponse: ApplicationsResponse?
}

extension GetAppsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationsResponse = "ApplicationsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsResponseDecoded = try containerValues.decodeIfPresent(ApplicationsResponse.self, forKey: .applicationsResponse)
        applicationsResponse = applicationsResponseDecoded
    }
}

extension GetBaiduChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBaiduChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetBaiduChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetBaiduChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetBaiduChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBaiduChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBaiduChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBaiduChannelInput>
    public typealias MOutput = OperationOutput<GetBaiduChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBaiduChannelOutputError>
}

public struct GetBaiduChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetBaiduChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetBaiduChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetBaiduChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetBaiduChannelInput>
    public typealias MOutput = OperationOutput<GetBaiduChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetBaiduChannelOutputError>
}

public struct GetBaiduChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetBaiduChannelInputBody: Equatable {
}

extension GetBaiduChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetBaiduChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetBaiduChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetBaiduChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetBaiduChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetBaiduChannelOutputResponse(baiduChannelResponse: \(String(describing: baiduChannelResponse)))"}
}

extension GetBaiduChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: BaiduChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.baiduChannelResponse = output
            } else {
                self.baiduChannelResponse = nil
            }
        } else {
            self.baiduChannelResponse = nil
        }
    }
}

public struct GetBaiduChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
    public let baiduChannelResponse: BaiduChannelResponse?

    public init (
        baiduChannelResponse: BaiduChannelResponse? = nil
    )
    {
        self.baiduChannelResponse = baiduChannelResponse
    }
}

struct GetBaiduChannelOutputResponseBody: Equatable {
    public let baiduChannelResponse: BaiduChannelResponse?
}

extension GetBaiduChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baiduChannelResponse = "BaiduChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baiduChannelResponseDecoded = try containerValues.decodeIfPresent(BaiduChannelResponse.self, forKey: .baiduChannelResponse)
        baiduChannelResponse = baiduChannelResponseDecoded
    }
}

extension GetCampaignActivitiesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignActivitiesInput(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)), pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetCampaignActivitiesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCampaignActivitiesInputHeadersMiddleware: Middleware {
    public let id: String = "GetCampaignActivitiesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignActivitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignActivitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignActivitiesInput>
    public typealias MOutput = OperationOutput<GetCampaignActivitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignActivitiesOutputError>
}

public struct GetCampaignActivitiesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCampaignActivitiesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignActivitiesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignActivitiesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignActivitiesInput>
    public typealias MOutput = OperationOutput<GetCampaignActivitiesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignActivitiesOutputError>
}

public struct GetCampaignActivitiesInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign.</p>
    public let campaignId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil,
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetCampaignActivitiesInputBody: Equatable {
}

extension GetCampaignActivitiesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCampaignActivitiesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCampaignActivitiesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCampaignActivitiesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCampaignActivitiesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignActivitiesOutputResponse(activitiesResponse: \(String(describing: activitiesResponse)))"}
}

extension GetCampaignActivitiesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ActivitiesResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.activitiesResponse = output
            } else {
                self.activitiesResponse = nil
            }
        } else {
            self.activitiesResponse = nil
        }
    }
}

public struct GetCampaignActivitiesOutputResponse: Equatable {
    /// <p>Provides information about the activities that were performed by a campaign.</p>
    public let activitiesResponse: ActivitiesResponse?

    public init (
        activitiesResponse: ActivitiesResponse? = nil
    )
    {
        self.activitiesResponse = activitiesResponse
    }
}

struct GetCampaignActivitiesOutputResponseBody: Equatable {
    public let activitiesResponse: ActivitiesResponse?
}

extension GetCampaignActivitiesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case activitiesResponse = "ActivitiesResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activitiesResponseDecoded = try containerValues.decodeIfPresent(ActivitiesResponse.self, forKey: .activitiesResponse)
        activitiesResponse = activitiesResponseDecoded
    }
}

extension GetCampaignDateRangeKpiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignDateRangeKpiInput(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)), endTime: \(String(describing: endTime)), kpiName: \(String(describing: kpiName)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), startTime: \(String(describing: startTime)))"}
}

extension GetCampaignDateRangeKpiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCampaignDateRangeKpiInputHeadersMiddleware: Middleware {
    public let id: String = "GetCampaignDateRangeKpiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignDateRangeKpiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignDateRangeKpiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignDateRangeKpiInput>
    public typealias MOutput = OperationOutput<GetCampaignDateRangeKpiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignDateRangeKpiOutputError>
}

public struct GetCampaignDateRangeKpiInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCampaignDateRangeKpiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignDateRangeKpiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignDateRangeKpiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "end-time".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "start-time".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignDateRangeKpiInput>
    public typealias MOutput = OperationOutput<GetCampaignDateRangeKpiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignDateRangeKpiOutputError>
}

public struct GetCampaignDateRangeKpiInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign.</p>
    public let campaignId: String?
    /// <p>The last date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-26T20:00:00Z for 8:00 PM UTC July 26, 2019.</p>
    public let endTime: Date?
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, to retrieve data for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. Examples are email-open-rate and successful-delivery-rate. For a list of valid values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let kpiName: String?
    /// <p>The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let nextToken: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The first date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-19T20:00:00Z for 8:00 PM UTC July 19, 2019. This value should also be fewer than 90 days from the current day.</p>
    public let startTime: Date?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil,
        endTime: Date? = nil,
        kpiName: String? = nil,
        nextToken: String? = nil,
        pageSize: String? = nil,
        startTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.endTime = endTime
        self.kpiName = kpiName
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startTime = startTime
    }
}

struct GetCampaignDateRangeKpiInputBody: Equatable {
}

extension GetCampaignDateRangeKpiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCampaignDateRangeKpiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCampaignDateRangeKpiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCampaignDateRangeKpiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCampaignDateRangeKpiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignDateRangeKpiOutputResponse(campaignDateRangeKpiResponse: \(String(describing: campaignDateRangeKpiResponse)))"}
}

extension GetCampaignDateRangeKpiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignDateRangeKpiResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignDateRangeKpiResponse = output
            } else {
                self.campaignDateRangeKpiResponse = nil
            }
        } else {
            self.campaignDateRangeKpiResponse = nil
        }
    }
}

public struct GetCampaignDateRangeKpiOutputResponse: Equatable {
    /// <p>Provides the results of a query that retrieved the data for a standard metric that applies to a campaign, and provides information about that query.</p>
    public let campaignDateRangeKpiResponse: CampaignDateRangeKpiResponse?

    public init (
        campaignDateRangeKpiResponse: CampaignDateRangeKpiResponse? = nil
    )
    {
        self.campaignDateRangeKpiResponse = campaignDateRangeKpiResponse
    }
}

struct GetCampaignDateRangeKpiOutputResponseBody: Equatable {
    public let campaignDateRangeKpiResponse: CampaignDateRangeKpiResponse?
}

extension GetCampaignDateRangeKpiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignDateRangeKpiResponse = "CampaignDateRangeKpiResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignDateRangeKpiResponseDecoded = try containerValues.decodeIfPresent(CampaignDateRangeKpiResponse.self, forKey: .campaignDateRangeKpiResponse)
        campaignDateRangeKpiResponse = campaignDateRangeKpiResponseDecoded
    }
}

extension GetCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignInput(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)))"}
}

extension GetCampaignInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "GetCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignInput>
    public typealias MOutput = OperationOutput<GetCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignOutputError>
}

public struct GetCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignInput>
    public typealias MOutput = OperationOutput<GetCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignOutputError>
}

public struct GetCampaignInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign.</p>
    public let campaignId: String?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
    }
}

struct GetCampaignInputBody: Equatable {
}

extension GetCampaignInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCampaignOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignOutputResponse(campaignResponse: \(String(describing: campaignResponse)))"}
}

extension GetCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignResponse = output
            } else {
                self.campaignResponse = nil
            }
        } else {
            self.campaignResponse = nil
        }
    }
}

public struct GetCampaignOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
    public let campaignResponse: CampaignResponse?

    public init (
        campaignResponse: CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

struct GetCampaignOutputResponseBody: Equatable {
    public let campaignResponse: CampaignResponse?
}

extension GetCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignResponse = "CampaignResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignResponseDecoded = try containerValues.decodeIfPresent(CampaignResponse.self, forKey: .campaignResponse)
        campaignResponse = campaignResponseDecoded
    }
}

extension GetCampaignVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignVersionInput(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)), version: \(String(describing: version)))"}
}

extension GetCampaignVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCampaignVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetCampaignVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignVersionInput>
    public typealias MOutput = OperationOutput<GetCampaignVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignVersionOutputError>
}

public struct GetCampaignVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCampaignVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignVersionInput>
    public typealias MOutput = OperationOutput<GetCampaignVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignVersionOutputError>
}

public struct GetCampaignVersionInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign.</p>
    public let campaignId: String?
    /// <p>The unique version number (Version property) for the campaign version.</p>
    public let version: String?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil,
        version: String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.version = version
    }
}

struct GetCampaignVersionInputBody: Equatable {
}

extension GetCampaignVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCampaignVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCampaignVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCampaignVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCampaignVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignVersionOutputResponse(campaignResponse: \(String(describing: campaignResponse)))"}
}

extension GetCampaignVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignResponse = output
            } else {
                self.campaignResponse = nil
            }
        } else {
            self.campaignResponse = nil
        }
    }
}

public struct GetCampaignVersionOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
    public let campaignResponse: CampaignResponse?

    public init (
        campaignResponse: CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

struct GetCampaignVersionOutputResponseBody: Equatable {
    public let campaignResponse: CampaignResponse?
}

extension GetCampaignVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignResponse = "CampaignResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignResponseDecoded = try containerValues.decodeIfPresent(CampaignResponse.self, forKey: .campaignResponse)
        campaignResponse = campaignResponseDecoded
    }
}

extension GetCampaignVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignVersionsInput(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)), pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetCampaignVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCampaignVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCampaignVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignVersionsInput>
    public typealias MOutput = OperationOutput<GetCampaignVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignVersionsOutputError>
}

public struct GetCampaignVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCampaignVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignVersionsInput>
    public typealias MOutput = OperationOutput<GetCampaignVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignVersionsOutputError>
}

public struct GetCampaignVersionsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign.</p>
    public let campaignId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil,
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetCampaignVersionsInputBody: Equatable {
}

extension GetCampaignVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCampaignVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCampaignVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCampaignVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCampaignVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignVersionsOutputResponse(campaignsResponse: \(String(describing: campaignsResponse)))"}
}

extension GetCampaignVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignsResponse = output
            } else {
                self.campaignsResponse = nil
            }
        } else {
            self.campaignsResponse = nil
        }
    }
}

public struct GetCampaignVersionsOutputResponse: Equatable {
    /// <p>Provides information about the configuration and other settings for all the campaigns that are associated with an application.</p>
    public let campaignsResponse: CampaignsResponse?

    public init (
        campaignsResponse: CampaignsResponse? = nil
    )
    {
        self.campaignsResponse = campaignsResponse
    }
}

struct GetCampaignVersionsOutputResponseBody: Equatable {
    public let campaignsResponse: CampaignsResponse?
}

extension GetCampaignVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignsResponse = "CampaignsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsResponseDecoded = try containerValues.decodeIfPresent(CampaignsResponse.self, forKey: .campaignsResponse)
        campaignsResponse = campaignsResponseDecoded
    }
}

extension GetCampaignsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignsInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetCampaignsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCampaignsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCampaignsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignsInput>
    public typealias MOutput = OperationOutput<GetCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignsOutputError>
}

public struct GetCampaignsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCampaignsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCampaignsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCampaignsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCampaignsInput>
    public typealias MOutput = OperationOutput<GetCampaignsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCampaignsOutputError>
}

public struct GetCampaignsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetCampaignsInputBody: Equatable {
}

extension GetCampaignsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCampaignsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCampaignsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCampaignsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCampaignsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCampaignsOutputResponse(campaignsResponse: \(String(describing: campaignsResponse)))"}
}

extension GetCampaignsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignsResponse = output
            } else {
                self.campaignsResponse = nil
            }
        } else {
            self.campaignsResponse = nil
        }
    }
}

public struct GetCampaignsOutputResponse: Equatable {
    /// <p>Provides information about the configuration and other settings for all the campaigns that are associated with an application.</p>
    public let campaignsResponse: CampaignsResponse?

    public init (
        campaignsResponse: CampaignsResponse? = nil
    )
    {
        self.campaignsResponse = campaignsResponse
    }
}

struct GetCampaignsOutputResponseBody: Equatable {
    public let campaignsResponse: CampaignsResponse?
}

extension GetCampaignsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignsResponse = "CampaignsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignsResponseDecoded = try containerValues.decodeIfPresent(CampaignsResponse.self, forKey: .campaignsResponse)
        campaignsResponse = campaignsResponseDecoded
    }
}

extension GetChannelsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelsInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetChannelsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetChannelsInputHeadersMiddleware: Middleware {
    public let id: String = "GetChannelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelsInput>
    public typealias MOutput = OperationOutput<GetChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelsOutputError>
}

public struct GetChannelsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetChannelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetChannelsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetChannelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetChannelsInput>
    public typealias MOutput = OperationOutput<GetChannelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetChannelsOutputError>
}

public struct GetChannelsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetChannelsInputBody: Equatable {
}

extension GetChannelsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetChannelsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetChannelsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetChannelsOutputResponse(channelsResponse: \(String(describing: channelsResponse)))"}
}

extension GetChannelsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ChannelsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.channelsResponse = output
            } else {
                self.channelsResponse = nil
            }
        } else {
            self.channelsResponse = nil
        }
    }
}

public struct GetChannelsOutputResponse: Equatable {
    /// <p>Provides information about the general settings and status of all channels for an application, including channels that aren't enabled for the application.</p>
    public let channelsResponse: ChannelsResponse?

    public init (
        channelsResponse: ChannelsResponse? = nil
    )
    {
        self.channelsResponse = channelsResponse
    }
}

struct GetChannelsOutputResponseBody: Equatable {
    public let channelsResponse: ChannelsResponse?
}

extension GetChannelsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case channelsResponse = "ChannelsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsResponseDecoded = try containerValues.decodeIfPresent(ChannelsResponse.self, forKey: .channelsResponse)
        channelsResponse = channelsResponseDecoded
    }
}

extension GetEmailChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetEmailChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEmailChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetEmailChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailChannelInput>
    public typealias MOutput = OperationOutput<GetEmailChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailChannelOutputError>
}

public struct GetEmailChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEmailChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailChannelInput>
    public typealias MOutput = OperationOutput<GetEmailChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailChannelOutputError>
}

public struct GetEmailChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetEmailChannelInputBody: Equatable {
}

extension GetEmailChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEmailChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEmailChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEmailChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEmailChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailChannelOutputResponse(emailChannelResponse: \(String(describing: emailChannelResponse)))"}
}

extension GetEmailChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EmailChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.emailChannelResponse = output
            } else {
                self.emailChannelResponse = nil
            }
        } else {
            self.emailChannelResponse = nil
        }
    }
}

public struct GetEmailChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the email channel for an application.</p>
    public let emailChannelResponse: EmailChannelResponse?

    public init (
        emailChannelResponse: EmailChannelResponse? = nil
    )
    {
        self.emailChannelResponse = emailChannelResponse
    }
}

struct GetEmailChannelOutputResponseBody: Equatable {
    public let emailChannelResponse: EmailChannelResponse?
}

extension GetEmailChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailChannelResponse = "EmailChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailChannelResponseDecoded = try containerValues.decodeIfPresent(EmailChannelResponse.self, forKey: .emailChannelResponse)
        emailChannelResponse = emailChannelResponseDecoded
    }
}

extension GetEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension GetEmailTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailTemplateOutputError>
}

public struct GetEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEmailTemplateInput>
    public typealias MOutput = OperationOutput<GetEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEmailTemplateOutputError>
}

public struct GetEmailTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct GetEmailTemplateInputBody: Equatable {
}

extension GetEmailTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEmailTemplateOutputResponse(emailTemplateResponse: \(String(describing: emailTemplateResponse)))"}
}

extension GetEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EmailTemplateResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.emailTemplateResponse = output
            } else {
                self.emailTemplateResponse = nil
            }
        } else {
            self.emailTemplateResponse = nil
        }
    }
}

public struct GetEmailTemplateOutputResponse: Equatable {
    /// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through the email channel.</p>
    public let emailTemplateResponse: EmailTemplateResponse?

    public init (
        emailTemplateResponse: EmailTemplateResponse? = nil
    )
    {
        self.emailTemplateResponse = emailTemplateResponse
    }
}

struct GetEmailTemplateOutputResponseBody: Equatable {
    public let emailTemplateResponse: EmailTemplateResponse?
}

extension GetEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailTemplateResponse = "EmailTemplateResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailTemplateResponseDecoded = try containerValues.decodeIfPresent(EmailTemplateResponse.self, forKey: .emailTemplateResponse)
        emailTemplateResponse = emailTemplateResponseDecoded
    }
}

extension GetEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEndpointInput(applicationId: \(String(describing: applicationId)), endpointId: \(String(describing: endpointId)))"}
}

extension GetEndpointInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "GetEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEndpointInput>
    public typealias MOutput = OperationOutput<GetEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEndpointOutputError>
}

public struct GetEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEndpointInput>
    public typealias MOutput = OperationOutput<GetEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEndpointOutputError>
}

public struct GetEndpointInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the endpoint.</p>
    public let endpointId: String?

    public init (
        applicationId: String? = nil,
        endpointId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointId = endpointId
    }
}

struct GetEndpointInputBody: Equatable {
}

extension GetEndpointInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEndpointOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEndpointOutputResponse(endpointResponse: \(String(describing: endpointResponse)))"}
}

extension GetEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EndpointResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.endpointResponse = output
            } else {
                self.endpointResponse = nil
            }
        } else {
            self.endpointResponse = nil
        }
    }
}

public struct GetEndpointOutputResponse: Equatable {
    /// <p>Provides information about the channel type and other settings for an endpoint.</p>
    public let endpointResponse: EndpointResponse?

    public init (
        endpointResponse: EndpointResponse? = nil
    )
    {
        self.endpointResponse = endpointResponse
    }
}

struct GetEndpointOutputResponseBody: Equatable {
    public let endpointResponse: EndpointResponse?
}

extension GetEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointResponse = "EndpointResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointResponseDecoded = try containerValues.decodeIfPresent(EndpointResponse.self, forKey: .endpointResponse)
        endpointResponse = endpointResponseDecoded
    }
}

extension GetEventStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventStreamInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetEventStreamInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEventStreamInputHeadersMiddleware: Middleware {
    public let id: String = "GetEventStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventStreamInput>
    public typealias MOutput = OperationOutput<GetEventStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventStreamOutputError>
}

public struct GetEventStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEventStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventStreamInput>
    public typealias MOutput = OperationOutput<GetEventStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventStreamOutputError>
}

public struct GetEventStreamInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetEventStreamInputBody: Equatable {
}

extension GetEventStreamInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEventStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventStreamOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventStreamOutputResponse(eventStream: \(String(describing: eventStream)))"}
}

extension GetEventStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EventStream = try responseDecoder.decode(responseBody: unwrappedData)
                self.eventStream = output
            } else {
                self.eventStream = nil
            }
        } else {
            self.eventStream = nil
        }
    }
}

public struct GetEventStreamOutputResponse: Equatable {
    /// <p>Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.</p>
    public let eventStream: EventStream?

    public init (
        eventStream: EventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

struct GetEventStreamOutputResponseBody: Equatable {
    public let eventStream: EventStream?
}

extension GetEventStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventStream = "EventStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventStreamDecoded = try containerValues.decodeIfPresent(EventStream.self, forKey: .eventStream)
        eventStream = eventStreamDecoded
    }
}

extension GetExportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExportJobInput(applicationId: \(String(describing: applicationId)), jobId: \(String(describing: jobId)))"}
}

extension GetExportJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetExportJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetExportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExportJobInput>
    public typealias MOutput = OperationOutput<GetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExportJobOutputError>
}

public struct GetExportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExportJobInput>
    public typealias MOutput = OperationOutput<GetExportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExportJobOutputError>
}

public struct GetExportJobInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the job.</p>
    public let jobId: String?

    public init (
        applicationId: String? = nil,
        jobId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobId = jobId
    }
}

struct GetExportJobInputBody: Equatable {
}

extension GetExportJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetExportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExportJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExportJobOutputResponse(exportJobResponse: \(String(describing: exportJobResponse)))"}
}

extension GetExportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ExportJobResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.exportJobResponse = output
            } else {
                self.exportJobResponse = nil
            }
        } else {
            self.exportJobResponse = nil
        }
    }
}

public struct GetExportJobOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of a job that exports endpoint definitions to a file. The file can be added directly to an Amazon Simple Storage Service (Amazon S3) bucket by using the Amazon Pinpoint API or downloaded directly to a computer by using the Amazon Pinpoint console.</p>
    public let exportJobResponse: ExportJobResponse?

    public init (
        exportJobResponse: ExportJobResponse? = nil
    )
    {
        self.exportJobResponse = exportJobResponse
    }
}

struct GetExportJobOutputResponseBody: Equatable {
    public let exportJobResponse: ExportJobResponse?
}

extension GetExportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportJobResponse = "ExportJobResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobResponseDecoded = try containerValues.decodeIfPresent(ExportJobResponse.self, forKey: .exportJobResponse)
        exportJobResponse = exportJobResponseDecoded
    }
}

extension GetExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExportJobsInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetExportJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "GetExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExportJobsInput>
    public typealias MOutput = OperationOutput<GetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExportJobsOutputError>
}

public struct GetExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExportJobsInput>
    public typealias MOutput = OperationOutput<GetExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExportJobsOutputError>
}

public struct GetExportJobsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetExportJobsInputBody: Equatable {
}

extension GetExportJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExportJobsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExportJobsOutputResponse(exportJobsResponse: \(String(describing: exportJobsResponse)))"}
}

extension GetExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ExportJobsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.exportJobsResponse = output
            } else {
                self.exportJobsResponse = nil
            }
        } else {
            self.exportJobsResponse = nil
        }
    }
}

public struct GetExportJobsOutputResponse: Equatable {
    /// <p>Provides information about all the export jobs that are associated with an application or segment. An export job is a job that exports endpoint definitions to a file.</p>
    public let exportJobsResponse: ExportJobsResponse?

    public init (
        exportJobsResponse: ExportJobsResponse? = nil
    )
    {
        self.exportJobsResponse = exportJobsResponse
    }
}

struct GetExportJobsOutputResponseBody: Equatable {
    public let exportJobsResponse: ExportJobsResponse?
}

extension GetExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportJobsResponse = "ExportJobsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobsResponseDecoded = try containerValues.decodeIfPresent(ExportJobsResponse.self, forKey: .exportJobsResponse)
        exportJobsResponse = exportJobsResponseDecoded
    }
}

extension GetGcmChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGcmChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetGcmChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetGcmChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetGcmChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGcmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGcmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGcmChannelInput>
    public typealias MOutput = OperationOutput<GetGcmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGcmChannelOutputError>
}

public struct GetGcmChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetGcmChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetGcmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetGcmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetGcmChannelInput>
    public typealias MOutput = OperationOutput<GetGcmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetGcmChannelOutputError>
}

public struct GetGcmChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetGcmChannelInputBody: Equatable {
}

extension GetGcmChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetGcmChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetGcmChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetGcmChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetGcmChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetGcmChannelOutputResponse(gCMChannelResponse: \(String(describing: gCMChannelResponse)))"}
}

extension GetGcmChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: GCMChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.gCMChannelResponse = output
            } else {
                self.gCMChannelResponse = nil
            }
        } else {
            self.gCMChannelResponse = nil
        }
    }
}

public struct GetGcmChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
    public let gCMChannelResponse: GCMChannelResponse?

    public init (
        gCMChannelResponse: GCMChannelResponse? = nil
    )
    {
        self.gCMChannelResponse = gCMChannelResponse
    }
}

struct GetGcmChannelOutputResponseBody: Equatable {
    public let gCMChannelResponse: GCMChannelResponse?
}

extension GetGcmChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gCMChannelResponse = "GCMChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gCMChannelResponseDecoded = try containerValues.decodeIfPresent(GCMChannelResponse.self, forKey: .gCMChannelResponse)
        gCMChannelResponse = gCMChannelResponseDecoded
    }
}

extension GetImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImportJobInput(applicationId: \(String(describing: applicationId)), jobId: \(String(describing: jobId)))"}
}

extension GetImportJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "GetImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImportJobInput>
    public typealias MOutput = OperationOutput<GetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImportJobOutputError>
}

public struct GetImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImportJobInput>
    public typealias MOutput = OperationOutput<GetImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImportJobOutputError>
}

public struct GetImportJobInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the job.</p>
    public let jobId: String?

    public init (
        applicationId: String? = nil,
        jobId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.jobId = jobId
    }
}

struct GetImportJobInputBody: Equatable {
}

extension GetImportJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImportJobOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImportJobOutputResponse(importJobResponse: \(String(describing: importJobResponse)))"}
}

extension GetImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ImportJobResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.importJobResponse = output
            } else {
                self.importJobResponse = nil
            }
        } else {
            self.importJobResponse = nil
        }
    }
}

public struct GetImportJobOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.</p>
    public let importJobResponse: ImportJobResponse?

    public init (
        importJobResponse: ImportJobResponse? = nil
    )
    {
        self.importJobResponse = importJobResponse
    }
}

struct GetImportJobOutputResponseBody: Equatable {
    public let importJobResponse: ImportJobResponse?
}

extension GetImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importJobResponse = "ImportJobResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobResponseDecoded = try containerValues.decodeIfPresent(ImportJobResponse.self, forKey: .importJobResponse)
        importJobResponse = importJobResponseDecoded
    }
}

extension GetImportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImportJobsInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetImportJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetImportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "GetImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImportJobsInput>
    public typealias MOutput = OperationOutput<GetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImportJobsOutputError>
}

public struct GetImportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetImportJobsInput>
    public typealias MOutput = OperationOutput<GetImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetImportJobsOutputError>
}

public struct GetImportJobsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetImportJobsInputBody: Equatable {
}

extension GetImportJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetImportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetImportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetImportJobsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetImportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetImportJobsOutputResponse(importJobsResponse: \(String(describing: importJobsResponse)))"}
}

extension GetImportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ImportJobsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.importJobsResponse = output
            } else {
                self.importJobsResponse = nil
            }
        } else {
            self.importJobsResponse = nil
        }
    }
}

public struct GetImportJobsOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of all the import jobs that are associated with an application or segment. An import job is a job that imports endpoint definitions from one or more files.</p>
    public let importJobsResponse: ImportJobsResponse?

    public init (
        importJobsResponse: ImportJobsResponse? = nil
    )
    {
        self.importJobsResponse = importJobsResponse
    }
}

struct GetImportJobsOutputResponseBody: Equatable {
    public let importJobsResponse: ImportJobsResponse?
}

extension GetImportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importJobsResponse = "ImportJobsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobsResponseDecoded = try containerValues.decodeIfPresent(ImportJobsResponse.self, forKey: .importJobsResponse)
        importJobsResponse = importJobsResponseDecoded
    }
}

extension GetJourneyDateRangeKpiInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyDateRangeKpiInput(applicationId: \(String(describing: applicationId)), endTime: \(String(describing: endTime)), journeyId: \(String(describing: journeyId)), kpiName: \(String(describing: kpiName)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), startTime: \(String(describing: startTime)))"}
}

extension GetJourneyDateRangeKpiInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJourneyDateRangeKpiInputHeadersMiddleware: Middleware {
    public let id: String = "GetJourneyDateRangeKpiInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyDateRangeKpiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyDateRangeKpiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyDateRangeKpiInput>
    public typealias MOutput = OperationOutput<GetJourneyDateRangeKpiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyDateRangeKpiOutputError>
}

public struct GetJourneyDateRangeKpiInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJourneyDateRangeKpiInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyDateRangeKpiInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyDateRangeKpiOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endTime = input.operationInput.endTime {
            let endTimeQueryItem = URLQueryItem(name: "end-time".urlPercentEncoding(), value: String(endTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endTimeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let startTime = input.operationInput.startTime {
            let startTimeQueryItem = URLQueryItem(name: "start-time".urlPercentEncoding(), value: String(startTime.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startTimeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyDateRangeKpiInput>
    public typealias MOutput = OperationOutput<GetJourneyDateRangeKpiOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyDateRangeKpiOutputError>
}

public struct GetJourneyDateRangeKpiInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The last date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-26T20:00:00Z for 8:00 PM UTC July 26, 2019.</p>
    public let endTime: Date?
    /// <p>The unique identifier for the journey.</p>
    public let journeyId: String?
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, to retrieve data for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. Examples are email-open-rate and successful-delivery-rate. For a list of valid values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let kpiName: String?
    /// <p>The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let nextToken: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The first date and time to retrieve data for, as part of an inclusive date range that filters the query results. This value should be in extended ISO 8601 format and use Coordinated Universal Time (UTC), for example: 2019-07-19T20:00:00Z for 8:00 PM UTC July 19, 2019. This value should also be fewer than 90 days from the current day.</p>
    public let startTime: Date?

    public init (
        applicationId: String? = nil,
        endTime: Date? = nil,
        journeyId: String? = nil,
        kpiName: String? = nil,
        nextToken: String? = nil,
        pageSize: String? = nil,
        startTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.endTime = endTime
        self.journeyId = journeyId
        self.kpiName = kpiName
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.startTime = startTime
    }
}

struct GetJourneyDateRangeKpiInputBody: Equatable {
}

extension GetJourneyDateRangeKpiInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJourneyDateRangeKpiOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJourneyDateRangeKpiOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJourneyDateRangeKpiOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJourneyDateRangeKpiOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyDateRangeKpiOutputResponse(journeyDateRangeKpiResponse: \(String(describing: journeyDateRangeKpiResponse)))"}
}

extension GetJourneyDateRangeKpiOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyDateRangeKpiResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyDateRangeKpiResponse = output
            } else {
                self.journeyDateRangeKpiResponse = nil
            }
        } else {
            self.journeyDateRangeKpiResponse = nil
        }
    }
}

public struct GetJourneyDateRangeKpiOutputResponse: Equatable {
    /// <p>Provides the results of a query that retrieved the data for a standard engagement metric that applies to a journey, and provides information about that query.</p>
    public let journeyDateRangeKpiResponse: JourneyDateRangeKpiResponse?

    public init (
        journeyDateRangeKpiResponse: JourneyDateRangeKpiResponse? = nil
    )
    {
        self.journeyDateRangeKpiResponse = journeyDateRangeKpiResponse
    }
}

struct GetJourneyDateRangeKpiOutputResponseBody: Equatable {
    public let journeyDateRangeKpiResponse: JourneyDateRangeKpiResponse?
}

extension GetJourneyDateRangeKpiOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyDateRangeKpiResponse = "JourneyDateRangeKpiResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyDateRangeKpiResponseDecoded = try containerValues.decodeIfPresent(JourneyDateRangeKpiResponse.self, forKey: .journeyDateRangeKpiResponse)
        journeyDateRangeKpiResponse = journeyDateRangeKpiResponseDecoded
    }
}

extension GetJourneyExecutionActivityMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyExecutionActivityMetricsInput(applicationId: \(String(describing: applicationId)), journeyActivityId: \(String(describing: journeyActivityId)), journeyId: \(String(describing: journeyId)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension GetJourneyExecutionActivityMetricsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJourneyExecutionActivityMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "GetJourneyExecutionActivityMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyExecutionActivityMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyExecutionActivityMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyExecutionActivityMetricsInput>
    public typealias MOutput = OperationOutput<GetJourneyExecutionActivityMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyExecutionActivityMetricsOutputError>
}

public struct GetJourneyExecutionActivityMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJourneyExecutionActivityMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyExecutionActivityMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyExecutionActivityMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyExecutionActivityMetricsInput>
    public typealias MOutput = OperationOutput<GetJourneyExecutionActivityMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyExecutionActivityMetricsOutputError>
}

public struct GetJourneyExecutionActivityMetricsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the journey activity.</p>
    public let journeyActivityId: String?
    /// <p>The unique identifier for the journey.</p>
    public let journeyId: String?
    /// <p>The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let nextToken: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?

    public init (
        applicationId: String? = nil,
        journeyActivityId: String? = nil,
        journeyId: String? = nil,
        nextToken: String? = nil,
        pageSize: String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyActivityId = journeyActivityId
        self.journeyId = journeyId
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct GetJourneyExecutionActivityMetricsInputBody: Equatable {
}

extension GetJourneyExecutionActivityMetricsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJourneyExecutionActivityMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJourneyExecutionActivityMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJourneyExecutionActivityMetricsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJourneyExecutionActivityMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyExecutionActivityMetricsOutputResponse(journeyExecutionActivityMetricsResponse: \(String(describing: journeyExecutionActivityMetricsResponse)))"}
}

extension GetJourneyExecutionActivityMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyExecutionActivityMetricsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyExecutionActivityMetricsResponse = output
            } else {
                self.journeyExecutionActivityMetricsResponse = nil
            }
        } else {
            self.journeyExecutionActivityMetricsResponse = nil
        }
    }
}

public struct GetJourneyExecutionActivityMetricsOutputResponse: Equatable {
    /// <p>Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey activity, and provides information about that query.</p>
    public let journeyExecutionActivityMetricsResponse: JourneyExecutionActivityMetricsResponse?

    public init (
        journeyExecutionActivityMetricsResponse: JourneyExecutionActivityMetricsResponse? = nil
    )
    {
        self.journeyExecutionActivityMetricsResponse = journeyExecutionActivityMetricsResponse
    }
}

struct GetJourneyExecutionActivityMetricsOutputResponseBody: Equatable {
    public let journeyExecutionActivityMetricsResponse: JourneyExecutionActivityMetricsResponse?
}

extension GetJourneyExecutionActivityMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyExecutionActivityMetricsResponse = "JourneyExecutionActivityMetricsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyExecutionActivityMetricsResponseDecoded = try containerValues.decodeIfPresent(JourneyExecutionActivityMetricsResponse.self, forKey: .journeyExecutionActivityMetricsResponse)
        journeyExecutionActivityMetricsResponse = journeyExecutionActivityMetricsResponseDecoded
    }
}

extension GetJourneyExecutionMetricsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyExecutionMetricsInput(applicationId: \(String(describing: applicationId)), journeyId: \(String(describing: journeyId)), nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension GetJourneyExecutionMetricsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJourneyExecutionMetricsInputHeadersMiddleware: Middleware {
    public let id: String = "GetJourneyExecutionMetricsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyExecutionMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyExecutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyExecutionMetricsInput>
    public typealias MOutput = OperationOutput<GetJourneyExecutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyExecutionMetricsOutputError>
}

public struct GetJourneyExecutionMetricsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJourneyExecutionMetricsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyExecutionMetricsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyExecutionMetricsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyExecutionMetricsInput>
    public typealias MOutput = OperationOutput<GetJourneyExecutionMetricsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyExecutionMetricsOutputError>
}

public struct GetJourneyExecutionMetricsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the journey.</p>
    public let journeyId: String?
    /// <p>The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let nextToken: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?

    public init (
        applicationId: String? = nil,
        journeyId: String? = nil,
        nextToken: String? = nil,
        pageSize: String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct GetJourneyExecutionMetricsInputBody: Equatable {
}

extension GetJourneyExecutionMetricsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJourneyExecutionMetricsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJourneyExecutionMetricsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJourneyExecutionMetricsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJourneyExecutionMetricsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyExecutionMetricsOutputResponse(journeyExecutionMetricsResponse: \(String(describing: journeyExecutionMetricsResponse)))"}
}

extension GetJourneyExecutionMetricsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyExecutionMetricsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyExecutionMetricsResponse = output
            } else {
                self.journeyExecutionMetricsResponse = nil
            }
        } else {
            self.journeyExecutionMetricsResponse = nil
        }
    }
}

public struct GetJourneyExecutionMetricsOutputResponse: Equatable {
    /// <p>Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey, and provides information about that query.</p>
    public let journeyExecutionMetricsResponse: JourneyExecutionMetricsResponse?

    public init (
        journeyExecutionMetricsResponse: JourneyExecutionMetricsResponse? = nil
    )
    {
        self.journeyExecutionMetricsResponse = journeyExecutionMetricsResponse
    }
}

struct GetJourneyExecutionMetricsOutputResponseBody: Equatable {
    public let journeyExecutionMetricsResponse: JourneyExecutionMetricsResponse?
}

extension GetJourneyExecutionMetricsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyExecutionMetricsResponse = "JourneyExecutionMetricsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyExecutionMetricsResponseDecoded = try containerValues.decodeIfPresent(JourneyExecutionMetricsResponse.self, forKey: .journeyExecutionMetricsResponse)
        journeyExecutionMetricsResponse = journeyExecutionMetricsResponseDecoded
    }
}

extension GetJourneyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyInput(applicationId: \(String(describing: applicationId)), journeyId: \(String(describing: journeyId)))"}
}

extension GetJourneyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetJourneyInputHeadersMiddleware: Middleware {
    public let id: String = "GetJourneyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyInput>
    public typealias MOutput = OperationOutput<GetJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyOutputError>
}

public struct GetJourneyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetJourneyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetJourneyInput>
    public typealias MOutput = OperationOutput<GetJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetJourneyOutputError>
}

public struct GetJourneyInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the journey.</p>
    public let journeyId: String?

    public init (
        applicationId: String? = nil,
        journeyId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
    }
}

struct GetJourneyInputBody: Equatable {
}

extension GetJourneyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetJourneyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetJourneyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetJourneyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetJourneyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetJourneyOutputResponse(journeyResponse: \(String(describing: journeyResponse)))"}
}

extension GetJourneyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyResponse = output
            } else {
                self.journeyResponse = nil
            }
        } else {
            self.journeyResponse = nil
        }
    }
}

public struct GetJourneyOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a journey.</p>
    public let journeyResponse: JourneyResponse?

    public init (
        journeyResponse: JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

struct GetJourneyOutputResponseBody: Equatable {
    public let journeyResponse: JourneyResponse?
}

extension GetJourneyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyResponse = "JourneyResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyResponseDecoded = try containerValues.decodeIfPresent(JourneyResponse.self, forKey: .journeyResponse)
        journeyResponse = journeyResponseDecoded
    }
}

extension GetPushTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPushTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension GetPushTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPushTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetPushTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPushTemplateInput>
    public typealias MOutput = OperationOutput<GetPushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPushTemplateOutputError>
}

public struct GetPushTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPushTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPushTemplateInput>
    public typealias MOutput = OperationOutput<GetPushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPushTemplateOutputError>
}

public struct GetPushTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct GetPushTemplateInputBody: Equatable {
}

extension GetPushTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPushTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPushTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPushTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPushTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPushTemplateOutputResponse(pushNotificationTemplateResponse: \(String(describing: pushNotificationTemplateResponse)))"}
}

extension GetPushTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: PushNotificationTemplateResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.pushNotificationTemplateResponse = output
            } else {
                self.pushNotificationTemplateResponse = nil
            }
        } else {
            self.pushNotificationTemplateResponse = nil
        }
    }
}

public struct GetPushTemplateOutputResponse: Equatable {
    /// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through a push notification channel.</p>
    public let pushNotificationTemplateResponse: PushNotificationTemplateResponse?

    public init (
        pushNotificationTemplateResponse: PushNotificationTemplateResponse? = nil
    )
    {
        self.pushNotificationTemplateResponse = pushNotificationTemplateResponse
    }
}

struct GetPushTemplateOutputResponseBody: Equatable {
    public let pushNotificationTemplateResponse: PushNotificationTemplateResponse?
}

extension GetPushTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pushNotificationTemplateResponse = "PushNotificationTemplateResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushNotificationTemplateResponseDecoded = try containerValues.decodeIfPresent(PushNotificationTemplateResponse.self, forKey: .pushNotificationTemplateResponse)
        pushNotificationTemplateResponse = pushNotificationTemplateResponseDecoded
    }
}

extension GetRecommenderConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommenderConfigurationInput(recommenderId: \(String(describing: recommenderId)))"}
}

extension GetRecommenderConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRecommenderConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecommenderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<GetRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommenderConfigurationOutputError>
}

public struct GetRecommenderConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecommenderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<GetRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommenderConfigurationOutputError>
}

public struct GetRecommenderConfigurationInput: Equatable {
    /// <p>The unique identifier for the recommender model configuration. This identifier is displayed as the <b>Recommender ID</b> on the Amazon Pinpoint console.</p>
    public let recommenderId: String?

    public init (
        recommenderId: String? = nil
    )
    {
        self.recommenderId = recommenderId
    }
}

struct GetRecommenderConfigurationInputBody: Equatable {
}

extension GetRecommenderConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRecommenderConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommenderConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommenderConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommenderConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommenderConfigurationOutputResponse(recommenderConfigurationResponse: \(String(describing: recommenderConfigurationResponse)))"}
}

extension GetRecommenderConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RecommenderConfigurationResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.recommenderConfigurationResponse = output
            } else {
                self.recommenderConfigurationResponse = nil
            }
        } else {
            self.recommenderConfigurationResponse = nil
        }
    }
}

public struct GetRecommenderConfigurationOutputResponse: Equatable {
    /// <p>Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.</p>
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?

    public init (
        recommenderConfigurationResponse: RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

struct GetRecommenderConfigurationOutputResponseBody: Equatable {
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?
}

extension GetRecommenderConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recommenderConfigurationResponse = "RecommenderConfigurationResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderConfigurationResponseDecoded = try containerValues.decodeIfPresent(RecommenderConfigurationResponse.self, forKey: .recommenderConfigurationResponse)
        recommenderConfigurationResponse = recommenderConfigurationResponseDecoded
    }
}

extension GetRecommenderConfigurationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommenderConfigurationsInput(pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetRecommenderConfigurationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetRecommenderConfigurationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetRecommenderConfigurationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommenderConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommenderConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommenderConfigurationsInput>
    public typealias MOutput = OperationOutput<GetRecommenderConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommenderConfigurationsOutputError>
}

public struct GetRecommenderConfigurationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetRecommenderConfigurationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetRecommenderConfigurationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetRecommenderConfigurationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetRecommenderConfigurationsInput>
    public typealias MOutput = OperationOutput<GetRecommenderConfigurationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetRecommenderConfigurationsOutputError>
}

public struct GetRecommenderConfigurationsInput: Equatable {
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetRecommenderConfigurationsInputBody: Equatable {
}

extension GetRecommenderConfigurationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetRecommenderConfigurationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecommenderConfigurationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetRecommenderConfigurationsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecommenderConfigurationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetRecommenderConfigurationsOutputResponse(listRecommenderConfigurationsResponse: \(String(describing: listRecommenderConfigurationsResponse)))"}
}

extension GetRecommenderConfigurationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ListRecommenderConfigurationsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.listRecommenderConfigurationsResponse = output
            } else {
                self.listRecommenderConfigurationsResponse = nil
            }
        } else {
            self.listRecommenderConfigurationsResponse = nil
        }
    }
}

public struct GetRecommenderConfigurationsOutputResponse: Equatable {
    /// <p>Provides information about all the recommender model configurations that are associated with your Amazon Pinpoint account.</p>
    public let listRecommenderConfigurationsResponse: ListRecommenderConfigurationsResponse?

    public init (
        listRecommenderConfigurationsResponse: ListRecommenderConfigurationsResponse? = nil
    )
    {
        self.listRecommenderConfigurationsResponse = listRecommenderConfigurationsResponse
    }
}

struct GetRecommenderConfigurationsOutputResponseBody: Equatable {
    public let listRecommenderConfigurationsResponse: ListRecommenderConfigurationsResponse?
}

extension GetRecommenderConfigurationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case listRecommenderConfigurationsResponse = "ListRecommenderConfigurationsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listRecommenderConfigurationsResponseDecoded = try containerValues.decodeIfPresent(ListRecommenderConfigurationsResponse.self, forKey: .listRecommenderConfigurationsResponse)
        listRecommenderConfigurationsResponse = listRecommenderConfigurationsResponseDecoded
    }
}

extension GetSegmentExportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentExportJobsInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), segmentId: \(String(describing: segmentId)), token: \(String(describing: token)))"}
}

extension GetSegmentExportJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSegmentExportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSegmentExportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentExportJobsInput>
    public typealias MOutput = OperationOutput<GetSegmentExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentExportJobsOutputError>
}

public struct GetSegmentExportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSegmentExportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentExportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentExportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentExportJobsInput>
    public typealias MOutput = OperationOutput<GetSegmentExportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentExportJobsOutputError>
}

public struct GetSegmentExportJobsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The unique identifier for the segment.</p>
    public let segmentId: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        segmentId: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.segmentId = segmentId
        self.token = token
    }
}

struct GetSegmentExportJobsInputBody: Equatable {
}

extension GetSegmentExportJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSegmentExportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSegmentExportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSegmentExportJobsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSegmentExportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentExportJobsOutputResponse(exportJobsResponse: \(String(describing: exportJobsResponse)))"}
}

extension GetSegmentExportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ExportJobsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.exportJobsResponse = output
            } else {
                self.exportJobsResponse = nil
            }
        } else {
            self.exportJobsResponse = nil
        }
    }
}

public struct GetSegmentExportJobsOutputResponse: Equatable {
    /// <p>Provides information about all the export jobs that are associated with an application or segment. An export job is a job that exports endpoint definitions to a file.</p>
    public let exportJobsResponse: ExportJobsResponse?

    public init (
        exportJobsResponse: ExportJobsResponse? = nil
    )
    {
        self.exportJobsResponse = exportJobsResponse
    }
}

struct GetSegmentExportJobsOutputResponseBody: Equatable {
    public let exportJobsResponse: ExportJobsResponse?
}

extension GetSegmentExportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportJobsResponse = "ExportJobsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportJobsResponseDecoded = try containerValues.decodeIfPresent(ExportJobsResponse.self, forKey: .exportJobsResponse)
        exportJobsResponse = exportJobsResponseDecoded
    }
}

extension GetSegmentImportJobsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentImportJobsInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), segmentId: \(String(describing: segmentId)), token: \(String(describing: token)))"}
}

extension GetSegmentImportJobsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSegmentImportJobsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSegmentImportJobsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentImportJobsInput>
    public typealias MOutput = OperationOutput<GetSegmentImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentImportJobsOutputError>
}

public struct GetSegmentImportJobsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSegmentImportJobsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentImportJobsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentImportJobsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentImportJobsInput>
    public typealias MOutput = OperationOutput<GetSegmentImportJobsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentImportJobsOutputError>
}

public struct GetSegmentImportJobsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The unique identifier for the segment.</p>
    public let segmentId: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        segmentId: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.segmentId = segmentId
        self.token = token
    }
}

struct GetSegmentImportJobsInputBody: Equatable {
}

extension GetSegmentImportJobsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSegmentImportJobsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSegmentImportJobsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSegmentImportJobsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSegmentImportJobsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentImportJobsOutputResponse(importJobsResponse: \(String(describing: importJobsResponse)))"}
}

extension GetSegmentImportJobsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ImportJobsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.importJobsResponse = output
            } else {
                self.importJobsResponse = nil
            }
        } else {
            self.importJobsResponse = nil
        }
    }
}

public struct GetSegmentImportJobsOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of all the import jobs that are associated with an application or segment. An import job is a job that imports endpoint definitions from one or more files.</p>
    public let importJobsResponse: ImportJobsResponse?

    public init (
        importJobsResponse: ImportJobsResponse? = nil
    )
    {
        self.importJobsResponse = importJobsResponse
    }
}

struct GetSegmentImportJobsOutputResponseBody: Equatable {
    public let importJobsResponse: ImportJobsResponse?
}

extension GetSegmentImportJobsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case importJobsResponse = "ImportJobsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let importJobsResponseDecoded = try containerValues.decodeIfPresent(ImportJobsResponse.self, forKey: .importJobsResponse)
        importJobsResponse = importJobsResponseDecoded
    }
}

extension GetSegmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentInput(applicationId: \(String(describing: applicationId)), segmentId: \(String(describing: segmentId)))"}
}

extension GetSegmentInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSegmentInputHeadersMiddleware: Middleware {
    public let id: String = "GetSegmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentInput>
    public typealias MOutput = OperationOutput<GetSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentOutputError>
}

public struct GetSegmentInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSegmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentInput>
    public typealias MOutput = OperationOutput<GetSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentOutputError>
}

public struct GetSegmentInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the segment.</p>
    public let segmentId: String?

    public init (
        applicationId: String? = nil,
        segmentId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
    }
}

struct GetSegmentInputBody: Equatable {
}

extension GetSegmentInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSegmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSegmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSegmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSegmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentOutputResponse(segmentResponse: \(String(describing: segmentResponse)))"}
}

extension GetSegmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SegmentResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.segmentResponse = output
            } else {
                self.segmentResponse = nil
            }
        } else {
            self.segmentResponse = nil
        }
    }
}

public struct GetSegmentOutputResponse: Equatable {
    /// <p>Provides information about the configuration, dimension, and other settings for a segment.</p>
    public let segmentResponse: SegmentResponse?

    public init (
        segmentResponse: SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

struct GetSegmentOutputResponseBody: Equatable {
    public let segmentResponse: SegmentResponse?
}

extension GetSegmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case segmentResponse = "SegmentResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentResponseDecoded = try containerValues.decodeIfPresent(SegmentResponse.self, forKey: .segmentResponse)
        segmentResponse = segmentResponseDecoded
    }
}

extension GetSegmentVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentVersionInput(applicationId: \(String(describing: applicationId)), segmentId: \(String(describing: segmentId)), version: \(String(describing: version)))"}
}

extension GetSegmentVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSegmentVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetSegmentVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentVersionInput>
    public typealias MOutput = OperationOutput<GetSegmentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentVersionOutputError>
}

public struct GetSegmentVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSegmentVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentVersionInput>
    public typealias MOutput = OperationOutput<GetSegmentVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentVersionOutputError>
}

public struct GetSegmentVersionInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the segment.</p>
    public let segmentId: String?
    /// <p>The unique version number (Version property) for the campaign version.</p>
    public let version: String?

    public init (
        applicationId: String? = nil,
        segmentId: String? = nil,
        version: String? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
        self.version = version
    }
}

struct GetSegmentVersionInputBody: Equatable {
}

extension GetSegmentVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSegmentVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSegmentVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSegmentVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSegmentVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentVersionOutputResponse(segmentResponse: \(String(describing: segmentResponse)))"}
}

extension GetSegmentVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SegmentResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.segmentResponse = output
            } else {
                self.segmentResponse = nil
            }
        } else {
            self.segmentResponse = nil
        }
    }
}

public struct GetSegmentVersionOutputResponse: Equatable {
    /// <p>Provides information about the configuration, dimension, and other settings for a segment.</p>
    public let segmentResponse: SegmentResponse?

    public init (
        segmentResponse: SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

struct GetSegmentVersionOutputResponseBody: Equatable {
    public let segmentResponse: SegmentResponse?
}

extension GetSegmentVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case segmentResponse = "SegmentResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentResponseDecoded = try containerValues.decodeIfPresent(SegmentResponse.self, forKey: .segmentResponse)
        segmentResponse = segmentResponseDecoded
    }
}

extension GetSegmentVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentVersionsInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), segmentId: \(String(describing: segmentId)), token: \(String(describing: token)))"}
}

extension GetSegmentVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSegmentVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSegmentVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentVersionsInput>
    public typealias MOutput = OperationOutput<GetSegmentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentVersionsOutputError>
}

public struct GetSegmentVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSegmentVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentVersionsInput>
    public typealias MOutput = OperationOutput<GetSegmentVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentVersionsOutputError>
}

public struct GetSegmentVersionsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The unique identifier for the segment.</p>
    public let segmentId: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        segmentId: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.segmentId = segmentId
        self.token = token
    }
}

struct GetSegmentVersionsInputBody: Equatable {
}

extension GetSegmentVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSegmentVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSegmentVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSegmentVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSegmentVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentVersionsOutputResponse(segmentsResponse: \(String(describing: segmentsResponse)))"}
}

extension GetSegmentVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SegmentsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.segmentsResponse = output
            } else {
                self.segmentsResponse = nil
            }
        } else {
            self.segmentsResponse = nil
        }
    }
}

public struct GetSegmentVersionsOutputResponse: Equatable {
    /// <p>Provides information about all the segments that are associated with an application.</p>
    public let segmentsResponse: SegmentsResponse?

    public init (
        segmentsResponse: SegmentsResponse? = nil
    )
    {
        self.segmentsResponse = segmentsResponse
    }
}

struct GetSegmentVersionsOutputResponseBody: Equatable {
    public let segmentsResponse: SegmentsResponse?
}

extension GetSegmentVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case segmentsResponse = "SegmentsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentsResponseDecoded = try containerValues.decodeIfPresent(SegmentsResponse.self, forKey: .segmentsResponse)
        segmentsResponse = segmentsResponseDecoded
    }
}

extension GetSegmentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentsInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension GetSegmentsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSegmentsInputHeadersMiddleware: Middleware {
    public let id: String = "GetSegmentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentsInput>
    public typealias MOutput = OperationOutput<GetSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentsOutputError>
}

public struct GetSegmentsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSegmentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSegmentsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSegmentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSegmentsInput>
    public typealias MOutput = OperationOutput<GetSegmentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSegmentsOutputError>
}

public struct GetSegmentsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

struct GetSegmentsInputBody: Equatable {
}

extension GetSegmentsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSegmentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSegmentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSegmentsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSegmentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSegmentsOutputResponse(segmentsResponse: \(String(describing: segmentsResponse)))"}
}

extension GetSegmentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SegmentsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.segmentsResponse = output
            } else {
                self.segmentsResponse = nil
            }
        } else {
            self.segmentsResponse = nil
        }
    }
}

public struct GetSegmentsOutputResponse: Equatable {
    /// <p>Provides information about all the segments that are associated with an application.</p>
    public let segmentsResponse: SegmentsResponse?

    public init (
        segmentsResponse: SegmentsResponse? = nil
    )
    {
        self.segmentsResponse = segmentsResponse
    }
}

struct GetSegmentsOutputResponseBody: Equatable {
    public let segmentsResponse: SegmentsResponse?
}

extension GetSegmentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case segmentsResponse = "SegmentsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentsResponseDecoded = try containerValues.decodeIfPresent(SegmentsResponse.self, forKey: .segmentsResponse)
        segmentsResponse = segmentsResponseDecoded
    }
}

extension GetSmsChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSmsChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetSmsChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSmsChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetSmsChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSmsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSmsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSmsChannelInput>
    public typealias MOutput = OperationOutput<GetSmsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSmsChannelOutputError>
}

public struct GetSmsChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSmsChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSmsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSmsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSmsChannelInput>
    public typealias MOutput = OperationOutput<GetSmsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSmsChannelOutputError>
}

public struct GetSmsChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetSmsChannelInputBody: Equatable {
}

extension GetSmsChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSmsChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSmsChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSmsChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSmsChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSmsChannelOutputResponse(sMSChannelResponse: \(String(describing: sMSChannelResponse)))"}
}

extension GetSmsChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SMSChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.sMSChannelResponse = output
            } else {
                self.sMSChannelResponse = nil
            }
        } else {
            self.sMSChannelResponse = nil
        }
    }
}

public struct GetSmsChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the SMS channel for an application.</p>
    public let sMSChannelResponse: SMSChannelResponse?

    public init (
        sMSChannelResponse: SMSChannelResponse? = nil
    )
    {
        self.sMSChannelResponse = sMSChannelResponse
    }
}

struct GetSmsChannelOutputResponseBody: Equatable {
    public let sMSChannelResponse: SMSChannelResponse?
}

extension GetSmsChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSChannelResponse = "SMSChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSChannelResponseDecoded = try containerValues.decodeIfPresent(SMSChannelResponse.self, forKey: .sMSChannelResponse)
        sMSChannelResponse = sMSChannelResponseDecoded
    }
}

extension GetSmsTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSmsTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension GetSmsTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSmsTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetSmsTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSmsTemplateInput>
    public typealias MOutput = OperationOutput<GetSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSmsTemplateOutputError>
}

public struct GetSmsTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSmsTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSmsTemplateInput>
    public typealias MOutput = OperationOutput<GetSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSmsTemplateOutputError>
}

public struct GetSmsTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct GetSmsTemplateInputBody: Equatable {
}

extension GetSmsTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSmsTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSmsTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSmsTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSmsTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSmsTemplateOutputResponse(sMSTemplateResponse: \(String(describing: sMSTemplateResponse)))"}
}

extension GetSmsTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SMSTemplateResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.sMSTemplateResponse = output
            } else {
                self.sMSTemplateResponse = nil
            }
        } else {
            self.sMSTemplateResponse = nil
        }
    }
}

public struct GetSmsTemplateOutputResponse: Equatable {
    /// <p>Provides information about the content and settings for a message template that can be used in text messages that are sent through the SMS channel.</p>
    public let sMSTemplateResponse: SMSTemplateResponse?

    public init (
        sMSTemplateResponse: SMSTemplateResponse? = nil
    )
    {
        self.sMSTemplateResponse = sMSTemplateResponse
    }
}

struct GetSmsTemplateOutputResponseBody: Equatable {
    public let sMSTemplateResponse: SMSTemplateResponse?
}

extension GetSmsTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSTemplateResponse = "SMSTemplateResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSTemplateResponseDecoded = try containerValues.decodeIfPresent(SMSTemplateResponse.self, forKey: .sMSTemplateResponse)
        sMSTemplateResponse = sMSTemplateResponseDecoded
    }
}

extension GetUserEndpointsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserEndpointsInput(applicationId: \(String(describing: applicationId)), userId: \(String(describing: userId)))"}
}

extension GetUserEndpointsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetUserEndpointsInputHeadersMiddleware: Middleware {
    public let id: String = "GetUserEndpointsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserEndpointsInput>
    public typealias MOutput = OperationOutput<GetUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserEndpointsOutputError>
}

public struct GetUserEndpointsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetUserEndpointsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetUserEndpointsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetUserEndpointsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetUserEndpointsInput>
    public typealias MOutput = OperationOutput<GetUserEndpointsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetUserEndpointsOutputError>
}

public struct GetUserEndpointsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the user.</p>
    public let userId: String?

    public init (
        applicationId: String? = nil,
        userId: String? = nil
    )
    {
        self.applicationId = applicationId
        self.userId = userId
    }
}

struct GetUserEndpointsInputBody: Equatable {
}

extension GetUserEndpointsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetUserEndpointsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserEndpointsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetUserEndpointsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserEndpointsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetUserEndpointsOutputResponse(endpointsResponse: \(String(describing: endpointsResponse)))"}
}

extension GetUserEndpointsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EndpointsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.endpointsResponse = output
            } else {
                self.endpointsResponse = nil
            }
        } else {
            self.endpointsResponse = nil
        }
    }
}

public struct GetUserEndpointsOutputResponse: Equatable {
    /// <p>Provides information about all the endpoints that are associated with a user ID.</p>
    public let endpointsResponse: EndpointsResponse?

    public init (
        endpointsResponse: EndpointsResponse? = nil
    )
    {
        self.endpointsResponse = endpointsResponse
    }
}

struct GetUserEndpointsOutputResponseBody: Equatable {
    public let endpointsResponse: EndpointsResponse?
}

extension GetUserEndpointsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointsResponse = "EndpointsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsResponseDecoded = try containerValues.decodeIfPresent(EndpointsResponse.self, forKey: .endpointsResponse)
        endpointsResponse = endpointsResponseDecoded
    }
}

extension GetVoiceChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVoiceChannelInput(applicationId: \(String(describing: applicationId)))"}
}

extension GetVoiceChannelInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVoiceChannelInputHeadersMiddleware: Middleware {
    public let id: String = "GetVoiceChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVoiceChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVoiceChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVoiceChannelInput>
    public typealias MOutput = OperationOutput<GetVoiceChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVoiceChannelOutputError>
}

public struct GetVoiceChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVoiceChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVoiceChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVoiceChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVoiceChannelInput>
    public typealias MOutput = OperationOutput<GetVoiceChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVoiceChannelOutputError>
}

public struct GetVoiceChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        applicationId: String? = nil
    )
    {
        self.applicationId = applicationId
    }
}

struct GetVoiceChannelInputBody: Equatable {
}

extension GetVoiceChannelInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVoiceChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVoiceChannelOutputResponse(voiceChannelResponse: \(String(describing: voiceChannelResponse)))"}
}

extension GetVoiceChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VoiceChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.voiceChannelResponse = output
            } else {
                self.voiceChannelResponse = nil
            }
        } else {
            self.voiceChannelResponse = nil
        }
    }
}

public struct GetVoiceChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the voice channel for an application.</p>
    public let voiceChannelResponse: VoiceChannelResponse?

    public init (
        voiceChannelResponse: VoiceChannelResponse? = nil
    )
    {
        self.voiceChannelResponse = voiceChannelResponse
    }
}

struct GetVoiceChannelOutputResponseBody: Equatable {
    public let voiceChannelResponse: VoiceChannelResponse?
}

extension GetVoiceChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case voiceChannelResponse = "VoiceChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceChannelResponseDecoded = try containerValues.decodeIfPresent(VoiceChannelResponse.self, forKey: .voiceChannelResponse)
        voiceChannelResponse = voiceChannelResponseDecoded
    }
}

extension GetVoiceTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVoiceTemplateInput(templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension GetVoiceTemplateInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetVoiceTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "GetVoiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVoiceTemplateInput>
    public typealias MOutput = OperationOutput<GetVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVoiceTemplateOutputError>
}

public struct GetVoiceTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "GetVoiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<GetVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetVoiceTemplateInput>
    public typealias MOutput = OperationOutput<GetVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetVoiceTemplateOutputError>
}

public struct GetVoiceTemplateInput: Equatable {
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.templateName = templateName
        self.version = version
    }
}

struct GetVoiceTemplateInputBody: Equatable {
}

extension GetVoiceTemplateInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetVoiceTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetVoiceTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetVoiceTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetVoiceTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetVoiceTemplateOutputResponse(voiceTemplateResponse: \(String(describing: voiceTemplateResponse)))"}
}

extension GetVoiceTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VoiceTemplateResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.voiceTemplateResponse = output
            } else {
                self.voiceTemplateResponse = nil
            }
        } else {
            self.voiceTemplateResponse = nil
        }
    }
}

public struct GetVoiceTemplateOutputResponse: Equatable {
    /// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through the voice channel.</p>
    public let voiceTemplateResponse: VoiceTemplateResponse?

    public init (
        voiceTemplateResponse: VoiceTemplateResponse? = nil
    )
    {
        self.voiceTemplateResponse = voiceTemplateResponse
    }
}

struct GetVoiceTemplateOutputResponseBody: Equatable {
    public let voiceTemplateResponse: VoiceTemplateResponse?
}

extension GetVoiceTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case voiceTemplateResponse = "VoiceTemplateResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceTemplateResponseDecoded = try containerValues.decodeIfPresent(VoiceTemplateResponse.self, forKey: .voiceTemplateResponse)
        voiceTemplateResponse = voiceTemplateResponseDecoded
    }
}

extension HoldoutActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextActivity = "NextActivity"
        case percentage = "Percentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
        if percentage != 0 {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
        let percentageDecoded = try containerValues.decode(Int.self, forKey: .percentage)
        percentage = percentageDecoded
    }
}

extension HoldoutActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "HoldoutActivity(nextActivity: \(String(describing: nextActivity)), percentage: \(String(describing: percentage)))"}
}

/// <p>Specifies the settings for a holdout activity in a journey. This type of activity stops a journey for a specified percentage of participants.</p>
public struct HoldoutActivity: Equatable {
    /// <p>The unique identifier for the next activity to perform, after performing the holdout activity.</p>
    public let nextActivity: String?
    /// <p>The percentage of participants who shouldn't continue the journey.</p> <p>To determine which participants are held out, Amazon Pinpoint applies a probability-based algorithm to the percentage that you specify. Therefore, the actual percentage of participants who are held out may not be equal to the percentage that you specify.</p>
    public let percentage: Int

    public init (
        nextActivity: String? = nil,
        percentage: Int = 0
    )
    {
        self.nextActivity = nextActivity
        self.percentage = percentage
    }
}

extension ImportJobRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defineSegment = "DefineSegment"
        case externalId = "ExternalId"
        case format = "Format"
        case registerEndpoints = "RegisterEndpoints"
        case roleArn = "RoleArn"
        case s3Url = "S3Url"
        case segmentId = "SegmentId"
        case segmentName = "SegmentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defineSegment != false {
            try encodeContainer.encode(defineSegment, forKey: .defineSegment)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if registerEndpoints != false {
            try encodeContainer.encode(registerEndpoints, forKey: .registerEndpoints)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3Url = s3Url {
            try encodeContainer.encode(s3Url, forKey: .s3Url)
        }
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
        if let segmentName = segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defineSegmentDecoded = try containerValues.decode(Bool.self, forKey: .defineSegment)
        defineSegment = defineSegmentDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let registerEndpointsDecoded = try containerValues.decode(Bool.self, forKey: .registerEndpoints)
        registerEndpoints = registerEndpointsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let s3UrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
    }
}

extension ImportJobRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportJobRequest(defineSegment: \(String(describing: defineSegment)), externalId: \(String(describing: externalId)), format: \(String(describing: format)), registerEndpoints: \(String(describing: registerEndpoints)), roleArn: \(String(describing: roleArn)), s3Url: \(String(describing: s3Url)), segmentId: \(String(describing: segmentId)), segmentName: \(String(describing: segmentName)))"}
}

/// <p>Specifies the settings for a job that imports endpoint definitions from an Amazon Simple Storage Service (Amazon S3) bucket.</p>
public struct ImportJobRequest: Equatable {
    /// <p>Specifies whether to create a segment that contains the endpoints, when the endpoint definitions are imported.</p>
    public let defineSegment: Bool
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    public let externalId: String?
    /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format. If the Amazon S3 location stores multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
    public let format: Format?
    /// <p>Specifies whether to register the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
    public let registerEndpoints: Bool
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
    public let roleArn: String?
    /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
    public let s3Url: String?
    /// <p>The identifier for the segment to update or add the imported endpoint definitions to, if the import job is meant to update an existing segment.</p>
    public let segmentId: String?
    /// <p>A custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
    public let segmentName: String?

    public init (
        defineSegment: Bool = false,
        externalId: String? = nil,
        format: Format? = nil,
        registerEndpoints: Bool = false,
        roleArn: String? = nil,
        s3Url: String? = nil,
        segmentId: String? = nil,
        segmentName: String? = nil
    )
    {
        self.defineSegment = defineSegment
        self.externalId = externalId
        self.format = format
        self.registerEndpoints = registerEndpoints
        self.roleArn = roleArn
        self.s3Url = s3Url
        self.segmentId = segmentId
        self.segmentName = segmentName
    }
}

extension ImportJobResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case defineSegment = "DefineSegment"
        case externalId = "ExternalId"
        case format = "Format"
        case registerEndpoints = "RegisterEndpoints"
        case roleArn = "RoleArn"
        case s3Url = "S3Url"
        case segmentId = "SegmentId"
        case segmentName = "SegmentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if defineSegment != false {
            try encodeContainer.encode(defineSegment, forKey: .defineSegment)
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if registerEndpoints != false {
            try encodeContainer.encode(registerEndpoints, forKey: .registerEndpoints)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3Url = s3Url {
            try encodeContainer.encode(s3Url, forKey: .s3Url)
        }
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
        if let segmentName = segmentName {
            try encodeContainer.encode(segmentName, forKey: .segmentName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defineSegmentDecoded = try containerValues.decode(Bool.self, forKey: .defineSegment)
        defineSegment = defineSegmentDecoded
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let registerEndpointsDecoded = try containerValues.decode(Bool.self, forKey: .registerEndpoints)
        registerEndpoints = registerEndpointsDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let s3UrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
        let segmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentName)
        segmentName = segmentNameDecoded
    }
}

extension ImportJobResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportJobResource(defineSegment: \(String(describing: defineSegment)), externalId: \(String(describing: externalId)), format: \(String(describing: format)), registerEndpoints: \(String(describing: registerEndpoints)), roleArn: \(String(describing: roleArn)), s3Url: \(String(describing: s3Url)), segmentId: \(String(describing: segmentId)), segmentName: \(String(describing: segmentName)))"}
}

/// <p>Provides information about the resource settings for a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.</p>
public struct ImportJobResource: Equatable {
    /// <p>Specifies whether the import job creates a segment that contains the endpoints, when the endpoint definitions are imported.</p>
    public let defineSegment: Bool
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    public let externalId: String?
    /// <p>The format of the files that contain the endpoint definitions to import. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p> <p>If the files are stored in an Amazon S3 location and that location contains multiple files that use different formats, Amazon Pinpoint imports data only from the files that use the specified format.</p>
    public let format: Format?
    /// <p>Specifies whether the import job registers the endpoints with Amazon Pinpoint, when the endpoint definitions are imported.</p>
    public let registerEndpoints: Bool
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
    public let roleArn: String?
    /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that contains the endpoint definitions to import. This location can be a folder or a single file. If the location is a folder, Amazon Pinpoint imports endpoint definitions from the files in this location, including any subfolders that the folder contains.</p> <p>The URL should be in the following format: s3://<replaceable>bucket-name</replaceable>/<replaceable>folder-name</replaceable>/<replaceable>file-name</replaceable>. The location can end with the key for an individual object or a prefix that qualifies multiple objects.</p>
    public let s3Url: String?
    /// <p>The identifier for the segment that the import job updates or adds endpoint definitions to, if the import job updates an existing segment.</p>
    public let segmentId: String?
    /// <p>The custom name for the segment that's created by the import job, if the value of the DefineSegment property is true.</p>
    public let segmentName: String?

    public init (
        defineSegment: Bool = false,
        externalId: String? = nil,
        format: Format? = nil,
        registerEndpoints: Bool = false,
        roleArn: String? = nil,
        s3Url: String? = nil,
        segmentId: String? = nil,
        segmentName: String? = nil
    )
    {
        self.defineSegment = defineSegment
        self.externalId = externalId
        self.format = format
        self.registerEndpoints = registerEndpoints
        self.roleArn = roleArn
        self.s3Url = s3Url
        self.segmentId = segmentId
        self.segmentName = segmentName
    }
}

extension ImportJobResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case completedPieces = "CompletedPieces"
        case completionDate = "CompletionDate"
        case creationDate = "CreationDate"
        case definition = "Definition"
        case failedPieces = "FailedPieces"
        case failures = "Failures"
        case id = "Id"
        case jobStatus = "JobStatus"
        case totalFailures = "TotalFailures"
        case totalPieces = "TotalPieces"
        case totalProcessed = "TotalProcessed"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if completedPieces != 0 {
            try encodeContainer.encode(completedPieces, forKey: .completedPieces)
        }
        if let completionDate = completionDate {
            try encodeContainer.encode(completionDate, forKey: .completionDate)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let definition = definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if failedPieces != 0 {
            try encodeContainer.encode(failedPieces, forKey: .failedPieces)
        }
        if let failures = failures {
            var failuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .failures)
            for listof__string0 in failures {
                try failuresContainer.encode(listof__string0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let jobStatus = jobStatus {
            try encodeContainer.encode(jobStatus.rawValue, forKey: .jobStatus)
        }
        if totalFailures != 0 {
            try encodeContainer.encode(totalFailures, forKey: .totalFailures)
        }
        if totalPieces != 0 {
            try encodeContainer.encode(totalPieces, forKey: .totalPieces)
        }
        if totalProcessed != 0 {
            try encodeContainer.encode(totalProcessed, forKey: .totalProcessed)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let completedPiecesDecoded = try containerValues.decode(Int.self, forKey: .completedPieces)
        completedPieces = completedPiecesDecoded
        let completionDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .completionDate)
        completionDate = completionDateDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(ImportJobResource.self, forKey: .definition)
        definition = definitionDecoded
        let failedPiecesDecoded = try containerValues.decode(Int.self, forKey: .failedPieces)
        failedPieces = failedPiecesDecoded
        let failuresContainer = try containerValues.decodeIfPresent([String?].self, forKey: .failures)
        var failuresDecoded0:[String]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [String]()
            for string0 in failuresContainer {
                if let string0 = string0 {
                    failuresDecoded0?.append(string0)
                }
            }
        }
        failures = failuresDecoded0
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let totalFailuresDecoded = try containerValues.decode(Int.self, forKey: .totalFailures)
        totalFailures = totalFailuresDecoded
        let totalPiecesDecoded = try containerValues.decode(Int.self, forKey: .totalPieces)
        totalPieces = totalPiecesDecoded
        let totalProcessedDecoded = try containerValues.decode(Int.self, forKey: .totalProcessed)
        totalProcessed = totalProcessedDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ImportJobResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportJobResponse(applicationId: \(String(describing: applicationId)), completedPieces: \(String(describing: completedPieces)), completionDate: \(String(describing: completionDate)), creationDate: \(String(describing: creationDate)), definition: \(String(describing: definition)), failedPieces: \(String(describing: failedPieces)), failures: \(String(describing: failures)), id: \(String(describing: id)), jobStatus: \(String(describing: jobStatus)), totalFailures: \(String(describing: totalFailures)), totalPieces: \(String(describing: totalPieces)), totalProcessed: \(String(describing: totalProcessed)), type: \(String(describing: type)))"}
}

/// <p>Provides information about the status and settings of a job that imports endpoint definitions from one or more files. The files can be stored in an Amazon Simple Storage Service (Amazon S3) bucket or uploaded directly from a computer by using the Amazon Pinpoint console.</p>
public struct ImportJobResponse: Equatable {
    /// <p>The unique identifier for the application that's associated with the import job.</p>
    public let applicationId: String?
    /// <p>The number of pieces that were processed successfully (completed) by the import job, as of the time of the request.</p>
    public let completedPieces: Int
    /// <p>The date, in ISO 8601 format, when the import job was completed.</p>
    public let completionDate: String?
    /// <p>The date, in ISO 8601 format, when the import job was created.</p>
    public let creationDate: String?
    /// <p>The resource settings that apply to the import job.</p>
    public let definition: ImportJobResource?
    /// <p>The number of pieces that weren't processed successfully (failed) by the import job, as of the time of the request.</p>
    public let failedPieces: Int
    /// <p>An array of entries, one for each of the first 100 entries that weren't processed successfully (failed) by the import job, if any.</p>
    public let failures: [String]?
    /// <p>The unique identifier for the import job.</p>
    public let id: String?
    /// <p>The status of the import job. The job status is FAILED if Amazon Pinpoint wasn't able to process one or more pieces in the job.</p>
    public let jobStatus: JobStatus?
    /// <p>The total number of endpoint definitions that weren't processed successfully (failed) by the import job, typically because an error, such as a syntax error, occurred.</p>
    public let totalFailures: Int
    /// <p>The total number of pieces that must be processed to complete the import job. Each piece consists of an approximately equal portion of the endpoint definitions that are part of the import job.</p>
    public let totalPieces: Int
    /// <p>The total number of endpoint definitions that were processed by the import job.</p>
    public let totalProcessed: Int
    /// <p>The job type. This value is IMPORT for import jobs.</p>
    public let type: String?

    public init (
        applicationId: String? = nil,
        completedPieces: Int = 0,
        completionDate: String? = nil,
        creationDate: String? = nil,
        definition: ImportJobResource? = nil,
        failedPieces: Int = 0,
        failures: [String]? = nil,
        id: String? = nil,
        jobStatus: JobStatus? = nil,
        totalFailures: Int = 0,
        totalPieces: Int = 0,
        totalProcessed: Int = 0,
        type: String? = nil
    )
    {
        self.applicationId = applicationId
        self.completedPieces = completedPieces
        self.completionDate = completionDate
        self.creationDate = creationDate
        self.definition = definition
        self.failedPieces = failedPieces
        self.failures = failures
        self.id = id
        self.jobStatus = jobStatus
        self.totalFailures = totalFailures
        self.totalPieces = totalPieces
        self.totalProcessed = totalProcessed
        self.type = type
    }
}

extension ImportJobsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofimportjobresponse0 in item {
                try itemContainer.encode(listofimportjobresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([ImportJobResponse?].self, forKey: .item)
        var itemDecoded0:[ImportJobResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [ImportJobResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ImportJobsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportJobsResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about the status and settings of all the import jobs that are associated with an application or segment. An import job is a job that imports endpoint definitions from one or more files.</p>
public struct ImportJobsResponse: Equatable {
    /// <p>An array of responses, one for each import job that's associated with the application (Import Jobs resource) or segment (Segment Import Jobs resource).</p>
    public let item: [ImportJobResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [ImportJobResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

public enum Include {
    case all
    case any
    case `none`
    case sdkUnknown(String)
}

extension Include : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Include] {
        return [
            .all,
            .any,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .any: return "ANY"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Include(rawValue: rawValue) ?? Include.sdkUnknown(rawValue)
    }
}

extension InternalServerErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerErrorException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension InternalServerErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct InternalServerErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct InternalServerErrorExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension InternalServerErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension ItemResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointItemResponse = "EndpointItemResponse"
        case eventsItemResponse = "EventsItemResponse"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointItemResponse = endpointItemResponse {
            try encodeContainer.encode(endpointItemResponse, forKey: .endpointItemResponse)
        }
        if let eventsItemResponse = eventsItemResponse {
            var eventsItemResponseContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .eventsItemResponse)
            for (dictKey0, mapofeventitemresponse0) in eventsItemResponse {
                try eventsItemResponseContainer.encode(mapofeventitemresponse0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointItemResponseDecoded = try containerValues.decodeIfPresent(EndpointItemResponse.self, forKey: .endpointItemResponse)
        endpointItemResponse = endpointItemResponseDecoded
        let eventsItemResponseContainer = try containerValues.decodeIfPresent([String: EventItemResponse?].self, forKey: .eventsItemResponse)
        var eventsItemResponseDecoded0: [String:EventItemResponse]? = nil
        if let eventsItemResponseContainer = eventsItemResponseContainer {
            eventsItemResponseDecoded0 = [String:EventItemResponse]()
            for (key0, eventitemresponse0) in eventsItemResponseContainer {
                if let eventitemresponse0 = eventitemresponse0 {
                    eventsItemResponseDecoded0?[key0] = eventitemresponse0
                }
            }
        }
        eventsItemResponse = eventsItemResponseDecoded0
    }
}

extension ItemResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ItemResponse(endpointItemResponse: \(String(describing: endpointItemResponse)), eventsItemResponse: \(String(describing: eventsItemResponse)))"}
}

/// <p>Provides information about the results of a request to create or update an endpoint that's associated with an event.</p>
public struct ItemResponse: Equatable {
    /// <p>The response that was received after the endpoint data was accepted.</p>
    public let endpointItemResponse: EndpointItemResponse?
    /// <p>A multipart response object that contains a key and a value for each event in the request. In each object, the event ID is the key and an EventItemResponse object is the value.</p>
    public let eventsItemResponse: [String:EventItemResponse]?

    public init (
        endpointItemResponse: EndpointItemResponse? = nil,
        eventsItemResponse: [String:EventItemResponse]? = nil
    )
    {
        self.endpointItemResponse = endpointItemResponse
        self.eventsItemResponse = eventsItemResponse
    }
}

public enum JobStatus {
    case completed
    case completing
    case created
    case failed
    case failing
    case initializing
    case pendingJob
    case preparingForInitialization
    case processing
    case sdkUnknown(String)
}

extension JobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [JobStatus] {
        return [
            .completed,
            .completing,
            .created,
            .failed,
            .failing,
            .initializing,
            .pendingJob,
            .preparingForInitialization,
            .processing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .completing: return "COMPLETING"
        case .created: return "CREATED"
        case .failed: return "FAILED"
        case .failing: return "FAILING"
        case .initializing: return "INITIALIZING"
        case .pendingJob: return "PENDING_JOB"
        case .preparingForInitialization: return "PREPARING_FOR_INITIALIZATION"
        case .processing: return "PROCESSING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
    }
}

extension JourneyCustomMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
    }
}

extension JourneyCustomMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyCustomMessage(data: \(String(describing: data)))"}
}

/// <p>Specifies the message content for a custom channel message that's sent to participants in a journey.</p>
public struct JourneyCustomMessage: Equatable {
    /// <p>The message content that's passed to an AWS Lambda function or to a web hook.</p>
    public let data: String?

    public init (
        data: String? = nil
    )
    {
        self.data = data
    }
}

extension JourneyDateRangeKpiResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case endTime = "EndTime"
        case journeyId = "JourneyId"
        case kpiName = "KpiName"
        case kpiResult = "KpiResult"
        case nextToken = "NextToken"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let journeyId = journeyId {
            try encodeContainer.encode(journeyId, forKey: .journeyId)
        }
        if let kpiName = kpiName {
            try encodeContainer.encode(kpiName, forKey: .kpiName)
        }
        if let kpiResult = kpiResult {
            try encodeContainer.encode(kpiResult, forKey: .kpiResult)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let journeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .journeyId)
        journeyId = journeyIdDecoded
        let kpiNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kpiName)
        kpiName = kpiNameDecoded
        let kpiResultDecoded = try containerValues.decodeIfPresent(BaseKpiResult.self, forKey: .kpiResult)
        kpiResult = kpiResultDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension JourneyDateRangeKpiResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyDateRangeKpiResponse(applicationId: \(String(describing: applicationId)), endTime: \(String(describing: endTime)), journeyId: \(String(describing: journeyId)), kpiName: \(String(describing: kpiName)), kpiResult: \(String(describing: kpiResult)), nextToken: \(String(describing: nextToken)), startTime: \(String(describing: startTime)))"}
}

/// <p>Provides the results of a query that retrieved the data for a standard engagement metric that applies to a journey, and provides information about that query.</p>
public struct JourneyDateRangeKpiResponse: Equatable {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    public let applicationId: String?
    /// <p>The last date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    public let endTime: Date?
    /// <p>The unique identifier for the journey that the metric applies to.</p>
    public let journeyId: String?
    /// <p>The name of the metric, also referred to as a <i>key performance indicator (KPI)</i>, that the data was retrieved for. This value describes the associated metric and consists of two or more terms, which are comprised of lowercase alphanumeric characters, separated by a hyphen. For a list of possible values, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let kpiName: String?
    /// <p>An array of objects that contains the results of the query. Each object contains the value for the metric and metadata about that value.</p>
    public let kpiResult: BaseKpiResult?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null for the Journey Engagement Metrics resource because the resource returns all results in a single page.</p>
    public let nextToken: String?
    /// <p>The first date and time of the date range that was used to filter the query results, in extended ISO 8601 format. The date range is inclusive.</p>
    public let startTime: Date?

    public init (
        applicationId: String? = nil,
        endTime: Date? = nil,
        journeyId: String? = nil,
        kpiName: String? = nil,
        kpiResult: BaseKpiResult? = nil,
        nextToken: String? = nil,
        startTime: Date? = nil
    )
    {
        self.applicationId = applicationId
        self.endTime = endTime
        self.journeyId = journeyId
        self.kpiName = kpiName
        self.kpiResult = kpiResult
        self.nextToken = nextToken
        self.startTime = startTime
    }
}

extension JourneyEmailMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fromAddress = "FromAddress"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromAddress = fromAddress {
            try encodeContainer.encode(fromAddress, forKey: .fromAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fromAddress)
        fromAddress = fromAddressDecoded
    }
}

extension JourneyEmailMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyEmailMessage(fromAddress: \(String(describing: fromAddress)))"}
}

/// <p>Specifies the "From" address for an email message that's sent to participants in a journey.</p>
public struct JourneyEmailMessage: Equatable {
    /// <p>The verified email address to send the email message from. The default address is the FromAddress specified for the email channel for the application.</p>
    public let fromAddress: String?

    public init (
        fromAddress: String? = nil
    )
    {
        self.fromAddress = fromAddress
    }
}

extension JourneyExecutionActivityMetricsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activityType = "ActivityType"
        case applicationId = "ApplicationId"
        case journeyActivityId = "JourneyActivityId"
        case journeyId = "JourneyId"
        case lastEvaluatedTime = "LastEvaluatedTime"
        case metrics = "Metrics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activityType = activityType {
            try encodeContainer.encode(activityType, forKey: .activityType)
        }
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let journeyActivityId = journeyActivityId {
            try encodeContainer.encode(journeyActivityId, forKey: .journeyActivityId)
        }
        if let journeyId = journeyId {
            try encodeContainer.encode(journeyId, forKey: .journeyId)
        }
        if let lastEvaluatedTime = lastEvaluatedTime {
            try encodeContainer.encode(lastEvaluatedTime, forKey: .lastEvaluatedTime)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__string0) in metrics {
                try metricsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activityTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .activityType)
        activityType = activityTypeDecoded
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let journeyActivityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .journeyActivityId)
        journeyActivityId = journeyActivityIdDecoded
        let journeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .journeyId)
        journeyId = journeyIdDecoded
        let lastEvaluatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastEvaluatedTime)
        lastEvaluatedTime = lastEvaluatedTimeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .metrics)
        var metricsDecoded0: [String:String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:String]()
            for (key0, __string0) in metricsContainer {
                if let __string0 = __string0 {
                    metricsDecoded0?[key0] = __string0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension JourneyExecutionActivityMetricsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyExecutionActivityMetricsResponse(activityType: \(String(describing: activityType)), applicationId: \(String(describing: applicationId)), journeyActivityId: \(String(describing: journeyActivityId)), journeyId: \(String(describing: journeyId)), lastEvaluatedTime: \(String(describing: lastEvaluatedTime)), metrics: \(String(describing: metrics)))"}
}

/// <p>Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey activity, and provides information about that query.</p>
public struct JourneyExecutionActivityMetricsResponse: Equatable {
    /// <p>The type of activity that the metric applies to. Possible values are:</p> <ul><li><p>CONDITIONAL_SPLIT - For a yes/no split activity, which is an activity that sends participants down one of two paths in a journey.</p></li> <li><p>HOLDOUT - For a holdout activity, which is an activity that stops a journey for a specified percentage of participants.</p></li> <li><p>MESSAGE - For an email activity, which is an activity that sends an email message to participants.</p></li> <li><p>MULTI_CONDITIONAL_SPLIT - For a multivariate split activity, which is an activity that sends participants down one of as many as five paths in a journey.</p></li> <li><p>RANDOM_SPLIT - For a random split activity, which is an activity that sends specified percentages of participants down one of as many as five paths in a journey.</p></li> <li><p>WAIT - For a wait activity, which is an activity that waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p></li></ul>
    public let activityType: String?
    /// <p>The unique identifier for the application that the metric applies to.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the activity that the metric applies to.</p>
    public let journeyActivityId: String?
    /// <p>The unique identifier for the journey that the metric applies to.</p>
    public let journeyId: String?
    /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the execution status of the activity and updated the data for the metric.</p>
    public let lastEvaluatedTime: String?
    /// <p>A JSON object that contains the results of the query. The results vary depending on the type of activity (ActivityType). For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let metrics: [String:String]?

    public init (
        activityType: String? = nil,
        applicationId: String? = nil,
        journeyActivityId: String? = nil,
        journeyId: String? = nil,
        lastEvaluatedTime: String? = nil,
        metrics: [String:String]? = nil
    )
    {
        self.activityType = activityType
        self.applicationId = applicationId
        self.journeyActivityId = journeyActivityId
        self.journeyId = journeyId
        self.lastEvaluatedTime = lastEvaluatedTime
        self.metrics = metrics
    }
}

extension JourneyExecutionMetricsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case journeyId = "JourneyId"
        case lastEvaluatedTime = "LastEvaluatedTime"
        case metrics = "Metrics"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let journeyId = journeyId {
            try encodeContainer.encode(journeyId, forKey: .journeyId)
        }
        if let lastEvaluatedTime = lastEvaluatedTime {
            try encodeContainer.encode(lastEvaluatedTime, forKey: .lastEvaluatedTime)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__string0) in metrics {
                try metricsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let journeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .journeyId)
        journeyId = journeyIdDecoded
        let lastEvaluatedTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastEvaluatedTime)
        lastEvaluatedTime = lastEvaluatedTimeDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .metrics)
        var metricsDecoded0: [String:String]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:String]()
            for (key0, __string0) in metricsContainer {
                if let __string0 = __string0 {
                    metricsDecoded0?[key0] = __string0
                }
            }
        }
        metrics = metricsDecoded0
    }
}

extension JourneyExecutionMetricsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyExecutionMetricsResponse(applicationId: \(String(describing: applicationId)), journeyId: \(String(describing: journeyId)), lastEvaluatedTime: \(String(describing: lastEvaluatedTime)), metrics: \(String(describing: metrics)))"}
}

/// <p>Provides the results of a query that retrieved the data for a standard execution metric that applies to a journey, and provides information about that query.</p>
public struct JourneyExecutionMetricsResponse: Equatable {
    /// <p>The unique identifier for the application that the metric applies to.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the journey that the metric applies to.</p>
    public let journeyId: String?
    /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint last evaluated the journey and updated the data for the metric.</p>
    public let lastEvaluatedTime: String?
    /// <p>A JSON object that contains the results of the query. For information about the structure and contents of the results, see the <a href="https://docs.aws.amazon.com//pinpoint/latest/developerguide/analytics-standard-metrics.html">Amazon Pinpoint Developer Guide</a>.</p>
    public let metrics: [String:String]?

    public init (
        applicationId: String? = nil,
        journeyId: String? = nil,
        lastEvaluatedTime: String? = nil,
        metrics: [String:String]? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.lastEvaluatedTime = lastEvaluatedTime
        self.metrics = metrics
    }
}

extension JourneyLimits: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dailyCap = "DailyCap"
        case endpointReentryCap = "EndpointReentryCap"
        case endpointReentryInterval = "EndpointReentryInterval"
        case messagesPerSecond = "MessagesPerSecond"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dailyCap != 0 {
            try encodeContainer.encode(dailyCap, forKey: .dailyCap)
        }
        if endpointReentryCap != 0 {
            try encodeContainer.encode(endpointReentryCap, forKey: .endpointReentryCap)
        }
        if let endpointReentryInterval = endpointReentryInterval {
            try encodeContainer.encode(endpointReentryInterval, forKey: .endpointReentryInterval)
        }
        if messagesPerSecond != 0 {
            try encodeContainer.encode(messagesPerSecond, forKey: .messagesPerSecond)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dailyCapDecoded = try containerValues.decode(Int.self, forKey: .dailyCap)
        dailyCap = dailyCapDecoded
        let endpointReentryCapDecoded = try containerValues.decode(Int.self, forKey: .endpointReentryCap)
        endpointReentryCap = endpointReentryCapDecoded
        let messagesPerSecondDecoded = try containerValues.decode(Int.self, forKey: .messagesPerSecond)
        messagesPerSecond = messagesPerSecondDecoded
        let endpointReentryIntervalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointReentryInterval)
        endpointReentryInterval = endpointReentryIntervalDecoded
    }
}

extension JourneyLimits: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyLimits(dailyCap: \(String(describing: dailyCap)), endpointReentryCap: \(String(describing: endpointReentryCap)), endpointReentryInterval: \(String(describing: endpointReentryInterval)), messagesPerSecond: \(String(describing: messagesPerSecond)))"}
}

/// <p>Specifies limits on the messages that a journey can send and the number of times participants can enter a journey.</p>
public struct JourneyLimits: Equatable {
    /// <p>The maximum number of messages that the journey can send to a single participant during a 24-hour period. The maximum value is 100.</p>
    public let dailyCap: Int
    /// <p>The maximum number of times that a participant can enter the journey. The maximum value is 100. To allow participants to enter the journey an unlimited number of times, set this value to 0.</p>
    public let endpointReentryCap: Int
    /// <p>Minimum time that must pass before an endpoint can re-enter a given journey. The duration should use an ISO 8601 format, such as PT1H. </p>
    public let endpointReentryInterval: String?
    /// <p>The maximum number of messages that the journey can send each second.</p>
    public let messagesPerSecond: Int

    public init (
        dailyCap: Int = 0,
        endpointReentryCap: Int = 0,
        endpointReentryInterval: String? = nil,
        messagesPerSecond: Int = 0
    )
    {
        self.dailyCap = dailyCap
        self.endpointReentryCap = endpointReentryCap
        self.endpointReentryInterval = endpointReentryInterval
        self.messagesPerSecond = messagesPerSecond
    }
}

extension JourneyPushMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case timeToLive = "TimeToLive"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeToLive = timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeToLiveDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
    }
}

extension JourneyPushMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyPushMessage(timeToLive: \(String(describing: timeToLive)))"}
}

/// <p>Specifies the message configuration for a push notification that's sent to participants in a journey.</p>
public struct JourneyPushMessage: Equatable {
    /// <p>The number of seconds that the push notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
    public let timeToLive: String?

    public init (
        timeToLive: String? = nil
    )
    {
        self.timeToLive = timeToLive
    }
}

extension JourneyResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activities = "Activities"
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case id = "Id"
        case lastModifiedDate = "LastModifiedDate"
        case limits = "Limits"
        case localTime = "LocalTime"
        case name = "Name"
        case quietTime = "QuietTime"
        case refreshFrequency = "RefreshFrequency"
        case refreshOnSegmentUpdate = "RefreshOnSegmentUpdate"
        case schedule = "Schedule"
        case startActivity = "StartActivity"
        case startCondition = "StartCondition"
        case state = "State"
        case waitForQuietTime = "WaitForQuietTime"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activities = activities {
            var activitiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .activities)
            for (dictKey0, mapofactivity0) in activities {
                try activitiesContainer.encode(mapofactivity0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let limits = limits {
            try encodeContainer.encode(limits, forKey: .limits)
        }
        if localTime != false {
            try encodeContainer.encode(localTime, forKey: .localTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quietTime = quietTime {
            try encodeContainer.encode(quietTime, forKey: .quietTime)
        }
        if let refreshFrequency = refreshFrequency {
            try encodeContainer.encode(refreshFrequency, forKey: .refreshFrequency)
        }
        if refreshOnSegmentUpdate != false {
            try encodeContainer.encode(refreshOnSegmentUpdate, forKey: .refreshOnSegmentUpdate)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let startActivity = startActivity {
            try encodeContainer.encode(startActivity, forKey: .startActivity)
        }
        if let startCondition = startCondition {
            try encodeContainer.encode(startCondition, forKey: .startCondition)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if waitForQuietTime != false {
            try encodeContainer.encode(waitForQuietTime, forKey: .waitForQuietTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activitiesContainer = try containerValues.decodeIfPresent([String: Activity?].self, forKey: .activities)
        var activitiesDecoded0: [String:Activity]? = nil
        if let activitiesContainer = activitiesContainer {
            activitiesDecoded0 = [String:Activity]()
            for (key0, activity0) in activitiesContainer {
                if let activity0 = activity0 {
                    activitiesDecoded0?[key0] = activity0
                }
            }
        }
        activities = activitiesDecoded0
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(JourneyLimits.self, forKey: .limits)
        limits = limitsDecoded
        let localTimeDecoded = try containerValues.decode(Bool.self, forKey: .localTime)
        localTime = localTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let quietTimeDecoded = try containerValues.decodeIfPresent(QuietTime.self, forKey: .quietTime)
        quietTime = quietTimeDecoded
        let refreshFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshFrequency)
        refreshFrequency = refreshFrequencyDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(JourneySchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let startActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startActivity)
        startActivity = startActivityDecoded
        let startConditionDecoded = try containerValues.decodeIfPresent(StartCondition.self, forKey: .startCondition)
        startCondition = startConditionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let waitForQuietTimeDecoded = try containerValues.decode(Bool.self, forKey: .waitForQuietTime)
        waitForQuietTime = waitForQuietTimeDecoded
        let refreshOnSegmentUpdateDecoded = try containerValues.decode(Bool.self, forKey: .refreshOnSegmentUpdate)
        refreshOnSegmentUpdate = refreshOnSegmentUpdateDecoded
    }
}

extension JourneyResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyResponse(activities: \(String(describing: activities)), applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), id: \(String(describing: id)), lastModifiedDate: \(String(describing: lastModifiedDate)), limits: \(String(describing: limits)), localTime: \(String(describing: localTime)), name: \(String(describing: name)), quietTime: \(String(describing: quietTime)), refreshFrequency: \(String(describing: refreshFrequency)), refreshOnSegmentUpdate: \(String(describing: refreshOnSegmentUpdate)), schedule: \(String(describing: schedule)), startActivity: \(String(describing: startActivity)), startCondition: \(String(describing: startCondition)), state: \(String(describing: state)), waitForQuietTime: \(String(describing: waitForQuietTime)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about the status, configuration, and other settings for a journey.</p>
public struct JourneyResponse: Equatable {
    /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity.</p>
    public let activities: [String:Activity]?
    /// <p>The unique identifier for the application that the journey applies to.</p>
    public let applicationId: String?
    /// <p>The date, in ISO 8601 format, when the journey was created.</p>
    public let creationDate: String?
    /// <p>The unique identifier for the journey.</p>
    public let id: String?
    /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The messaging and entry limits for the journey.</p>
    public let limits: JourneyLimits?
    /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. If this value is true, the schedule uses each participant's local time.</p>
    public let localTime: Bool
    /// <p>The name of the journey.</p>
    public let name: String?
    /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
    public let quietTime: QuietTime?
    /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
    public let refreshFrequency: String?
    /// <p>Specifies whether a journey should be refreshed on segment update.</p>
    public let refreshOnSegmentUpdate: Bool
    /// <p>The schedule settings for the journey.</p>
    public let schedule: JourneySchedule?
    /// <p>The unique identifier for the first activity in the journey.</p>
    public let startActivity: String?
    /// <p>The segment that defines which users are participants in the journey.</p>
    public let startCondition: StartCondition?
    /// <p>The current status of the journey. Possible values are:</p> <ul><li><p>DRAFT - The journey is being developed and hasn't been published yet.</p></li> <li><p>ACTIVE - The journey has been developed and published. Depending on the journey's schedule, the journey may currently be running or scheduled to start running at a later time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li> <li><p>COMPLETED - The journey has been published and has finished running. All participants have entered the journey and no participants are waiting to complete the journey or any activities in the journey.</p></li> <li><p>CANCELLED - The journey has been stopped. If a journey's status is CANCELLED, you can't add, change, or remove activities or segment settings from the journey.</p></li> <li><p>CLOSED - The journey has been published and has started running. It may have also passed its scheduled end time, or passed its scheduled start time and a refresh frequency hasn't been specified for it. If a journey's status is CLOSED, you can't add participants to it, and no existing participants can enter the journey for the first time. However, any existing participants who are currently waiting to start an activity may continue the journey.</p></li></ul>
    public let state: State?
    /// <p>This object is not used or supported.</p>
    public let tags: [String:String]?
    /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
    public let waitForQuietTime: Bool

    public init (
        activities: [String:Activity]? = nil,
        applicationId: String? = nil,
        creationDate: String? = nil,
        id: String? = nil,
        lastModifiedDate: String? = nil,
        limits: JourneyLimits? = nil,
        localTime: Bool = false,
        name: String? = nil,
        quietTime: QuietTime? = nil,
        refreshFrequency: String? = nil,
        refreshOnSegmentUpdate: Bool = false,
        schedule: JourneySchedule? = nil,
        startActivity: String? = nil,
        startCondition: StartCondition? = nil,
        state: State? = nil,
        tags: [String:String]? = nil,
        waitForQuietTime: Bool = false
    )
    {
        self.activities = activities
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.id = id
        self.lastModifiedDate = lastModifiedDate
        self.limits = limits
        self.localTime = localTime
        self.name = name
        self.quietTime = quietTime
        self.refreshFrequency = refreshFrequency
        self.refreshOnSegmentUpdate = refreshOnSegmentUpdate
        self.schedule = schedule
        self.startActivity = startActivity
        self.startCondition = startCondition
        self.state = state
        self.tags = tags
        self.waitForQuietTime = waitForQuietTime
    }
}

extension JourneySMSMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case entityId = "EntityId"
        case messageType = "MessageType"
        case originationNumber = "OriginationNumber"
        case senderId = "SenderId"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let originationNumber = originationNumber {
            try encodeContainer.encode(originationNumber, forKey: .originationNumber)
        }
        if let senderId = senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let originationNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originationNumber)
        originationNumber = originationNumberDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension JourneySMSMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneySMSMessage(entityId: \(String(describing: entityId)), messageType: \(String(describing: messageType)), originationNumber: \(String(describing: originationNumber)), senderId: \(String(describing: senderId)), templateId: \(String(describing: templateId)))"}
}

/// <p>Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.</p>
public struct JourneySMSMessage: Equatable {
    /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
    public let entityId: String?
    /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
    public let messageType: MessageType?
    /// <p>The long code to send the SMS message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code using an E.164 format to ensure prompt and accurate delivery of the message. For example, +12065550100.</p>
    public let originationNumber: String?
    /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/userguide/channels-sms-countries.html">Supported Countries and Regions</a> in the Amazon Pinpoint User Guide.</p>
    public let senderId: String?
    /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
    public let templateId: String?

    public init (
        entityId: String? = nil,
        messageType: MessageType? = nil,
        originationNumber: String? = nil,
        senderId: String? = nil,
        templateId: String? = nil
    )
    {
        self.entityId = entityId
        self.messageType = messageType
        self.originationNumber = originationNumber
        self.senderId = senderId
        self.templateId = templateId
    }
}

extension JourneySchedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

extension JourneySchedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneySchedule(endTime: \(String(describing: endTime)), startTime: \(String(describing: startTime)), timezone: \(String(describing: timezone)))"}
}

/// <p>Specifies the schedule settings for a journey.</p>
public struct JourneySchedule: Equatable {
    /// <p>The scheduled time, in ISO 8601 format, when the journey ended or will end.</p>
    public let endTime: Date?
    /// <p>The scheduled time, in ISO 8601 format, when the journey began or will begin.</p>
    public let startTime: Date?
    /// <p>The starting UTC offset for the journey schedule, if the value of the journey's LocalTime property is true. Valid values are: UTC,
    ///                   UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05, UTC+05:30,
    ///                   UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+08:45, UTC+09, UTC+09:30,
    ///                   UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+12:45, UTC+13, UTC+13:45, UTC-02,
    ///                   UTC-02:30, UTC-03, UTC-03:30, UTC-04, UTC-05, UTC-06, UTC-07, UTC-08, UTC-09,
    ///                   UTC-09:30, UTC-10, and UTC-11.</p>
    public let timezone: String?

    public init (
        endTime: Date? = nil,
        startTime: Date? = nil,
        timezone: String? = nil
    )
    {
        self.endTime = endTime
        self.startTime = startTime
        self.timezone = timezone
    }
}

extension JourneyStateRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
    }
}

extension JourneyStateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneyStateRequest(state: \(String(describing: state)))"}
}

/// <p>Changes the status of a journey.</p>
public struct JourneyStateRequest: Equatable {
    /// <p>The status of the journey. Currently, Supported values are ACTIVE, PAUSED, and CANCELLED</p> <p>If you cancel a journey, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Amazon Pinpoint also continues to collect and aggregate analytics data for those activities, until they are complete, and any activities that were complete when you cancelled the journey.</p> <p>After you cancel a journey, you can't add, change, or remove any activities from the journey. In addition, Amazon Pinpoint stops evaluating the journey and doesn't perform any activities that haven't started.</p> <p>When the journey is paused, Amazon Pinpoint continues to perform activities that are currently in progress, until those activities are complete. Endpoints will stop entering journeys when the journey is paused and will resume entering the journey after the journey is resumed. For wait activities, wait time is paused when the journey is paused. Currently, PAUSED only supports journeys with a segment refresh interval.</p>
    public let state: State?

    public init (
        state: State? = nil
    )
    {
        self.state = state
    }
}

extension JourneysResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofjourneyresponse0 in item {
                try itemContainer.encode(listofjourneyresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([JourneyResponse?].self, forKey: .item)
        var itemDecoded0:[JourneyResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [JourneyResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension JourneysResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "JourneysResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about the status, configuration, and other settings for all the journeys that are associated with an application.</p>
public struct JourneysResponse: Equatable {
    /// <p>An array of responses, one for each journey that's associated with the application.</p>
    public let item: [JourneyResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [JourneyResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

extension ListJourneysInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJourneysInput(applicationId: \(String(describing: applicationId)), pageSize: \(String(describing: pageSize)), token: \(String(describing: token)))"}
}

extension ListJourneysInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListJourneysInputHeadersMiddleware: Middleware {
    public let id: String = "ListJourneysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJourneysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJourneysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJourneysInput>
    public typealias MOutput = OperationOutput<ListJourneysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJourneysOutputError>
}

public struct ListJourneysInputQueryItemMiddleware: Middleware {
    public let id: String = "ListJourneysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListJourneysInput>,
                  next: H) -> Swift.Result<OperationOutput<ListJourneysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let token = input.operationInput.token {
            let tokenQueryItem = URLQueryItem(name: "token".urlPercentEncoding(), value: String(token).urlPercentEncoding())
            input.builder.withQueryItem(tokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListJourneysInput>
    public typealias MOutput = OperationOutput<ListJourneysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListJourneysOutputError>
}

public struct ListJourneysInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The NextToken string that specifies which page of results to return in a paginated response.</p>
    public let token: String?

    public init (
        applicationId: String? = nil,
        pageSize: String? = nil,
        token: String? = nil
    )
    {
        self.applicationId = applicationId
        self.pageSize = pageSize
        self.token = token
    }
}

struct ListJourneysInputBody: Equatable {
}

extension ListJourneysInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListJourneysOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListJourneysOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListJourneysOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListJourneysOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListJourneysOutputResponse(journeysResponse: \(String(describing: journeysResponse)))"}
}

extension ListJourneysOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneysResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeysResponse = output
            } else {
                self.journeysResponse = nil
            }
        } else {
            self.journeysResponse = nil
        }
    }
}

public struct ListJourneysOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for all the journeys that are associated with an application.</p>
    public let journeysResponse: JourneysResponse?

    public init (
        journeysResponse: JourneysResponse? = nil
    )
    {
        self.journeysResponse = journeysResponse
    }
}

struct ListJourneysOutputResponseBody: Equatable {
    public let journeysResponse: JourneysResponse?
}

extension ListJourneysOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeysResponse = "JourneysResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeysResponseDecoded = try containerValues.decodeIfPresent(JourneysResponse.self, forKey: .journeysResponse)
        journeysResponse = journeysResponseDecoded
    }
}

extension ListRecommenderConfigurationsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofrecommenderconfigurationresponse0 in item {
                try itemContainer.encode(listofrecommenderconfigurationresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([RecommenderConfigurationResponse?].self, forKey: .item)
        var itemDecoded0:[RecommenderConfigurationResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [RecommenderConfigurationResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommenderConfigurationsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRecommenderConfigurationsResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about all the recommender model configurations that are associated with your Amazon Pinpoint account.</p>
public struct ListRecommenderConfigurationsResponse: Equatable {
    /// <p>An array of responses, one for each recommender model configuration that's associated with your Amazon Pinpoint account.</p>
    public let item: [RecommenderConfigurationResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [RecommenderConfigurationResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagsModel: \(String(describing: tagsModel)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: TagsModel = try responseDecoder.decode(responseBody: unwrappedData)
                self.tagsModel = output
            } else {
                self.tagsModel = nil
            }
        } else {
            self.tagsModel = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>Specifies the tags (keys and values) for an application, campaign, message template, or segment.</p>
    public let tagsModel: TagsModel?

    public init (
        tagsModel: TagsModel? = nil
    )
    {
        self.tagsModel = tagsModel
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagsModel: TagsModel?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagsModel = "TagsModel"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsModelDecoded = try containerValues.decodeIfPresent(TagsModel.self, forKey: .tagsModel)
        tagsModel = tagsModelDecoded
    }
}

extension ListTemplateVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplateVersionsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)))"}
}

extension ListTemplateVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTemplateVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTemplateVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplateVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplateVersionsInput>
    public typealias MOutput = OperationOutput<ListTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplateVersionsOutputError>
}

public struct ListTemplateVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTemplateVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplateVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplateVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplateVersionsInput>
    public typealias MOutput = OperationOutput<ListTemplateVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplateVersionsOutputError>
}

public struct ListTemplateVersionsInput: Equatable {
    /// <p>The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let nextToken: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. Valid values are: EMAIL, PUSH, SMS, and VOICE.</p>
    public let templateType: String?

    public init (
        nextToken: String? = nil,
        pageSize: String? = nil,
        templateName: String? = nil,
        templateType: String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct ListTemplateVersionsInputBody: Equatable {
}

extension ListTemplateVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTemplateVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplateVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplateVersionsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplateVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplateVersionsOutputResponse(templateVersionsResponse: \(String(describing: templateVersionsResponse)))"}
}

extension ListTemplateVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: TemplateVersionsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.templateVersionsResponse = output
            } else {
                self.templateVersionsResponse = nil
            }
        } else {
            self.templateVersionsResponse = nil
        }
    }
}

public struct ListTemplateVersionsOutputResponse: Equatable {
    /// <p>Provides information about all the versions of a specific message template.</p>
    public let templateVersionsResponse: TemplateVersionsResponse?

    public init (
        templateVersionsResponse: TemplateVersionsResponse? = nil
    )
    {
        self.templateVersionsResponse = templateVersionsResponse
    }
}

struct ListTemplateVersionsOutputResponseBody: Equatable {
    public let templateVersionsResponse: TemplateVersionsResponse?
}

extension ListTemplateVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateVersionsResponse = "TemplateVersionsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateVersionsResponseDecoded = try containerValues.decodeIfPresent(TemplateVersionsResponse.self, forKey: .templateVersionsResponse)
        templateVersionsResponse = templateVersionsResponseDecoded
    }
}

extension ListTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplatesInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)), prefix: \(String(describing: prefix)), templateType: \(String(describing: templateType)))"}
}

extension ListTemplatesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplatesInput>
    public typealias MOutput = OperationOutput<ListTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplatesOutputError>
}

public struct ListTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "next-token".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "page-size".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        if let prefix = input.operationInput.prefix {
            let prefixQueryItem = URLQueryItem(name: "prefix".urlPercentEncoding(), value: String(prefix).urlPercentEncoding())
            input.builder.withQueryItem(prefixQueryItem)
        }
        if let templateType = input.operationInput.templateType {
            let templateTypeQueryItem = URLQueryItem(name: "template-type".urlPercentEncoding(), value: String(templateType).urlPercentEncoding())
            input.builder.withQueryItem(templateTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTemplatesInput>
    public typealias MOutput = OperationOutput<ListTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTemplatesOutputError>
}

public struct ListTemplatesInput: Equatable {
    /// <p>The  string that specifies which page of results to return in a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let nextToken: String?
    /// <p>The maximum number of items to include in each page of a paginated response. This parameter is not supported for application, campaign, and journey metrics.</p>
    public let pageSize: String?
    /// <p>The substring to match in the names of the message templates to include in the results. If you specify this value, Amazon Pinpoint returns only those templates whose names begin with the value that you specify.</p>
    public let prefix: String?
    /// <p>The type of message template to include in the results. Valid values are: EMAIL, PUSH, SMS, and VOICE. To include all types of templates in the results, don't include this parameter in your request.</p>
    public let templateType: String?

    public init (
        nextToken: String? = nil,
        pageSize: String? = nil,
        prefix: String? = nil,
        templateType: String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
        self.prefix = prefix
        self.templateType = templateType
    }
}

struct ListTemplatesInputBody: Equatable {
}

extension ListTemplatesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTemplatesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTemplatesOutputResponse(templatesResponse: \(String(describing: templatesResponse)))"}
}

extension ListTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: TemplatesResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.templatesResponse = output
            } else {
                self.templatesResponse = nil
            }
        } else {
            self.templatesResponse = nil
        }
    }
}

public struct ListTemplatesOutputResponse: Equatable {
    /// <p>Provides information about all the message templates that are associated with your Amazon Pinpoint account.</p>
    public let templatesResponse: TemplatesResponse?

    public init (
        templatesResponse: TemplatesResponse? = nil
    )
    {
        self.templatesResponse = templatesResponse
    }
}

struct ListTemplatesOutputResponseBody: Equatable {
    public let templatesResponse: TemplatesResponse?
}

extension ListTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templatesResponse = "TemplatesResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templatesResponseDecoded = try containerValues.decodeIfPresent(TemplatesResponse.self, forKey: .templatesResponse)
        templatesResponse = templatesResponseDecoded
    }
}

extension Message: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case body = "Body"
        case imageIconUrl = "ImageIconUrl"
        case imageSmallIconUrl = "ImageSmallIconUrl"
        case imageUrl = "ImageUrl"
        case jsonBody = "JsonBody"
        case mediaUrl = "MediaUrl"
        case rawContent = "RawContent"
        case silentPush = "SilentPush"
        case timeToLive = "TimeToLive"
        case title = "Title"
        case url = "Url"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let imageIconUrl = imageIconUrl {
            try encodeContainer.encode(imageIconUrl, forKey: .imageIconUrl)
        }
        if let imageSmallIconUrl = imageSmallIconUrl {
            try encodeContainer.encode(imageSmallIconUrl, forKey: .imageSmallIconUrl)
        }
        if let imageUrl = imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let jsonBody = jsonBody {
            try encodeContainer.encode(jsonBody, forKey: .jsonBody)
        }
        if let mediaUrl = mediaUrl {
            try encodeContainer.encode(mediaUrl, forKey: .mediaUrl)
        }
        if let rawContent = rawContent {
            try encodeContainer.encode(rawContent, forKey: .rawContent)
        }
        if silentPush != false {
            try encodeContainer.encode(silentPush, forKey: .silentPush)
        }
        if timeToLive != 0 {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(Action.self, forKey: .action)
        action = actionDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let imageIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageIconUrl)
        imageIconUrl = imageIconUrlDecoded
        let imageSmallIconUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageSmallIconUrl)
        imageSmallIconUrl = imageSmallIconUrlDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let jsonBodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jsonBody)
        jsonBody = jsonBodyDecoded
        let mediaUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaUrl)
        mediaUrl = mediaUrlDecoded
        let rawContentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawContent)
        rawContent = rawContentDecoded
        let silentPushDecoded = try containerValues.decode(Bool.self, forKey: .silentPush)
        silentPush = silentPushDecoded
        let timeToLiveDecoded = try containerValues.decode(Int.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

extension Message: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Message(action: \(String(describing: action)), body: \(String(describing: body)), imageIconUrl: \(String(describing: imageIconUrl)), imageSmallIconUrl: \(String(describing: imageSmallIconUrl)), imageUrl: \(String(describing: imageUrl)), jsonBody: \(String(describing: jsonBody)), mediaUrl: \(String(describing: mediaUrl)), rawContent: \(String(describing: rawContent)), silentPush: \(String(describing: silentPush)), timeToLive: \(String(describing: timeToLive)), title: \(String(describing: title)), url: \(String(describing: url)))"}
}

/// <p>Specifies the content and settings for a push notification that's sent to recipients of a campaign.</p>
public struct Message: Equatable {
    /// <p>The action to occur if a recipient taps the push notification. Valid values are:</p> <ul><li><p>OPEN_APP - Your app opens or it becomes the foreground app if it was sent to the background. This is the default action.</p></li> <li><p>DEEP_LINK - Your app opens and displays a designated user interface in the app. This setting uses the deep-linking features of iOS and Android.</p></li> <li><p>URL - The default mobile browser on the recipient's device opens and loads the web page at a URL that you specify.</p></li></ul>
    public let action: Action?
    /// <p>The body of the notification message. The maximum number of characters is 200.</p>
    public let body: String?
    /// <p>The URL of the image to display as the push-notification icon, such as the icon for the app.</p>
    public let imageIconUrl: String?
    /// <p>The URL of the image to display as the small, push-notification icon, such as a small version of the icon for the app.</p>
    public let imageSmallIconUrl: String?
    /// <p>The URL of an image to display in the push notification.</p>
    public let imageUrl: String?
    /// <p>The JSON payload to use for a silent push notification.</p>
    public let jsonBody: String?
    /// <p>The URL of the image or video to display in the push notification.</p>
    public let mediaUrl: String?
    /// <p>The raw, JSON-formatted string to use as the payload for the notification message. If specified, this value overrides all other content for the message.</p>
    public let rawContent: String?
    /// <p>Specifies whether the notification is a silent push notification, which is a push notification that doesn't display on a recipient's device. Silent push notifications can be used for cases such as updating an app's configuration, displaying messages in an in-app message center, or supporting phone home functionality.</p>
    public let silentPush: Bool
    /// <p>The number of seconds that the push-notification service should keep the message, if the service is unable to deliver the notification the first time. This value is converted to an expiration value when it's sent to a push-notification service. If this value is 0, the service treats the notification as if it expires immediately and the service doesn't store or try to deliver the notification again.</p> <p>This value doesn't apply to messages that are sent through the Amazon Device Messaging (ADM) service.</p>
    public let timeToLive: Int
    /// <p>The title to display above the notification message on a recipient's device.</p>
    public let title: String?
    /// <p>The URL to open in a recipient's default mobile browser, if a recipient taps the push notification and the value of the Action property is URL.</p>
    public let url: String?

    public init (
        action: Action? = nil,
        body: String? = nil,
        imageIconUrl: String? = nil,
        imageSmallIconUrl: String? = nil,
        imageUrl: String? = nil,
        jsonBody: String? = nil,
        mediaUrl: String? = nil,
        rawContent: String? = nil,
        silentPush: Bool = false,
        timeToLive: Int = 0,
        title: String? = nil,
        url: String? = nil
    )
    {
        self.action = action
        self.body = body
        self.imageIconUrl = imageIconUrl
        self.imageSmallIconUrl = imageSmallIconUrl
        self.imageUrl = imageUrl
        self.jsonBody = jsonBody
        self.mediaUrl = mediaUrl
        self.rawContent = rawContent
        self.silentPush = silentPush
        self.timeToLive = timeToLive
        self.title = title
        self.url = url
    }
}

extension MessageBody: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let requestID = requestID {
            try encodeContainer.encode(requestID, forKey: .requestID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension MessageBody: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageBody(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

/// <p>Provides information about an API request or response.</p>
public struct MessageBody: Equatable {
    /// <p>The message that's returned from the API.</p>
    public let message: String?
    /// <p>The unique identifier for the request or response.</p>
    public let requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

extension MessageConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aDMMessage = "ADMMessage"
        case aPNSMessage = "APNSMessage"
        case baiduMessage = "BaiduMessage"
        case customMessage = "CustomMessage"
        case defaultMessage = "DefaultMessage"
        case emailMessage = "EmailMessage"
        case gCMMessage = "GCMMessage"
        case sMSMessage = "SMSMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aDMMessage = aDMMessage {
            try encodeContainer.encode(aDMMessage, forKey: .aDMMessage)
        }
        if let aPNSMessage = aPNSMessage {
            try encodeContainer.encode(aPNSMessage, forKey: .aPNSMessage)
        }
        if let baiduMessage = baiduMessage {
            try encodeContainer.encode(baiduMessage, forKey: .baiduMessage)
        }
        if let customMessage = customMessage {
            try encodeContainer.encode(customMessage, forKey: .customMessage)
        }
        if let defaultMessage = defaultMessage {
            try encodeContainer.encode(defaultMessage, forKey: .defaultMessage)
        }
        if let emailMessage = emailMessage {
            try encodeContainer.encode(emailMessage, forKey: .emailMessage)
        }
        if let gCMMessage = gCMMessage {
            try encodeContainer.encode(gCMMessage, forKey: .gCMMessage)
        }
        if let sMSMessage = sMSMessage {
            try encodeContainer.encode(sMSMessage, forKey: .sMSMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMMessageDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .aDMMessage)
        aDMMessage = aDMMessageDecoded
        let aPNSMessageDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .aPNSMessage)
        aPNSMessage = aPNSMessageDecoded
        let baiduMessageDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .baiduMessage)
        baiduMessage = baiduMessageDecoded
        let customMessageDecoded = try containerValues.decodeIfPresent(CampaignCustomMessage.self, forKey: .customMessage)
        customMessage = customMessageDecoded
        let defaultMessageDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .defaultMessage)
        defaultMessage = defaultMessageDecoded
        let emailMessageDecoded = try containerValues.decodeIfPresent(CampaignEmailMessage.self, forKey: .emailMessage)
        emailMessage = emailMessageDecoded
        let gCMMessageDecoded = try containerValues.decodeIfPresent(Message.self, forKey: .gCMMessage)
        gCMMessage = gCMMessageDecoded
        let sMSMessageDecoded = try containerValues.decodeIfPresent(CampaignSmsMessage.self, forKey: .sMSMessage)
        sMSMessage = sMSMessageDecoded
    }
}

extension MessageConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageConfiguration(aDMMessage: \(String(describing: aDMMessage)), aPNSMessage: \(String(describing: aPNSMessage)), baiduMessage: \(String(describing: baiduMessage)), customMessage: \(String(describing: customMessage)), defaultMessage: \(String(describing: defaultMessage)), emailMessage: \(String(describing: emailMessage)), gCMMessage: \(String(describing: gCMMessage)), sMSMessage: \(String(describing: sMSMessage)))"}
}

/// <p>Specifies the message configuration settings for a campaign.</p>
public struct MessageConfiguration: Equatable {
    /// <p>The message that the campaign sends through the ADM (Amazon Device Messaging) channel. If specified, this message overrides the default message.</p>
    public let aDMMessage: Message?
    /// <p>The message that the campaign sends through the APNs (Apple Push Notification service) channel. If specified, this message overrides the default message.</p>
    public let aPNSMessage: Message?
    /// <p>The message that the campaign sends through the Baidu (Baidu Cloud Push) channel. If specified, this message overrides the default message.</p>
    public let baiduMessage: Message?
    /// <p>The message that the campaign sends through a custom channel, as specified by the delivery configuration (CustomDeliveryConfiguration) settings for the campaign. If specified, this message overrides the default message.</p>
    public let customMessage: CampaignCustomMessage?
    /// <p>The default message that the campaign sends through all the channels that are configured for the campaign.</p>
    public let defaultMessage: Message?
    /// <p>The message that the campaign sends through the email channel. If specified, this message overrides the default message.</p>
    public let emailMessage: CampaignEmailMessage?
    /// <p>The message that the campaign sends through the GCM channel, which enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. If specified, this message overrides the default message.</p>
    public let gCMMessage: Message?
    /// <p>The message that the campaign sends through the SMS channel. If specified, this message overrides the default message.</p>
    public let sMSMessage: CampaignSmsMessage?

    public init (
        aDMMessage: Message? = nil,
        aPNSMessage: Message? = nil,
        baiduMessage: Message? = nil,
        customMessage: CampaignCustomMessage? = nil,
        defaultMessage: Message? = nil,
        emailMessage: CampaignEmailMessage? = nil,
        gCMMessage: Message? = nil,
        sMSMessage: CampaignSmsMessage? = nil
    )
    {
        self.aDMMessage = aDMMessage
        self.aPNSMessage = aPNSMessage
        self.baiduMessage = baiduMessage
        self.customMessage = customMessage
        self.defaultMessage = defaultMessage
        self.emailMessage = emailMessage
        self.gCMMessage = gCMMessage
        self.sMSMessage = sMSMessage
    }
}

extension MessageRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addresses = "Addresses"
        case context = "Context"
        case endpoints = "Endpoints"
        case messageConfiguration = "MessageConfiguration"
        case templateConfiguration = "TemplateConfiguration"
        case traceId = "TraceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addresses = addresses {
            var addressesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .addresses)
            for (dictKey0, mapofaddressconfiguration0) in addresses {
                try addressesContainer.encode(mapofaddressconfiguration0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .context)
            for (dictKey0, mapof__string0) in context {
                try contextContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .endpoints)
            for (dictKey0, mapofendpointsendconfiguration0) in endpoints {
                try endpointsContainer.encode(mapofendpointsendconfiguration0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let messageConfiguration = messageConfiguration {
            try encodeContainer.encode(messageConfiguration, forKey: .messageConfiguration)
        }
        if let templateConfiguration = templateConfiguration {
            try encodeContainer.encode(templateConfiguration, forKey: .templateConfiguration)
        }
        if let traceId = traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressesContainer = try containerValues.decodeIfPresent([String: AddressConfiguration?].self, forKey: .addresses)
        var addressesDecoded0: [String:AddressConfiguration]? = nil
        if let addressesContainer = addressesContainer {
            addressesDecoded0 = [String:AddressConfiguration]()
            for (key0, addressconfiguration0) in addressesContainer {
                if let addressconfiguration0 = addressconfiguration0 {
                    addressesDecoded0?[key0] = addressconfiguration0
                }
            }
        }
        addresses = addressesDecoded0
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let endpointsContainer = try containerValues.decodeIfPresent([String: EndpointSendConfiguration?].self, forKey: .endpoints)
        var endpointsDecoded0: [String:EndpointSendConfiguration]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [String:EndpointSendConfiguration]()
            for (key0, endpointsendconfiguration0) in endpointsContainer {
                if let endpointsendconfiguration0 = endpointsendconfiguration0 {
                    endpointsDecoded0?[key0] = endpointsendconfiguration0
                }
            }
        }
        endpoints = endpointsDecoded0
        let messageConfigurationDecoded = try containerValues.decodeIfPresent(DirectMessageConfiguration.self, forKey: .messageConfiguration)
        messageConfiguration = messageConfigurationDecoded
        let templateConfigurationDecoded = try containerValues.decodeIfPresent(TemplateConfiguration.self, forKey: .templateConfiguration)
        templateConfiguration = templateConfigurationDecoded
        let traceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceId)
        traceId = traceIdDecoded
    }
}

extension MessageRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageRequest(addresses: \(String(describing: addresses)), context: \(String(describing: context)), endpoints: \(String(describing: endpoints)), messageConfiguration: \(String(describing: messageConfiguration)), templateConfiguration: \(String(describing: templateConfiguration)), traceId: \(String(describing: traceId)))"}
}

/// <p>Specifies the configuration and other settings for a message.</p>
public struct MessageRequest: Equatable {
    /// <p>A map of key-value pairs, where each key is an address and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object. An address can be a push notification token, a phone number, or an email address. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-addressconfiguration">AddressConfiguration</a> object to tailor the message for an address by specifying settings such as content overrides and message variables.</p>
    public let addresses: [String:AddressConfiguration]?
    /// <p>A map of custom attributes to attach to the message. For a push notification, this payload is added to the data.pinpoint object. For an email or text message, this payload is added to email/SMS delivery receipt event attributes.</p>
    public let context: [String:String]?
    /// <p>A map of key-value pairs, where each key is an endpoint ID and each value is an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for an endpoint by specifying settings such as content overrides and message variables.</p>
    public let endpoints: [String:EndpointSendConfiguration]?
    /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
    public let messageConfiguration: DirectMessageConfiguration?
    /// <p>The message template to use for the message.</p>
    public let templateConfiguration: TemplateConfiguration?
    /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
    public let traceId: String?

    public init (
        addresses: [String:AddressConfiguration]? = nil,
        context: [String:String]? = nil,
        endpoints: [String:EndpointSendConfiguration]? = nil,
        messageConfiguration: DirectMessageConfiguration? = nil,
        templateConfiguration: TemplateConfiguration? = nil,
        traceId: String? = nil
    )
    {
        self.addresses = addresses
        self.context = context
        self.endpoints = endpoints
        self.messageConfiguration = messageConfiguration
        self.templateConfiguration = templateConfiguration
        self.traceId = traceId
    }
}

extension MessageResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case endpointResult = "EndpointResult"
        case requestId = "RequestId"
        case result = "Result"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let endpointResult = endpointResult {
            var endpointResultContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .endpointResult)
            for (dictKey0, mapofendpointmessageresult0) in endpointResult {
                try endpointResultContainer.encode(mapofendpointmessageresult0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let result = result {
            var resultContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .result)
            for (dictKey0, mapofmessageresult0) in result {
                try resultContainer.encode(mapofmessageresult0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let endpointResultContainer = try containerValues.decodeIfPresent([String: EndpointMessageResult?].self, forKey: .endpointResult)
        var endpointResultDecoded0: [String:EndpointMessageResult]? = nil
        if let endpointResultContainer = endpointResultContainer {
            endpointResultDecoded0 = [String:EndpointMessageResult]()
            for (key0, endpointmessageresult0) in endpointResultContainer {
                if let endpointmessageresult0 = endpointmessageresult0 {
                    endpointResultDecoded0?[key0] = endpointmessageresult0
                }
            }
        }
        endpointResult = endpointResultDecoded0
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let resultContainer = try containerValues.decodeIfPresent([String: MessageResult?].self, forKey: .result)
        var resultDecoded0: [String:MessageResult]? = nil
        if let resultContainer = resultContainer {
            resultDecoded0 = [String:MessageResult]()
            for (key0, messageresult0) in resultContainer {
                if let messageresult0 = messageresult0 {
                    resultDecoded0?[key0] = messageresult0
                }
            }
        }
        result = resultDecoded0
    }
}

extension MessageResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageResponse(applicationId: \(String(describing: applicationId)), endpointResult: \(String(describing: endpointResult)), requestId: \(String(describing: requestId)), result: \(String(describing: result)))"}
}

/// <p>Provides information about the results of a request to send a message to an endpoint address.</p>
public struct MessageResponse: Equatable {
    /// <p>The unique identifier for the application that was used to send the message.</p>
    public let applicationId: String?
    /// <p>A map that contains a multipart response for each address that the message was sent to. In the map, the endpoint ID is the key and the result is the value.</p>
    public let endpointResult: [String:EndpointMessageResult]?
    /// <p>The identifier for the original request that the message was delivered for.</p>
    public let requestId: String?
    /// <p>A map that contains a multipart response for each address (email address, phone number, or push notification token) that the message was sent to. In the map, the address is the key and the result is the value.</p>
    public let result: [String:MessageResult]?

    public init (
        applicationId: String? = nil,
        endpointResult: [String:EndpointMessageResult]? = nil,
        requestId: String? = nil,
        result: [String:MessageResult]? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointResult = endpointResult
        self.requestId = requestId
        self.result = result
    }
}

extension MessageResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryStatus = "DeliveryStatus"
        case messageId = "MessageId"
        case statusCode = "StatusCode"
        case statusMessage = "StatusMessage"
        case updatedToken = "UpdatedToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStatus = deliveryStatus {
            try encodeContainer.encode(deliveryStatus.rawValue, forKey: .deliveryStatus)
        }
        if let messageId = messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if statusCode != 0 {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let updatedToken = updatedToken {
            try encodeContainer.encode(updatedToken, forKey: .updatedToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStatusDecoded = try containerValues.decodeIfPresent(DeliveryStatus.self, forKey: .deliveryStatus)
        deliveryStatus = deliveryStatusDecoded
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let updatedTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .updatedToken)
        updatedToken = updatedTokenDecoded
    }
}

extension MessageResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MessageResult(deliveryStatus: \(String(describing: deliveryStatus)), messageId: \(String(describing: messageId)), statusCode: \(String(describing: statusCode)), statusMessage: \(String(describing: statusMessage)), updatedToken: \(String(describing: updatedToken)))"}
}

/// <p>Provides information about the results of sending a message directly to an endpoint address.</p>
public struct MessageResult: Equatable {
    /// <p>The delivery status of the message. Possible values are:</p> <ul> <li><p>DUPLICATE - The endpoint address is a duplicate of another endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>OPT_OUT - The user who's associated with the endpoint address has opted out of receiving messages from you. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>PERMANENT_FAILURE - An error occurred when delivering the message to the endpoint address. Amazon Pinpoint won't attempt to send the message again.</p></li>   <li><p>SUCCESSFUL - The message was successfully delivered to the endpoint address.</p></li> <li><p>TEMPORARY_FAILURE - A temporary error occurred. Amazon Pinpoint won't attempt to send the message again.</p></li> <li><p>THROTTLED - Amazon Pinpoint throttled the operation to send the message to the endpoint address.</p></li> <li><p>TIMEOUT - The message couldn't be sent within the timeout period.</p></li> <li><p>UNKNOWN_FAILURE - An unknown error occurred.</p></li></ul>
    public let deliveryStatus: DeliveryStatus?
    /// <p>The unique identifier for the message that was sent.</p>
    public let messageId: String?
    /// <p>The downstream service status code for delivering the message.</p>
    public let statusCode: Int
    /// <p>The status message for delivering the message.</p>
    public let statusMessage: String?
    /// <p>For push notifications that are sent through the GCM channel, specifies whether the endpoint's device registration token was updated as part of delivering the message.</p>
    public let updatedToken: String?

    public init (
        deliveryStatus: DeliveryStatus? = nil,
        messageId: String? = nil,
        statusCode: Int = 0,
        statusMessage: String? = nil,
        updatedToken: String? = nil
    )
    {
        self.deliveryStatus = deliveryStatus
        self.messageId = messageId
        self.statusCode = statusCode
        self.statusMessage = statusMessage
        self.updatedToken = updatedToken
    }
}

public enum MessageType {
    case promotional
    case transactional
    case sdkUnknown(String)
}

extension MessageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MessageType] {
        return [
            .promotional,
            .transactional,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .promotional: return "PROMOTIONAL"
        case .transactional: return "TRANSACTIONAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MessageType(rawValue: rawValue) ?? MessageType.sdkUnknown(rawValue)
    }
}

extension MethodNotAllowedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MethodNotAllowedException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension MethodNotAllowedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: MethodNotAllowedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct MethodNotAllowedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct MethodNotAllowedExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension MethodNotAllowedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension MetricDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = comparisonOperator {
            try encodeContainer.encode(comparisonOperator, forKey: .comparisonOperator)
        }
        if value != 0.0 {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let valueDecoded = try containerValues.decode(Double.self, forKey: .value)
        value = valueDecoded
    }
}

extension MetricDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MetricDimension(comparisonOperator: \(String(describing: comparisonOperator)), value: \(String(describing: value)))"}
}

/// <p>Specifies metric-based criteria for including or excluding endpoints from a segment. These criteria derive from custom metrics that you define for endpoints.</p>
public struct MetricDimension: Equatable {
    /// <p>The operator to use when comparing metric values. Valid values are: GREATER_THAN, LESS_THAN, GREATER_THAN_OR_EQUAL, LESS_THAN_OR_EQUAL, and EQUAL.</p>
    public let comparisonOperator: String?
    /// <p>The value to compare.</p>
    public let value: Double

    public init (
        comparisonOperator: String? = nil,
        value: Double = 0.0
    )
    {
        self.comparisonOperator = comparisonOperator
        self.value = value
    }
}

public enum Mode {
    case delivery
    case filter
    case sdkUnknown(String)
}

extension Mode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Mode] {
        return [
            .delivery,
            .filter,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delivery: return "DELIVERY"
        case .filter: return "FILTER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Mode(rawValue: rawValue) ?? Mode.sdkUnknown(rawValue)
    }
}

extension MultiConditionalBranch: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition = "Condition"
        case nextActivity = "NextActivity"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(SimpleCondition.self, forKey: .condition)
        condition = conditionDecoded
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
    }
}

extension MultiConditionalBranch: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MultiConditionalBranch(condition: \(String(describing: condition)), nextActivity: \(String(describing: nextActivity)))"}
}

/// <p>Specifies a condition to evaluate for an activity path in a journey.</p>
public struct MultiConditionalBranch: Equatable {
    /// <p>The condition to evaluate for the activity path.</p>
    public let condition: SimpleCondition?
    /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
    public let nextActivity: String?

    public init (
        condition: SimpleCondition? = nil,
        nextActivity: String? = nil
    )
    {
        self.condition = condition
        self.nextActivity = nextActivity
    }
}

extension MultiConditionalSplitActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branches = "Branches"
        case defaultActivity = "DefaultActivity"
        case evaluationWaitTime = "EvaluationWaitTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branches = branches {
            var branchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .branches)
            for listofmulticonditionalbranch0 in branches {
                try branchesContainer.encode(listofmulticonditionalbranch0)
            }
        }
        if let defaultActivity = defaultActivity {
            try encodeContainer.encode(defaultActivity, forKey: .defaultActivity)
        }
        if let evaluationWaitTime = evaluationWaitTime {
            try encodeContainer.encode(evaluationWaitTime, forKey: .evaluationWaitTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchesContainer = try containerValues.decodeIfPresent([MultiConditionalBranch?].self, forKey: .branches)
        var branchesDecoded0:[MultiConditionalBranch]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [MultiConditionalBranch]()
            for structure0 in branchesContainer {
                if let structure0 = structure0 {
                    branchesDecoded0?.append(structure0)
                }
            }
        }
        branches = branchesDecoded0
        let defaultActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultActivity)
        defaultActivity = defaultActivityDecoded
        let evaluationWaitTimeDecoded = try containerValues.decodeIfPresent(WaitTime.self, forKey: .evaluationWaitTime)
        evaluationWaitTime = evaluationWaitTimeDecoded
    }
}

extension MultiConditionalSplitActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "MultiConditionalSplitActivity(branches: \(String(describing: branches)), defaultActivity: \(String(describing: defaultActivity)), evaluationWaitTime: \(String(describing: evaluationWaitTime)))"}
}

/// <p>Specifies the settings for a multivariate split activity in a journey. This type of activity sends participants down one of as many as five paths (including a default <i>Else</i> path) in a journey, based on conditions that you specify.</p> <note><p>To create multivariate split activities that send participants down different paths based on push notification events (such as Open or Received events), your mobile app has to specify the User ID and Endpoint ID values. For more information, see <a href="https://docs.aws.amazon.com/pinpoint/latest/developerguide/integrate.html">Integrating Amazon Pinpoint with your application</a> in the <i>Amazon Pinpoint Developer Guide</i>.</p></note>
public struct MultiConditionalSplitActivity: Equatable {
    /// <p>The paths for the activity, including the conditions for entering each path and the activity to perform for each path.</p>
    public let branches: [MultiConditionalBranch]?
    /// <p>The unique identifier for the activity to perform for participants who don't meet any of the conditions specified for other paths in the activity.</p>
    public let defaultActivity: String?
    /// <p>The amount of time to wait or the date and time when Amazon Pinpoint determines whether the conditions are met.</p>
    public let evaluationWaitTime: WaitTime?

    public init (
        branches: [MultiConditionalBranch]? = nil,
        defaultActivity: String? = nil,
        evaluationWaitTime: WaitTime? = nil
    )
    {
        self.branches = branches
        self.defaultActivity = defaultActivity
        self.evaluationWaitTime = evaluationWaitTime
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension NumberValidateRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case isoCountryCode = "IsoCountryCode"
        case phoneNumber = "PhoneNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isoCountryCode = isoCountryCode {
            try encodeContainer.encode(isoCountryCode, forKey: .isoCountryCode)
        }
        if let phoneNumber = phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isoCountryCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .isoCountryCode)
        isoCountryCode = isoCountryCodeDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
    }
}

extension NumberValidateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberValidateRequest(isoCountryCode: \(String(describing: isoCountryCode)), phoneNumber: \(String(describing: phoneNumber)))"}
}

/// <p>Specifies a phone number to validate and retrieve information about.</p>
public struct NumberValidateRequest: Equatable {
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
    public let isoCountryCode: String?
    /// <p>The phone number to retrieve information about. The phone number that you provide should include a valid numeric country code. Otherwise, the operation might result in an error.</p>
    public let phoneNumber: String?

    public init (
        isoCountryCode: String? = nil,
        phoneNumber: String? = nil
    )
    {
        self.isoCountryCode = isoCountryCode
        self.phoneNumber = phoneNumber
    }
}

extension NumberValidateResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case carrier = "Carrier"
        case city = "City"
        case cleansedPhoneNumberE164 = "CleansedPhoneNumberE164"
        case cleansedPhoneNumberNational = "CleansedPhoneNumberNational"
        case country = "Country"
        case countryCodeIso2 = "CountryCodeIso2"
        case countryCodeNumeric = "CountryCodeNumeric"
        case county = "County"
        case originalCountryCodeIso2 = "OriginalCountryCodeIso2"
        case originalPhoneNumber = "OriginalPhoneNumber"
        case phoneType = "PhoneType"
        case phoneTypeCode = "PhoneTypeCode"
        case timezone = "Timezone"
        case zipCode = "ZipCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let carrier = carrier {
            try encodeContainer.encode(carrier, forKey: .carrier)
        }
        if let city = city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let cleansedPhoneNumberE164 = cleansedPhoneNumberE164 {
            try encodeContainer.encode(cleansedPhoneNumberE164, forKey: .cleansedPhoneNumberE164)
        }
        if let cleansedPhoneNumberNational = cleansedPhoneNumberNational {
            try encodeContainer.encode(cleansedPhoneNumberNational, forKey: .cleansedPhoneNumberNational)
        }
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let countryCodeIso2 = countryCodeIso2 {
            try encodeContainer.encode(countryCodeIso2, forKey: .countryCodeIso2)
        }
        if let countryCodeNumeric = countryCodeNumeric {
            try encodeContainer.encode(countryCodeNumeric, forKey: .countryCodeNumeric)
        }
        if let county = county {
            try encodeContainer.encode(county, forKey: .county)
        }
        if let originalCountryCodeIso2 = originalCountryCodeIso2 {
            try encodeContainer.encode(originalCountryCodeIso2, forKey: .originalCountryCodeIso2)
        }
        if let originalPhoneNumber = originalPhoneNumber {
            try encodeContainer.encode(originalPhoneNumber, forKey: .originalPhoneNumber)
        }
        if let phoneType = phoneType {
            try encodeContainer.encode(phoneType, forKey: .phoneType)
        }
        if phoneTypeCode != 0 {
            try encodeContainer.encode(phoneTypeCode, forKey: .phoneTypeCode)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
        if let zipCode = zipCode {
            try encodeContainer.encode(zipCode, forKey: .zipCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let carrierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .carrier)
        carrier = carrierDecoded
        let cityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .city)
        city = cityDecoded
        let cleansedPhoneNumberE164Decoded = try containerValues.decodeIfPresent(String.self, forKey: .cleansedPhoneNumberE164)
        cleansedPhoneNumberE164 = cleansedPhoneNumberE164Decoded
        let cleansedPhoneNumberNationalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cleansedPhoneNumberNational)
        cleansedPhoneNumberNational = cleansedPhoneNumberNationalDecoded
        let countryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .country)
        country = countryDecoded
        let countryCodeIso2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .countryCodeIso2)
        countryCodeIso2 = countryCodeIso2Decoded
        let countryCodeNumericDecoded = try containerValues.decodeIfPresent(String.self, forKey: .countryCodeNumeric)
        countryCodeNumeric = countryCodeNumericDecoded
        let countyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .county)
        county = countyDecoded
        let originalCountryCodeIso2Decoded = try containerValues.decodeIfPresent(String.self, forKey: .originalCountryCodeIso2)
        originalCountryCodeIso2 = originalCountryCodeIso2Decoded
        let originalPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originalPhoneNumber)
        originalPhoneNumber = originalPhoneNumberDecoded
        let phoneTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .phoneType)
        phoneType = phoneTypeDecoded
        let phoneTypeCodeDecoded = try containerValues.decode(Int.self, forKey: .phoneTypeCode)
        phoneTypeCode = phoneTypeCodeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
        let zipCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zipCode)
        zipCode = zipCodeDecoded
    }
}

extension NumberValidateResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NumberValidateResponse(carrier: \(String(describing: carrier)), city: \(String(describing: city)), cleansedPhoneNumberE164: \(String(describing: cleansedPhoneNumberE164)), cleansedPhoneNumberNational: \(String(describing: cleansedPhoneNumberNational)), country: \(String(describing: country)), countryCodeIso2: \(String(describing: countryCodeIso2)), countryCodeNumeric: \(String(describing: countryCodeNumeric)), county: \(String(describing: county)), originalCountryCodeIso2: \(String(describing: originalCountryCodeIso2)), originalPhoneNumber: \(String(describing: originalPhoneNumber)), phoneType: \(String(describing: phoneType)), phoneTypeCode: \(String(describing: phoneTypeCode)), timezone: \(String(describing: timezone)), zipCode: \(String(describing: zipCode)))"}
}

/// <p>Provides information about a phone number.</p>
public struct NumberValidateResponse: Equatable {
    /// <p>The carrier or service provider that the phone number is currently registered with. In some countries and regions, this value may be the carrier or service provider that the phone number was originally registered with.</p>
    public let carrier: String?
    /// <p>The name of the city where the phone number was originally registered.</p>
    public let city: String?
    /// <p>The cleansed phone number, in E.164 format, for the location where the phone number was originally registered.</p>
    public let cleansedPhoneNumberE164: String?
    /// <p>The cleansed phone number, in the format for the location where the phone number was originally registered.</p>
    public let cleansedPhoneNumberNational: String?
    /// <p>The name of the country or region where the phone number was originally registered.</p>
    public let country: String?
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, for the country or region where the phone number was originally registered.</p>
    public let countryCodeIso2: String?
    /// <p>The numeric code for the country or region where the phone number was originally registered.</p>
    public let countryCodeNumeric: String?
    /// <p>The name of the county where the phone number was originally registered.</p>
    public let county: String?
    /// <p>The two-character code, in ISO 3166-1 alpha-2 format, that was sent in the request body.</p>
    public let originalCountryCodeIso2: String?
    /// <p>The phone number that was sent in the request body.</p>
    public let originalPhoneNumber: String?
    /// <p>The description of the phone type. Valid values are: MOBILE, LANDLINE, VOIP,
    ///                   INVALID, PREPAID, and OTHER.</p>
    public let phoneType: String?
    /// <p>The phone type, represented by an integer. Valid values are: 0 (mobile), 1 (landline), 2 (VoIP), 3 (invalid), 4 (other), and 5 (prepaid).</p>
    public let phoneTypeCode: Int
    /// <p>The time zone for the location where the phone number was originally registered.</p>
    public let timezone: String?
    /// <p>The postal or ZIP code for the location where the phone number was originally registered.</p>
    public let zipCode: String?

    public init (
        carrier: String? = nil,
        city: String? = nil,
        cleansedPhoneNumberE164: String? = nil,
        cleansedPhoneNumberNational: String? = nil,
        country: String? = nil,
        countryCodeIso2: String? = nil,
        countryCodeNumeric: String? = nil,
        county: String? = nil,
        originalCountryCodeIso2: String? = nil,
        originalPhoneNumber: String? = nil,
        phoneType: String? = nil,
        phoneTypeCode: Int = 0,
        timezone: String? = nil,
        zipCode: String? = nil
    )
    {
        self.carrier = carrier
        self.city = city
        self.cleansedPhoneNumberE164 = cleansedPhoneNumberE164
        self.cleansedPhoneNumberNational = cleansedPhoneNumberNational
        self.country = country
        self.countryCodeIso2 = countryCodeIso2
        self.countryCodeNumeric = countryCodeNumeric
        self.county = county
        self.originalCountryCodeIso2 = originalCountryCodeIso2
        self.originalPhoneNumber = originalPhoneNumber
        self.phoneType = phoneType
        self.phoneTypeCode = phoneTypeCode
        self.timezone = timezone
        self.zipCode = zipCode
    }
}

public enum Operator {
    case all
    case any
    case sdkUnknown(String)
}

extension Operator : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Operator] {
        return [
            .all,
            .any,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .any: return "ANY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Operator(rawValue: rawValue) ?? Operator.sdkUnknown(rawValue)
    }
}

extension PayloadTooLargeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PayloadTooLargeException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension PayloadTooLargeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PayloadTooLargeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct PayloadTooLargeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct PayloadTooLargeExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension PayloadTooLargeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

public struct PhoneNumberValidateInputBodyMiddleware: Middleware {
    public let id: String = "PhoneNumberValidateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PhoneNumberValidateInput>,
                  next: H) -> Swift.Result<OperationOutput<PhoneNumberValidateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let numberValidateRequest = input.operationInput.numberValidateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(numberValidateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PhoneNumberValidateInput>
    public typealias MOutput = OperationOutput<PhoneNumberValidateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PhoneNumberValidateOutputError>
}

extension PhoneNumberValidateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhoneNumberValidateInput(numberValidateRequest: \(String(describing: numberValidateRequest)))"}
}

extension PhoneNumberValidateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case numberValidateRequest = "NumberValidateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberValidateRequest = numberValidateRequest {
            try encodeContainer.encode(numberValidateRequest, forKey: .numberValidateRequest)
        }
    }
}

public struct PhoneNumberValidateInputHeadersMiddleware: Middleware {
    public let id: String = "PhoneNumberValidateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PhoneNumberValidateInput>,
                  next: H) -> Swift.Result<OperationOutput<PhoneNumberValidateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PhoneNumberValidateInput>
    public typealias MOutput = OperationOutput<PhoneNumberValidateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PhoneNumberValidateOutputError>
}

public struct PhoneNumberValidateInputQueryItemMiddleware: Middleware {
    public let id: String = "PhoneNumberValidateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PhoneNumberValidateInput>,
                  next: H) -> Swift.Result<OperationOutput<PhoneNumberValidateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PhoneNumberValidateInput>
    public typealias MOutput = OperationOutput<PhoneNumberValidateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PhoneNumberValidateOutputError>
}

public struct PhoneNumberValidateInput: Equatable {
    /// <p>Specifies a phone number to validate and retrieve information about.</p>
    public let numberValidateRequest: NumberValidateRequest?

    public init (
        numberValidateRequest: NumberValidateRequest? = nil
    )
    {
        self.numberValidateRequest = numberValidateRequest
    }
}

struct PhoneNumberValidateInputBody: Equatable {
    public let numberValidateRequest: NumberValidateRequest?
}

extension PhoneNumberValidateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case numberValidateRequest = "NumberValidateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberValidateRequestDecoded = try containerValues.decodeIfPresent(NumberValidateRequest.self, forKey: .numberValidateRequest)
        numberValidateRequest = numberValidateRequestDecoded
    }
}

extension PhoneNumberValidateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PhoneNumberValidateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PhoneNumberValidateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PhoneNumberValidateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PhoneNumberValidateOutputResponse(numberValidateResponse: \(String(describing: numberValidateResponse)))"}
}

extension PhoneNumberValidateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: NumberValidateResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.numberValidateResponse = output
            } else {
                self.numberValidateResponse = nil
            }
        } else {
            self.numberValidateResponse = nil
        }
    }
}

public struct PhoneNumberValidateOutputResponse: Equatable {
    /// <p>Provides information about a phone number.</p>
    public let numberValidateResponse: NumberValidateResponse?

    public init (
        numberValidateResponse: NumberValidateResponse? = nil
    )
    {
        self.numberValidateResponse = numberValidateResponse
    }
}

struct PhoneNumberValidateOutputResponseBody: Equatable {
    public let numberValidateResponse: NumberValidateResponse?
}

extension PhoneNumberValidateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case numberValidateResponse = "NumberValidateResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberValidateResponseDecoded = try containerValues.decodeIfPresent(NumberValidateResponse.self, forKey: .numberValidateResponse)
        numberValidateResponse = numberValidateResponseDecoded
    }
}

extension PublicEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case attributes = "Attributes"
        case channelType = "ChannelType"
        case demographic = "Demographic"
        case effectiveDate = "EffectiveDate"
        case endpointStatus = "EndpointStatus"
        case location = "Location"
        case metrics = "Metrics"
        case optOut = "OptOut"
        case requestId = "RequestId"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapoflistof__string0) in attributes {
                try attributesContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let demographic = demographic {
            try encodeContainer.encode(demographic, forKey: .demographic)
        }
        if let effectiveDate = effectiveDate {
            try encodeContainer.encode(effectiveDate, forKey: .effectiveDate)
        }
        if let endpointStatus = endpointStatus {
            try encodeContainer.encode(endpointStatus, forKey: .endpointStatus)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__double0) in metrics {
                try metricsContainer.encode(mapof__double0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let optOut = optOut {
            try encodeContainer.encode(optOut, forKey: .optOut)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .attributes)
        var attributesDecoded0: [String:[String]]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:[String]]()
            for (key0, listof__string0) in attributesContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                attributesDecoded0?[key0] = listof__string0Decoded0
            }
        }
        attributes = attributesDecoded0
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let demographicDecoded = try containerValues.decodeIfPresent(EndpointDemographic.self, forKey: .demographic)
        demographic = demographicDecoded
        let effectiveDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveDate)
        effectiveDate = effectiveDateDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let locationDecoded = try containerValues.decodeIfPresent(EndpointLocation.self, forKey: .location)
        location = locationDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: Double?].self, forKey: .metrics)
        var metricsDecoded0: [String:Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:Double]()
            for (key0, __double0) in metricsContainer {
                if let __double0 = __double0 {
                    metricsDecoded0?[key0] = __double0
                }
            }
        }
        metrics = metricsDecoded0
        let optOutDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optOut)
        optOut = optOutDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(EndpointUser.self, forKey: .user)
        user = userDecoded
    }
}

extension PublicEndpoint: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublicEndpoint(address: \(String(describing: address)), attributes: \(String(describing: attributes)), channelType: \(String(describing: channelType)), demographic: \(String(describing: demographic)), effectiveDate: \(String(describing: effectiveDate)), endpointStatus: \(String(describing: endpointStatus)), location: \(String(describing: location)), metrics: \(String(describing: metrics)), optOut: \(String(describing: optOut)), requestId: \(String(describing: requestId)), user: \(String(describing: user)))"}
}

/// <p>Specifies the properties and attributes of an endpoint that's associated with an event.</p>
public struct PublicEndpoint: Equatable {
    /// <p>The unique identifier for the recipient, such as a device token, email address, or mobile phone number.</p>
    public let address: String?
    /// <p>One or more custom attributes that describe the endpoint by associating a name with an array of values. You can use these attributes as filter criteria when you create segments.</p>
    public let attributes: [String:[String]]?
    /// <p>The channel that's used when sending messages or push notifications to the endpoint.</p>
    public let channelType: ChannelType?
    /// <p>The demographic information for the endpoint, such as the time zone and platform.</p>
    public let demographic: EndpointDemographic?
    /// <p>The date and time, in ISO 8601 format, when the endpoint was last updated.</p>
    public let effectiveDate: String?
    /// <p>Specifies whether to send messages or push notifications to the endpoint. Valid values are: ACTIVE, messages are sent to the endpoint; and, INACTIVE, messages aren’t sent to the endpoint.</p> <p>Amazon Pinpoint automatically sets this value to ACTIVE when you create an endpoint or update an existing endpoint. Amazon Pinpoint automatically sets this value to INACTIVE if you update another endpoint that has the same address specified by the Address property.</p>
    public let endpointStatus: String?
    /// <p>The geographic information for the endpoint.</p>
    public let location: EndpointLocation?
    /// <p>One or more custom metrics that your app reports to Amazon Pinpoint for the endpoint.</p>
    public let metrics: [String:Double]?
    /// <p>Specifies whether the user who's associated with the endpoint has opted out of receiving messages and push notifications from you. Possible values are: ALL, the user has opted out and doesn't want to receive any messages or push notifications; and, NONE, the user hasn't opted out and wants to receive all messages and push notifications.</p>
    public let optOut: String?
    /// <p>A unique identifier that's generated each time the endpoint is updated.</p>
    public let requestId: String?
    /// <p>One or more custom user attributes that your app reports to Amazon Pinpoint for the user who's associated with the endpoint.</p>
    public let user: EndpointUser?

    public init (
        address: String? = nil,
        attributes: [String:[String]]? = nil,
        channelType: ChannelType? = nil,
        demographic: EndpointDemographic? = nil,
        effectiveDate: String? = nil,
        endpointStatus: String? = nil,
        location: EndpointLocation? = nil,
        metrics: [String:Double]? = nil,
        optOut: String? = nil,
        requestId: String? = nil,
        user: EndpointUser? = nil
    )
    {
        self.address = address
        self.attributes = attributes
        self.channelType = channelType
        self.demographic = demographic
        self.effectiveDate = effectiveDate
        self.endpointStatus = endpointStatus
        self.location = location
        self.metrics = metrics
        self.optOut = optOut
        self.requestId = requestId
        self.user = user
    }
}

extension PushMessageActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageConfig = "MessageConfig"
        case nextActivity = "NextActivity"
        case templateName = "TemplateName"
        case templateVersion = "TemplateVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageConfig = messageConfig {
            try encodeContainer.encode(messageConfig, forKey: .messageConfig)
        }
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateVersion = templateVersion {
            try encodeContainer.encode(templateVersion, forKey: .templateVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageConfigDecoded = try containerValues.decodeIfPresent(JourneyPushMessage.self, forKey: .messageConfig)
        messageConfig = messageConfigDecoded
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
    }
}

extension PushMessageActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PushMessageActivity(messageConfig: \(String(describing: messageConfig)), nextActivity: \(String(describing: nextActivity)), templateName: \(String(describing: templateName)), templateVersion: \(String(describing: templateVersion)))"}
}

/// <p>Specifies the settings for a push notification activity in a journey. This type of activity sends a push notification to participants.</p>
public struct PushMessageActivity: Equatable {
    /// <p>Specifies the time to live (TTL) value for push notifications that are sent to participants in a journey.</p>
    public let messageConfig: JourneyPushMessage?
    /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
    public let nextActivity: String?
    /// <p>The name of the push notification template to use for the message. If specified, this value must match the name of an existing message template.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the push notification template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    public let templateVersion: String?

    public init (
        messageConfig: JourneyPushMessage? = nil,
        nextActivity: String? = nil,
        templateName: String? = nil,
        templateVersion: String? = nil
    )
    {
        self.messageConfig = messageConfig
        self.nextActivity = nextActivity
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

extension PushNotificationTemplateRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aDM = "ADM"
        case aPNS = "APNS"
        case baidu = "Baidu"
        case `default` = "Default"
        case defaultSubstitutions = "DefaultSubstitutions"
        case gCM = "GCM"
        case recommenderId = "RecommenderId"
        case templateDescription = "TemplateDescription"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aDM = aDM {
            try encodeContainer.encode(aDM, forKey: .aDM)
        }
        if let aPNS = aPNS {
            try encodeContainer.encode(aPNS, forKey: .aPNS)
        }
        if let baidu = baidu {
            try encodeContainer.encode(baidu, forKey: .baidu)
        }
        if let `default` = `default` {
            try encodeContainer.encode(`default`, forKey: .`default`)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let gCM = gCM {
            try encodeContainer.encode(gCM, forKey: .gCM)
        }
        if let recommenderId = recommenderId {
            try encodeContainer.encode(recommenderId, forKey: .recommenderId)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMDecoded = try containerValues.decodeIfPresent(AndroidPushNotificationTemplate.self, forKey: .aDM)
        aDM = aDMDecoded
        let aPNSDecoded = try containerValues.decodeIfPresent(APNSPushNotificationTemplate.self, forKey: .aPNS)
        aPNS = aPNSDecoded
        let baiduDecoded = try containerValues.decodeIfPresent(AndroidPushNotificationTemplate.self, forKey: .baidu)
        baidu = baiduDecoded
        let defaultDecoded = try containerValues.decodeIfPresent(DefaultPushNotificationTemplate.self, forKey: .default)
        `default` = defaultDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let gCMDecoded = try containerValues.decodeIfPresent(AndroidPushNotificationTemplate.self, forKey: .gCM)
        gCM = gCMDecoded
        let recommenderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommenderId)
        recommenderId = recommenderIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
    }
}

extension PushNotificationTemplateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PushNotificationTemplateRequest(aDM: \(String(describing: aDM)), aPNS: \(String(describing: aPNS)), baidu: \(String(describing: baidu)), default: \(String(describing: `default`)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), gCM: \(String(describing: gCM)), recommenderId: \(String(describing: recommenderId)), templateDescription: \(String(describing: templateDescription)), tags: \(String(describing: tags)))"}
}

/// <p>Specifies the content and settings for a message template that can be used in messages that are sent through a push notification channel.</p>
public struct PushNotificationTemplateRequest: Equatable {
    /// <p>The default message template to use for push notification channels.</p>
    public let `default`: DefaultPushNotificationTemplate?
    /// <p>The message template to use for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let aDM: AndroidPushNotificationTemplate?
    /// <p>The message template to use for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let aPNS: APNSPushNotificationTemplate?
    /// <p>The message template to use for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let baidu: AndroidPushNotificationTemplate?
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    public let defaultSubstitutions: String?
    /// <p>The message template to use for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let gCM: AndroidPushNotificationTemplate?
    /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
    public let recommenderId: String?
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>A custom description of the message template.</p>
    public let templateDescription: String?

    public init (
        `default`: DefaultPushNotificationTemplate? = nil,
        aDM: AndroidPushNotificationTemplate? = nil,
        aPNS: APNSPushNotificationTemplate? = nil,
        baidu: AndroidPushNotificationTemplate? = nil,
        defaultSubstitutions: String? = nil,
        gCM: AndroidPushNotificationTemplate? = nil,
        recommenderId: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil
    )
    {
        self.`default` = `default`
        self.aDM = aDM
        self.aPNS = aPNS
        self.baidu = baidu
        self.defaultSubstitutions = defaultSubstitutions
        self.gCM = gCM
        self.recommenderId = recommenderId
        self.tags = tags
        self.templateDescription = templateDescription
    }
}

extension PushNotificationTemplateResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aDM = "ADM"
        case aPNS = "APNS"
        case arn = "Arn"
        case baidu = "Baidu"
        case creationDate = "CreationDate"
        case `default` = "Default"
        case defaultSubstitutions = "DefaultSubstitutions"
        case gCM = "GCM"
        case lastModifiedDate = "LastModifiedDate"
        case recommenderId = "RecommenderId"
        case templateDescription = "TemplateDescription"
        case templateName = "TemplateName"
        case templateType = "TemplateType"
        case version = "Version"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aDM = aDM {
            try encodeContainer.encode(aDM, forKey: .aDM)
        }
        if let aPNS = aPNS {
            try encodeContainer.encode(aPNS, forKey: .aPNS)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let baidu = baidu {
            try encodeContainer.encode(baidu, forKey: .baidu)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let `default` = `default` {
            try encodeContainer.encode(`default`, forKey: .`default`)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let gCM = gCM {
            try encodeContainer.encode(gCM, forKey: .gCM)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let recommenderId = recommenderId {
            try encodeContainer.encode(recommenderId, forKey: .recommenderId)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMDecoded = try containerValues.decodeIfPresent(AndroidPushNotificationTemplate.self, forKey: .aDM)
        aDM = aDMDecoded
        let aPNSDecoded = try containerValues.decodeIfPresent(APNSPushNotificationTemplate.self, forKey: .aPNS)
        aPNS = aPNSDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let baiduDecoded = try containerValues.decodeIfPresent(AndroidPushNotificationTemplate.self, forKey: .baidu)
        baidu = baiduDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultDecoded = try containerValues.decodeIfPresent(DefaultPushNotificationTemplate.self, forKey: .default)
        `default` = defaultDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let gCMDecoded = try containerValues.decodeIfPresent(AndroidPushNotificationTemplate.self, forKey: .gCM)
        gCM = gCMDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let recommenderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommenderId)
        recommenderId = recommenderIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension PushNotificationTemplateResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PushNotificationTemplateResponse(aDM: \(String(describing: aDM)), aPNS: \(String(describing: aPNS)), arn: \(String(describing: arn)), baidu: \(String(describing: baidu)), creationDate: \(String(describing: creationDate)), default: \(String(describing: `default`)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), gCM: \(String(describing: gCM)), lastModifiedDate: \(String(describing: lastModifiedDate)), recommenderId: \(String(describing: recommenderId)), templateDescription: \(String(describing: templateDescription)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)), version: \(String(describing: version)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through a push notification channel.</p>
public struct PushNotificationTemplateResponse: Equatable {
    /// <p>The default message template that's used for push notification channels.</p>
    public let `default`: DefaultPushNotificationTemplate?
    /// <p>The message template that's used for the ADM (Amazon Device Messaging) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let aDM: AndroidPushNotificationTemplate?
    /// <p>The message template that's used for the APNs (Apple Push Notification service) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let aPNS: APNSPushNotificationTemplate?
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    public let arn: String?
    /// <p>The message template that's used for the Baidu (Baidu Cloud Push) channel. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let baidu: AndroidPushNotificationTemplate?
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    public let creationDate: String?
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    public let defaultSubstitutions: String?
    /// <p>The message template that's used for the GCM channel, which is used to send notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service. This message template overrides the default template for push notification channels (DefaultPushNotificationTemplate).</p>
    public let gCM: AndroidPushNotificationTemplate?
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The unique identifier for the recommender model that's used by the message template.</p>
    public let recommenderId: String?
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>The custom description of the message template.</p>
    public let templateDescription: String?
    /// <p>The name of the message template.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. For a push notification template, this value is PUSH.</p>
    public let templateType: TemplateType?
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    public let version: String?

    public init (
        `default`: DefaultPushNotificationTemplate? = nil,
        aDM: AndroidPushNotificationTemplate? = nil,
        aPNS: APNSPushNotificationTemplate? = nil,
        arn: String? = nil,
        baidu: AndroidPushNotificationTemplate? = nil,
        creationDate: String? = nil,
        defaultSubstitutions: String? = nil,
        gCM: AndroidPushNotificationTemplate? = nil,
        lastModifiedDate: String? = nil,
        recommenderId: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil,
        templateName: String? = nil,
        templateType: TemplateType? = nil,
        version: String? = nil
    )
    {
        self.`default` = `default`
        self.aDM = aDM
        self.aPNS = aPNS
        self.arn = arn
        self.baidu = baidu
        self.creationDate = creationDate
        self.defaultSubstitutions = defaultSubstitutions
        self.gCM = gCM
        self.lastModifiedDate = lastModifiedDate
        self.recommenderId = recommenderId
        self.tags = tags
        self.templateDescription = templateDescription
        self.templateName = templateName
        self.templateType = templateType
        self.version = version
    }
}

public struct PutEventStreamInputBodyMiddleware: Middleware {
    public let id: String = "PutEventStreamInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeEventStream = input.operationInput.writeEventStream {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeEventStream)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventStreamInput>
    public typealias MOutput = OperationOutput<PutEventStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventStreamOutputError>
}

extension PutEventStreamInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventStreamInput(applicationId: \(String(describing: applicationId)), writeEventStream: \(String(describing: writeEventStream)))"}
}

extension PutEventStreamInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeEventStream = "WriteEventStream"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeEventStream = writeEventStream {
            try encodeContainer.encode(writeEventStream, forKey: .writeEventStream)
        }
    }
}

public struct PutEventStreamInputHeadersMiddleware: Middleware {
    public let id: String = "PutEventStreamInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventStreamInput>
    public typealias MOutput = OperationOutput<PutEventStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventStreamOutputError>
}

public struct PutEventStreamInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEventStreamInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventStreamInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventStreamOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventStreamInput>
    public typealias MOutput = OperationOutput<PutEventStreamOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventStreamOutputError>
}

public struct PutEventStreamInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the Amazon Resource Name (ARN) of an event stream to publish events to and the AWS Identity and Access Management (IAM) role to use when publishing those events.</p>
    public let writeEventStream: WriteEventStream?

    public init (
        applicationId: String? = nil,
        writeEventStream: WriteEventStream? = nil
    )
    {
        self.applicationId = applicationId
        self.writeEventStream = writeEventStream
    }
}

struct PutEventStreamInputBody: Equatable {
    public let writeEventStream: WriteEventStream?
}

extension PutEventStreamInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeEventStream = "WriteEventStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeEventStreamDecoded = try containerValues.decodeIfPresent(WriteEventStream.self, forKey: .writeEventStream)
        writeEventStream = writeEventStreamDecoded
    }
}

extension PutEventStreamOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventStreamOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventStreamOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventStreamOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventStreamOutputResponse(eventStream: \(String(describing: eventStream)))"}
}

extension PutEventStreamOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EventStream = try responseDecoder.decode(responseBody: unwrappedData)
                self.eventStream = output
            } else {
                self.eventStream = nil
            }
        } else {
            self.eventStream = nil
        }
    }
}

public struct PutEventStreamOutputResponse: Equatable {
    /// <p>Specifies settings for publishing event data to an Amazon Kinesis data stream or an Amazon Kinesis Data Firehose delivery stream.</p>
    public let eventStream: EventStream?

    public init (
        eventStream: EventStream? = nil
    )
    {
        self.eventStream = eventStream
    }
}

struct PutEventStreamOutputResponseBody: Equatable {
    public let eventStream: EventStream?
}

extension PutEventStreamOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventStream = "EventStream"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventStreamDecoded = try containerValues.decodeIfPresent(EventStream.self, forKey: .eventStream)
        eventStream = eventStreamDecoded
    }
}

public struct PutEventsInputBodyMiddleware: Middleware {
    public let id: String = "PutEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let eventsRequest = input.operationInput.eventsRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(eventsRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

extension PutEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsInput(applicationId: \(String(describing: applicationId)), eventsRequest: \(String(describing: eventsRequest)))"}
}

extension PutEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventsRequest = "EventsRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventsRequest = eventsRequest {
            try encodeContainer.encode(eventsRequest, forKey: .eventsRequest)
        }
    }
}

public struct PutEventsInputHeadersMiddleware: Middleware {
    public let id: String = "PutEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

public struct PutEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "PutEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<PutEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutEventsInput>
    public typealias MOutput = OperationOutput<PutEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutEventsOutputError>
}

public struct PutEventsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies a batch of events to process.</p>
    public let eventsRequest: EventsRequest?

    public init (
        applicationId: String? = nil,
        eventsRequest: EventsRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.eventsRequest = eventsRequest
    }
}

struct PutEventsInputBody: Equatable {
    public let eventsRequest: EventsRequest?
}

extension PutEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventsRequest = "EventsRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsRequestDecoded = try containerValues.decodeIfPresent(EventsRequest.self, forKey: .eventsRequest)
        eventsRequest = eventsRequestDecoded
    }
}

extension PutEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutEventsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutEventsOutputResponse(eventsResponse: \(String(describing: eventsResponse)))"}
}

extension PutEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EventsResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.eventsResponse = output
            } else {
                self.eventsResponse = nil
            }
        } else {
            self.eventsResponse = nil
        }
    }
}

public struct PutEventsOutputResponse: Equatable {
    /// <p>Provides information about endpoints and the events that they're associated with.</p>
    public let eventsResponse: EventsResponse?

    public init (
        eventsResponse: EventsResponse? = nil
    )
    {
        self.eventsResponse = eventsResponse
    }
}

struct PutEventsOutputResponseBody: Equatable {
    public let eventsResponse: EventsResponse?
}

extension PutEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventsResponse = "EventsResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsResponseDecoded = try containerValues.decodeIfPresent(EventsResponse.self, forKey: .eventsResponse)
        eventsResponse = eventsResponseDecoded
    }
}

extension QuietTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endDecoded = try containerValues.decodeIfPresent(String.self, forKey: .end)
        end = endDecoded
        let startDecoded = try containerValues.decodeIfPresent(String.self, forKey: .start)
        start = startDecoded
    }
}

extension QuietTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QuietTime(end: \(String(describing: end)), start: \(String(describing: start)))"}
}

/// <p>Specifies the start and end times that define a time range when messages aren't sent to endpoints.</p>
public struct QuietTime: Equatable {
    /// <p>The specific time when quiet time ends. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
    public let end: String?
    /// <p>The specific time when quiet time begins. This value has to use 24-hour notation and be in HH:MM format, where HH is the hour (with a leading zero, if applicable) and MM is the minutes. For example, use 02:30 to represent 2:30 AM, or 14:30 to represent 2:30 PM.</p>
    public let start: String?

    public init (
        end: String? = nil,
        start: String? = nil
    )
    {
        self.end = end
        self.start = start
    }
}

extension RandomSplitActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case branches = "Branches"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branches = branches {
            var branchesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .branches)
            for listofrandomsplitentry0 in branches {
                try branchesContainer.encode(listofrandomsplitentry0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let branchesContainer = try containerValues.decodeIfPresent([RandomSplitEntry?].self, forKey: .branches)
        var branchesDecoded0:[RandomSplitEntry]? = nil
        if let branchesContainer = branchesContainer {
            branchesDecoded0 = [RandomSplitEntry]()
            for structure0 in branchesContainer {
                if let structure0 = structure0 {
                    branchesDecoded0?.append(structure0)
                }
            }
        }
        branches = branchesDecoded0
    }
}

extension RandomSplitActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RandomSplitActivity(branches: \(String(describing: branches)))"}
}

/// <p>Specifies the settings for a random split activity in a journey. This type of activity randomly sends specified percentages of participants down one of as many as five paths in a journey, based on conditions that you specify.</p>
public struct RandomSplitActivity: Equatable {
    /// <p>The paths for the activity, including the percentage of participants to enter each path and the activity to perform for each path.</p>
    public let branches: [RandomSplitEntry]?

    public init (
        branches: [RandomSplitEntry]? = nil
    )
    {
        self.branches = branches
    }
}

extension RandomSplitEntry: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextActivity = "NextActivity"
        case percentage = "Percentage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
        if percentage != 0 {
            try encodeContainer.encode(percentage, forKey: .percentage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
        let percentageDecoded = try containerValues.decode(Int.self, forKey: .percentage)
        percentage = percentageDecoded
    }
}

extension RandomSplitEntry: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RandomSplitEntry(nextActivity: \(String(describing: nextActivity)), percentage: \(String(describing: percentage)))"}
}

/// <p>Specifies the settings for a path in a random split activity in a journey.</p>
public struct RandomSplitEntry: Equatable {
    /// <p>The unique identifier for the next activity to perform, after completing the activity for the path.</p>
    public let nextActivity: String?
    /// <p>The percentage of participants to send down the activity path.</p> <p>To determine which participants are sent down each path, Amazon Pinpoint applies a probability-based algorithm to the percentages that you specify for the paths. Therefore, the actual percentage of participants who are sent down a path may not be equal to the percentage that you specify.</p>
    public let percentage: Int

    public init (
        nextActivity: String? = nil,
        percentage: Int = 0
    )
    {
        self.nextActivity = nextActivity
        self.percentage = percentage
    }
}

extension RawEmail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .data)
        data = dataDecoded
    }
}

extension RawEmail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RawEmail(data: \(String(describing: data)))"}
}

/// <p>Specifies the contents of an email message, represented as a raw MIME message.</p>
public struct RawEmail: Equatable {
    /// <p>The email message, represented as a raw MIME message. The entire message must be base64 encoded.</p>
    public let data: Data?

    public init (
        data: Data? = nil
    )
    {
        self.data = data
    }
}

extension RecencyDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case recencyType = "RecencyType"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let duration = duration {
            try encodeContainer.encode(duration.rawValue, forKey: .duration)
        }
        if let recencyType = recencyType {
            try encodeContainer.encode(recencyType.rawValue, forKey: .recencyType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationDecoded = try containerValues.decodeIfPresent(Duration.self, forKey: .duration)
        duration = durationDecoded
        let recencyTypeDecoded = try containerValues.decodeIfPresent(RecencyType.self, forKey: .recencyType)
        recencyType = recencyTypeDecoded
    }
}

extension RecencyDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecencyDimension(duration: \(String(describing: duration)), recencyType: \(String(describing: recencyType)))"}
}

/// <p>Specifies criteria for including or excluding endpoints from a segment based on how recently an endpoint was active.</p>
public struct RecencyDimension: Equatable {
    /// <p>The duration to use when determining whether an endpoint is active or inactive.</p>
    public let duration: Duration?
    /// <p>The type of recency dimension to use for the segment. Valid values are: ACTIVE, endpoints that were active within the specified duration are included in the segment; and, INACTIVE, endpoints that weren't active within the specified duration are included in the segment.</p>
    public let recencyType: RecencyType?

    public init (
        duration: Duration? = nil,
        recencyType: RecencyType? = nil
    )
    {
        self.duration = duration
        self.recencyType = recencyType
    }
}

public enum RecencyType {
    case active
    case inactive
    case sdkUnknown(String)
}

extension RecencyType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RecencyType] {
        return [
            .active,
            .inactive,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .inactive: return "INACTIVE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RecencyType(rawValue: rawValue) ?? RecencyType.sdkUnknown(rawValue)
    }
}

extension RecommenderConfigurationResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case creationDate = "CreationDate"
        case description = "Description"
        case id = "Id"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case recommendationProviderIdType = "RecommendationProviderIdType"
        case recommendationProviderRoleArn = "RecommendationProviderRoleArn"
        case recommendationProviderUri = "RecommendationProviderUri"
        case recommendationTransformerUri = "RecommendationTransformerUri"
        case recommendationsDisplayName = "RecommendationsDisplayName"
        case recommendationsPerMessage = "RecommendationsPerMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapof__string0) in attributes {
                try attributesContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationProviderIdType = recommendationProviderIdType {
            try encodeContainer.encode(recommendationProviderIdType, forKey: .recommendationProviderIdType)
        }
        if let recommendationProviderRoleArn = recommendationProviderRoleArn {
            try encodeContainer.encode(recommendationProviderRoleArn, forKey: .recommendationProviderRoleArn)
        }
        if let recommendationProviderUri = recommendationProviderUri {
            try encodeContainer.encode(recommendationProviderUri, forKey: .recommendationProviderUri)
        }
        if let recommendationTransformerUri = recommendationTransformerUri {
            try encodeContainer.encode(recommendationTransformerUri, forKey: .recommendationTransformerUri)
        }
        if let recommendationsDisplayName = recommendationsDisplayName {
            try encodeContainer.encode(recommendationsDisplayName, forKey: .recommendationsDisplayName)
        }
        if recommendationsPerMessage != 0 {
            try encodeContainer.encode(recommendationsPerMessage, forKey: .recommendationsPerMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, __string0) in attributesContainer {
                if let __string0 = __string0 {
                    attributesDecoded0?[key0] = __string0
                }
            }
        }
        attributes = attributesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recommendationProviderIdTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderIdType)
        recommendationProviderIdType = recommendationProviderIdTypeDecoded
        let recommendationProviderRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderRoleArn)
        recommendationProviderRoleArn = recommendationProviderRoleArnDecoded
        let recommendationProviderUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderUri)
        recommendationProviderUri = recommendationProviderUriDecoded
        let recommendationTransformerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationTransformerUri)
        recommendationTransformerUri = recommendationTransformerUriDecoded
        let recommendationsDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationsDisplayName)
        recommendationsDisplayName = recommendationsDisplayNameDecoded
        let recommendationsPerMessageDecoded = try containerValues.decode(Int.self, forKey: .recommendationsPerMessage)
        recommendationsPerMessage = recommendationsPerMessageDecoded
    }
}

extension RecommenderConfigurationResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RecommenderConfigurationResponse(attributes: \(String(describing: attributes)), creationDate: \(String(describing: creationDate)), description: \(String(describing: description)), id: \(String(describing: id)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), recommendationProviderIdType: \(String(describing: recommendationProviderIdType)), recommendationProviderRoleArn: \(String(describing: recommendationProviderRoleArn)), recommendationProviderUri: \(String(describing: recommendationProviderUri)), recommendationTransformerUri: \(String(describing: recommendationTransformerUri)), recommendationsDisplayName: \(String(describing: recommendationsDisplayName)), recommendationsPerMessage: \(String(describing: recommendationsPerMessage)))"}
}

/// <p>Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.</p>
public struct RecommenderConfigurationResponse: Equatable {
    /// <p>A map that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    public let attributes: [String:String]?
    /// <p>The date, in extended ISO 8601 format, when the configuration was created for the recommender model.</p>
    public let creationDate: String?
    /// <p>The custom description of the configuration for the recommender model.</p>
    public let description: String?
    /// <p>The unique identifier for the recommender model configuration.</p>
    public let id: String?
    /// <p>The date, in extended ISO 8601 format, when the configuration for the recommender model was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The custom name of the configuration for the recommender model.</p>
    public let name: String?
    /// <p>The type of Amazon Pinpoint ID that's associated with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Possible values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Each user in the model is associated with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Each user in the model is associated with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If this value is specified, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
    public let recommendationProviderIdType: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
    public let recommendationProviderRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the recommender model that Amazon Pinpoint retrieves the recommendation data from. This value is the ARN of an Amazon Personalize campaign.</p>
    public let recommendationProviderUri: String?
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function that Amazon Pinpoint invokes to perform additional processing of recommendation data that it retrieves from the recommender model.</p>
    public let recommendationTransformerUri: String?
    /// <p>The custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console.</p> <p>This value is null if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    public let recommendationsDisplayName: String?
    /// <p>The number of recommended items that are retrieved from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables.</p>
    public let recommendationsPerMessage: Int

    public init (
        attributes: [String:String]? = nil,
        creationDate: String? = nil,
        description: String? = nil,
        id: String? = nil,
        lastModifiedDate: String? = nil,
        name: String? = nil,
        recommendationProviderIdType: String? = nil,
        recommendationProviderRoleArn: String? = nil,
        recommendationProviderUri: String? = nil,
        recommendationTransformerUri: String? = nil,
        recommendationsDisplayName: String? = nil,
        recommendationsPerMessage: Int = 0
    )
    {
        self.attributes = attributes
        self.creationDate = creationDate
        self.description = description
        self.id = id
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.recommendationProviderIdType = recommendationProviderIdType
        self.recommendationProviderRoleArn = recommendationProviderRoleArn
        self.recommendationProviderUri = recommendationProviderUri
        self.recommendationTransformerUri = recommendationTransformerUri
        self.recommendationsDisplayName = recommendationsDisplayName
        self.recommendationsPerMessage = recommendationsPerMessage
    }
}

public struct RemoveAttributesInputBodyMiddleware: Middleware {
    public let id: String = "RemoveAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let updateAttributesRequest = input.operationInput.updateAttributesRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(updateAttributesRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAttributesInput>
    public typealias MOutput = OperationOutput<RemoveAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAttributesOutputError>
}

extension RemoveAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAttributesInput(applicationId: \(String(describing: applicationId)), attributeType: \(String(describing: attributeType)), updateAttributesRequest: \(String(describing: updateAttributesRequest)))"}
}

extension RemoveAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case updateAttributesRequest = "UpdateAttributesRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateAttributesRequest = updateAttributesRequest {
            try encodeContainer.encode(updateAttributesRequest, forKey: .updateAttributesRequest)
        }
    }
}

public struct RemoveAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAttributesInput>
    public typealias MOutput = OperationOutput<RemoveAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAttributesOutputError>
}

public struct RemoveAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAttributesInput>
    public typealias MOutput = OperationOutput<RemoveAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAttributesOutputError>
}

public struct RemoveAttributesInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The type of attribute or attributes to remove. Valid values are:</p> <ul><li><p>endpoint-custom-attributes - Custom attributes that describe endpoints, such as the date when an associated user opted in or out of receiving communications from you through a specific type of channel.</p></li> <li><p>endpoint-metric-attributes - Custom metrics that your app reports to Amazon Pinpoint for endpoints, such as the number of app sessions or the number of items left in a cart.</p></li> <li><p>endpoint-user-attributes - Custom attributes that describe users, such as first name, last name, and age.</p></li></ul>
    public let attributeType: String?
    /// <p>Specifies one or more attributes to remove from all the endpoints that are associated with an application.</p>
    public let updateAttributesRequest: UpdateAttributesRequest?

    public init (
        applicationId: String? = nil,
        attributeType: String? = nil,
        updateAttributesRequest: UpdateAttributesRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.attributeType = attributeType
        self.updateAttributesRequest = updateAttributesRequest
    }
}

struct RemoveAttributesInputBody: Equatable {
    public let updateAttributesRequest: UpdateAttributesRequest?
}

extension RemoveAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case updateAttributesRequest = "UpdateAttributesRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateAttributesRequestDecoded = try containerValues.decodeIfPresent(UpdateAttributesRequest.self, forKey: .updateAttributesRequest)
        updateAttributesRequest = updateAttributesRequestDecoded
    }
}

extension RemoveAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveAttributesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAttributesOutputResponse(attributesResource: \(String(describing: attributesResource)))"}
}

extension RemoveAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: AttributesResource = try responseDecoder.decode(responseBody: unwrappedData)
                self.attributesResource = output
            } else {
                self.attributesResource = nil
            }
        } else {
            self.attributesResource = nil
        }
    }
}

public struct RemoveAttributesOutputResponse: Equatable {
    /// <p>Provides information about the type and the names of attributes that were removed from all the endpoints that are associated with an application.</p>
    public let attributesResource: AttributesResource?

    public init (
        attributesResource: AttributesResource? = nil
    )
    {
        self.attributesResource = attributesResource
    }
}

struct RemoveAttributesOutputResponseBody: Equatable {
    public let attributesResource: AttributesResource?
}

extension RemoveAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributesResource = "AttributesResource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesResourceDecoded = try containerValues.decodeIfPresent(AttributesResource.self, forKey: .attributesResource)
        attributesResource = attributesResourceDecoded
    }
}

extension ResultRow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupedBys = "GroupedBys"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupedBys = groupedBys {
            var groupedBysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupedBys)
            for listofresultrowvalue0 in groupedBys {
                try groupedBysContainer.encode(listofresultrowvalue0)
            }
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for listofresultrowvalue0 in values {
                try valuesContainer.encode(listofresultrowvalue0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupedBysContainer = try containerValues.decodeIfPresent([ResultRowValue?].self, forKey: .groupedBys)
        var groupedBysDecoded0:[ResultRowValue]? = nil
        if let groupedBysContainer = groupedBysContainer {
            groupedBysDecoded0 = [ResultRowValue]()
            for structure0 in groupedBysContainer {
                if let structure0 = structure0 {
                    groupedBysDecoded0?.append(structure0)
                }
            }
        }
        groupedBys = groupedBysDecoded0
        let valuesContainer = try containerValues.decodeIfPresent([ResultRowValue?].self, forKey: .values)
        var valuesDecoded0:[ResultRowValue]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [ResultRowValue]()
            for structure0 in valuesContainer {
                if let structure0 = structure0 {
                    valuesDecoded0?.append(structure0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension ResultRow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultRow(groupedBys: \(String(describing: groupedBys)), values: \(String(describing: values)))"}
}

/// <p>Provides the results of a query that retrieved the data for a standard metric that applies to an application, campaign, or journey.</p>
public struct ResultRow: Equatable {
    /// <p>An array of objects that defines the field and field values that were used to group data in a result set that contains multiple results. This value is null if the data in a result set isn’t grouped.</p>
    public let groupedBys: [ResultRowValue]?
    /// <p>An array of objects that provides pre-aggregated values for a standard metric that applies to an application, campaign, or journey.</p>
    public let values: [ResultRowValue]?

    public init (
        groupedBys: [ResultRowValue]? = nil,
        values: [ResultRowValue]? = nil
    )
    {
        self.groupedBys = groupedBys
        self.values = values
    }
}

extension ResultRowValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case type = "Type"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ResultRowValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultRowValue(key: \(String(describing: key)), type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Provides a single value and metadata about that value as part of an array of query results for a standard metric that applies to an application, campaign, or journey.</p>
public struct ResultRowValue: Equatable {
    /// <p>The friendly name of the metric whose value is specified by the Value property.</p>
    public let key: String?
    /// <p>The data type of the value specified by the Value property.</p>
    public let type: String?
    /// <p>In a Values object, the value for the metric that the query retrieved data for. In a GroupedBys object, the value for the field that was used to group data in a result set that contains multiple results (Values objects).</p>
    public let value: String?

    public init (
        key: String? = nil,
        type: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.type = type
        self.value = value
    }
}

extension SMSChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
        case senderId = "SenderId"
        case shortCode = "ShortCode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let senderId = senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let shortCode = shortCode {
            try encodeContainer.encode(shortCode, forKey: .shortCode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let shortCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortCode)
        shortCode = shortCodeDecoded
    }
}

extension SMSChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSChannelRequest(enabled: \(String(describing: enabled)), senderId: \(String(describing: senderId)), shortCode: \(String(describing: shortCode)))"}
}

/// <p>Specifies the status and settings of the SMS channel for an application.</p>
public struct SMSChannelRequest: Equatable {
    /// <p>Specifies whether to enable the SMS channel for the application.</p>
    public let enabled: Bool
    /// <p>The identity that you want to display on recipients' devices when they receive messages from the SMS channel.</p>
    public let senderId: String?
    /// <p>The registered short code that you want to use when you send messages through the SMS channel.</p>
    public let shortCode: String?

    public init (
        enabled: Bool = false,
        senderId: String? = nil,
        shortCode: String? = nil
    )
    {
        self.enabled = enabled
        self.senderId = senderId
        self.shortCode = shortCode
    }
}

extension SMSChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case promotionalMessagesPerSecond = "PromotionalMessagesPerSecond"
        case senderId = "SenderId"
        case shortCode = "ShortCode"
        case transactionalMessagesPerSecond = "TransactionalMessagesPerSecond"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if promotionalMessagesPerSecond != 0 {
            try encodeContainer.encode(promotionalMessagesPerSecond, forKey: .promotionalMessagesPerSecond)
        }
        if let senderId = senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let shortCode = shortCode {
            try encodeContainer.encode(shortCode, forKey: .shortCode)
        }
        if transactionalMessagesPerSecond != 0 {
            try encodeContainer.encode(transactionalMessagesPerSecond, forKey: .transactionalMessagesPerSecond)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let promotionalMessagesPerSecondDecoded = try containerValues.decode(Int.self, forKey: .promotionalMessagesPerSecond)
        promotionalMessagesPerSecond = promotionalMessagesPerSecondDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let shortCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .shortCode)
        shortCode = shortCodeDecoded
        let transactionalMessagesPerSecondDecoded = try containerValues.decode(Int.self, forKey: .transactionalMessagesPerSecond)
        transactionalMessagesPerSecond = transactionalMessagesPerSecondDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension SMSChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), promotionalMessagesPerSecond: \(String(describing: promotionalMessagesPerSecond)), senderId: \(String(describing: senderId)), shortCode: \(String(describing: shortCode)), transactionalMessagesPerSecond: \(String(describing: transactionalMessagesPerSecond)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the SMS channel for an application.</p>
public struct SMSChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the SMS channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time, in ISO 8601 format, when the SMS channel was enabled.</p>
    public let creationDate: String?
    /// <p>Specifies whether the SMS channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>(Deprecated) An identifier for the SMS channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the SMS channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the SMS channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time, in ISO 8601 format, when the SMS channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the SMS channel, this value is SMS.</p>
    public let platform: String?
    /// <p>The maximum number of promotional messages that you can send through the SMS channel each second.</p>
    public let promotionalMessagesPerSecond: Int
    /// <p>The identity that displays on recipients' devices when they receive messages from the SMS channel.</p>
    public let senderId: String?
    /// <p>The registered short code to use when you send messages through the SMS channel.</p>
    public let shortCode: String?
    /// <p>The maximum number of transactional messages that you can send through the SMS channel each second.</p>
    public let transactionalMessagesPerSecond: Int
    /// <p>The current version of the SMS channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        promotionalMessagesPerSecond: Int = 0,
        senderId: String? = nil,
        shortCode: String? = nil,
        transactionalMessagesPerSecond: Int = 0,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.promotionalMessagesPerSecond = promotionalMessagesPerSecond
        self.senderId = senderId
        self.shortCode = shortCode
        self.transactionalMessagesPerSecond = transactionalMessagesPerSecond
        self.version = version
    }
}

extension SMSMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case entityId = "EntityId"
        case keyword = "Keyword"
        case mediaUrl = "MediaUrl"
        case messageType = "MessageType"
        case originationNumber = "OriginationNumber"
        case senderId = "SenderId"
        case substitutions = "Substitutions"
        case templateId = "TemplateId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let entityId = entityId {
            try encodeContainer.encode(entityId, forKey: .entityId)
        }
        if let keyword = keyword {
            try encodeContainer.encode(keyword, forKey: .keyword)
        }
        if let mediaUrl = mediaUrl {
            try encodeContainer.encode(mediaUrl, forKey: .mediaUrl)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType.rawValue, forKey: .messageType)
        }
        if let originationNumber = originationNumber {
            try encodeContainer.encode(originationNumber, forKey: .originationNumber)
        }
        if let senderId = senderId {
            try encodeContainer.encode(senderId, forKey: .senderId)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let templateId = templateId {
            try encodeContainer.encode(templateId, forKey: .templateId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let keywordDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyword)
        keyword = keywordDecoded
        let mediaUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .mediaUrl)
        mediaUrl = mediaUrlDecoded
        let messageTypeDecoded = try containerValues.decodeIfPresent(MessageType.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let originationNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originationNumber)
        originationNumber = originationNumberDecoded
        let senderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .senderId)
        senderId = senderIdDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let entityIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .entityId)
        entityId = entityIdDecoded
        let templateIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateId)
        templateId = templateIdDecoded
    }
}

extension SMSMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSMessage(body: \(String(describing: body)), entityId: \(String(describing: entityId)), keyword: \(String(describing: keyword)), mediaUrl: \(String(describing: mediaUrl)), messageType: \(String(describing: messageType)), originationNumber: \(String(describing: originationNumber)), senderId: \(String(describing: senderId)), substitutions: \(String(describing: substitutions)), templateId: \(String(describing: templateId)))"}
}

/// <p>Specifies the default settings for a one-time SMS message that's sent directly to an endpoint.</p>
public struct SMSMessage: Equatable {
    /// <p>The body of the SMS message.</p>
    public let body: String?
    /// <p>The entity ID or Principal Entity (PE) id received from the regulatory body for sending SMS in your country.</p>
    public let entityId: String?
    /// <p>The SMS program name that you provided to AWS Support when you requested your dedicated number.</p>
    public let keyword: String?
    /// <p>This field is reserved for future use.</p>
    public let mediaUrl: String?
    /// <p>The SMS message type. Valid values are TRANSACTIONAL (for messages that are critical or time-sensitive, such as a one-time passwords) and PROMOTIONAL (for messsages that aren't critical or time-sensitive, such as marketing messages).</p>
    public let messageType: MessageType?
    /// <p>The number to send the SMS message from. This value should be one of the dedicated long or short codes that's assigned to your AWS account. If you don't specify a long or short code, Amazon Pinpoint assigns a random long code to the SMS message and sends the message from that code.</p>
    public let originationNumber: String?
    /// <p>The sender ID to display as the sender of the message on a recipient's device. Support for sender IDs varies by country or region.</p>
    public let senderId: String?
    /// <p>The message variables to use in the SMS message. You can override the default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The template ID received from the regulatory body for sending SMS in your country.</p>
    public let templateId: String?

    public init (
        body: String? = nil,
        entityId: String? = nil,
        keyword: String? = nil,
        mediaUrl: String? = nil,
        messageType: MessageType? = nil,
        originationNumber: String? = nil,
        senderId: String? = nil,
        substitutions: [String:[String]]? = nil,
        templateId: String? = nil
    )
    {
        self.body = body
        self.entityId = entityId
        self.keyword = keyword
        self.mediaUrl = mediaUrl
        self.messageType = messageType
        self.originationNumber = originationNumber
        self.senderId = senderId
        self.substitutions = substitutions
        self.templateId = templateId
    }
}

extension SMSMessageActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageConfig = "MessageConfig"
        case nextActivity = "NextActivity"
        case templateName = "TemplateName"
        case templateVersion = "TemplateVersion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageConfig = messageConfig {
            try encodeContainer.encode(messageConfig, forKey: .messageConfig)
        }
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateVersion = templateVersion {
            try encodeContainer.encode(templateVersion, forKey: .templateVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageConfigDecoded = try containerValues.decodeIfPresent(JourneySMSMessage.self, forKey: .messageConfig)
        messageConfig = messageConfigDecoded
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateVersion)
        templateVersion = templateVersionDecoded
    }
}

extension SMSMessageActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSMessageActivity(messageConfig: \(String(describing: messageConfig)), nextActivity: \(String(describing: nextActivity)), templateName: \(String(describing: templateName)), templateVersion: \(String(describing: templateVersion)))"}
}

/// <p>Specifies the settings for an SMS activity in a journey. This type of activity sends a text message to participants.</p>
public struct SMSMessageActivity: Equatable {
    /// <p>Specifies the sender ID and message type for an SMS message that's sent to participants in a journey.</p>
    public let messageConfig: JourneySMSMessage?
    /// <p>The unique identifier for the next activity to perform, after the message is sent.</p>
    public let nextActivity: String?
    /// <p>The name of the SMS message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the SMS template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    public let templateVersion: String?

    public init (
        messageConfig: JourneySMSMessage? = nil,
        nextActivity: String? = nil,
        templateName: String? = nil,
        templateVersion: String? = nil
    )
    {
        self.messageConfig = messageConfig
        self.nextActivity = nextActivity
        self.templateName = templateName
        self.templateVersion = templateVersion
    }
}

extension SMSTemplateRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case defaultSubstitutions = "DefaultSubstitutions"
        case recommenderId = "RecommenderId"
        case templateDescription = "TemplateDescription"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let recommenderId = recommenderId {
            try encodeContainer.encode(recommenderId, forKey: .recommenderId)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let recommenderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommenderId)
        recommenderId = recommenderIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
    }
}

extension SMSTemplateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSTemplateRequest(body: \(String(describing: body)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), recommenderId: \(String(describing: recommenderId)), templateDescription: \(String(describing: templateDescription)), tags: \(String(describing: tags)))"}
}

/// <p>Specifies the content and settings for a message template that can be used in text messages that are sent through the SMS channel.</p>
public struct SMSTemplateRequest: Equatable {
    /// <p>The message body to use in text messages that are based on the message template.</p>
    public let body: String?
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    public let defaultSubstitutions: String?
    /// <p>The unique identifier for the recommender model to use for the message template. Amazon Pinpoint uses this value to determine how to retrieve and process data from a recommender model when it sends messages that use the template, if the template contains message variables for recommendation data.</p>
    public let recommenderId: String?
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>A custom description of the message template.</p>
    public let templateDescription: String?

    public init (
        body: String? = nil,
        defaultSubstitutions: String? = nil,
        recommenderId: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil
    )
    {
        self.body = body
        self.defaultSubstitutions = defaultSubstitutions
        self.recommenderId = recommenderId
        self.tags = tags
        self.templateDescription = templateDescription
    }
}

extension SMSTemplateResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case body = "Body"
        case creationDate = "CreationDate"
        case defaultSubstitutions = "DefaultSubstitutions"
        case lastModifiedDate = "LastModifiedDate"
        case recommenderId = "RecommenderId"
        case templateDescription = "TemplateDescription"
        case templateName = "TemplateName"
        case templateType = "TemplateType"
        case version = "Version"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let recommenderId = recommenderId {
            try encodeContainer.encode(recommenderId, forKey: .recommenderId)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let recommenderIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommenderId)
        recommenderId = recommenderIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension SMSTemplateResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SMSTemplateResponse(arn: \(String(describing: arn)), body: \(String(describing: body)), creationDate: \(String(describing: creationDate)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), lastModifiedDate: \(String(describing: lastModifiedDate)), recommenderId: \(String(describing: recommenderId)), templateDescription: \(String(describing: templateDescription)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)), version: \(String(describing: version)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about the content and settings for a message template that can be used in text messages that are sent through the SMS channel.</p>
public struct SMSTemplateResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    public let arn: String?
    /// <p>The message body that's used in text messages that are based on the message template.</p>
    public let body: String?
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    public let creationDate: String?
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    public let defaultSubstitutions: String?
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The unique identifier for the recommender model that's used by the message template.</p>
    public let recommenderId: String?
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>The custom description of the message template.</p>
    public let templateDescription: String?
    /// <p>The name of the message template.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. For an SMS template, this value is SMS.</p>
    public let templateType: TemplateType?
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        body: String? = nil,
        creationDate: String? = nil,
        defaultSubstitutions: String? = nil,
        lastModifiedDate: String? = nil,
        recommenderId: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil,
        templateName: String? = nil,
        templateType: TemplateType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.body = body
        self.creationDate = creationDate
        self.defaultSubstitutions = defaultSubstitutions
        self.lastModifiedDate = lastModifiedDate
        self.recommenderId = recommenderId
        self.tags = tags
        self.templateDescription = templateDescription
        self.templateName = templateName
        self.templateType = templateType
        self.version = version
    }
}

extension Schedule: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case eventFilter = "EventFilter"
        case frequency = "Frequency"
        case isLocalTime = "IsLocalTime"
        case quietTime = "QuietTime"
        case startTime = "StartTime"
        case timezone = "Timezone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let eventFilter = eventFilter {
            try encodeContainer.encode(eventFilter, forKey: .eventFilter)
        }
        if let frequency = frequency {
            try encodeContainer.encode(frequency.rawValue, forKey: .frequency)
        }
        if isLocalTime != false {
            try encodeContainer.encode(isLocalTime, forKey: .isLocalTime)
        }
        if let quietTime = quietTime {
            try encodeContainer.encode(quietTime, forKey: .quietTime)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
        if let timezone = timezone {
            try encodeContainer.encode(timezone, forKey: .timezone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTime)
        endTime = endTimeDecoded
        let eventFilterDecoded = try containerValues.decodeIfPresent(CampaignEventFilter.self, forKey: .eventFilter)
        eventFilter = eventFilterDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Frequency.self, forKey: .frequency)
        frequency = frequencyDecoded
        let isLocalTimeDecoded = try containerValues.decode(Bool.self, forKey: .isLocalTime)
        isLocalTime = isLocalTimeDecoded
        let quietTimeDecoded = try containerValues.decodeIfPresent(QuietTime.self, forKey: .quietTime)
        quietTime = quietTimeDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTime)
        startTime = startTimeDecoded
        let timezoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .timezone)
        timezone = timezoneDecoded
    }
}

extension Schedule: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Schedule(endTime: \(String(describing: endTime)), eventFilter: \(String(describing: eventFilter)), frequency: \(String(describing: frequency)), isLocalTime: \(String(describing: isLocalTime)), quietTime: \(String(describing: quietTime)), startTime: \(String(describing: startTime)), timezone: \(String(describing: timezone)))"}
}

/// <p>Specifies the schedule settings for a campaign.</p>
public struct Schedule: Equatable {
    /// <p>The scheduled time, in ISO 8601 format, when the campaign ended or will end.</p>
    public let endTime: String?
    /// <p>The type of event that causes the campaign to be sent, if the value of the Frequency property is EVENT.</p>
    public let eventFilter: CampaignEventFilter?
    /// <p>Specifies how often the campaign is sent or whether the campaign is sent in response to a specific event.</p>
    public let frequency: Frequency?
    /// <p>Specifies whether the start and end times for the campaign schedule use each recipient's local time. To base the schedule on each recipient's local time, set this value to true.</p>
    public let isLocalTime: Bool
    /// <p>The default quiet time for the campaign. Quiet time is a specific time range when a campaign doesn't send messages to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the campaign.</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the campaign.</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from the campaign, even if quiet time is enabled.</p>
    public let quietTime: QuietTime?
    /// <p>The scheduled time when the campaign began or will begin. Valid values are: IMMEDIATE, to start the campaign immediately; or, a specific time in ISO 8601 format.</p>
    public let startTime: String?
    /// <p>The starting UTC offset for the campaign schedule, if the value of the IsLocalTime property is true. Valid values are: UTC, UTC+01, UTC+02, UTC+03, UTC+03:30, UTC+04, UTC+04:30, UTC+05,
    ///                   UTC+05:30, UTC+05:45, UTC+06, UTC+06:30, UTC+07, UTC+08, UTC+09, UTC+09:30,
    ///                   UTC+10, UTC+10:30, UTC+11, UTC+12, UTC+13, UTC-02, UTC-03, UTC-04, UTC-05, UTC-06,
    ///                   UTC-07, UTC-08, UTC-09, UTC-10, and UTC-11.</p>
    public let timezone: String?

    public init (
        endTime: String? = nil,
        eventFilter: CampaignEventFilter? = nil,
        frequency: Frequency? = nil,
        isLocalTime: Bool = false,
        quietTime: QuietTime? = nil,
        startTime: String? = nil,
        timezone: String? = nil
    )
    {
        self.endTime = endTime
        self.eventFilter = eventFilter
        self.frequency = frequency
        self.isLocalTime = isLocalTime
        self.quietTime = quietTime
        self.startTime = startTime
        self.timezone = timezone
    }
}

extension SegmentBehaviors: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case recency = "Recency"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recency = recency {
            try encodeContainer.encode(recency, forKey: .recency)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recencyDecoded = try containerValues.decodeIfPresent(RecencyDimension.self, forKey: .recency)
        recency = recencyDecoded
    }
}

extension SegmentBehaviors: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentBehaviors(recency: \(String(describing: recency)))"}
}

/// <p>Specifies dimension settings for including or excluding endpoints from a segment based on how recently an endpoint was active.</p>
public struct SegmentBehaviors: Equatable {
    /// <p>The dimension settings that are based on how recently an endpoint was active.</p>
    public let recency: RecencyDimension?

    public init (
        recency: RecencyDimension? = nil
    )
    {
        self.recency = recency
    }
}

extension SegmentCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case segmentId = "SegmentId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
    }
}

extension SegmentCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentCondition(segmentId: \(String(describing: segmentId)))"}
}

/// <p>Specifies a segment to associate with an activity in a journey.</p>
public struct SegmentCondition: Equatable {
    /// <p>The unique identifier for the segment to associate with the activity.</p>
    public let segmentId: String?

    public init (
        segmentId: String? = nil
    )
    {
        self.segmentId = segmentId
    }
}

extension SegmentDemographics: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appVersion = "AppVersion"
        case channel = "Channel"
        case deviceType = "DeviceType"
        case make = "Make"
        case model = "Model"
        case platform = "Platform"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appVersion = appVersion {
            try encodeContainer.encode(appVersion, forKey: .appVersion)
        }
        if let channel = channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let deviceType = deviceType {
            try encodeContainer.encode(deviceType, forKey: .deviceType)
        }
        if let make = make {
            try encodeContainer.encode(make, forKey: .make)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appVersionDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .appVersion)
        appVersion = appVersionDecoded
        let channelDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .channel)
        channel = channelDecoded
        let deviceTypeDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .deviceType)
        deviceType = deviceTypeDecoded
        let makeDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .make)
        make = makeDecoded
        let modelDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .model)
        model = modelDecoded
        let platformDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension SegmentDemographics: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentDemographics(appVersion: \(String(describing: appVersion)), channel: \(String(describing: channel)), deviceType: \(String(describing: deviceType)), make: \(String(describing: make)), model: \(String(describing: model)), platform: \(String(describing: platform)))"}
}

/// <p>Specifies demographic-based dimension settings for including or excluding endpoints from a segment. These settings derive from characteristics of endpoint devices, such as platform, make, and model.</p>
public struct SegmentDemographics: Equatable {
    /// <p>The app version criteria for the segment.</p>
    public let appVersion: SetDimension?
    /// <p>The channel criteria for the segment.</p>
    public let channel: SetDimension?
    /// <p>The device type criteria for the segment.</p>
    public let deviceType: SetDimension?
    /// <p>The device make criteria for the segment.</p>
    public let make: SetDimension?
    /// <p>The device model criteria for the segment.</p>
    public let model: SetDimension?
    /// <p>The device platform criteria for the segment.</p>
    public let platform: SetDimension?

    public init (
        appVersion: SetDimension? = nil,
        channel: SetDimension? = nil,
        deviceType: SetDimension? = nil,
        make: SetDimension? = nil,
        model: SetDimension? = nil,
        platform: SetDimension? = nil
    )
    {
        self.appVersion = appVersion
        self.channel = channel
        self.deviceType = deviceType
        self.make = make
        self.model = model
        self.platform = platform
    }
}

extension SegmentDimensions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case behavior = "Behavior"
        case demographic = "Demographic"
        case location = "Location"
        case metrics = "Metrics"
        case userAttributes = "UserAttributes"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapofattributedimension0) in attributes {
                try attributesContainer.encode(mapofattributedimension0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let behavior = behavior {
            try encodeContainer.encode(behavior, forKey: .behavior)
        }
        if let demographic = demographic {
            try encodeContainer.encode(demographic, forKey: .demographic)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapofmetricdimension0) in metrics {
                try metricsContainer.encode(mapofmetricdimension0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .userAttributes)
            for (dictKey0, mapofattributedimension0) in userAttributes {
                try userAttributesContainer.encode(mapofattributedimension0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: AttributeDimension?].self, forKey: .attributes)
        var attributesDecoded0: [String:AttributeDimension]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:AttributeDimension]()
            for (key0, attributedimension0) in attributesContainer {
                if let attributedimension0 = attributedimension0 {
                    attributesDecoded0?[key0] = attributedimension0
                }
            }
        }
        attributes = attributesDecoded0
        let behaviorDecoded = try containerValues.decodeIfPresent(SegmentBehaviors.self, forKey: .behavior)
        behavior = behaviorDecoded
        let demographicDecoded = try containerValues.decodeIfPresent(SegmentDemographics.self, forKey: .demographic)
        demographic = demographicDecoded
        let locationDecoded = try containerValues.decodeIfPresent(SegmentLocation.self, forKey: .location)
        location = locationDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String: MetricDimension?].self, forKey: .metrics)
        var metricsDecoded0: [String:MetricDimension]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:MetricDimension]()
            for (key0, metricdimension0) in metricsContainer {
                if let metricdimension0 = metricdimension0 {
                    metricsDecoded0?[key0] = metricdimension0
                }
            }
        }
        metrics = metricsDecoded0
        let userAttributesContainer = try containerValues.decodeIfPresent([String: AttributeDimension?].self, forKey: .userAttributes)
        var userAttributesDecoded0: [String:AttributeDimension]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [String:AttributeDimension]()
            for (key0, attributedimension0) in userAttributesContainer {
                if let attributedimension0 = attributedimension0 {
                    userAttributesDecoded0?[key0] = attributedimension0
                }
            }
        }
        userAttributes = userAttributesDecoded0
    }
}

extension SegmentDimensions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentDimensions(attributes: \(String(describing: attributes)), behavior: \(String(describing: behavior)), demographic: \(String(describing: demographic)), location: \(String(describing: location)), metrics: \(String(describing: metrics)), userAttributes: \(String(describing: userAttributes)))"}
}

/// <p>Specifies the dimension settings for a segment.</p>
public struct SegmentDimensions: Equatable {
    /// <p>One or more custom attributes to use as criteria for the segment.</p>
    public let attributes: [String:AttributeDimension]?
    /// <p>The behavior-based criteria, such as how recently users have used your app, for the segment.</p>
    public let behavior: SegmentBehaviors?
    /// <p>The demographic-based criteria, such as device platform, for the segment.</p>
    public let demographic: SegmentDemographics?
    /// <p>The location-based criteria, such as region or GPS coordinates, for the segment.</p>
    public let location: SegmentLocation?
    /// <p>One or more custom metrics to use as criteria for the segment.</p>
    public let metrics: [String:MetricDimension]?
    /// <p>One or more custom user attributes to use as criteria for the segment.</p>
    public let userAttributes: [String:AttributeDimension]?

    public init (
        attributes: [String:AttributeDimension]? = nil,
        behavior: SegmentBehaviors? = nil,
        demographic: SegmentDemographics? = nil,
        location: SegmentLocation? = nil,
        metrics: [String:MetricDimension]? = nil,
        userAttributes: [String:AttributeDimension]? = nil
    )
    {
        self.attributes = attributes
        self.behavior = behavior
        self.demographic = demographic
        self.location = location
        self.metrics = metrics
        self.userAttributes = userAttributes
    }
}

extension SegmentGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case sourceSegments = "SourceSegments"
        case sourceType = "SourceType"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            var dimensionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensions)
            for listofsegmentdimensions0 in dimensions {
                try dimensionsContainer.encode(listofsegmentdimensions0)
            }
        }
        if let sourceSegments = sourceSegments {
            var sourceSegmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceSegments)
            for listofsegmentreference0 in sourceSegments {
                try sourceSegmentsContainer.encode(listofsegmentreference0)
            }
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType.rawValue, forKey: .sourceType)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsContainer = try containerValues.decodeIfPresent([SegmentDimensions?].self, forKey: .dimensions)
        var dimensionsDecoded0:[SegmentDimensions]? = nil
        if let dimensionsContainer = dimensionsContainer {
            dimensionsDecoded0 = [SegmentDimensions]()
            for structure0 in dimensionsContainer {
                if let structure0 = structure0 {
                    dimensionsDecoded0?.append(structure0)
                }
            }
        }
        dimensions = dimensionsDecoded0
        let sourceSegmentsContainer = try containerValues.decodeIfPresent([SegmentReference?].self, forKey: .sourceSegments)
        var sourceSegmentsDecoded0:[SegmentReference]? = nil
        if let sourceSegmentsContainer = sourceSegmentsContainer {
            sourceSegmentsDecoded0 = [SegmentReference]()
            for structure0 in sourceSegmentsContainer {
                if let structure0 = structure0 {
                    sourceSegmentsDecoded0?.append(structure0)
                }
            }
        }
        sourceSegments = sourceSegmentsDecoded0
        let sourceTypeDecoded = try containerValues.decodeIfPresent(SourceType.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(`Type`.self, forKey: .type)
        type = typeDecoded
    }
}

extension SegmentGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentGroup(dimensions: \(String(describing: dimensions)), sourceSegments: \(String(describing: sourceSegments)), sourceType: \(String(describing: sourceType)), type: \(String(describing: type)))"}
}

/// <p>Specifies the base segments and dimensions for a segment, and the relationships between these base segments and dimensions.</p>
public struct SegmentGroup: Equatable {
    /// <p>An array that defines the dimensions for the segment.</p>
    public let dimensions: [SegmentDimensions]?
    /// <p>The base segment to build the segment on. A base segment, also referred to as a <i>source segment</i>, defines the initial population of endpoints for a segment. When you add dimensions to a segment, Amazon Pinpoint filters the base segment by using the dimensions that you specify.</p> <p>You can specify more than one dimensional segment or only one imported segment. If you specify an imported segment, the Amazon Pinpoint console displays a segment size estimate that indicates the size of the imported segment without any filters applied to it.</p>
    public let sourceSegments: [SegmentReference]?
    /// <p>Specifies how to handle multiple base segments for the segment. For example, if you specify three base segments for the segment, whether the resulting segment is based on all, any, or none of the base segments.</p>
    public let sourceType: SourceType?
    /// <p>Specifies how to handle multiple dimensions for the segment. For example, if you specify three dimensions for the segment, whether the resulting segment includes endpoints that match all, any, or none of the dimensions.</p>
    public let type: `Type`?

    public init (
        dimensions: [SegmentDimensions]? = nil,
        sourceSegments: [SegmentReference]? = nil,
        sourceType: SourceType? = nil,
        type: `Type`? = nil
    )
    {
        self.dimensions = dimensions
        self.sourceSegments = sourceSegments
        self.sourceType = sourceType
        self.type = type
    }
}

extension SegmentGroupList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groups = "Groups"
        case include = "Include"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for listofsegmentgroup0 in groups {
                try groupsContainer.encode(listofsegmentgroup0)
            }
        }
        if let include = include {
            try encodeContainer.encode(include.rawValue, forKey: .include)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([SegmentGroup?].self, forKey: .groups)
        var groupsDecoded0:[SegmentGroup]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [SegmentGroup]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let includeDecoded = try containerValues.decodeIfPresent(Include.self, forKey: .include)
        include = includeDecoded
    }
}

extension SegmentGroupList: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentGroupList(groups: \(String(describing: groups)), include: \(String(describing: include)))"}
}

/// <p>Specifies the settings that define the relationships between segment groups for a segment.</p>
public struct SegmentGroupList: Equatable {
    /// <p>An array that defines the set of segment criteria to evaluate when handling segment groups for the segment.</p>
    public let groups: [SegmentGroup]?
    /// <p>Specifies how to handle multiple segment groups for the segment. For example, if the segment includes three segment groups, whether the resulting segment includes endpoints that match all, any, or none of the segment groups.</p>
    public let include: Include?

    public init (
        groups: [SegmentGroup]? = nil,
        include: Include? = nil
    )
    {
        self.groups = groups
        self.include = include
    }
}

extension SegmentImportResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case channelCounts = "ChannelCounts"
        case externalId = "ExternalId"
        case format = "Format"
        case roleArn = "RoleArn"
        case s3Url = "S3Url"
        case size = "Size"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelCounts = channelCounts {
            var channelCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .channelCounts)
            for (dictKey0, mapof__integer0) in channelCounts {
                try channelCountsContainer.encode(mapof__integer0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let externalId = externalId {
            try encodeContainer.encode(externalId, forKey: .externalId)
        }
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3Url = s3Url {
            try encodeContainer.encode(s3Url, forKey: .s3Url)
        }
        if size != 0 {
            try encodeContainer.encode(size, forKey: .size)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .channelCounts)
        var channelCountsDecoded0: [String:Int]? = nil
        if let channelCountsContainer = channelCountsContainer {
            channelCountsDecoded0 = [String:Int]()
            for (key0, __integer0) in channelCountsContainer {
                if let __integer0 = __integer0 {
                    channelCountsDecoded0?[key0] = __integer0
                }
            }
        }
        channelCounts = channelCountsDecoded0
        let externalIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .externalId)
        externalId = externalIdDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let s3UrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Url)
        s3Url = s3UrlDecoded
        let sizeDecoded = try containerValues.decode(Int.self, forKey: .size)
        size = sizeDecoded
    }
}

extension SegmentImportResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentImportResource(channelCounts: \(String(describing: channelCounts)), externalId: \(String(describing: externalId)), format: \(String(describing: format)), roleArn: \(String(describing: roleArn)), s3Url: \(String(describing: s3Url)), size: \(String(describing: size)))"}
}

/// <p>Provides information about the import job that created a segment. An import job is a job that creates a user segment by importing endpoint definitions.</p>
public struct SegmentImportResource: Equatable {
    /// <p>The number of channel types in the endpoint definitions that were imported to create the segment.</p>
    public let channelCounts: [String:Int]?
    /// <p>(Deprecated) Your AWS account ID, which you assigned to an external ID key in an IAM trust policy. Amazon Pinpoint previously used this value to assume an IAM role when importing endpoint definitions, but we removed this requirement. We don't recommend use of external IDs for IAM roles that are assumed by Amazon Pinpoint.</p>
    public let externalId: String?
    /// <p>The format of the files that were imported to create the segment. Valid values are: CSV, for comma-separated values format; and, JSON, for newline-delimited JSON format.</p>
    public let format: Format?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorized Amazon Pinpoint to access the Amazon S3 location to import endpoint definitions from.</p>
    public let roleArn: String?
    /// <p>The URL of the Amazon Simple Storage Service (Amazon S3) bucket that the endpoint definitions were imported from to create the segment.</p>
    public let s3Url: String?
    /// <p>The number of endpoint definitions that were imported successfully to create the segment.</p>
    public let size: Int

    public init (
        channelCounts: [String:Int]? = nil,
        externalId: String? = nil,
        format: Format? = nil,
        roleArn: String? = nil,
        s3Url: String? = nil,
        size: Int = 0
    )
    {
        self.channelCounts = channelCounts
        self.externalId = externalId
        self.format = format
        self.roleArn = roleArn
        self.s3Url = s3Url
        self.size = size
    }
}

extension SegmentLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case country = "Country"
        case gPSPoint = "GPSPoint"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let country = country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let gPSPoint = gPSPoint {
            try encodeContainer.encode(gPSPoint, forKey: .gPSPoint)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryDecoded = try containerValues.decodeIfPresent(SetDimension.self, forKey: .country)
        country = countryDecoded
        let gPSPointDecoded = try containerValues.decodeIfPresent(GPSPointDimension.self, forKey: .gPSPoint)
        gPSPoint = gPSPointDecoded
    }
}

extension SegmentLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentLocation(country: \(String(describing: country)), gPSPoint: \(String(describing: gPSPoint)))"}
}

/// <p>Specifies geographical dimension settings for a segment.</p>
public struct SegmentLocation: Equatable {
    /// <p>The country or region code, in ISO 3166-1 alpha-2 format, for the segment.</p>
    public let country: SetDimension?
    /// <p>The GPS location and range for the segment.</p>
    public let gPSPoint: GPSPointDimension?

    public init (
        country: SetDimension? = nil,
        gPSPoint: GPSPointDimension? = nil
    )
    {
        self.country = country
        self.gPSPoint = gPSPoint
    }
}

extension SegmentReference: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case id = "Id"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension SegmentReference: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentReference(id: \(String(describing: id)), version: \(String(describing: version)))"}
}

/// <p>Specifies the segment identifier and version of a segment.</p>
public struct SegmentReference: Equatable {
    /// <p>The unique identifier for the segment.</p>
    public let id: String?
    /// <p>The version number of the segment.</p>
    public let version: Int

    public init (
        id: String? = nil,
        version: Int = 0
    )
    {
        self.id = id
        self.version = version
    }
}

extension SegmentResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case arn = "Arn"
        case creationDate = "CreationDate"
        case dimensions = "Dimensions"
        case id = "Id"
        case importDefinition = "ImportDefinition"
        case lastModifiedDate = "LastModifiedDate"
        case name = "Name"
        case segmentGroups = "SegmentGroups"
        case segmentType = "SegmentType"
        case version = "Version"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let importDefinition = importDefinition {
            try encodeContainer.encode(importDefinition, forKey: .importDefinition)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let segmentGroups = segmentGroups {
            try encodeContainer.encode(segmentGroups, forKey: .segmentGroups)
        }
        if let segmentType = segmentType {
            try encodeContainer.encode(segmentType.rawValue, forKey: .segmentType)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let dimensionsDecoded = try containerValues.decodeIfPresent(SegmentDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let importDefinitionDecoded = try containerValues.decodeIfPresent(SegmentImportResource.self, forKey: .importDefinition)
        importDefinition = importDefinitionDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let segmentGroupsDecoded = try containerValues.decodeIfPresent(SegmentGroupList.self, forKey: .segmentGroups)
        segmentGroups = segmentGroupsDecoded
        let segmentTypeDecoded = try containerValues.decodeIfPresent(SegmentType.self, forKey: .segmentType)
        segmentType = segmentTypeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension SegmentResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentResponse(applicationId: \(String(describing: applicationId)), arn: \(String(describing: arn)), creationDate: \(String(describing: creationDate)), dimensions: \(String(describing: dimensions)), id: \(String(describing: id)), importDefinition: \(String(describing: importDefinition)), lastModifiedDate: \(String(describing: lastModifiedDate)), name: \(String(describing: name)), segmentGroups: \(String(describing: segmentGroups)), segmentType: \(String(describing: segmentType)), version: \(String(describing: version)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about the configuration, dimension, and other settings for a segment.</p>
public struct SegmentResponse: Equatable {
    /// <p>The unique identifier for the application that the segment is associated with.</p>
    public let applicationId: String?
    /// <p>The Amazon Resource Name (ARN) of the segment.</p>
    public let arn: String?
    /// <p>The date and time when the segment was created.</p>
    public let creationDate: String?
    /// <p>The dimension settings for the segment.</p>
    public let dimensions: SegmentDimensions?
    /// <p>The unique identifier for the segment.</p>
    public let id: String?
    /// <p>The settings for the import job that's associated with the segment.</p>
    public let importDefinition: SegmentImportResource?
    /// <p>The date and time when the segment was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The name of the segment.</p>
    public let name: String?
    /// <p>A list of one or more segment groups that apply to the segment. Each segment group consists of zero or more base segments and the dimensions that are applied to those base segments.</p>
    public let segmentGroups: SegmentGroupList?
    /// <p>The segment type. Valid values are:</p> <ul><li><p>DIMENSIONAL - A dynamic segment, which is a segment that uses selection criteria that you specify and is based on endpoint data that's reported by your app. Dynamic segments can change over time.</p></li> <li><p>IMPORT - A static segment, which is a segment that uses selection criteria that you specify and is based on endpoint definitions that you import from a file. Imported segments are static; they don't change over time.</p></li></ul>
    public let segmentType: SegmentType?
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the segment. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>The version number of the segment.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        arn: String? = nil,
        creationDate: String? = nil,
        dimensions: SegmentDimensions? = nil,
        id: String? = nil,
        importDefinition: SegmentImportResource? = nil,
        lastModifiedDate: String? = nil,
        name: String? = nil,
        segmentGroups: SegmentGroupList? = nil,
        segmentType: SegmentType? = nil,
        tags: [String:String]? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.arn = arn
        self.creationDate = creationDate
        self.dimensions = dimensions
        self.id = id
        self.importDefinition = importDefinition
        self.lastModifiedDate = lastModifiedDate
        self.name = name
        self.segmentGroups = segmentGroups
        self.segmentType = segmentType
        self.tags = tags
        self.version = version
    }
}

public enum SegmentType {
    case dimensional
    case `import`
    case sdkUnknown(String)
}

extension SegmentType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SegmentType] {
        return [
            .dimensional,
            .import,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dimensional: return "DIMENSIONAL"
        case .import: return "IMPORT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SegmentType(rawValue: rawValue) ?? SegmentType.sdkUnknown(rawValue)
    }
}

extension SegmentsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listofsegmentresponse0 in item {
                try itemContainer.encode(listofsegmentresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([SegmentResponse?].self, forKey: .item)
        var itemDecoded0:[SegmentResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [SegmentResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension SegmentsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SegmentsResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about all the segments that are associated with an application.</p>
public struct SegmentsResponse: Equatable {
    /// <p>An array of responses, one for each segment that's associated with the application (Segments resource) or each version of a segment that's associated with the application (Segment Versions resource).</p>
    public let item: [SegmentResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [SegmentResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

public struct SendMessagesInputBodyMiddleware: Middleware {
    public let id: String = "SendMessagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<SendMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let messageRequest = input.operationInput.messageRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(messageRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendMessagesInput>
    public typealias MOutput = OperationOutput<SendMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendMessagesOutputError>
}

extension SendMessagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendMessagesInput(applicationId: \(String(describing: applicationId)), messageRequest: \(String(describing: messageRequest)))"}
}

extension SendMessagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case messageRequest = "MessageRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageRequest = messageRequest {
            try encodeContainer.encode(messageRequest, forKey: .messageRequest)
        }
    }
}

public struct SendMessagesInputHeadersMiddleware: Middleware {
    public let id: String = "SendMessagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<SendMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendMessagesInput>
    public typealias MOutput = OperationOutput<SendMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendMessagesOutputError>
}

public struct SendMessagesInputQueryItemMiddleware: Middleware {
    public let id: String = "SendMessagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<SendMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendMessagesInput>
    public typealias MOutput = OperationOutput<SendMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendMessagesOutputError>
}

public struct SendMessagesInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the configuration and other settings for a message.</p>
    public let messageRequest: MessageRequest?

    public init (
        applicationId: String? = nil,
        messageRequest: MessageRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.messageRequest = messageRequest
    }
}

struct SendMessagesInputBody: Equatable {
    public let messageRequest: MessageRequest?
}

extension SendMessagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageRequest = "MessageRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageRequestDecoded = try containerValues.decodeIfPresent(MessageRequest.self, forKey: .messageRequest)
        messageRequest = messageRequestDecoded
    }
}

extension SendMessagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendMessagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendMessagesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendMessagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendMessagesOutputResponse(messageResponse: \(String(describing: messageResponse)))"}
}

extension SendMessagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageResponse = output
            } else {
                self.messageResponse = nil
            }
        } else {
            self.messageResponse = nil
        }
    }
}

public struct SendMessagesOutputResponse: Equatable {
    /// <p>Provides information about the results of a request to send a message to an endpoint address.</p>
    public let messageResponse: MessageResponse?

    public init (
        messageResponse: MessageResponse? = nil
    )
    {
        self.messageResponse = messageResponse
    }
}

struct SendMessagesOutputResponseBody: Equatable {
    public let messageResponse: MessageResponse?
}

extension SendMessagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageResponse = "MessageResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageResponseDecoded = try containerValues.decodeIfPresent(MessageResponse.self, forKey: .messageResponse)
        messageResponse = messageResponseDecoded
    }
}

extension SendUsersMessageRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case context = "Context"
        case messageConfiguration = "MessageConfiguration"
        case templateConfiguration = "TemplateConfiguration"
        case traceId = "TraceId"
        case users = "Users"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = context {
            var contextContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .context)
            for (dictKey0, mapof__string0) in context {
                try contextContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let messageConfiguration = messageConfiguration {
            try encodeContainer.encode(messageConfiguration, forKey: .messageConfiguration)
        }
        if let templateConfiguration = templateConfiguration {
            try encodeContainer.encode(templateConfiguration, forKey: .templateConfiguration)
        }
        if let traceId = traceId {
            try encodeContainer.encode(traceId, forKey: .traceId)
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .users)
            for (dictKey0, mapofendpointsendconfiguration0) in users {
                try usersContainer.encode(mapofendpointsendconfiguration0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contextContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .context)
        var contextDecoded0: [String:String]? = nil
        if let contextContainer = contextContainer {
            contextDecoded0 = [String:String]()
            for (key0, __string0) in contextContainer {
                if let __string0 = __string0 {
                    contextDecoded0?[key0] = __string0
                }
            }
        }
        context = contextDecoded0
        let messageConfigurationDecoded = try containerValues.decodeIfPresent(DirectMessageConfiguration.self, forKey: .messageConfiguration)
        messageConfiguration = messageConfigurationDecoded
        let templateConfigurationDecoded = try containerValues.decodeIfPresent(TemplateConfiguration.self, forKey: .templateConfiguration)
        templateConfiguration = templateConfigurationDecoded
        let traceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .traceId)
        traceId = traceIdDecoded
        let usersContainer = try containerValues.decodeIfPresent([String: EndpointSendConfiguration?].self, forKey: .users)
        var usersDecoded0: [String:EndpointSendConfiguration]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [String:EndpointSendConfiguration]()
            for (key0, endpointsendconfiguration0) in usersContainer {
                if let endpointsendconfiguration0 = endpointsendconfiguration0 {
                    usersDecoded0?[key0] = endpointsendconfiguration0
                }
            }
        }
        users = usersDecoded0
    }
}

extension SendUsersMessageRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendUsersMessageRequest(context: \(String(describing: context)), messageConfiguration: \(String(describing: messageConfiguration)), templateConfiguration: \(String(describing: templateConfiguration)), traceId: \(String(describing: traceId)), users: \(String(describing: users)))"}
}

/// <p>Specifies the configuration and other settings for a message to send to all the endpoints that are associated with a list of users.</p>
public struct SendUsersMessageRequest: Equatable {
    /// <p>A map of custom attribute-value pairs. For a push notification, Amazon Pinpoint adds these attributes to the data.pinpoint object in the body of the notification payload. Amazon Pinpoint also provides these attributes in the events that it generates for users-messages deliveries.</p>
    public let context: [String:String]?
    /// <p>The settings and content for the default message and any default messages that you defined for specific channels.</p>
    public let messageConfiguration: DirectMessageConfiguration?
    /// <p>The message template to use for the message.</p>
    public let templateConfiguration: TemplateConfiguration?
    /// <p>The unique identifier for tracing the message. This identifier is visible to message recipients.</p>
    public let traceId: String?
    /// <p>A map that associates user IDs with <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> objects. You can use an <a href="https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-messages.html#apps-application-id-messages-model-endpointsendconfiguration">EndpointSendConfiguration</a> object to tailor the message for a user by specifying settings such as content overrides and message variables.</p>
    public let users: [String:EndpointSendConfiguration]?

    public init (
        context: [String:String]? = nil,
        messageConfiguration: DirectMessageConfiguration? = nil,
        templateConfiguration: TemplateConfiguration? = nil,
        traceId: String? = nil,
        users: [String:EndpointSendConfiguration]? = nil
    )
    {
        self.context = context
        self.messageConfiguration = messageConfiguration
        self.templateConfiguration = templateConfiguration
        self.traceId = traceId
        self.users = users
    }
}

extension SendUsersMessageResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case requestId = "RequestId"
        case result = "Result"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let result = result {
            var resultContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .result)
            for (dictKey0, mapofmapofendpointmessageresult0) in result {
                try resultContainer.encode(mapofmapofendpointmessageresult0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let resultContainer = try containerValues.decodeIfPresent([String: [String: EndpointMessageResult?]?].self, forKey: .result)
        var resultDecoded0: [String:[String:EndpointMessageResult]]? = nil
        if let resultContainer = resultContainer {
            resultDecoded0 = [String:[String:EndpointMessageResult]]()
            for (key0, mapofendpointmessageresult0) in resultContainer {
                var mapofendpointmessageresult0Decoded0: [String: EndpointMessageResult]? = nil
                if let mapofendpointmessageresult0 = mapofendpointmessageresult0 {
                    mapofendpointmessageresult0Decoded0 = [String: EndpointMessageResult]()
                    for (key1, endpointmessageresult1) in mapofendpointmessageresult0 {
                        if let endpointmessageresult1 = endpointmessageresult1 {
                            mapofendpointmessageresult0Decoded0?[key1] = endpointmessageresult1
                        }
                    }
                }
                resultDecoded0?[key0] = mapofendpointmessageresult0Decoded0
            }
        }
        result = resultDecoded0
    }
}

extension SendUsersMessageResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendUsersMessageResponse(applicationId: \(String(describing: applicationId)), requestId: \(String(describing: requestId)), result: \(String(describing: result)))"}
}

/// <p>Provides information about which users and endpoints a message was sent to.</p>
public struct SendUsersMessageResponse: Equatable {
    /// <p>The unique identifier for the application that was used to send the message.</p>
    public let applicationId: String?
    /// <p>The unique identifier that was assigned to the message request.</p>
    public let requestId: String?
    /// <p>An object that indicates which endpoints the message was sent to, for each user. The object lists user IDs and, for each user ID, provides the endpoint IDs that the message was sent to. For each endpoint ID, it provides an EndpointMessageResult object.</p>
    public let result: [String:[String:EndpointMessageResult]]?

    public init (
        applicationId: String? = nil,
        requestId: String? = nil,
        result: [String:[String:EndpointMessageResult]]? = nil
    )
    {
        self.applicationId = applicationId
        self.requestId = requestId
        self.result = result
    }
}

public struct SendUsersMessagesInputBodyMiddleware: Middleware {
    public let id: String = "SendUsersMessagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendUsersMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<SendUsersMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sendUsersMessageRequest = input.operationInput.sendUsersMessageRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(sendUsersMessageRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendUsersMessagesInput>
    public typealias MOutput = OperationOutput<SendUsersMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendUsersMessagesOutputError>
}

extension SendUsersMessagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendUsersMessagesInput(applicationId: \(String(describing: applicationId)), sendUsersMessageRequest: \(String(describing: sendUsersMessageRequest)))"}
}

extension SendUsersMessagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sendUsersMessageRequest = "SendUsersMessageRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sendUsersMessageRequest = sendUsersMessageRequest {
            try encodeContainer.encode(sendUsersMessageRequest, forKey: .sendUsersMessageRequest)
        }
    }
}

public struct SendUsersMessagesInputHeadersMiddleware: Middleware {
    public let id: String = "SendUsersMessagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendUsersMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<SendUsersMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendUsersMessagesInput>
    public typealias MOutput = OperationOutput<SendUsersMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendUsersMessagesOutputError>
}

public struct SendUsersMessagesInputQueryItemMiddleware: Middleware {
    public let id: String = "SendUsersMessagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendUsersMessagesInput>,
                  next: H) -> Swift.Result<OperationOutput<SendUsersMessagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendUsersMessagesInput>
    public typealias MOutput = OperationOutput<SendUsersMessagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendUsersMessagesOutputError>
}

public struct SendUsersMessagesInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the configuration and other settings for a message to send to all the endpoints that are associated with a list of users.</p>
    public let sendUsersMessageRequest: SendUsersMessageRequest?

    public init (
        applicationId: String? = nil,
        sendUsersMessageRequest: SendUsersMessageRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.sendUsersMessageRequest = sendUsersMessageRequest
    }
}

struct SendUsersMessagesInputBody: Equatable {
    public let sendUsersMessageRequest: SendUsersMessageRequest?
}

extension SendUsersMessagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendUsersMessageRequest = "SendUsersMessageRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendUsersMessageRequestDecoded = try containerValues.decodeIfPresent(SendUsersMessageRequest.self, forKey: .sendUsersMessageRequest)
        sendUsersMessageRequest = sendUsersMessageRequestDecoded
    }
}

extension SendUsersMessagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendUsersMessagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendUsersMessagesOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendUsersMessagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendUsersMessagesOutputResponse(sendUsersMessageResponse: \(String(describing: sendUsersMessageResponse)))"}
}

extension SendUsersMessagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SendUsersMessageResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.sendUsersMessageResponse = output
            } else {
                self.sendUsersMessageResponse = nil
            }
        } else {
            self.sendUsersMessageResponse = nil
        }
    }
}

public struct SendUsersMessagesOutputResponse: Equatable {
    /// <p>Provides information about which users and endpoints a message was sent to.</p>
    public let sendUsersMessageResponse: SendUsersMessageResponse?

    public init (
        sendUsersMessageResponse: SendUsersMessageResponse? = nil
    )
    {
        self.sendUsersMessageResponse = sendUsersMessageResponse
    }
}

struct SendUsersMessagesOutputResponseBody: Equatable {
    public let sendUsersMessageResponse: SendUsersMessageResponse?
}

extension SendUsersMessagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sendUsersMessageResponse = "SendUsersMessageResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sendUsersMessageResponseDecoded = try containerValues.decodeIfPresent(SendUsersMessageResponse.self, forKey: .sendUsersMessageResponse)
        sendUsersMessageResponse = sendUsersMessageResponseDecoded
    }
}

extension Session: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case duration = "Duration"
        case id = "Id"
        case startTimestamp = "StartTimestamp"
        case stopTimestamp = "StopTimestamp"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if duration != 0 {
            try encodeContainer.encode(duration, forKey: .duration)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let startTimestamp = startTimestamp {
            try encodeContainer.encode(startTimestamp, forKey: .startTimestamp)
        }
        if let stopTimestamp = stopTimestamp {
            try encodeContainer.encode(stopTimestamp, forKey: .stopTimestamp)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationDecoded = try containerValues.decode(Int.self, forKey: .duration)
        duration = durationDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let startTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTimestamp)
        startTimestamp = startTimestampDecoded
        let stopTimestampDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stopTimestamp)
        stopTimestamp = stopTimestampDecoded
    }
}

extension Session: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Session(duration: \(String(describing: duration)), id: \(String(describing: id)), startTimestamp: \(String(describing: startTimestamp)), stopTimestamp: \(String(describing: stopTimestamp)))"}
}

/// <p>Provides information about a session.</p>
public struct Session: Equatable {
    /// <p>The duration of the session, in milliseconds.</p>
    public let duration: Int
    /// <p>The unique identifier for the session.</p>
    public let id: String?
    /// <p>The date and time when the session began.</p>
    public let startTimestamp: String?
    /// <p>The date and time when the session ended.</p>
    public let stopTimestamp: String?

    public init (
        duration: Int = 0,
        id: String? = nil,
        startTimestamp: String? = nil,
        stopTimestamp: String? = nil
    )
    {
        self.duration = duration
        self.id = id
        self.startTimestamp = startTimestamp
        self.stopTimestamp = stopTimestamp
    }
}

extension SetDimension: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensionType = "DimensionType"
        case values = "Values"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensionType = dimensionType {
            try encodeContainer.encode(dimensionType.rawValue, forKey: .dimensionType)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for listof__string0 in values {
                try valuesContainer.encode(listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionTypeDecoded = try containerValues.decodeIfPresent(DimensionType.self, forKey: .dimensionType)
        dimensionType = dimensionTypeDecoded
        let valuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .values)
        var valuesDecoded0:[String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SetDimension: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetDimension(dimensionType: \(String(describing: dimensionType)), values: \(String(describing: values)))"}
}

/// <p>Specifies the dimension type and values for a segment dimension.</p>
public struct SetDimension: Equatable {
    /// <p>The type of segment dimension to use. Valid values are: INCLUSIVE, endpoints that match the criteria are included in the segment; and, EXCLUSIVE, endpoints that match the criteria are excluded from the segment.</p>
    public let dimensionType: DimensionType?
    /// <p>The criteria values to use for the segment dimension. Depending on the value of the DimensionType property, endpoints are included or excluded from the segment if their values match the criteria values.</p>
    public let values: [String]?

    public init (
        dimensionType: DimensionType? = nil,
        values: [String]? = nil
    )
    {
        self.dimensionType = dimensionType
        self.values = values
    }
}

extension SimpleCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventCondition = "EventCondition"
        case segmentCondition = "SegmentCondition"
        case segmentDimensions = "segmentDimensions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventCondition = eventCondition {
            try encodeContainer.encode(eventCondition, forKey: .eventCondition)
        }
        if let segmentCondition = segmentCondition {
            try encodeContainer.encode(segmentCondition, forKey: .segmentCondition)
        }
        if let segmentDimensions = segmentDimensions {
            try encodeContainer.encode(segmentDimensions, forKey: .segmentDimensions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventConditionDecoded = try containerValues.decodeIfPresent(EventCondition.self, forKey: .eventCondition)
        eventCondition = eventConditionDecoded
        let segmentConditionDecoded = try containerValues.decodeIfPresent(SegmentCondition.self, forKey: .segmentCondition)
        segmentCondition = segmentConditionDecoded
        let segmentDimensionsDecoded = try containerValues.decodeIfPresent(SegmentDimensions.self, forKey: .segmentDimensions)
        segmentDimensions = segmentDimensionsDecoded
    }
}

extension SimpleCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimpleCondition(eventCondition: \(String(describing: eventCondition)), segmentCondition: \(String(describing: segmentCondition)), segmentDimensions: \(String(describing: segmentDimensions)))"}
}

/// <p>Specifies a condition to evaluate for an activity in a journey.</p>
public struct SimpleCondition: Equatable {
    /// <p>The dimension settings for the event that's associated with the activity.</p>
    public let eventCondition: EventCondition?
    /// <p>The segment that's associated with the activity.</p>
    public let segmentCondition: SegmentCondition?
    /// <p>The dimension settings for the segment that's associated with the activity.</p>
    public let segmentDimensions: SegmentDimensions?

    public init (
        eventCondition: EventCondition? = nil,
        segmentCondition: SegmentCondition? = nil,
        segmentDimensions: SegmentDimensions? = nil
    )
    {
        self.eventCondition = eventCondition
        self.segmentCondition = segmentCondition
        self.segmentDimensions = segmentDimensions
    }
}

extension SimpleEmail: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case htmlPart = "HtmlPart"
        case subject = "Subject"
        case textPart = "TextPart"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let htmlPart = htmlPart {
            try encodeContainer.encode(htmlPart, forKey: .htmlPart)
        }
        if let subject = subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let textPart = textPart {
            try encodeContainer.encode(textPart, forKey: .textPart)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let htmlPartDecoded = try containerValues.decodeIfPresent(SimpleEmailPart.self, forKey: .htmlPart)
        htmlPart = htmlPartDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(SimpleEmailPart.self, forKey: .subject)
        subject = subjectDecoded
        let textPartDecoded = try containerValues.decodeIfPresent(SimpleEmailPart.self, forKey: .textPart)
        textPart = textPartDecoded
    }
}

extension SimpleEmail: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimpleEmail(htmlPart: \(String(describing: htmlPart)), subject: \(String(describing: subject)), textPart: \(String(describing: textPart)))"}
}

/// <p>Specifies the contents of an email message, composed of a subject, a text part, and an HTML part.</p>
public struct SimpleEmail: Equatable {
    /// <p>The body of the email message, in HTML format. We recommend using HTML format for email clients that render HTML content. You can include links, formatted text, and more in an HTML message.</p>
    public let htmlPart: SimpleEmailPart?
    /// <p>The subject line, or title, of the email.</p>
    public let subject: SimpleEmailPart?
    /// <p>The body of the email message, in plain text format. We recommend using plain text format for email clients that don't render HTML content and clients that are connected to high-latency networks, such as mobile devices.</p>
    public let textPart: SimpleEmailPart?

    public init (
        htmlPart: SimpleEmailPart? = nil,
        subject: SimpleEmailPart? = nil,
        textPart: SimpleEmailPart? = nil
    )
    {
        self.htmlPart = htmlPart
        self.subject = subject
        self.textPart = textPart
    }
}

extension SimpleEmailPart: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case charset = "Charset"
        case data = "Data"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let charset = charset {
            try encodeContainer.encode(charset, forKey: .charset)
        }
        if let data = data {
            try encodeContainer.encode(data, forKey: .data)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let charsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .charset)
        charset = charsetDecoded
        let dataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .data)
        data = dataDecoded
    }
}

extension SimpleEmailPart: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SimpleEmailPart(charset: \(String(describing: charset)), data: \(String(describing: data)))"}
}

/// <p>Specifies the subject or body of an email message, represented as textual email data and the applicable character set.</p>
public struct SimpleEmailPart: Equatable {
    /// <p>The applicable character set for the message content.</p>
    public let charset: String?
    /// <p>The textual data of the message content.</p>
    public let data: String?

    public init (
        charset: String? = nil,
        data: String? = nil
    )
    {
        self.charset = charset
        self.data = data
    }
}

public enum SourceType {
    case all
    case any
    case `none`
    case sdkUnknown(String)
}

extension SourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceType] {
        return [
            .all,
            .any,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .any: return "ANY"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceType(rawValue: rawValue) ?? SourceType.sdkUnknown(rawValue)
    }
}

extension StartCondition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case eventStartCondition = "EventStartCondition"
        case segmentStartCondition = "SegmentStartCondition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let eventStartCondition = eventStartCondition {
            try encodeContainer.encode(eventStartCondition, forKey: .eventStartCondition)
        }
        if let segmentStartCondition = segmentStartCondition {
            try encodeContainer.encode(segmentStartCondition, forKey: .segmentStartCondition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let eventStartConditionDecoded = try containerValues.decodeIfPresent(EventStartCondition.self, forKey: .eventStartCondition)
        eventStartCondition = eventStartConditionDecoded
        let segmentStartConditionDecoded = try containerValues.decodeIfPresent(SegmentCondition.self, forKey: .segmentStartCondition)
        segmentStartCondition = segmentStartConditionDecoded
    }
}

extension StartCondition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartCondition(description: \(String(describing: description)), eventStartCondition: \(String(describing: eventStartCondition)), segmentStartCondition: \(String(describing: segmentStartCondition)))"}
}

/// <p>Specifies the conditions for the first activity in a journey. This activity and its conditions determine which users are participants in a journey.</p>
public struct StartCondition: Equatable {
    /// <p>The custom description of the condition.</p>
    public let description: String?
    /// <p>Specifies the settings for an event that causes a journey activity to start.</p>
    public let eventStartCondition: EventStartCondition?
    /// <p>The segment that's associated with the first activity in the journey. This segment determines which users are participants in the journey.</p>
    public let segmentStartCondition: SegmentCondition?

    public init (
        description: String? = nil,
        eventStartCondition: EventStartCondition? = nil,
        segmentStartCondition: SegmentCondition? = nil
    )
    {
        self.description = description
        self.eventStartCondition = eventStartCondition
        self.segmentStartCondition = segmentStartCondition
    }
}

public enum State {
    case active
    case cancelled
    case closed
    case completed
    case draft
    case paused
    case sdkUnknown(String)
}

extension State : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [State] {
        return [
            .active,
            .cancelled,
            .closed,
            .completed,
            .draft,
            .paused,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .cancelled: return "CANCELLED"
        case .closed: return "CLOSED"
        case .completed: return "COMPLETED"
        case .draft: return "DRAFT"
        case .paused: return "PAUSED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagsModel = input.operationInput.tagsModel {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(tagsModel)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tagsModel: \(String(describing: tagsModel)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tagsModel = "TagsModel"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagsModel = tagsModel {
            try encodeContainer.encode(tagsModel, forKey: .tagsModel)
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>Specifies the tags (keys and values) for an application, campaign, message template, or segment.</p>
    public let tagsModel: TagsModel?

    public init (
        resourceArn: String? = nil,
        tagsModel: TagsModel? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagsModel = tagsModel
    }
}

struct TagResourceInputBody: Equatable {
    public let tagsModel: TagsModel?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagsModel = "TagsModel"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsModelDecoded = try containerValues.decodeIfPresent(TagsModel.self, forKey: .tagsModel)
        tagsModel = tagsModelDecoded
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TagsModel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagsModel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagsModel(tags: \(String(describing: tags)))"}
}

/// <p>Specifies the tags (keys and values) for an application, campaign, message template, or segment.</p>
public struct TagsModel: Equatable {
    /// <p>A string-to-string map of key-value pairs that defines the tags for an application, campaign, message template, or segment. Each of these resources can have a maximum of 50 tags.</p> <p>Each tag consists of a required tag key and an associated tag value. The maximum length of a tag key is 128 characters. The maximum length of a tag value is 256 characters.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

extension Template: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension Template: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Template(name: \(String(describing: name)), version: \(String(describing: version)))"}
}

/// <p>Specifies the name and version of the message template to use for the message.</p>
public struct Template: Equatable {
    /// <p>The name of the message template to use for the message. If specified, this value must match the name of an existing message template.</p>
    public let name: String?
    /// <p>The unique identifier for the version of the message template to use for the message. If specified, this value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If you don't specify a value for this property, Amazon Pinpoint uses the <i>active version</i> of the template. The <i>active version</i> is typically the version of a template that's been most recently reviewed and approved for use, depending on your workflow. It isn't necessarily the latest version of a template.</p>
    public let version: String?

    public init (
        name: String? = nil,
        version: String? = nil
    )
    {
        self.name = name
        self.version = version
    }
}

extension TemplateActiveVersionRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension TemplateActiveVersionRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateActiveVersionRequest(version: \(String(describing: version)))"}
}

/// <p>Specifies which version of a message template to use as the active version of the template.</p>
public struct TemplateActiveVersionRequest: Equatable {
    /// <p>The version of the message template to use as the active version of the template. Valid values are: latest, for the most recent version of the template; or, the unique identifier for any existing version of the template. If you specify an identifier, the value must match the identifier for an existing template version. To retrieve a list of versions and version identifiers for a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p>
    public let version: String?

    public init (
        version: String? = nil
    )
    {
        self.version = version
    }
}

extension TemplateConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailTemplate = "EmailTemplate"
        case pushTemplate = "PushTemplate"
        case sMSTemplate = "SMSTemplate"
        case voiceTemplate = "VoiceTemplate"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailTemplate = emailTemplate {
            try encodeContainer.encode(emailTemplate, forKey: .emailTemplate)
        }
        if let pushTemplate = pushTemplate {
            try encodeContainer.encode(pushTemplate, forKey: .pushTemplate)
        }
        if let sMSTemplate = sMSTemplate {
            try encodeContainer.encode(sMSTemplate, forKey: .sMSTemplate)
        }
        if let voiceTemplate = voiceTemplate {
            try encodeContainer.encode(voiceTemplate, forKey: .voiceTemplate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailTemplateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .emailTemplate)
        emailTemplate = emailTemplateDecoded
        let pushTemplateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .pushTemplate)
        pushTemplate = pushTemplateDecoded
        let sMSTemplateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .sMSTemplate)
        sMSTemplate = sMSTemplateDecoded
        let voiceTemplateDecoded = try containerValues.decodeIfPresent(Template.self, forKey: .voiceTemplate)
        voiceTemplate = voiceTemplateDecoded
    }
}

extension TemplateConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateConfiguration(emailTemplate: \(String(describing: emailTemplate)), pushTemplate: \(String(describing: pushTemplate)), sMSTemplate: \(String(describing: sMSTemplate)), voiceTemplate: \(String(describing: voiceTemplate)))"}
}

/// <p>Specifies the message template to use for the message, for each type of channel.</p>
public struct TemplateConfiguration: Equatable {
    /// <p>The email template to use for the message.</p>
    public let emailTemplate: Template?
    /// <p>The push notification template to use for the message.</p>
    public let pushTemplate: Template?
    /// <p>The SMS template to use for the message.</p>
    public let sMSTemplate: Template?
    /// <p>The voice template to use for the message. This object isn't supported for campaigns.</p>
    public let voiceTemplate: Template?

    public init (
        emailTemplate: Template? = nil,
        pushTemplate: Template? = nil,
        sMSTemplate: Template? = nil,
        voiceTemplate: Template? = nil
    )
    {
        self.emailTemplate = emailTemplate
        self.pushTemplate = pushTemplate
        self.sMSTemplate = sMSTemplate
        self.voiceTemplate = voiceTemplate
    }
}

extension TemplateResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case creationDate = "CreationDate"
        case defaultSubstitutions = "DefaultSubstitutions"
        case lastModifiedDate = "LastModifiedDate"
        case templateDescription = "TemplateDescription"
        case templateName = "TemplateName"
        case templateType = "TemplateType"
        case version = "Version"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension TemplateResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateResponse(arn: \(String(describing: arn)), creationDate: \(String(describing: creationDate)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), lastModifiedDate: \(String(describing: lastModifiedDate)), templateDescription: \(String(describing: templateDescription)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)), version: \(String(describing: version)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about a message template that's associated with your Amazon Pinpoint account.</p>
public struct TemplateResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the message template. This value isn't included in a TemplateResponse object. To retrieve the ARN of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the ARN for.</p>
    public let arn: String?
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    public let creationDate: String?
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
    public let defaultSubstitutions: String?
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>A map of key-value pairs that identifies the tags that are associated with the message template. This object isn't included in a TemplateResponse object. To retrieve this object for a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the object for.</p>
    public let tags: [String:String]?
    /// <p>The custom description of the message template. This value isn't included in a TemplateResponse object. To retrieve the description of a template, use the GetEmailTemplate, GetPushTemplate, GetSmsTemplate, or GetVoiceTemplate operation, depending on the type of template that you want to retrieve the description for.</p>
    public let templateDescription: String?
    /// <p>The name of the message template.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
    public let templateType: TemplateType?
    /// <p>The unique identifier, as an integer, for the active version of the message template.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        creationDate: String? = nil,
        defaultSubstitutions: String? = nil,
        lastModifiedDate: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil,
        templateName: String? = nil,
        templateType: TemplateType? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.creationDate = creationDate
        self.defaultSubstitutions = defaultSubstitutions
        self.lastModifiedDate = lastModifiedDate
        self.tags = tags
        self.templateDescription = templateDescription
        self.templateName = templateName
        self.templateType = templateType
        self.version = version
    }
}

public enum TemplateType {
    case email
    case push
    case sms
    case voice
    case sdkUnknown(String)
}

extension TemplateType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TemplateType] {
        return [
            .email,
            .push,
            .sms,
            .voice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .email: return "EMAIL"
        case .push: return "PUSH"
        case .sms: return "SMS"
        case .voice: return "VOICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TemplateType(rawValue: rawValue) ?? TemplateType.sdkUnknown(rawValue)
    }
}

extension TemplateVersionResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case creationDate = "CreationDate"
        case defaultSubstitutions = "DefaultSubstitutions"
        case lastModifiedDate = "LastModifiedDate"
        case templateDescription = "TemplateDescription"
        case templateName = "TemplateName"
        case templateType = "TemplateType"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType, forKey: .templateType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
    }
}

extension TemplateVersionResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateVersionResponse(creationDate: \(String(describing: creationDate)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), lastModifiedDate: \(String(describing: lastModifiedDate)), templateDescription: \(String(describing: templateDescription)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)), version: \(String(describing: version)))"}
}

/// <p>Provides information about a specific version of a message template.</p>
public struct TemplateVersionResponse: Equatable {
    /// <p>The date, in ISO 8601 format, when the version of the message template was created.</p>
    public let creationDate: String?
    /// <p>A JSON object that specifies the default values that are used for message variables in the version of the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    public let defaultSubstitutions: String?
    /// <p>The date, in ISO 8601 format, when the version of the message template was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The custom description of the version of the message template.</p>
    public let templateDescription: String?
    /// <p>The name of the message template.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. Possible values are: EMAIL, PUSH, SMS, and VOICE.</p>
    public let templateType: String?
    /// <p>The unique identifier for the version of the message template. This value is an integer that Amazon Pinpoint automatically increments and assigns to each new version of a template.</p>
    public let version: String?

    public init (
        creationDate: String? = nil,
        defaultSubstitutions: String? = nil,
        lastModifiedDate: String? = nil,
        templateDescription: String? = nil,
        templateName: String? = nil,
        templateType: String? = nil,
        version: String? = nil
    )
    {
        self.creationDate = creationDate
        self.defaultSubstitutions = defaultSubstitutions
        self.lastModifiedDate = lastModifiedDate
        self.templateDescription = templateDescription
        self.templateName = templateName
        self.templateType = templateType
        self.version = version
    }
}

extension TemplateVersionsResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case message = "Message"
        case nextToken = "NextToken"
        case requestID = "RequestID"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listoftemplateversionresponse0 in item {
                try itemContainer.encode(listoftemplateversionresponse0)
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let requestID = requestID {
            try encodeContainer.encode(requestID, forKey: .requestID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([TemplateVersionResponse?].self, forKey: .item)
        var itemDecoded0:[TemplateVersionResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [TemplateVersionResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension TemplateVersionsResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplateVersionsResponse(item: \(String(describing: item)), message: \(String(describing: message)), nextToken: \(String(describing: nextToken)), requestID: \(String(describing: requestID)))"}
}

/// <p>Provides information about all the versions of a specific message template.</p>
public struct TemplateVersionsResponse: Equatable {
    /// <p>An array of responses, one for each version of the message template.</p>
    public let item: [TemplateVersionResponse]?
    /// <p>The message that's returned from the API for the request to retrieve information about all the versions of the message template.</p>
    public let message: String?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?
    /// <p>The unique identifier for the request to retrieve information about all the versions of the message template.</p>
    public let requestID: String?

    public init (
        item: [TemplateVersionResponse]? = nil,
        message: String? = nil,
        nextToken: String? = nil,
        requestID: String? = nil
    )
    {
        self.item = item
        self.message = message
        self.nextToken = nextToken
        self.requestID = requestID
    }
}

extension TemplatesResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case item = "Item"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let item = item {
            var itemContainer = encodeContainer.nestedUnkeyedContainer(forKey: .item)
            for listoftemplateresponse0 in item {
                try itemContainer.encode(listoftemplateresponse0)
            }
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemContainer = try containerValues.decodeIfPresent([TemplateResponse?].self, forKey: .item)
        var itemDecoded0:[TemplateResponse]? = nil
        if let itemContainer = itemContainer {
            itemDecoded0 = [TemplateResponse]()
            for structure0 in itemContainer {
                if let structure0 = structure0 {
                    itemDecoded0?.append(structure0)
                }
            }
        }
        item = itemDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension TemplatesResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TemplatesResponse(item: \(String(describing: item)), nextToken: \(String(describing: nextToken)))"}
}

/// <p>Provides information about all the message templates that are associated with your Amazon Pinpoint account.</p>
public struct TemplatesResponse: Equatable {
    /// <p>An array of responses, one for each message template that's associated with your Amazon Pinpoint account and meets any filter criteria that you specified in the request.</p>
    public let item: [TemplateResponse]?
    /// <p>The string to use in a subsequent request to get the next page of results in a paginated response. This value is null if there are no additional pages.</p>
    public let nextToken: String?

    public init (
        item: [TemplateResponse]? = nil,
        nextToken: String? = nil
    )
    {
        self.item = item
        self.nextToken = nextToken
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)), requestID: \(String(describing: requestID)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.requestID = output.requestID
        } else {
            self.message = nil
            self.requestID = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Provides information about an API request or response.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The message that's returned from the API.</p>
    public var message: String?
    /// <p>The unique identifier for the request or response.</p>
    public var requestID: String?

    public init (
        message: String? = nil,
        requestID: String? = nil
    )
    {
        self.message = message
        self.requestID = requestID
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
    public let requestID: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case requestID = "RequestID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let requestIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestID)
        requestID = requestIDDecoded
    }
}

extension TreatmentResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customDeliveryConfiguration = "CustomDeliveryConfiguration"
        case id = "Id"
        case messageConfiguration = "MessageConfiguration"
        case schedule = "Schedule"
        case sizePercent = "SizePercent"
        case state = "State"
        case templateConfiguration = "TemplateConfiguration"
        case treatmentDescription = "TreatmentDescription"
        case treatmentName = "TreatmentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDeliveryConfiguration = customDeliveryConfiguration {
            try encodeContainer.encode(customDeliveryConfiguration, forKey: .customDeliveryConfiguration)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let messageConfiguration = messageConfiguration {
            try encodeContainer.encode(messageConfiguration, forKey: .messageConfiguration)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if sizePercent != 0 {
            try encodeContainer.encode(sizePercent, forKey: .sizePercent)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let templateConfiguration = templateConfiguration {
            try encodeContainer.encode(templateConfiguration, forKey: .templateConfiguration)
        }
        if let treatmentDescription = treatmentDescription {
            try encodeContainer.encode(treatmentDescription, forKey: .treatmentDescription)
        }
        if let treatmentName = treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(CustomDeliveryConfiguration.self, forKey: .customDeliveryConfiguration)
        customDeliveryConfiguration = customDeliveryConfigurationDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let messageConfigurationDecoded = try containerValues.decodeIfPresent(MessageConfiguration.self, forKey: .messageConfiguration)
        messageConfiguration = messageConfigurationDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let sizePercentDecoded = try containerValues.decode(Int.self, forKey: .sizePercent)
        sizePercent = sizePercentDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CampaignState.self, forKey: .state)
        state = stateDecoded
        let templateConfigurationDecoded = try containerValues.decodeIfPresent(TemplateConfiguration.self, forKey: .templateConfiguration)
        templateConfiguration = templateConfigurationDecoded
        let treatmentDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentDescription)
        treatmentDescription = treatmentDescriptionDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
    }
}

extension TreatmentResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TreatmentResource(customDeliveryConfiguration: \(String(describing: customDeliveryConfiguration)), id: \(String(describing: id)), messageConfiguration: \(String(describing: messageConfiguration)), schedule: \(String(describing: schedule)), sizePercent: \(String(describing: sizePercent)), state: \(String(describing: state)), templateConfiguration: \(String(describing: templateConfiguration)), treatmentDescription: \(String(describing: treatmentDescription)), treatmentName: \(String(describing: treatmentName)))"}
}

/// <p>Specifies the settings for a campaign treatment. A <i>treatment</i> is a variation of a campaign that's used for A/B testing of a campaign.</p>
public struct TreatmentResource: Equatable {
    /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
    public let customDeliveryConfiguration: CustomDeliveryConfiguration?
    /// <p>The unique identifier for the treatment.</p>
    public let id: String?
    /// <p>The message configuration settings for the treatment.</p>
    public let messageConfiguration: MessageConfiguration?
    /// <p>The schedule settings for the treatment.</p>
    public let schedule: Schedule?
    /// <p>The allocated percentage of users (segment members) that the treatment is sent to.</p>
    public let sizePercent: Int
    /// <p>The current status of the treatment.</p>
    public let state: CampaignState?
    /// <p>The message template to use for the treatment.</p>
    public let templateConfiguration: TemplateConfiguration?
    /// <p>The custom description of the treatment.</p>
    public let treatmentDescription: String?
    /// <p>The custom name of the treatment.</p>
    public let treatmentName: String?

    public init (
        customDeliveryConfiguration: CustomDeliveryConfiguration? = nil,
        id: String? = nil,
        messageConfiguration: MessageConfiguration? = nil,
        schedule: Schedule? = nil,
        sizePercent: Int = 0,
        state: CampaignState? = nil,
        templateConfiguration: TemplateConfiguration? = nil,
        treatmentDescription: String? = nil,
        treatmentName: String? = nil
    )
    {
        self.customDeliveryConfiguration = customDeliveryConfiguration
        self.id = id
        self.messageConfiguration = messageConfiguration
        self.schedule = schedule
        self.sizePercent = sizePercent
        self.state = state
        self.templateConfiguration = templateConfiguration
        self.treatmentDescription = treatmentDescription
        self.treatmentName = treatmentName
    }
}

public enum `Type` {
    case all
    case any
    case `none`
    case sdkUnknown(String)
}

extension `Type` : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [`Type`] {
        return [
            .all,
            .any,
            .none,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case .any: return "ANY"
        case .none: return "NONE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = `Type`(rawValue: rawValue) ?? `Type`.sdkUnknown(rawValue)
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The key of the tag to remove from the resource. To remove multiple tags, append the tagKeys parameter and argument for each additional tag to remove, separated by an ampersand (&amp;).</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAdmChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAdmChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAdmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAdmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aDMChannelRequest = input.operationInput.aDMChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(aDMChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAdmChannelInput>
    public typealias MOutput = OperationOutput<UpdateAdmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAdmChannelOutputError>
}

extension UpdateAdmChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAdmChannelInput(aDMChannelRequest: \(String(describing: aDMChannelRequest)), applicationId: \(String(describing: applicationId)))"}
}

extension UpdateAdmChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aDMChannelRequest = "ADMChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aDMChannelRequest = aDMChannelRequest {
            try encodeContainer.encode(aDMChannelRequest, forKey: .aDMChannelRequest)
        }
    }
}

public struct UpdateAdmChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAdmChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAdmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAdmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAdmChannelInput>
    public typealias MOutput = OperationOutput<UpdateAdmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAdmChannelOutputError>
}

public struct UpdateAdmChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAdmChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAdmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAdmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAdmChannelInput>
    public typealias MOutput = OperationOutput<UpdateAdmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAdmChannelOutputError>
}

public struct UpdateAdmChannelInput: Equatable {
    /// <p>Specifies the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
    public let aDMChannelRequest: ADMChannelRequest?
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        aDMChannelRequest: ADMChannelRequest? = nil,
        applicationId: String? = nil
    )
    {
        self.aDMChannelRequest = aDMChannelRequest
        self.applicationId = applicationId
    }
}

struct UpdateAdmChannelInputBody: Equatable {
    public let aDMChannelRequest: ADMChannelRequest?
}

extension UpdateAdmChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aDMChannelRequest = "ADMChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMChannelRequestDecoded = try containerValues.decodeIfPresent(ADMChannelRequest.self, forKey: .aDMChannelRequest)
        aDMChannelRequest = aDMChannelRequestDecoded
    }
}

extension UpdateAdmChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAdmChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAdmChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAdmChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAdmChannelOutputResponse(aDMChannelResponse: \(String(describing: aDMChannelResponse)))"}
}

extension UpdateAdmChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ADMChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aDMChannelResponse = output
            } else {
                self.aDMChannelResponse = nil
            }
        } else {
            self.aDMChannelResponse = nil
        }
    }
}

public struct UpdateAdmChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the ADM (Amazon Device Messaging) channel for an application.</p>
    public let aDMChannelResponse: ADMChannelResponse?

    public init (
        aDMChannelResponse: ADMChannelResponse? = nil
    )
    {
        self.aDMChannelResponse = aDMChannelResponse
    }
}

struct UpdateAdmChannelOutputResponseBody: Equatable {
    public let aDMChannelResponse: ADMChannelResponse?
}

extension UpdateAdmChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aDMChannelResponse = "ADMChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aDMChannelResponseDecoded = try containerValues.decodeIfPresent(ADMChannelResponse.self, forKey: .aDMChannelResponse)
        aDMChannelResponse = aDMChannelResponseDecoded
    }
}

public struct UpdateApnsChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApnsChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aPNSChannelRequest = input.operationInput.aPNSChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(aPNSChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsChannelOutputError>
}

extension UpdateApnsChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsChannelInput(aPNSChannelRequest: \(String(describing: aPNSChannelRequest)), applicationId: \(String(describing: applicationId)))"}
}

extension UpdateApnsChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aPNSChannelRequest = "APNSChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aPNSChannelRequest = aPNSChannelRequest {
            try encodeContainer.encode(aPNSChannelRequest, forKey: .aPNSChannelRequest)
        }
    }
}

public struct UpdateApnsChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApnsChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsChannelOutputError>
}

public struct UpdateApnsChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApnsChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsChannelOutputError>
}

public struct UpdateApnsChannelInput: Equatable {
    /// <p>Specifies the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
    public let aPNSChannelRequest: APNSChannelRequest?
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        aPNSChannelRequest: APNSChannelRequest? = nil,
        applicationId: String? = nil
    )
    {
        self.aPNSChannelRequest = aPNSChannelRequest
        self.applicationId = applicationId
    }
}

struct UpdateApnsChannelInputBody: Equatable {
    public let aPNSChannelRequest: APNSChannelRequest?
}

extension UpdateApnsChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSChannelRequest = "APNSChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSChannelRequestDecoded = try containerValues.decodeIfPresent(APNSChannelRequest.self, forKey: .aPNSChannelRequest)
        aPNSChannelRequest = aPNSChannelRequestDecoded
    }
}

extension UpdateApnsChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApnsChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApnsChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApnsChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsChannelOutputResponse(aPNSChannelResponse: \(String(describing: aPNSChannelResponse)))"}
}

extension UpdateApnsChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSChannelResponse = output
            } else {
                self.aPNSChannelResponse = nil
            }
        } else {
            self.aPNSChannelResponse = nil
        }
    }
}

public struct UpdateApnsChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) channel for an application.</p>
    public let aPNSChannelResponse: APNSChannelResponse?

    public init (
        aPNSChannelResponse: APNSChannelResponse? = nil
    )
    {
        self.aPNSChannelResponse = aPNSChannelResponse
    }
}

struct UpdateApnsChannelOutputResponseBody: Equatable {
    public let aPNSChannelResponse: APNSChannelResponse?
}

extension UpdateApnsChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSChannelResponse = "APNSChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSChannelResponseDecoded = try containerValues.decodeIfPresent(APNSChannelResponse.self, forKey: .aPNSChannelResponse)
        aPNSChannelResponse = aPNSChannelResponseDecoded
    }
}

public struct UpdateApnsSandboxChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApnsSandboxChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aPNSSandboxChannelRequest = input.operationInput.aPNSSandboxChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(aPNSSandboxChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsSandboxChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsSandboxChannelOutputError>
}

extension UpdateApnsSandboxChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsSandboxChannelInput(aPNSSandboxChannelRequest: \(String(describing: aPNSSandboxChannelRequest)), applicationId: \(String(describing: applicationId)))"}
}

extension UpdateApnsSandboxChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aPNSSandboxChannelRequest = "APNSSandboxChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aPNSSandboxChannelRequest = aPNSSandboxChannelRequest {
            try encodeContainer.encode(aPNSSandboxChannelRequest, forKey: .aPNSSandboxChannelRequest)
        }
    }
}

public struct UpdateApnsSandboxChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApnsSandboxChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsSandboxChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsSandboxChannelOutputError>
}

public struct UpdateApnsSandboxChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApnsSandboxChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsSandboxChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsSandboxChannelOutputError>
}

public struct UpdateApnsSandboxChannelInput: Equatable {
    /// <p>Specifies the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
    public let aPNSSandboxChannelRequest: APNSSandboxChannelRequest?
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        aPNSSandboxChannelRequest: APNSSandboxChannelRequest? = nil,
        applicationId: String? = nil
    )
    {
        self.aPNSSandboxChannelRequest = aPNSSandboxChannelRequest
        self.applicationId = applicationId
    }
}

struct UpdateApnsSandboxChannelInputBody: Equatable {
    public let aPNSSandboxChannelRequest: APNSSandboxChannelRequest?
}

extension UpdateApnsSandboxChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSSandboxChannelRequest = "APNSSandboxChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSSandboxChannelRequestDecoded = try containerValues.decodeIfPresent(APNSSandboxChannelRequest.self, forKey: .aPNSSandboxChannelRequest)
        aPNSSandboxChannelRequest = aPNSSandboxChannelRequestDecoded
    }
}

extension UpdateApnsSandboxChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApnsSandboxChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApnsSandboxChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApnsSandboxChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsSandboxChannelOutputResponse(aPNSSandboxChannelResponse: \(String(describing: aPNSSandboxChannelResponse)))"}
}

extension UpdateApnsSandboxChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSSandboxChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSSandboxChannelResponse = output
            } else {
                self.aPNSSandboxChannelResponse = nil
            }
        } else {
            self.aPNSSandboxChannelResponse = nil
        }
    }
}

public struct UpdateApnsSandboxChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) sandbox channel for an application.</p>
    public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse?

    public init (
        aPNSSandboxChannelResponse: APNSSandboxChannelResponse? = nil
    )
    {
        self.aPNSSandboxChannelResponse = aPNSSandboxChannelResponse
    }
}

struct UpdateApnsSandboxChannelOutputResponseBody: Equatable {
    public let aPNSSandboxChannelResponse: APNSSandboxChannelResponse?
}

extension UpdateApnsSandboxChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSSandboxChannelResponse = "APNSSandboxChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSSandboxChannelResponseDecoded = try containerValues.decodeIfPresent(APNSSandboxChannelResponse.self, forKey: .aPNSSandboxChannelResponse)
        aPNSSandboxChannelResponse = aPNSSandboxChannelResponseDecoded
    }
}

public struct UpdateApnsVoipChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApnsVoipChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsVoipChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsVoipChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aPNSVoipChannelRequest = input.operationInput.aPNSVoipChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(aPNSVoipChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsVoipChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsVoipChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsVoipChannelOutputError>
}

extension UpdateApnsVoipChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsVoipChannelInput(aPNSVoipChannelRequest: \(String(describing: aPNSVoipChannelRequest)), applicationId: \(String(describing: applicationId)))"}
}

extension UpdateApnsVoipChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipChannelRequest = "APNSVoipChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aPNSVoipChannelRequest = aPNSVoipChannelRequest {
            try encodeContainer.encode(aPNSVoipChannelRequest, forKey: .aPNSVoipChannelRequest)
        }
    }
}

public struct UpdateApnsVoipChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApnsVoipChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsVoipChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsVoipChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsVoipChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsVoipChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsVoipChannelOutputError>
}

public struct UpdateApnsVoipChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApnsVoipChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsVoipChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsVoipChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsVoipChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsVoipChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsVoipChannelOutputError>
}

public struct UpdateApnsVoipChannelInput: Equatable {
    /// <p>Specifies the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
    public let aPNSVoipChannelRequest: APNSVoipChannelRequest?
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        aPNSVoipChannelRequest: APNSVoipChannelRequest? = nil,
        applicationId: String? = nil
    )
    {
        self.aPNSVoipChannelRequest = aPNSVoipChannelRequest
        self.applicationId = applicationId
    }
}

struct UpdateApnsVoipChannelInputBody: Equatable {
    public let aPNSVoipChannelRequest: APNSVoipChannelRequest?
}

extension UpdateApnsVoipChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipChannelRequest = "APNSVoipChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipChannelRequestDecoded = try containerValues.decodeIfPresent(APNSVoipChannelRequest.self, forKey: .aPNSVoipChannelRequest)
        aPNSVoipChannelRequest = aPNSVoipChannelRequestDecoded
    }
}

extension UpdateApnsVoipChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApnsVoipChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApnsVoipChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApnsVoipChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsVoipChannelOutputResponse(aPNSVoipChannelResponse: \(String(describing: aPNSVoipChannelResponse)))"}
}

extension UpdateApnsVoipChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSVoipChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSVoipChannelResponse = output
            } else {
                self.aPNSVoipChannelResponse = nil
            }
        } else {
            self.aPNSVoipChannelResponse = nil
        }
    }
}

public struct UpdateApnsVoipChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP channel for an application.</p>
    public let aPNSVoipChannelResponse: APNSVoipChannelResponse?

    public init (
        aPNSVoipChannelResponse: APNSVoipChannelResponse? = nil
    )
    {
        self.aPNSVoipChannelResponse = aPNSVoipChannelResponse
    }
}

struct UpdateApnsVoipChannelOutputResponseBody: Equatable {
    public let aPNSVoipChannelResponse: APNSVoipChannelResponse?
}

extension UpdateApnsVoipChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipChannelResponse = "APNSVoipChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipChannelResponseDecoded = try containerValues.decodeIfPresent(APNSVoipChannelResponse.self, forKey: .aPNSVoipChannelResponse)
        aPNSVoipChannelResponse = aPNSVoipChannelResponseDecoded
    }
}

public struct UpdateApnsVoipSandboxChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApnsVoipSandboxChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsVoipSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsVoipSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aPNSVoipSandboxChannelRequest = input.operationInput.aPNSVoipSandboxChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(aPNSVoipSandboxChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsVoipSandboxChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsVoipSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsVoipSandboxChannelOutputError>
}

extension UpdateApnsVoipSandboxChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsVoipSandboxChannelInput(aPNSVoipSandboxChannelRequest: \(String(describing: aPNSVoipSandboxChannelRequest)), applicationId: \(String(describing: applicationId)))"}
}

extension UpdateApnsVoipSandboxChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipSandboxChannelRequest = "APNSVoipSandboxChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aPNSVoipSandboxChannelRequest = aPNSVoipSandboxChannelRequest {
            try encodeContainer.encode(aPNSVoipSandboxChannelRequest, forKey: .aPNSVoipSandboxChannelRequest)
        }
    }
}

public struct UpdateApnsVoipSandboxChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApnsVoipSandboxChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsVoipSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsVoipSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsVoipSandboxChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsVoipSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsVoipSandboxChannelOutputError>
}

public struct UpdateApnsVoipSandboxChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApnsVoipSandboxChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApnsVoipSandboxChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApnsVoipSandboxChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApnsVoipSandboxChannelInput>
    public typealias MOutput = OperationOutput<UpdateApnsVoipSandboxChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApnsVoipSandboxChannelOutputError>
}

public struct UpdateApnsVoipSandboxChannelInput: Equatable {
    /// <p>Specifies the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
    public let aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest?
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?

    public init (
        aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest? = nil,
        applicationId: String? = nil
    )
    {
        self.aPNSVoipSandboxChannelRequest = aPNSVoipSandboxChannelRequest
        self.applicationId = applicationId
    }
}

struct UpdateApnsVoipSandboxChannelInputBody: Equatable {
    public let aPNSVoipSandboxChannelRequest: APNSVoipSandboxChannelRequest?
}

extension UpdateApnsVoipSandboxChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipSandboxChannelRequest = "APNSVoipSandboxChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipSandboxChannelRequestDecoded = try containerValues.decodeIfPresent(APNSVoipSandboxChannelRequest.self, forKey: .aPNSVoipSandboxChannelRequest)
        aPNSVoipSandboxChannelRequest = aPNSVoipSandboxChannelRequestDecoded
    }
}

extension UpdateApnsVoipSandboxChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApnsVoipSandboxChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApnsVoipSandboxChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApnsVoipSandboxChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApnsVoipSandboxChannelOutputResponse(aPNSVoipSandboxChannelResponse: \(String(describing: aPNSVoipSandboxChannelResponse)))"}
}

extension UpdateApnsVoipSandboxChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: APNSVoipSandboxChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.aPNSVoipSandboxChannelResponse = output
            } else {
                self.aPNSVoipSandboxChannelResponse = nil
            }
        } else {
            self.aPNSVoipSandboxChannelResponse = nil
        }
    }
}

public struct UpdateApnsVoipSandboxChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the APNs (Apple Push Notification service) VoIP sandbox channel for an application.</p>
    public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse?

    public init (
        aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse? = nil
    )
    {
        self.aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponse
    }
}

struct UpdateApnsVoipSandboxChannelOutputResponseBody: Equatable {
    public let aPNSVoipSandboxChannelResponse: APNSVoipSandboxChannelResponse?
}

extension UpdateApnsVoipSandboxChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aPNSVoipSandboxChannelResponse = "APNSVoipSandboxChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aPNSVoipSandboxChannelResponseDecoded = try containerValues.decodeIfPresent(APNSVoipSandboxChannelResponse.self, forKey: .aPNSVoipSandboxChannelResponse)
        aPNSVoipSandboxChannelResponse = aPNSVoipSandboxChannelResponseDecoded
    }
}

public struct UpdateApplicationSettingsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationSettingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeApplicationSettingsRequest = input.operationInput.writeApplicationSettingsRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeApplicationSettingsRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationSettingsInput>
    public typealias MOutput = OperationOutput<UpdateApplicationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationSettingsOutputError>
}

extension UpdateApplicationSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationSettingsInput(applicationId: \(String(describing: applicationId)), writeApplicationSettingsRequest: \(String(describing: writeApplicationSettingsRequest)))"}
}

extension UpdateApplicationSettingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeApplicationSettingsRequest = "WriteApplicationSettingsRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeApplicationSettingsRequest = writeApplicationSettingsRequest {
            try encodeContainer.encode(writeApplicationSettingsRequest, forKey: .writeApplicationSettingsRequest)
        }
    }
}

public struct UpdateApplicationSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationSettingsInput>
    public typealias MOutput = OperationOutput<UpdateApplicationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationSettingsOutputError>
}

public struct UpdateApplicationSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationSettingsInput>
    public typealias MOutput = OperationOutput<UpdateApplicationSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationSettingsOutputError>
}

public struct UpdateApplicationSettingsInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the default settings for an application.</p>
    public let writeApplicationSettingsRequest: WriteApplicationSettingsRequest?

    public init (
        applicationId: String? = nil,
        writeApplicationSettingsRequest: WriteApplicationSettingsRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.writeApplicationSettingsRequest = writeApplicationSettingsRequest
    }
}

struct UpdateApplicationSettingsInputBody: Equatable {
    public let writeApplicationSettingsRequest: WriteApplicationSettingsRequest?
}

extension UpdateApplicationSettingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeApplicationSettingsRequest = "WriteApplicationSettingsRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeApplicationSettingsRequestDecoded = try containerValues.decodeIfPresent(WriteApplicationSettingsRequest.self, forKey: .writeApplicationSettingsRequest)
        writeApplicationSettingsRequest = writeApplicationSettingsRequestDecoded
    }
}

extension UpdateApplicationSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationSettingsOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationSettingsOutputResponse(applicationSettingsResource: \(String(describing: applicationSettingsResource)))"}
}

extension UpdateApplicationSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: ApplicationSettingsResource = try responseDecoder.decode(responseBody: unwrappedData)
                self.applicationSettingsResource = output
            } else {
                self.applicationSettingsResource = nil
            }
        } else {
            self.applicationSettingsResource = nil
        }
    }
}

public struct UpdateApplicationSettingsOutputResponse: Equatable {
    /// <p>Provides information about an application, including the default settings for an application.</p>
    public let applicationSettingsResource: ApplicationSettingsResource?

    public init (
        applicationSettingsResource: ApplicationSettingsResource? = nil
    )
    {
        self.applicationSettingsResource = applicationSettingsResource
    }
}

struct UpdateApplicationSettingsOutputResponseBody: Equatable {
    public let applicationSettingsResource: ApplicationSettingsResource?
}

extension UpdateApplicationSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationSettingsResource = "ApplicationSettingsResource"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationSettingsResourceDecoded = try containerValues.decodeIfPresent(ApplicationSettingsResource.self, forKey: .applicationSettingsResource)
        applicationSettingsResource = applicationSettingsResourceDecoded
    }
}

extension UpdateAttributesRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case blacklist = "Blacklist"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blacklist = blacklist {
            var blacklistContainer = encodeContainer.nestedUnkeyedContainer(forKey: .blacklist)
            for listof__string0 in blacklist {
                try blacklistContainer.encode(listof__string0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blacklistContainer = try containerValues.decodeIfPresent([String?].self, forKey: .blacklist)
        var blacklistDecoded0:[String]? = nil
        if let blacklistContainer = blacklistContainer {
            blacklistDecoded0 = [String]()
            for string0 in blacklistContainer {
                if let string0 = string0 {
                    blacklistDecoded0?.append(string0)
                }
            }
        }
        blacklist = blacklistDecoded0
    }
}

extension UpdateAttributesRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAttributesRequest(blacklist: \(String(describing: blacklist)))"}
}

/// <p>Specifies one or more attributes to remove from all the endpoints that are associated with an application.</p>
public struct UpdateAttributesRequest: Equatable {
    /// <p>An array of the attributes to remove from all the endpoints that are associated with the application. The array can specify the complete, exact name of each attribute to remove or it can specify a glob pattern that an attribute name must match in order for the attribute to be removed.</p>
    public let blacklist: [String]?

    public init (
        blacklist: [String]? = nil
    )
    {
        self.blacklist = blacklist
    }
}

public struct UpdateBaiduChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateBaiduChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBaiduChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBaiduChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let baiduChannelRequest = input.operationInput.baiduChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(baiduChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBaiduChannelInput>
    public typealias MOutput = OperationOutput<UpdateBaiduChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBaiduChannelOutputError>
}

extension UpdateBaiduChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBaiduChannelInput(applicationId: \(String(describing: applicationId)), baiduChannelRequest: \(String(describing: baiduChannelRequest)))"}
}

extension UpdateBaiduChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case baiduChannelRequest = "BaiduChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let baiduChannelRequest = baiduChannelRequest {
            try encodeContainer.encode(baiduChannelRequest, forKey: .baiduChannelRequest)
        }
    }
}

public struct UpdateBaiduChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateBaiduChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBaiduChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBaiduChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBaiduChannelInput>
    public typealias MOutput = OperationOutput<UpdateBaiduChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBaiduChannelOutputError>
}

public struct UpdateBaiduChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateBaiduChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateBaiduChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateBaiduChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateBaiduChannelInput>
    public typealias MOutput = OperationOutput<UpdateBaiduChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateBaiduChannelOutputError>
}

public struct UpdateBaiduChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
    public let baiduChannelRequest: BaiduChannelRequest?

    public init (
        applicationId: String? = nil,
        baiduChannelRequest: BaiduChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.baiduChannelRequest = baiduChannelRequest
    }
}

struct UpdateBaiduChannelInputBody: Equatable {
    public let baiduChannelRequest: BaiduChannelRequest?
}

extension UpdateBaiduChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baiduChannelRequest = "BaiduChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baiduChannelRequestDecoded = try containerValues.decodeIfPresent(BaiduChannelRequest.self, forKey: .baiduChannelRequest)
        baiduChannelRequest = baiduChannelRequestDecoded
    }
}

extension UpdateBaiduChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBaiduChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateBaiduChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBaiduChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateBaiduChannelOutputResponse(baiduChannelResponse: \(String(describing: baiduChannelResponse)))"}
}

extension UpdateBaiduChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: BaiduChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.baiduChannelResponse = output
            } else {
                self.baiduChannelResponse = nil
            }
        } else {
            self.baiduChannelResponse = nil
        }
    }
}

public struct UpdateBaiduChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the Baidu (Baidu Cloud Push) channel for an application.</p>
    public let baiduChannelResponse: BaiduChannelResponse?

    public init (
        baiduChannelResponse: BaiduChannelResponse? = nil
    )
    {
        self.baiduChannelResponse = baiduChannelResponse
    }
}

struct UpdateBaiduChannelOutputResponseBody: Equatable {
    public let baiduChannelResponse: BaiduChannelResponse?
}

extension UpdateBaiduChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case baiduChannelResponse = "BaiduChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baiduChannelResponseDecoded = try containerValues.decodeIfPresent(BaiduChannelResponse.self, forKey: .baiduChannelResponse)
        baiduChannelResponse = baiduChannelResponseDecoded
    }
}

public struct UpdateCampaignInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCampaignInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeCampaignRequest = input.operationInput.writeCampaignRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeCampaignRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCampaignOutputError>
}

extension UpdateCampaignInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCampaignInput(applicationId: \(String(describing: applicationId)), campaignId: \(String(describing: campaignId)), writeCampaignRequest: \(String(describing: writeCampaignRequest)))"}
}

extension UpdateCampaignInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeCampaignRequest = "WriteCampaignRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeCampaignRequest = writeCampaignRequest {
            try encodeContainer.encode(writeCampaignRequest, forKey: .writeCampaignRequest)
        }
    }
}

public struct UpdateCampaignInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCampaignInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCampaignOutputError>
}

public struct UpdateCampaignInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCampaignInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCampaignInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCampaignOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCampaignInput>
    public typealias MOutput = OperationOutput<UpdateCampaignOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCampaignOutputError>
}

public struct UpdateCampaignInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the campaign.</p>
    public let campaignId: String?
    /// <p>Specifies the configuration and other settings for a campaign.</p>
    public let writeCampaignRequest: WriteCampaignRequest?

    public init (
        applicationId: String? = nil,
        campaignId: String? = nil,
        writeCampaignRequest: WriteCampaignRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.campaignId = campaignId
        self.writeCampaignRequest = writeCampaignRequest
    }
}

struct UpdateCampaignInputBody: Equatable {
    public let writeCampaignRequest: WriteCampaignRequest?
}

extension UpdateCampaignInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeCampaignRequest = "WriteCampaignRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeCampaignRequestDecoded = try containerValues.decodeIfPresent(WriteCampaignRequest.self, forKey: .writeCampaignRequest)
        writeCampaignRequest = writeCampaignRequestDecoded
    }
}

extension UpdateCampaignOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCampaignOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCampaignOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCampaignOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCampaignOutputResponse(campaignResponse: \(String(describing: campaignResponse)))"}
}

extension UpdateCampaignOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: CampaignResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.campaignResponse = output
            } else {
                self.campaignResponse = nil
            }
        } else {
            self.campaignResponse = nil
        }
    }
}

public struct UpdateCampaignOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a campaign.</p>
    public let campaignResponse: CampaignResponse?

    public init (
        campaignResponse: CampaignResponse? = nil
    )
    {
        self.campaignResponse = campaignResponse
    }
}

struct UpdateCampaignOutputResponseBody: Equatable {
    public let campaignResponse: CampaignResponse?
}

extension UpdateCampaignOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case campaignResponse = "CampaignResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignResponseDecoded = try containerValues.decodeIfPresent(CampaignResponse.self, forKey: .campaignResponse)
        campaignResponse = campaignResponseDecoded
    }
}

public struct UpdateEmailChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEmailChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let emailChannelRequest = input.operationInput.emailChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(emailChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailChannelInput>
    public typealias MOutput = OperationOutput<UpdateEmailChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailChannelOutputError>
}

extension UpdateEmailChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailChannelInput(applicationId: \(String(describing: applicationId)), emailChannelRequest: \(String(describing: emailChannelRequest)))"}
}

extension UpdateEmailChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailChannelRequest = "EmailChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailChannelRequest = emailChannelRequest {
            try encodeContainer.encode(emailChannelRequest, forKey: .emailChannelRequest)
        }
    }
}

public struct UpdateEmailChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEmailChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailChannelInput>
    public typealias MOutput = OperationOutput<UpdateEmailChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailChannelOutputError>
}

public struct UpdateEmailChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEmailChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailChannelInput>
    public typealias MOutput = OperationOutput<UpdateEmailChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailChannelOutputError>
}

public struct UpdateEmailChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the status and settings of the email channel for an application.</p>
    public let emailChannelRequest: EmailChannelRequest?

    public init (
        applicationId: String? = nil,
        emailChannelRequest: EmailChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.emailChannelRequest = emailChannelRequest
    }
}

struct UpdateEmailChannelInputBody: Equatable {
    public let emailChannelRequest: EmailChannelRequest?
}

extension UpdateEmailChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailChannelRequest = "EmailChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailChannelRequestDecoded = try containerValues.decodeIfPresent(EmailChannelRequest.self, forKey: .emailChannelRequest)
        emailChannelRequest = emailChannelRequestDecoded
    }
}

extension UpdateEmailChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEmailChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEmailChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEmailChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailChannelOutputResponse(emailChannelResponse: \(String(describing: emailChannelResponse)))"}
}

extension UpdateEmailChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: EmailChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.emailChannelResponse = output
            } else {
                self.emailChannelResponse = nil
            }
        } else {
            self.emailChannelResponse = nil
        }
    }
}

public struct UpdateEmailChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the email channel for an application.</p>
    public let emailChannelResponse: EmailChannelResponse?

    public init (
        emailChannelResponse: EmailChannelResponse? = nil
    )
    {
        self.emailChannelResponse = emailChannelResponse
    }
}

struct UpdateEmailChannelOutputResponseBody: Equatable {
    public let emailChannelResponse: EmailChannelResponse?
}

extension UpdateEmailChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailChannelResponse = "EmailChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailChannelResponseDecoded = try containerValues.decodeIfPresent(EmailChannelResponse.self, forKey: .emailChannelResponse)
        emailChannelResponse = emailChannelResponseDecoded
    }
}

public struct UpdateEmailTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEmailTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let emailTemplateRequest = input.operationInput.emailTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(emailTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailTemplateOutputError>
}

extension UpdateEmailTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailTemplateInput(createNewVersion: \(String(describing: createNewVersion)), emailTemplateRequest: \(String(describing: emailTemplateRequest)), templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension UpdateEmailTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case emailTemplateRequest = "EmailTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let emailTemplateRequest = emailTemplateRequest {
            try encodeContainer.encode(emailTemplateRequest, forKey: .emailTemplateRequest)
        }
    }
}

public struct UpdateEmailTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEmailTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailTemplateOutputError>
}

public struct UpdateEmailTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEmailTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEmailTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEmailTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        let createNewVersionQueryItem = URLQueryItem(name: "create-new-version".urlPercentEncoding(), value: String(input.operationInput.createNewVersion).urlPercentEncoding())
        input.builder.withQueryItem(createNewVersionQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEmailTemplateInput>
    public typealias MOutput = OperationOutput<UpdateEmailTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEmailTemplateOutputError>
}

public struct UpdateEmailTemplateInput: Equatable {
    /// <p>Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.</p>
    public let createNewVersion: Bool
    /// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the email channel.</p>
    public let emailTemplateRequest: EmailTemplateRequest?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        createNewVersion: Bool = false,
        emailTemplateRequest: EmailTemplateRequest? = nil,
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.emailTemplateRequest = emailTemplateRequest
        self.templateName = templateName
        self.version = version
    }
}

struct UpdateEmailTemplateInputBody: Equatable {
    public let emailTemplateRequest: EmailTemplateRequest?
}

extension UpdateEmailTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case emailTemplateRequest = "EmailTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailTemplateRequestDecoded = try containerValues.decodeIfPresent(EmailTemplateRequest.self, forKey: .emailTemplateRequest)
        emailTemplateRequest = emailTemplateRequestDecoded
    }
}

extension UpdateEmailTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEmailTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEmailTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEmailTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEmailTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension UpdateEmailTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct UpdateEmailTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct UpdateEmailTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension UpdateEmailTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

public struct UpdateEndpointInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEndpointInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endpointRequest = input.operationInput.endpointRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(endpointRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointInput>
    public typealias MOutput = OperationOutput<UpdateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointOutputError>
}

extension UpdateEndpointInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointInput(applicationId: \(String(describing: applicationId)), endpointId: \(String(describing: endpointId)), endpointRequest: \(String(describing: endpointRequest)))"}
}

extension UpdateEndpointInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointRequest = "EndpointRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointRequest = endpointRequest {
            try encodeContainer.encode(endpointRequest, forKey: .endpointRequest)
        }
    }
}

public struct UpdateEndpointInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEndpointInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointInput>
    public typealias MOutput = OperationOutput<UpdateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointOutputError>
}

public struct UpdateEndpointInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEndpointInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointInput>
    public typealias MOutput = OperationOutput<UpdateEndpointOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointOutputError>
}

public struct UpdateEndpointInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the endpoint.</p>
    public let endpointId: String?
    /// <p>Specifies the channel type and other settings for an endpoint.</p>
    public let endpointRequest: EndpointRequest?

    public init (
        applicationId: String? = nil,
        endpointId: String? = nil,
        endpointRequest: EndpointRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointId = endpointId
        self.endpointRequest = endpointRequest
    }
}

struct UpdateEndpointInputBody: Equatable {
    public let endpointRequest: EndpointRequest?
}

extension UpdateEndpointInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointRequest = "EndpointRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointRequestDecoded = try containerValues.decodeIfPresent(EndpointRequest.self, forKey: .endpointRequest)
        endpointRequest = endpointRequestDecoded
    }
}

extension UpdateEndpointOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEndpointOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEndpointOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEndpointOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension UpdateEndpointOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct UpdateEndpointOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct UpdateEndpointOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension UpdateEndpointOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

public struct UpdateEndpointsBatchInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEndpointsBatchInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointsBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointsBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endpointBatchRequest = input.operationInput.endpointBatchRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(endpointBatchRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointsBatchInput>
    public typealias MOutput = OperationOutput<UpdateEndpointsBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointsBatchOutputError>
}

extension UpdateEndpointsBatchInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointsBatchInput(applicationId: \(String(describing: applicationId)), endpointBatchRequest: \(String(describing: endpointBatchRequest)))"}
}

extension UpdateEndpointsBatchInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpointBatchRequest = "EndpointBatchRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpointBatchRequest = endpointBatchRequest {
            try encodeContainer.encode(endpointBatchRequest, forKey: .endpointBatchRequest)
        }
    }
}

public struct UpdateEndpointsBatchInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEndpointsBatchInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointsBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointsBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointsBatchInput>
    public typealias MOutput = OperationOutput<UpdateEndpointsBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointsBatchOutputError>
}

public struct UpdateEndpointsBatchInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEndpointsBatchInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEndpointsBatchInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEndpointsBatchOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEndpointsBatchInput>
    public typealias MOutput = OperationOutput<UpdateEndpointsBatchOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEndpointsBatchOutputError>
}

public struct UpdateEndpointsBatchInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies a batch of endpoints to create or update and the settings and attributes to set or change for each endpoint.</p>
    public let endpointBatchRequest: EndpointBatchRequest?

    public init (
        applicationId: String? = nil,
        endpointBatchRequest: EndpointBatchRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.endpointBatchRequest = endpointBatchRequest
    }
}

struct UpdateEndpointsBatchInputBody: Equatable {
    public let endpointBatchRequest: EndpointBatchRequest?
}

extension UpdateEndpointsBatchInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endpointBatchRequest = "EndpointBatchRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointBatchRequestDecoded = try containerValues.decodeIfPresent(EndpointBatchRequest.self, forKey: .endpointBatchRequest)
        endpointBatchRequest = endpointBatchRequestDecoded
    }
}

extension UpdateEndpointsBatchOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEndpointsBatchOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEndpointsBatchOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEndpointsBatchOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEndpointsBatchOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension UpdateEndpointsBatchOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct UpdateEndpointsBatchOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct UpdateEndpointsBatchOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension UpdateEndpointsBatchOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

public struct UpdateGcmChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGcmChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGcmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGcmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let gCMChannelRequest = input.operationInput.gCMChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(gCMChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGcmChannelInput>
    public typealias MOutput = OperationOutput<UpdateGcmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGcmChannelOutputError>
}

extension UpdateGcmChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGcmChannelInput(applicationId: \(String(describing: applicationId)), gCMChannelRequest: \(String(describing: gCMChannelRequest)))"}
}

extension UpdateGcmChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case gCMChannelRequest = "GCMChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gCMChannelRequest = gCMChannelRequest {
            try encodeContainer.encode(gCMChannelRequest, forKey: .gCMChannelRequest)
        }
    }
}

public struct UpdateGcmChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGcmChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGcmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGcmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGcmChannelInput>
    public typealias MOutput = OperationOutput<UpdateGcmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGcmChannelOutputError>
}

public struct UpdateGcmChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGcmChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGcmChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGcmChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGcmChannelInput>
    public typealias MOutput = OperationOutput<UpdateGcmChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGcmChannelOutputError>
}

public struct UpdateGcmChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the status and settings of the GCM channel for an application. This channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
    public let gCMChannelRequest: GCMChannelRequest?

    public init (
        applicationId: String? = nil,
        gCMChannelRequest: GCMChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.gCMChannelRequest = gCMChannelRequest
    }
}

struct UpdateGcmChannelInputBody: Equatable {
    public let gCMChannelRequest: GCMChannelRequest?
}

extension UpdateGcmChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gCMChannelRequest = "GCMChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gCMChannelRequestDecoded = try containerValues.decodeIfPresent(GCMChannelRequest.self, forKey: .gCMChannelRequest)
        gCMChannelRequest = gCMChannelRequestDecoded
    }
}

extension UpdateGcmChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGcmChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGcmChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGcmChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGcmChannelOutputResponse(gCMChannelResponse: \(String(describing: gCMChannelResponse)))"}
}

extension UpdateGcmChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: GCMChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.gCMChannelResponse = output
            } else {
                self.gCMChannelResponse = nil
            }
        } else {
            self.gCMChannelResponse = nil
        }
    }
}

public struct UpdateGcmChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the GCM channel for an application. The GCM channel enables Amazon Pinpoint to send push notifications through the Firebase Cloud Messaging (FCM), formerly Google Cloud Messaging (GCM), service.</p>
    public let gCMChannelResponse: GCMChannelResponse?

    public init (
        gCMChannelResponse: GCMChannelResponse? = nil
    )
    {
        self.gCMChannelResponse = gCMChannelResponse
    }
}

struct UpdateGcmChannelOutputResponseBody: Equatable {
    public let gCMChannelResponse: GCMChannelResponse?
}

extension UpdateGcmChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case gCMChannelResponse = "GCMChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gCMChannelResponseDecoded = try containerValues.decodeIfPresent(GCMChannelResponse.self, forKey: .gCMChannelResponse)
        gCMChannelResponse = gCMChannelResponseDecoded
    }
}

public struct UpdateJourneyInputBodyMiddleware: Middleware {
    public let id: String = "UpdateJourneyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeJourneyRequest = input.operationInput.writeJourneyRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeJourneyRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJourneyInput>
    public typealias MOutput = OperationOutput<UpdateJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJourneyOutputError>
}

extension UpdateJourneyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJourneyInput(applicationId: \(String(describing: applicationId)), journeyId: \(String(describing: journeyId)), writeJourneyRequest: \(String(describing: writeJourneyRequest)))"}
}

extension UpdateJourneyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeJourneyRequest = "WriteJourneyRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeJourneyRequest = writeJourneyRequest {
            try encodeContainer.encode(writeJourneyRequest, forKey: .writeJourneyRequest)
        }
    }
}

public struct UpdateJourneyInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJourneyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJourneyInput>
    public typealias MOutput = OperationOutput<UpdateJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJourneyOutputError>
}

public struct UpdateJourneyInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJourneyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJourneyInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJourneyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJourneyInput>
    public typealias MOutput = OperationOutput<UpdateJourneyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJourneyOutputError>
}

public struct UpdateJourneyInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the journey.</p>
    public let journeyId: String?
    /// <p>Specifies the configuration and other settings for a journey.</p>
    public let writeJourneyRequest: WriteJourneyRequest?

    public init (
        applicationId: String? = nil,
        journeyId: String? = nil,
        writeJourneyRequest: WriteJourneyRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.writeJourneyRequest = writeJourneyRequest
    }
}

struct UpdateJourneyInputBody: Equatable {
    public let writeJourneyRequest: WriteJourneyRequest?
}

extension UpdateJourneyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeJourneyRequest = "WriteJourneyRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeJourneyRequestDecoded = try containerValues.decodeIfPresent(WriteJourneyRequest.self, forKey: .writeJourneyRequest)
        writeJourneyRequest = writeJourneyRequestDecoded
    }
}

extension UpdateJourneyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJourneyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJourneyOutputError: Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJourneyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJourneyOutputResponse(journeyResponse: \(String(describing: journeyResponse)))"}
}

extension UpdateJourneyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyResponse = output
            } else {
                self.journeyResponse = nil
            }
        } else {
            self.journeyResponse = nil
        }
    }
}

public struct UpdateJourneyOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a journey.</p>
    public let journeyResponse: JourneyResponse?

    public init (
        journeyResponse: JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

struct UpdateJourneyOutputResponseBody: Equatable {
    public let journeyResponse: JourneyResponse?
}

extension UpdateJourneyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyResponse = "JourneyResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyResponseDecoded = try containerValues.decodeIfPresent(JourneyResponse.self, forKey: .journeyResponse)
        journeyResponse = journeyResponseDecoded
    }
}

public struct UpdateJourneyStateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateJourneyStateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJourneyStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJourneyStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let journeyStateRequest = input.operationInput.journeyStateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(journeyStateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJourneyStateInput>
    public typealias MOutput = OperationOutput<UpdateJourneyStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJourneyStateOutputError>
}

extension UpdateJourneyStateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJourneyStateInput(applicationId: \(String(describing: applicationId)), journeyId: \(String(describing: journeyId)), journeyStateRequest: \(String(describing: journeyStateRequest)))"}
}

extension UpdateJourneyStateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case journeyStateRequest = "JourneyStateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let journeyStateRequest = journeyStateRequest {
            try encodeContainer.encode(journeyStateRequest, forKey: .journeyStateRequest)
        }
    }
}

public struct UpdateJourneyStateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateJourneyStateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJourneyStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJourneyStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJourneyStateInput>
    public typealias MOutput = OperationOutput<UpdateJourneyStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJourneyStateOutputError>
}

public struct UpdateJourneyStateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateJourneyStateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateJourneyStateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateJourneyStateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateJourneyStateInput>
    public typealias MOutput = OperationOutput<UpdateJourneyStateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateJourneyStateOutputError>
}

public struct UpdateJourneyStateInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the journey.</p>
    public let journeyId: String?
    /// <p>Changes the status of a journey.</p>
    public let journeyStateRequest: JourneyStateRequest?

    public init (
        applicationId: String? = nil,
        journeyId: String? = nil,
        journeyStateRequest: JourneyStateRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.journeyId = journeyId
        self.journeyStateRequest = journeyStateRequest
    }
}

struct UpdateJourneyStateInputBody: Equatable {
    public let journeyStateRequest: JourneyStateRequest?
}

extension UpdateJourneyStateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyStateRequest = "JourneyStateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyStateRequestDecoded = try containerValues.decodeIfPresent(JourneyStateRequest.self, forKey: .journeyStateRequest)
        journeyStateRequest = journeyStateRequestDecoded
    }
}

extension UpdateJourneyStateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateJourneyStateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateJourneyStateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateJourneyStateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateJourneyStateOutputResponse(journeyResponse: \(String(describing: journeyResponse)))"}
}

extension UpdateJourneyStateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: JourneyResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.journeyResponse = output
            } else {
                self.journeyResponse = nil
            }
        } else {
            self.journeyResponse = nil
        }
    }
}

public struct UpdateJourneyStateOutputResponse: Equatable {
    /// <p>Provides information about the status, configuration, and other settings for a journey.</p>
    public let journeyResponse: JourneyResponse?

    public init (
        journeyResponse: JourneyResponse? = nil
    )
    {
        self.journeyResponse = journeyResponse
    }
}

struct UpdateJourneyStateOutputResponseBody: Equatable {
    public let journeyResponse: JourneyResponse?
}

extension UpdateJourneyStateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case journeyResponse = "JourneyResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journeyResponseDecoded = try containerValues.decodeIfPresent(JourneyResponse.self, forKey: .journeyResponse)
        journeyResponse = journeyResponseDecoded
    }
}

public struct UpdatePushTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdatePushTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let pushNotificationTemplateRequest = input.operationInput.pushNotificationTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(pushNotificationTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePushTemplateInput>
    public typealias MOutput = OperationOutput<UpdatePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePushTemplateOutputError>
}

extension UpdatePushTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePushTemplateInput(createNewVersion: \(String(describing: createNewVersion)), pushNotificationTemplateRequest: \(String(describing: pushNotificationTemplateRequest)), templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension UpdatePushTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pushNotificationTemplateRequest = "PushNotificationTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pushNotificationTemplateRequest = pushNotificationTemplateRequest {
            try encodeContainer.encode(pushNotificationTemplateRequest, forKey: .pushNotificationTemplateRequest)
        }
    }
}

public struct UpdatePushTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdatePushTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePushTemplateInput>
    public typealias MOutput = OperationOutput<UpdatePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePushTemplateOutputError>
}

public struct UpdatePushTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdatePushTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdatePushTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdatePushTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        let createNewVersionQueryItem = URLQueryItem(name: "create-new-version".urlPercentEncoding(), value: String(input.operationInput.createNewVersion).urlPercentEncoding())
        input.builder.withQueryItem(createNewVersionQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdatePushTemplateInput>
    public typealias MOutput = OperationOutput<UpdatePushTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdatePushTemplateOutputError>
}

public struct UpdatePushTemplateInput: Equatable {
    /// <p>Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.</p>
    public let createNewVersion: Bool
    /// <p>Specifies the content and settings for a message template that can be used in messages that are sent through a push notification channel.</p>
    public let pushNotificationTemplateRequest: PushNotificationTemplateRequest?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        createNewVersion: Bool = false,
        pushNotificationTemplateRequest: PushNotificationTemplateRequest? = nil,
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.pushNotificationTemplateRequest = pushNotificationTemplateRequest
        self.templateName = templateName
        self.version = version
    }
}

struct UpdatePushTemplateInputBody: Equatable {
    public let pushNotificationTemplateRequest: PushNotificationTemplateRequest?
}

extension UpdatePushTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pushNotificationTemplateRequest = "PushNotificationTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pushNotificationTemplateRequestDecoded = try containerValues.decodeIfPresent(PushNotificationTemplateRequest.self, forKey: .pushNotificationTemplateRequest)
        pushNotificationTemplateRequest = pushNotificationTemplateRequestDecoded
    }
}

extension UpdatePushTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePushTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePushTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePushTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdatePushTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension UpdatePushTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct UpdatePushTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct UpdatePushTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension UpdatePushTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

public struct UpdateRecommenderConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRecommenderConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let updateRecommenderConfiguration = input.operationInput.updateRecommenderConfiguration {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(updateRecommenderConfiguration)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecommenderConfigurationOutputError>
}

extension UpdateRecommenderConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecommenderConfigurationInput(recommenderId: \(String(describing: recommenderId)), updateRecommenderConfiguration: \(String(describing: updateRecommenderConfiguration)))"}
}

extension UpdateRecommenderConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case updateRecommenderConfiguration = "UpdateRecommenderConfiguration"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let updateRecommenderConfiguration = updateRecommenderConfiguration {
            try encodeContainer.encode(updateRecommenderConfiguration, forKey: .updateRecommenderConfiguration)
        }
    }
}

public struct UpdateRecommenderConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRecommenderConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecommenderConfigurationOutputError>
}

public struct UpdateRecommenderConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRecommenderConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRecommenderConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRecommenderConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRecommenderConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateRecommenderConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRecommenderConfigurationOutputError>
}

public struct UpdateRecommenderConfigurationInput: Equatable {
    /// <p>The unique identifier for the recommender model configuration. This identifier is displayed as the <b>Recommender ID</b> on the Amazon Pinpoint console.</p>
    public let recommenderId: String?
    /// <p>Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.</p>
    public let updateRecommenderConfiguration: UpdateRecommenderConfigurationShape?

    public init (
        recommenderId: String? = nil,
        updateRecommenderConfiguration: UpdateRecommenderConfigurationShape? = nil
    )
    {
        self.recommenderId = recommenderId
        self.updateRecommenderConfiguration = updateRecommenderConfiguration
    }
}

struct UpdateRecommenderConfigurationInputBody: Equatable {
    public let updateRecommenderConfiguration: UpdateRecommenderConfigurationShape?
}

extension UpdateRecommenderConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case updateRecommenderConfiguration = "UpdateRecommenderConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let updateRecommenderConfigurationDecoded = try containerValues.decodeIfPresent(UpdateRecommenderConfigurationShape.self, forKey: .updateRecommenderConfiguration)
        updateRecommenderConfiguration = updateRecommenderConfigurationDecoded
    }
}

extension UpdateRecommenderConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRecommenderConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRecommenderConfigurationOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRecommenderConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecommenderConfigurationOutputResponse(recommenderConfigurationResponse: \(String(describing: recommenderConfigurationResponse)))"}
}

extension UpdateRecommenderConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: RecommenderConfigurationResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.recommenderConfigurationResponse = output
            } else {
                self.recommenderConfigurationResponse = nil
            }
        } else {
            self.recommenderConfigurationResponse = nil
        }
    }
}

public struct UpdateRecommenderConfigurationOutputResponse: Equatable {
    /// <p>Provides information about Amazon Pinpoint configuration settings for retrieving and processing data from a recommender model.</p>
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?

    public init (
        recommenderConfigurationResponse: RecommenderConfigurationResponse? = nil
    )
    {
        self.recommenderConfigurationResponse = recommenderConfigurationResponse
    }
}

struct UpdateRecommenderConfigurationOutputResponseBody: Equatable {
    public let recommenderConfigurationResponse: RecommenderConfigurationResponse?
}

extension UpdateRecommenderConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case recommenderConfigurationResponse = "RecommenderConfigurationResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommenderConfigurationResponseDecoded = try containerValues.decodeIfPresent(RecommenderConfigurationResponse.self, forKey: .recommenderConfigurationResponse)
        recommenderConfigurationResponse = recommenderConfigurationResponseDecoded
    }
}

extension UpdateRecommenderConfigurationShape: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
        case description = "Description"
        case name = "Name"
        case recommendationProviderIdType = "RecommendationProviderIdType"
        case recommendationProviderRoleArn = "RecommendationProviderRoleArn"
        case recommendationProviderUri = "RecommendationProviderUri"
        case recommendationTransformerUri = "RecommendationTransformerUri"
        case recommendationsDisplayName = "RecommendationsDisplayName"
        case recommendationsPerMessage = "RecommendationsPerMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapof__string0) in attributes {
                try attributesContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationProviderIdType = recommendationProviderIdType {
            try encodeContainer.encode(recommendationProviderIdType, forKey: .recommendationProviderIdType)
        }
        if let recommendationProviderRoleArn = recommendationProviderRoleArn {
            try encodeContainer.encode(recommendationProviderRoleArn, forKey: .recommendationProviderRoleArn)
        }
        if let recommendationProviderUri = recommendationProviderUri {
            try encodeContainer.encode(recommendationProviderUri, forKey: .recommendationProviderUri)
        }
        if let recommendationTransformerUri = recommendationTransformerUri {
            try encodeContainer.encode(recommendationTransformerUri, forKey: .recommendationTransformerUri)
        }
        if let recommendationsDisplayName = recommendationsDisplayName {
            try encodeContainer.encode(recommendationsDisplayName, forKey: .recommendationsDisplayName)
        }
        if recommendationsPerMessage != 0 {
            try encodeContainer.encode(recommendationsPerMessage, forKey: .recommendationsPerMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .attributes)
        var attributesDecoded0: [String:String]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:String]()
            for (key0, __string0) in attributesContainer {
                if let __string0 = __string0 {
                    attributesDecoded0?[key0] = __string0
                }
            }
        }
        attributes = attributesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let recommendationProviderIdTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderIdType)
        recommendationProviderIdType = recommendationProviderIdTypeDecoded
        let recommendationProviderRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderRoleArn)
        recommendationProviderRoleArn = recommendationProviderRoleArnDecoded
        let recommendationProviderUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationProviderUri)
        recommendationProviderUri = recommendationProviderUriDecoded
        let recommendationTransformerUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationTransformerUri)
        recommendationTransformerUri = recommendationTransformerUriDecoded
        let recommendationsDisplayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendationsDisplayName)
        recommendationsDisplayName = recommendationsDisplayNameDecoded
        let recommendationsPerMessageDecoded = try containerValues.decode(Int.self, forKey: .recommendationsPerMessage)
        recommendationsPerMessage = recommendationsPerMessageDecoded
    }
}

extension UpdateRecommenderConfigurationShape: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRecommenderConfigurationShape(attributes: \(String(describing: attributes)), description: \(String(describing: description)), name: \(String(describing: name)), recommendationProviderIdType: \(String(describing: recommendationProviderIdType)), recommendationProviderRoleArn: \(String(describing: recommendationProviderRoleArn)), recommendationProviderUri: \(String(describing: recommendationProviderUri)), recommendationTransformerUri: \(String(describing: recommendationTransformerUri)), recommendationsDisplayName: \(String(describing: recommendationsDisplayName)), recommendationsPerMessage: \(String(describing: recommendationsPerMessage)))"}
}

/// <p>Specifies Amazon Pinpoint configuration settings for retrieving and processing recommendation data from a recommender model.</p>
public struct UpdateRecommenderConfigurationShape: Equatable {
    /// <p>A map of key-value pairs that defines 1-10 custom endpoint or user attributes, depending on the value for the RecommendationProviderIdType property. Each of these attributes temporarily stores a recommended item that's retrieved from the recommender model and sent to an AWS Lambda function for additional processing. Each attribute can be used as a message variable in a message template.</p> <p>In the map, the key is the name of a custom attribute and the value is a custom display name for that attribute. The display name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The following restrictions apply to these names:</p> <ul><li><p>An attribute name must start with a letter or number and it can contain up to 50 characters. The characters can be letters, numbers, underscores (_), or hyphens (-). Attribute names are case sensitive and must be unique.</p></li> <li><p>An attribute display name must start with a letter or number and it can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p></li></ul> <p>This object is required if the configuration invokes an AWS Lambda function (RecommendationTransformerUri) to process recommendation data. Otherwise, don't include this object in your request.</p>
    public let attributes: [String:String]?
    /// <p>A custom description of the configuration for the recommender model. The description can contain up to 128 characters. The characters can be letters, numbers, spaces, or the following symbols: _ ; () , ‐.</p>
    public let description: String?
    /// <p>A custom name of the configuration for the recommender model. The name must start with a letter or number and it can contain up to 128 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-).</p>
    public let name: String?
    /// <p>The type of Amazon Pinpoint ID to associate with unique user IDs in the recommender model. This value enables the model to use attribute and event data that’s specific to a particular endpoint or user in an Amazon Pinpoint application. Valid values are:</p> <ul><li><p>PINPOINT_ENDPOINT_ID - Associate each user in the model with a particular endpoint in Amazon Pinpoint. The data is correlated based on endpoint IDs in Amazon Pinpoint. This is the default value.</p></li> <li><p>PINPOINT_USER_ID - Associate each user in the model with a particular user and endpoint in Amazon Pinpoint. The data is correlated based on user IDs in Amazon Pinpoint. If you specify this value, an endpoint definition in Amazon Pinpoint has to specify both a user ID (UserId) and an endpoint ID. Otherwise, messages won’t be sent to the user's endpoint.</p></li></ul>
    public let recommendationProviderIdType: String?
    /// <p>The Amazon Resource Name (ARN) of the AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to retrieve recommendation data from the recommender model.</p>
    public let recommendationProviderRoleArn: String?
    /// <p>The Amazon Resource Name (ARN) of the recommender model to retrieve recommendation data from. This value must match the ARN of an Amazon Personalize campaign.</p>
    public let recommendationProviderUri: String?
    /// <p>The name or Amazon Resource Name (ARN) of the AWS Lambda function to invoke for additional processing of recommendation data that's retrieved from the recommender model.</p>
    public let recommendationTransformerUri: String?
    /// <p>A custom display name for the standard endpoint or user attribute (RecommendationItems) that temporarily stores recommended items for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This value is required if the configuration doesn't invoke an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p> <p>This name appears in the <b>Attribute finder</b> of the template editor on the Amazon Pinpoint console. The name can contain up to 25 characters. The characters can be letters, numbers, spaces, underscores (_), or hyphens (-). These restrictions don't apply to attribute values.</p>
    public let recommendationsDisplayName: String?
    /// <p>The number of recommended items to retrieve from the model for each endpoint or user, depending on the value for the RecommendationProviderIdType property. This number determines how many recommended items are available for use in message variables. The minimum value is 1. The maximum value is 5. The default value is 5.</p> <p>To use multiple recommended items and custom attributes with message variables, you have to use an AWS Lambda function (RecommendationTransformerUri) to perform additional processing of recommendation data.</p>
    public let recommendationsPerMessage: Int

    public init (
        attributes: [String:String]? = nil,
        description: String? = nil,
        name: String? = nil,
        recommendationProviderIdType: String? = nil,
        recommendationProviderRoleArn: String? = nil,
        recommendationProviderUri: String? = nil,
        recommendationTransformerUri: String? = nil,
        recommendationsDisplayName: String? = nil,
        recommendationsPerMessage: Int = 0
    )
    {
        self.attributes = attributes
        self.description = description
        self.name = name
        self.recommendationProviderIdType = recommendationProviderIdType
        self.recommendationProviderRoleArn = recommendationProviderRoleArn
        self.recommendationProviderUri = recommendationProviderUri
        self.recommendationTransformerUri = recommendationTransformerUri
        self.recommendationsDisplayName = recommendationsDisplayName
        self.recommendationsPerMessage = recommendationsPerMessage
    }
}

public struct UpdateSegmentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSegmentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let writeSegmentRequest = input.operationInput.writeSegmentRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(writeSegmentRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSegmentInput>
    public typealias MOutput = OperationOutput<UpdateSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSegmentOutputError>
}

extension UpdateSegmentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSegmentInput(applicationId: \(String(describing: applicationId)), segmentId: \(String(describing: segmentId)), writeSegmentRequest: \(String(describing: writeSegmentRequest)))"}
}

extension UpdateSegmentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case writeSegmentRequest = "WriteSegmentRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let writeSegmentRequest = writeSegmentRequest {
            try encodeContainer.encode(writeSegmentRequest, forKey: .writeSegmentRequest)
        }
    }
}

public struct UpdateSegmentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSegmentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSegmentInput>
    public typealias MOutput = OperationOutput<UpdateSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSegmentOutputError>
}

public struct UpdateSegmentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSegmentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSegmentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSegmentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSegmentInput>
    public typealias MOutput = OperationOutput<UpdateSegmentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSegmentOutputError>
}

public struct UpdateSegmentInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>The unique identifier for the segment.</p>
    public let segmentId: String?
    /// <p>Specifies the configuration, dimension, and other settings for a segment. A WriteSegmentRequest object can include a Dimensions object or a SegmentGroups object, but not both.</p>
    public let writeSegmentRequest: WriteSegmentRequest?

    public init (
        applicationId: String? = nil,
        segmentId: String? = nil,
        writeSegmentRequest: WriteSegmentRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.segmentId = segmentId
        self.writeSegmentRequest = writeSegmentRequest
    }
}

struct UpdateSegmentInputBody: Equatable {
    public let writeSegmentRequest: WriteSegmentRequest?
}

extension UpdateSegmentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case writeSegmentRequest = "WriteSegmentRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let writeSegmentRequestDecoded = try containerValues.decodeIfPresent(WriteSegmentRequest.self, forKey: .writeSegmentRequest)
        writeSegmentRequest = writeSegmentRequestDecoded
    }
}

extension UpdateSegmentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSegmentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSegmentOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSegmentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSegmentOutputResponse(segmentResponse: \(String(describing: segmentResponse)))"}
}

extension UpdateSegmentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SegmentResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.segmentResponse = output
            } else {
                self.segmentResponse = nil
            }
        } else {
            self.segmentResponse = nil
        }
    }
}

public struct UpdateSegmentOutputResponse: Equatable {
    /// <p>Provides information about the configuration, dimension, and other settings for a segment.</p>
    public let segmentResponse: SegmentResponse?

    public init (
        segmentResponse: SegmentResponse? = nil
    )
    {
        self.segmentResponse = segmentResponse
    }
}

struct UpdateSegmentOutputResponseBody: Equatable {
    public let segmentResponse: SegmentResponse?
}

extension UpdateSegmentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case segmentResponse = "SegmentResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let segmentResponseDecoded = try containerValues.decodeIfPresent(SegmentResponse.self, forKey: .segmentResponse)
        segmentResponse = segmentResponseDecoded
    }
}

public struct UpdateSmsChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSmsChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSmsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSmsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sMSChannelRequest = input.operationInput.sMSChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(sMSChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSmsChannelInput>
    public typealias MOutput = OperationOutput<UpdateSmsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSmsChannelOutputError>
}

extension UpdateSmsChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSmsChannelInput(applicationId: \(String(describing: applicationId)), sMSChannelRequest: \(String(describing: sMSChannelRequest)))"}
}

extension UpdateSmsChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sMSChannelRequest = "SMSChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sMSChannelRequest = sMSChannelRequest {
            try encodeContainer.encode(sMSChannelRequest, forKey: .sMSChannelRequest)
        }
    }
}

public struct UpdateSmsChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSmsChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSmsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSmsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSmsChannelInput>
    public typealias MOutput = OperationOutput<UpdateSmsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSmsChannelOutputError>
}

public struct UpdateSmsChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSmsChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSmsChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSmsChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSmsChannelInput>
    public typealias MOutput = OperationOutput<UpdateSmsChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSmsChannelOutputError>
}

public struct UpdateSmsChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the status and settings of the SMS channel for an application.</p>
    public let sMSChannelRequest: SMSChannelRequest?

    public init (
        applicationId: String? = nil,
        sMSChannelRequest: SMSChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.sMSChannelRequest = sMSChannelRequest
    }
}

struct UpdateSmsChannelInputBody: Equatable {
    public let sMSChannelRequest: SMSChannelRequest?
}

extension UpdateSmsChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSChannelRequest = "SMSChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSChannelRequestDecoded = try containerValues.decodeIfPresent(SMSChannelRequest.self, forKey: .sMSChannelRequest)
        sMSChannelRequest = sMSChannelRequestDecoded
    }
}

extension UpdateSmsChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSmsChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSmsChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSmsChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSmsChannelOutputResponse(sMSChannelResponse: \(String(describing: sMSChannelResponse)))"}
}

extension UpdateSmsChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: SMSChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.sMSChannelResponse = output
            } else {
                self.sMSChannelResponse = nil
            }
        } else {
            self.sMSChannelResponse = nil
        }
    }
}

public struct UpdateSmsChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the SMS channel for an application.</p>
    public let sMSChannelResponse: SMSChannelResponse?

    public init (
        sMSChannelResponse: SMSChannelResponse? = nil
    )
    {
        self.sMSChannelResponse = sMSChannelResponse
    }
}

struct UpdateSmsChannelOutputResponseBody: Equatable {
    public let sMSChannelResponse: SMSChannelResponse?
}

extension UpdateSmsChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSChannelResponse = "SMSChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSChannelResponseDecoded = try containerValues.decodeIfPresent(SMSChannelResponse.self, forKey: .sMSChannelResponse)
        sMSChannelResponse = sMSChannelResponseDecoded
    }
}

public struct UpdateSmsTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSmsTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let sMSTemplateRequest = input.operationInput.sMSTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(sMSTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSmsTemplateInput>
    public typealias MOutput = OperationOutput<UpdateSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSmsTemplateOutputError>
}

extension UpdateSmsTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSmsTemplateInput(createNewVersion: \(String(describing: createNewVersion)), sMSTemplateRequest: \(String(describing: sMSTemplateRequest)), templateName: \(String(describing: templateName)), version: \(String(describing: version)))"}
}

extension UpdateSmsTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sMSTemplateRequest = "SMSTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sMSTemplateRequest = sMSTemplateRequest {
            try encodeContainer.encode(sMSTemplateRequest, forKey: .sMSTemplateRequest)
        }
    }
}

public struct UpdateSmsTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSmsTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSmsTemplateInput>
    public typealias MOutput = OperationOutput<UpdateSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSmsTemplateOutputError>
}

public struct UpdateSmsTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSmsTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSmsTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSmsTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        let createNewVersionQueryItem = URLQueryItem(name: "create-new-version".urlPercentEncoding(), value: String(input.operationInput.createNewVersion).urlPercentEncoding())
        input.builder.withQueryItem(createNewVersionQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSmsTemplateInput>
    public typealias MOutput = OperationOutput<UpdateSmsTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSmsTemplateOutputError>
}

public struct UpdateSmsTemplateInput: Equatable {
    /// <p>Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.</p>
    public let createNewVersion: Bool
    /// <p>Specifies the content and settings for a message template that can be used in text messages that are sent through the SMS channel.</p>
    public let sMSTemplateRequest: SMSTemplateRequest?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?

    public init (
        createNewVersion: Bool = false,
        sMSTemplateRequest: SMSTemplateRequest? = nil,
        templateName: String? = nil,
        version: String? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.sMSTemplateRequest = sMSTemplateRequest
        self.templateName = templateName
        self.version = version
    }
}

struct UpdateSmsTemplateInputBody: Equatable {
    public let sMSTemplateRequest: SMSTemplateRequest?
}

extension UpdateSmsTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case sMSTemplateRequest = "SMSTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sMSTemplateRequestDecoded = try containerValues.decodeIfPresent(SMSTemplateRequest.self, forKey: .sMSTemplateRequest)
        sMSTemplateRequest = sMSTemplateRequestDecoded
    }
}

extension UpdateSmsTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSmsTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSmsTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSmsTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSmsTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension UpdateSmsTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct UpdateSmsTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct UpdateSmsTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension UpdateSmsTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

public struct UpdateTemplateActiveVersionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTemplateActiveVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateActiveVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateActiveVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let templateActiveVersionRequest = input.operationInput.templateActiveVersionRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(templateActiveVersionRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateActiveVersionInput>
    public typealias MOutput = OperationOutput<UpdateTemplateActiveVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateActiveVersionOutputError>
}

extension UpdateTemplateActiveVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateActiveVersionInput(templateActiveVersionRequest: \(String(describing: templateActiveVersionRequest)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)))"}
}

extension UpdateTemplateActiveVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case templateActiveVersionRequest = "TemplateActiveVersionRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let templateActiveVersionRequest = templateActiveVersionRequest {
            try encodeContainer.encode(templateActiveVersionRequest, forKey: .templateActiveVersionRequest)
        }
    }
}

public struct UpdateTemplateActiveVersionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTemplateActiveVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateActiveVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateActiveVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateActiveVersionInput>
    public typealias MOutput = OperationOutput<UpdateTemplateActiveVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateActiveVersionOutputError>
}

public struct UpdateTemplateActiveVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTemplateActiveVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTemplateActiveVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTemplateActiveVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTemplateActiveVersionInput>
    public typealias MOutput = OperationOutput<UpdateTemplateActiveVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTemplateActiveVersionOutputError>
}

public struct UpdateTemplateActiveVersionInput: Equatable {
    /// <p>Specifies which version of a message template to use as the active version of the template.</p>
    public let templateActiveVersionRequest: TemplateActiveVersionRequest?
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. Valid values are: EMAIL, PUSH, SMS, and VOICE.</p>
    public let templateType: String?

    public init (
        templateActiveVersionRequest: TemplateActiveVersionRequest? = nil,
        templateName: String? = nil,
        templateType: String? = nil
    )
    {
        self.templateActiveVersionRequest = templateActiveVersionRequest
        self.templateName = templateName
        self.templateType = templateType
    }
}

struct UpdateTemplateActiveVersionInputBody: Equatable {
    public let templateActiveVersionRequest: TemplateActiveVersionRequest?
}

extension UpdateTemplateActiveVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case templateActiveVersionRequest = "TemplateActiveVersionRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let templateActiveVersionRequestDecoded = try containerValues.decodeIfPresent(TemplateActiveVersionRequest.self, forKey: .templateActiveVersionRequest)
        templateActiveVersionRequest = templateActiveVersionRequestDecoded
    }
}

extension UpdateTemplateActiveVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTemplateActiveVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTemplateActiveVersionOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTemplateActiveVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTemplateActiveVersionOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension UpdateTemplateActiveVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct UpdateTemplateActiveVersionOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct UpdateTemplateActiveVersionOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension UpdateTemplateActiveVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

public struct UpdateVoiceChannelInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVoiceChannelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVoiceChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVoiceChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let voiceChannelRequest = input.operationInput.voiceChannelRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(voiceChannelRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVoiceChannelInput>
    public typealias MOutput = OperationOutput<UpdateVoiceChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVoiceChannelOutputError>
}

extension UpdateVoiceChannelInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVoiceChannelInput(applicationId: \(String(describing: applicationId)), voiceChannelRequest: \(String(describing: voiceChannelRequest)))"}
}

extension UpdateVoiceChannelInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case voiceChannelRequest = "VoiceChannelRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceChannelRequest = voiceChannelRequest {
            try encodeContainer.encode(voiceChannelRequest, forKey: .voiceChannelRequest)
        }
    }
}

public struct UpdateVoiceChannelInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVoiceChannelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVoiceChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVoiceChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVoiceChannelInput>
    public typealias MOutput = OperationOutput<UpdateVoiceChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVoiceChannelOutputError>
}

public struct UpdateVoiceChannelInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVoiceChannelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVoiceChannelInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVoiceChannelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVoiceChannelInput>
    public typealias MOutput = OperationOutput<UpdateVoiceChannelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVoiceChannelOutputError>
}

public struct UpdateVoiceChannelInput: Equatable {
    /// <p>The unique identifier for the application. This identifier is displayed as the <b>Project ID</b> on the Amazon Pinpoint console.</p>
    public let applicationId: String?
    /// <p>Specifies the status and settings of the voice channel for an application.</p>
    public let voiceChannelRequest: VoiceChannelRequest?

    public init (
        applicationId: String? = nil,
        voiceChannelRequest: VoiceChannelRequest? = nil
    )
    {
        self.applicationId = applicationId
        self.voiceChannelRequest = voiceChannelRequest
    }
}

struct UpdateVoiceChannelInputBody: Equatable {
    public let voiceChannelRequest: VoiceChannelRequest?
}

extension UpdateVoiceChannelInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case voiceChannelRequest = "VoiceChannelRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceChannelRequestDecoded = try containerValues.decodeIfPresent(VoiceChannelRequest.self, forKey: .voiceChannelRequest)
        voiceChannelRequest = voiceChannelRequestDecoded
    }
}

extension UpdateVoiceChannelOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVoiceChannelOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVoiceChannelOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVoiceChannelOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVoiceChannelOutputResponse(voiceChannelResponse: \(String(describing: voiceChannelResponse)))"}
}

extension UpdateVoiceChannelOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: VoiceChannelResponse = try responseDecoder.decode(responseBody: unwrappedData)
                self.voiceChannelResponse = output
            } else {
                self.voiceChannelResponse = nil
            }
        } else {
            self.voiceChannelResponse = nil
        }
    }
}

public struct UpdateVoiceChannelOutputResponse: Equatable {
    /// <p>Provides information about the status and settings of the voice channel for an application.</p>
    public let voiceChannelResponse: VoiceChannelResponse?

    public init (
        voiceChannelResponse: VoiceChannelResponse? = nil
    )
    {
        self.voiceChannelResponse = voiceChannelResponse
    }
}

struct UpdateVoiceChannelOutputResponseBody: Equatable {
    public let voiceChannelResponse: VoiceChannelResponse?
}

extension UpdateVoiceChannelOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case voiceChannelResponse = "VoiceChannelResponse"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceChannelResponseDecoded = try containerValues.decodeIfPresent(VoiceChannelResponse.self, forKey: .voiceChannelResponse)
        voiceChannelResponse = voiceChannelResponseDecoded
    }
}

public struct UpdateVoiceTemplateInputBodyMiddleware: Middleware {
    public let id: String = "UpdateVoiceTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let voiceTemplateRequest = input.operationInput.voiceTemplateRequest {
            do {
                let encoder = context.getEncoder()
                let data = try encoder.encode(voiceTemplateRequest)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            } catch let err {
                return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVoiceTemplateInput>
    public typealias MOutput = OperationOutput<UpdateVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVoiceTemplateOutputError>
}

extension UpdateVoiceTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVoiceTemplateInput(createNewVersion: \(String(describing: createNewVersion)), templateName: \(String(describing: templateName)), version: \(String(describing: version)), voiceTemplateRequest: \(String(describing: voiceTemplateRequest)))"}
}

extension UpdateVoiceTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case voiceTemplateRequest = "VoiceTemplateRequest"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let voiceTemplateRequest = voiceTemplateRequest {
            try encodeContainer.encode(voiceTemplateRequest, forKey: .voiceTemplateRequest)
        }
    }
}

public struct UpdateVoiceTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateVoiceTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVoiceTemplateInput>
    public typealias MOutput = OperationOutput<UpdateVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVoiceTemplateOutputError>
}

public struct UpdateVoiceTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateVoiceTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateVoiceTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateVoiceTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let version = input.operationInput.version {
            let versionQueryItem = URLQueryItem(name: "version".urlPercentEncoding(), value: String(version).urlPercentEncoding())
            input.builder.withQueryItem(versionQueryItem)
        }
        let createNewVersionQueryItem = URLQueryItem(name: "create-new-version".urlPercentEncoding(), value: String(input.operationInput.createNewVersion).urlPercentEncoding())
        input.builder.withQueryItem(createNewVersionQueryItem)
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateVoiceTemplateInput>
    public typealias MOutput = OperationOutput<UpdateVoiceTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateVoiceTemplateOutputError>
}

public struct UpdateVoiceTemplateInput: Equatable {
    /// <p>Specifies whether to save the updates as a new version of the message template. Valid values are: true, save the updates as a new version; and, false, save the updates to (overwrite) the latest existing version of the template.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint saves the updates to (overwrites) the latest existing version of the template. If you specify a value of true for this parameter, don't specify a value for the version parameter. Otherwise, an error will occur.</p>
    public let createNewVersion: Bool
    /// <p>The name of the message template. A template name must start with an alphanumeric character and can contain a maximum of 128 characters. The characters can be alphanumeric characters, underscores (_), or hyphens (-). Template names are case sensitive.</p>
    public let templateName: String?
    /// <p>The unique identifier for the version of the message template to update, retrieve information about, or delete. To retrieve identifiers and other information for all the versions of a template, use the <link  linkend="templates-template-name-template-type-versions">Template Versions</link> resource.</p> <p>If specified, this value must match the identifier for an existing template version. If specified for an update operation, this value must match the identifier for the latest existing version of the template. This restriction helps ensure that race conditions don't occur.</p> <p>If you don't specify a value for this parameter, Amazon Pinpoint does the following:</p> <ul><li><p>For a get operation, retrieves information about the active version of the template.</p></li> <li><p>For an update operation, saves the updates to (overwrites) the latest existing version of the template, if the create-new-version parameter isn't used or is set to false.</p></li> <li><p>For a delete operation, deletes the template, including all versions of the template.</p></li></ul>
    public let version: String?
    /// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the voice channel.</p>
    public let voiceTemplateRequest: VoiceTemplateRequest?

    public init (
        createNewVersion: Bool = false,
        templateName: String? = nil,
        version: String? = nil,
        voiceTemplateRequest: VoiceTemplateRequest? = nil
    )
    {
        self.createNewVersion = createNewVersion
        self.templateName = templateName
        self.version = version
        self.voiceTemplateRequest = voiceTemplateRequest
    }
}

struct UpdateVoiceTemplateInputBody: Equatable {
    public let voiceTemplateRequest: VoiceTemplateRequest?
}

extension UpdateVoiceTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case voiceTemplateRequest = "VoiceTemplateRequest"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let voiceTemplateRequestDecoded = try containerValues.decodeIfPresent(VoiceTemplateRequest.self, forKey: .voiceTemplateRequest)
        voiceTemplateRequest = voiceTemplateRequestDecoded
    }
}

extension UpdateVoiceTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateVoiceTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ForbiddenException" : self = .forbiddenException(try ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "MethodNotAllowedException" : self = .methodNotAllowedException(try MethodNotAllowedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PayloadTooLargeException" : self = .payloadTooLargeException(try PayloadTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateVoiceTemplateOutputError: Equatable {
    case badRequestException(BadRequestException)
    case forbiddenException(ForbiddenException)
    case internalServerErrorException(InternalServerErrorException)
    case methodNotAllowedException(MethodNotAllowedException)
    case notFoundException(NotFoundException)
    case payloadTooLargeException(PayloadTooLargeException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateVoiceTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateVoiceTemplateOutputResponse(messageBody: \(String(describing: messageBody)))"}
}

extension UpdateVoiceTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            if let responseDecoder = decoder {
                let output: MessageBody = try responseDecoder.decode(responseBody: unwrappedData)
                self.messageBody = output
            } else {
                self.messageBody = nil
            }
        } else {
            self.messageBody = nil
        }
    }
}

public struct UpdateVoiceTemplateOutputResponse: Equatable {
    /// <p>Provides information about an API request or response.</p>
    public let messageBody: MessageBody?

    public init (
        messageBody: MessageBody? = nil
    )
    {
        self.messageBody = messageBody
    }
}

struct UpdateVoiceTemplateOutputResponseBody: Equatable {
    public let messageBody: MessageBody?
}

extension UpdateVoiceTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageBody = "MessageBody"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageBodyDecoded = try containerValues.decodeIfPresent(MessageBody.self, forKey: .messageBody)
        messageBody = messageBodyDecoded
    }
}

extension VoiceChannelRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case enabled = "Enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension VoiceChannelRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceChannelRequest(enabled: \(String(describing: enabled)))"}
}

/// <p>Specifies the status and settings of the voice channel for an application.</p>
public struct VoiceChannelRequest: Equatable {
    /// <p>Specifies whether to enable the voice channel for the application.</p>
    public let enabled: Bool

    public init (
        enabled: Bool = false
    )
    {
        self.enabled = enabled
    }
}

extension VoiceChannelResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case applicationId = "ApplicationId"
        case creationDate = "CreationDate"
        case enabled = "Enabled"
        case hasCredential = "HasCredential"
        case id = "Id"
        case isArchived = "IsArchived"
        case lastModifiedBy = "LastModifiedBy"
        case lastModifiedDate = "LastModifiedDate"
        case platform = "Platform"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationId = applicationId {
            try encodeContainer.encode(applicationId, forKey: .applicationId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if hasCredential != false {
            try encodeContainer.encode(hasCredential, forKey: .hasCredential)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if isArchived != false {
            try encodeContainer.encode(isArchived, forKey: .isArchived)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let platform = platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .applicationId)
        applicationId = applicationIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let hasCredentialDecoded = try containerValues.decode(Bool.self, forKey: .hasCredential)
        hasCredential = hasCredentialDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let isArchivedDecoded = try containerValues.decode(Bool.self, forKey: .isArchived)
        isArchived = isArchivedDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let platformDecoded = try containerValues.decodeIfPresent(String.self, forKey: .platform)
        platform = platformDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
    }
}

extension VoiceChannelResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceChannelResponse(applicationId: \(String(describing: applicationId)), creationDate: \(String(describing: creationDate)), enabled: \(String(describing: enabled)), hasCredential: \(String(describing: hasCredential)), id: \(String(describing: id)), isArchived: \(String(describing: isArchived)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedDate: \(String(describing: lastModifiedDate)), platform: \(String(describing: platform)), version: \(String(describing: version)))"}
}

/// <p>Provides information about the status and settings of the voice channel for an application.</p>
public struct VoiceChannelResponse: Equatable {
    /// <p>The unique identifier for the application that the voice channel applies to.</p>
    public let applicationId: String?
    /// <p>The date and time, in ISO 8601 format, when the voice channel was enabled.</p>
    public let creationDate: String?
    /// <p>Specifies whether the voice channel is enabled for the application.</p>
    public let enabled: Bool
    /// <p>(Not used) This property is retained only for backward compatibility.</p>
    public let hasCredential: Bool
    /// <p>(Deprecated) An identifier for the voice channel. This property is retained only for backward compatibility.</p>
    public let id: String?
    /// <p>Specifies whether the voice channel is archived.</p>
    public let isArchived: Bool
    /// <p>The user who last modified the voice channel.</p>
    public let lastModifiedBy: String?
    /// <p>The date and time, in ISO 8601 format, when the voice channel was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The type of messaging or notification platform for the channel. For the voice channel, this value is VOICE.</p>
    public let platform: String?
    /// <p>The current version of the voice channel.</p>
    public let version: Int

    public init (
        applicationId: String? = nil,
        creationDate: String? = nil,
        enabled: Bool = false,
        hasCredential: Bool = false,
        id: String? = nil,
        isArchived: Bool = false,
        lastModifiedBy: String? = nil,
        lastModifiedDate: String? = nil,
        platform: String? = nil,
        version: Int = 0
    )
    {
        self.applicationId = applicationId
        self.creationDate = creationDate
        self.enabled = enabled
        self.hasCredential = hasCredential
        self.id = id
        self.isArchived = isArchived
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedDate = lastModifiedDate
        self.platform = platform
        self.version = version
    }
}

extension VoiceMessage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case languageCode = "LanguageCode"
        case originationNumber = "OriginationNumber"
        case substitutions = "Substitutions"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let originationNumber = originationNumber {
            try encodeContainer.encode(originationNumber, forKey: .originationNumber)
        }
        if let substitutions = substitutions {
            var substitutionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .substitutions)
            for (dictKey0, mapoflistof__string0) in substitutions {
                try substitutionsContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let originationNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originationNumber)
        originationNumber = originationNumberDecoded
        let substitutionsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .substitutions)
        var substitutionsDecoded0: [String:[String]]? = nil
        if let substitutionsContainer = substitutionsContainer {
            substitutionsDecoded0 = [String:[String]]()
            for (key0, listof__string0) in substitutionsContainer {
                var listof__string0Decoded0: [String]? = nil
                if let listof__string0 = listof__string0 {
                    listof__string0Decoded0 = [String]()
                    for string1 in listof__string0 {
                        if let string1 = string1 {
                            listof__string0Decoded0?.append(string1)
                        }
                    }
                }
                substitutionsDecoded0?[key0] = listof__string0Decoded0
            }
        }
        substitutions = substitutionsDecoded0
        let voiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension VoiceMessage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceMessage(body: \(String(describing: body)), languageCode: \(String(describing: languageCode)), originationNumber: \(String(describing: originationNumber)), substitutions: \(String(describing: substitutions)), voiceId: \(String(describing: voiceId)))"}
}

/// <p>Specifies the settings for a one-time voice message that's sent directly to an endpoint through the voice channel.</p>
public struct VoiceMessage: Equatable {
    /// <p>The text of the script to use for the voice message.</p>
    public let body: String?
    /// <p>The code for the language to use when synthesizing the text of the message script. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    public let languageCode: String?
    /// <p>The long code to send the voice message from. This value should be one of the dedicated long codes that's assigned to your AWS account. Although it isn't required, we recommend that you specify the long code in E.164 format, for example +12065550100, to ensure prompt and accurate delivery of the message.</p>
    public let originationNumber: String?
    /// <p>The default message variables to use in the voice message. You can override the default variables with individual address variables.</p>
    public let substitutions: [String:[String]]?
    /// <p>The name of the voice to use when delivering the message. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    public let voiceId: String?

    public init (
        body: String? = nil,
        languageCode: String? = nil,
        originationNumber: String? = nil,
        substitutions: [String:[String]]? = nil,
        voiceId: String? = nil
    )
    {
        self.body = body
        self.languageCode = languageCode
        self.originationNumber = originationNumber
        self.substitutions = substitutions
        self.voiceId = voiceId
    }
}

extension VoiceTemplateRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case body = "Body"
        case defaultSubstitutions = "DefaultSubstitutions"
        case languageCode = "LanguageCode"
        case templateDescription = "TemplateDescription"
        case voiceId = "VoiceId"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension VoiceTemplateRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceTemplateRequest(body: \(String(describing: body)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), languageCode: \(String(describing: languageCode)), templateDescription: \(String(describing: templateDescription)), voiceId: \(String(describing: voiceId)), tags: \(String(describing: tags)))"}
}

/// <p>Specifies the content and settings for a message template that can be used in messages that are sent through the voice channel.</p>
public struct VoiceTemplateRequest: Equatable {
    /// <p>The text of the script to use in messages that are based on the message template, in plain text format.</p>
    public let body: String?
    /// <p>A JSON object that specifies the default values to use for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable. When you create a message that's based on the template, you can override these defaults with message-specific and address-specific variables and values.</p>
    public let defaultSubstitutions: String?
    /// <p>The code for the language to use when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    public let languageCode: String?
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>A custom description of the message template.</p>
    public let templateDescription: String?
    /// <p>The name of the voice to use when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    public let voiceId: String?

    public init (
        body: String? = nil,
        defaultSubstitutions: String? = nil,
        languageCode: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil,
        voiceId: String? = nil
    )
    {
        self.body = body
        self.defaultSubstitutions = defaultSubstitutions
        self.languageCode = languageCode
        self.tags = tags
        self.templateDescription = templateDescription
        self.voiceId = voiceId
    }
}

extension VoiceTemplateResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case body = "Body"
        case creationDate = "CreationDate"
        case defaultSubstitutions = "DefaultSubstitutions"
        case languageCode = "LanguageCode"
        case lastModifiedDate = "LastModifiedDate"
        case templateDescription = "TemplateDescription"
        case templateName = "TemplateName"
        case templateType = "TemplateType"
        case version = "Version"
        case voiceId = "VoiceId"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let body = body {
            try encodeContainer.encode(body, forKey: .body)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let defaultSubstitutions = defaultSubstitutions {
            try encodeContainer.encode(defaultSubstitutions, forKey: .defaultSubstitutions)
        }
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let templateDescription = templateDescription {
            try encodeContainer.encode(templateDescription, forKey: .templateDescription)
        }
        if let templateName = templateName {
            try encodeContainer.encode(templateName, forKey: .templateName)
        }
        if let templateType = templateType {
            try encodeContainer.encode(templateType.rawValue, forKey: .templateType)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let bodyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .body)
        body = bodyDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let defaultSubstitutionsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .defaultSubstitutions)
        defaultSubstitutions = defaultSubstitutionsDecoded
        let languageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateDescription)
        templateDescription = templateDescriptionDecoded
        let templateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .templateName)
        templateName = templateNameDecoded
        let templateTypeDecoded = try containerValues.decodeIfPresent(TemplateType.self, forKey: .templateType)
        templateType = templateTypeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension VoiceTemplateResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceTemplateResponse(arn: \(String(describing: arn)), body: \(String(describing: body)), creationDate: \(String(describing: creationDate)), defaultSubstitutions: \(String(describing: defaultSubstitutions)), languageCode: \(String(describing: languageCode)), lastModifiedDate: \(String(describing: lastModifiedDate)), templateDescription: \(String(describing: templateDescription)), templateName: \(String(describing: templateName)), templateType: \(String(describing: templateType)), version: \(String(describing: version)), voiceId: \(String(describing: voiceId)), tags: \(String(describing: tags)))"}
}

/// <p>Provides information about the content and settings for a message template that can be used in messages that are sent through the voice channel.</p>
public struct VoiceTemplateResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the message template.</p>
    public let arn: String?
    /// <p>The text of the script that's used in messages that are based on the message template, in plain text format.</p>
    public let body: String?
    /// <p>The date, in ISO 8601 format, when the message template was created.</p>
    public let creationDate: String?
    /// <p>The JSON object that specifies the default values that are used for message variables in the message template. This object is a set of key-value pairs. Each key defines a message variable in the template. The corresponding value defines the default value for that variable.</p>
    public let defaultSubstitutions: String?
    /// <p>The code for the language that's used when synthesizing the text of the script in messages that are based on the message template. For a list of supported languages and the code for each one, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    public let languageCode: String?
    /// <p>The date, in ISO 8601 format, when the message template was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>A string-to-string map of key-value pairs that identifies the tags that are associated with the message template. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>The custom description of the message template.</p>
    public let templateDescription: String?
    /// <p>The name of the message template.</p>
    public let templateName: String?
    /// <p>The type of channel that the message template is designed for. For a voice template, this value is VOICE.</p>
    public let templateType: TemplateType?
    /// <p>The unique identifier, as an integer, for the active version of the message template, or the version of the template that you specified by using the version parameter in your request.</p>
    public let version: String?
    /// <p>The name of the voice that's used when delivering messages that are based on the message template. For a list of supported voices, see the <a href="https://docs.aws.amazon.com/polly/latest/dg/what-is.html">Amazon Polly Developer Guide</a>.</p>
    public let voiceId: String?

    public init (
        arn: String? = nil,
        body: String? = nil,
        creationDate: String? = nil,
        defaultSubstitutions: String? = nil,
        languageCode: String? = nil,
        lastModifiedDate: String? = nil,
        tags: [String:String]? = nil,
        templateDescription: String? = nil,
        templateName: String? = nil,
        templateType: TemplateType? = nil,
        version: String? = nil,
        voiceId: String? = nil
    )
    {
        self.arn = arn
        self.body = body
        self.creationDate = creationDate
        self.defaultSubstitutions = defaultSubstitutions
        self.languageCode = languageCode
        self.lastModifiedDate = lastModifiedDate
        self.tags = tags
        self.templateDescription = templateDescription
        self.templateName = templateName
        self.templateType = templateType
        self.version = version
        self.voiceId = voiceId
    }
}

extension WaitActivity: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nextActivity = "NextActivity"
        case waitTime = "WaitTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextActivity = nextActivity {
            try encodeContainer.encode(nextActivity, forKey: .nextActivity)
        }
        if let waitTime = waitTime {
            try encodeContainer.encode(waitTime, forKey: .waitTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextActivity)
        nextActivity = nextActivityDecoded
        let waitTimeDecoded = try containerValues.decodeIfPresent(WaitTime.self, forKey: .waitTime)
        waitTime = waitTimeDecoded
    }
}

extension WaitActivity: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WaitActivity(nextActivity: \(String(describing: nextActivity)), waitTime: \(String(describing: waitTime)))"}
}

/// <p>Specifies the settings for a wait activity in a journey. This type of activity waits for a certain amount of time or until a specific date and time before moving participants to the next activity in a journey.</p>
public struct WaitActivity: Equatable {
    /// <p>The unique identifier for the next activity to perform, after performing the wait activity.</p>
    public let nextActivity: String?
    /// <p>The amount of time to wait or the date and time when the activity moves participants to the next activity in the journey.</p>
    public let waitTime: WaitTime?

    public init (
        nextActivity: String? = nil,
        waitTime: WaitTime? = nil
    )
    {
        self.nextActivity = nextActivity
        self.waitTime = waitTime
    }
}

extension WaitTime: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case waitFor = "WaitFor"
        case waitUntil = "WaitUntil"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let waitFor = waitFor {
            try encodeContainer.encode(waitFor, forKey: .waitFor)
        }
        if let waitUntil = waitUntil {
            try encodeContainer.encode(waitUntil, forKey: .waitUntil)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let waitForDecoded = try containerValues.decodeIfPresent(String.self, forKey: .waitFor)
        waitFor = waitForDecoded
        let waitUntilDecoded = try containerValues.decodeIfPresent(String.self, forKey: .waitUntil)
        waitUntil = waitUntilDecoded
    }
}

extension WaitTime: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WaitTime(waitFor: \(String(describing: waitFor)), waitUntil: \(String(describing: waitUntil)))"}
}

/// <p>Specifies a duration or a date and time that indicates when Amazon Pinpoint determines whether an activity's conditions have been met or an activity moves participants to the next activity in a journey.</p>
public struct WaitTime: Equatable {
    /// <p>The amount of time to wait, as a duration in ISO 8601 format, before determining whether the activity's conditions have been met or moving participants to the next activity in the journey.</p>
    public let waitFor: String?
    /// <p>The date and time, in ISO 8601 format, when Amazon Pinpoint determines whether the activity's conditions have been met or the activity moves participants to the next activity in the journey.</p>
    public let waitUntil: String?

    public init (
        waitFor: String? = nil,
        waitUntil: String? = nil
    )
    {
        self.waitFor = waitFor
        self.waitUntil = waitUntil
    }
}

extension WriteApplicationSettingsRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case campaignHook = "CampaignHook"
        case cloudWatchMetricsEnabled = "CloudWatchMetricsEnabled"
        case eventTaggingEnabled = "EventTaggingEnabled"
        case limits = "Limits"
        case quietTime = "QuietTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let campaignHook = campaignHook {
            try encodeContainer.encode(campaignHook, forKey: .campaignHook)
        }
        if cloudWatchMetricsEnabled != false {
            try encodeContainer.encode(cloudWatchMetricsEnabled, forKey: .cloudWatchMetricsEnabled)
        }
        if eventTaggingEnabled != false {
            try encodeContainer.encode(eventTaggingEnabled, forKey: .eventTaggingEnabled)
        }
        if let limits = limits {
            try encodeContainer.encode(limits, forKey: .limits)
        }
        if let quietTime = quietTime {
            try encodeContainer.encode(quietTime, forKey: .quietTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let campaignHookDecoded = try containerValues.decodeIfPresent(CampaignHook.self, forKey: .campaignHook)
        campaignHook = campaignHookDecoded
        let cloudWatchMetricsEnabledDecoded = try containerValues.decode(Bool.self, forKey: .cloudWatchMetricsEnabled)
        cloudWatchMetricsEnabled = cloudWatchMetricsEnabledDecoded
        let eventTaggingEnabledDecoded = try containerValues.decode(Bool.self, forKey: .eventTaggingEnabled)
        eventTaggingEnabled = eventTaggingEnabledDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(CampaignLimits.self, forKey: .limits)
        limits = limitsDecoded
        let quietTimeDecoded = try containerValues.decodeIfPresent(QuietTime.self, forKey: .quietTime)
        quietTime = quietTimeDecoded
    }
}

extension WriteApplicationSettingsRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteApplicationSettingsRequest(campaignHook: \(String(describing: campaignHook)), cloudWatchMetricsEnabled: \(String(describing: cloudWatchMetricsEnabled)), eventTaggingEnabled: \(String(describing: eventTaggingEnabled)), limits: \(String(describing: limits)), quietTime: \(String(describing: quietTime)))"}
}

/// <p>Specifies the default settings for an application.</p>
public struct WriteApplicationSettingsRequest: Equatable {
    /// <p>The settings for the AWS Lambda function to invoke by default as a code hook for campaigns in the application. You can use this hook to customize segments that are used by campaigns in the application.</p> <p>To override these settings and define custom settings for a specific campaign, use the CampaignHook object of the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource.</p>
    public let campaignHook: CampaignHook?
    /// <p>Specifies whether to enable application-related alarms in Amazon CloudWatch.</p>
    public let cloudWatchMetricsEnabled: Bool
    public let eventTaggingEnabled: Bool
    /// <p>The default sending limits for campaigns in the application. To override these limits and define custom limits for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource, respectively.</p>
    public let limits: CampaignLimits?
    /// <p>The default quiet time for campaigns in the application. Quiet time is a specific time range when messages aren't sent to endpoints, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint is set to a valid value.</p></li> <li><p>The current time in the endpoint's time zone is later than or equal to the time specified by the QuietTime.Start property for the application (or a campaign or journey that has custom quiet time settings).</p></li> <li><p>The current time in the endpoint's time zone is earlier than or equal to the time specified by the QuietTime.End property for the application (or a campaign or journey that has custom quiet time settings).</p></li></ul> <p>If any of the preceding conditions isn't met, the endpoint will receive messages from a campaign or journey, even if quiet time is enabled.</p> <p>To override the default quiet time settings for a specific campaign or journey, use the <link  linkend="apps-application-id-campaigns-campaign-id">Campaign</link> resource or the <link  linkend="apps-application-id-journeys-journey-id">Journey</link> resource to define a custom quiet time for the campaign or journey.</p>
    public let quietTime: QuietTime?

    public init (
        campaignHook: CampaignHook? = nil,
        cloudWatchMetricsEnabled: Bool = false,
        eventTaggingEnabled: Bool = false,
        limits: CampaignLimits? = nil,
        quietTime: QuietTime? = nil
    )
    {
        self.campaignHook = campaignHook
        self.cloudWatchMetricsEnabled = cloudWatchMetricsEnabled
        self.eventTaggingEnabled = eventTaggingEnabled
        self.limits = limits
        self.quietTime = quietTime
    }
}

extension WriteCampaignRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalTreatments = "AdditionalTreatments"
        case customDeliveryConfiguration = "CustomDeliveryConfiguration"
        case description = "Description"
        case holdoutPercent = "HoldoutPercent"
        case hook = "Hook"
        case isPaused = "IsPaused"
        case limits = "Limits"
        case messageConfiguration = "MessageConfiguration"
        case name = "Name"
        case schedule = "Schedule"
        case segmentId = "SegmentId"
        case segmentVersion = "SegmentVersion"
        case templateConfiguration = "TemplateConfiguration"
        case treatmentDescription = "TreatmentDescription"
        case treatmentName = "TreatmentName"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalTreatments = additionalTreatments {
            var additionalTreatmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalTreatments)
            for listofwritetreatmentresource0 in additionalTreatments {
                try additionalTreatmentsContainer.encode(listofwritetreatmentresource0)
            }
        }
        if let customDeliveryConfiguration = customDeliveryConfiguration {
            try encodeContainer.encode(customDeliveryConfiguration, forKey: .customDeliveryConfiguration)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if holdoutPercent != 0 {
            try encodeContainer.encode(holdoutPercent, forKey: .holdoutPercent)
        }
        if let hook = hook {
            try encodeContainer.encode(hook, forKey: .hook)
        }
        if isPaused != false {
            try encodeContainer.encode(isPaused, forKey: .isPaused)
        }
        if let limits = limits {
            try encodeContainer.encode(limits, forKey: .limits)
        }
        if let messageConfiguration = messageConfiguration {
            try encodeContainer.encode(messageConfiguration, forKey: .messageConfiguration)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let segmentId = segmentId {
            try encodeContainer.encode(segmentId, forKey: .segmentId)
        }
        if segmentVersion != 0 {
            try encodeContainer.encode(segmentVersion, forKey: .segmentVersion)
        }
        if let templateConfiguration = templateConfiguration {
            try encodeContainer.encode(templateConfiguration, forKey: .templateConfiguration)
        }
        if let treatmentDescription = treatmentDescription {
            try encodeContainer.encode(treatmentDescription, forKey: .treatmentDescription)
        }
        if let treatmentName = treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalTreatmentsContainer = try containerValues.decodeIfPresent([WriteTreatmentResource?].self, forKey: .additionalTreatments)
        var additionalTreatmentsDecoded0:[WriteTreatmentResource]? = nil
        if let additionalTreatmentsContainer = additionalTreatmentsContainer {
            additionalTreatmentsDecoded0 = [WriteTreatmentResource]()
            for structure0 in additionalTreatmentsContainer {
                if let structure0 = structure0 {
                    additionalTreatmentsDecoded0?.append(structure0)
                }
            }
        }
        additionalTreatments = additionalTreatmentsDecoded0
        let customDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(CustomDeliveryConfiguration.self, forKey: .customDeliveryConfiguration)
        customDeliveryConfiguration = customDeliveryConfigurationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let holdoutPercentDecoded = try containerValues.decode(Int.self, forKey: .holdoutPercent)
        holdoutPercent = holdoutPercentDecoded
        let hookDecoded = try containerValues.decodeIfPresent(CampaignHook.self, forKey: .hook)
        hook = hookDecoded
        let isPausedDecoded = try containerValues.decode(Bool.self, forKey: .isPaused)
        isPaused = isPausedDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(CampaignLimits.self, forKey: .limits)
        limits = limitsDecoded
        let messageConfigurationDecoded = try containerValues.decodeIfPresent(MessageConfiguration.self, forKey: .messageConfiguration)
        messageConfiguration = messageConfigurationDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let segmentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .segmentId)
        segmentId = segmentIdDecoded
        let segmentVersionDecoded = try containerValues.decode(Int.self, forKey: .segmentVersion)
        segmentVersion = segmentVersionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
        let templateConfigurationDecoded = try containerValues.decodeIfPresent(TemplateConfiguration.self, forKey: .templateConfiguration)
        templateConfiguration = templateConfigurationDecoded
        let treatmentDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentDescription)
        treatmentDescription = treatmentDescriptionDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
    }
}

extension WriteCampaignRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteCampaignRequest(additionalTreatments: \(String(describing: additionalTreatments)), customDeliveryConfiguration: \(String(describing: customDeliveryConfiguration)), description: \(String(describing: description)), holdoutPercent: \(String(describing: holdoutPercent)), hook: \(String(describing: hook)), isPaused: \(String(describing: isPaused)), limits: \(String(describing: limits)), messageConfiguration: \(String(describing: messageConfiguration)), name: \(String(describing: name)), schedule: \(String(describing: schedule)), segmentId: \(String(describing: segmentId)), segmentVersion: \(String(describing: segmentVersion)), templateConfiguration: \(String(describing: templateConfiguration)), treatmentDescription: \(String(describing: treatmentDescription)), treatmentName: \(String(describing: treatmentName)), tags: \(String(describing: tags)))"}
}

/// <p>Specifies the configuration and other settings for a campaign.</p>
public struct WriteCampaignRequest: Equatable {
    /// <p>An array of requests that defines additional treatments for the campaign, in addition to the default treatment for the campaign.</p>
    public let additionalTreatments: [WriteTreatmentResource]?
    /// <p>The delivery configuration settings for sending the campaign through a custom channel. This object is required if the MessageConfiguration object for the campaign specifies a CustomMessage object.</p>
    public let customDeliveryConfiguration: CustomDeliveryConfiguration?
    /// <p>A custom description of the campaign.</p>
    public let description: String?
    /// <p>The allocated percentage of users (segment members) who shouldn't receive messages from the campaign.</p>
    public let holdoutPercent: Int
    /// <p>The settings for the AWS Lambda function to invoke as a code hook for the campaign. You can use this hook to customize the segment that's used by the campaign.</p>
    public let hook: CampaignHook?
    /// <p>Specifies whether to pause the campaign. A paused campaign doesn't run unless you resume it by changing this value to false.</p>
    public let isPaused: Bool
    /// <p>The messaging limits for the campaign.</p>
    public let limits: CampaignLimits?
    /// <p>The message configuration settings for the campaign.</p>
    public let messageConfiguration: MessageConfiguration?
    /// <p>A custom name for the campaign.</p>
    public let name: String?
    /// <p>The schedule settings for the campaign.</p>
    public let schedule: Schedule?
    /// <p>The unique identifier for the segment to associate with the campaign.</p>
    public let segmentId: String?
    /// <p>The version of the segment to associate with the campaign.</p>
    public let segmentVersion: Int
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the campaign. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?
    /// <p>The message template to use for the campaign.</p>
    public let templateConfiguration: TemplateConfiguration?
    /// <p>A custom description of the default treatment for the campaign.</p>
    public let treatmentDescription: String?
    /// <p>A custom name of the default treatment for the campaign, if the campaign has multiple treatments. A <i>treatment</i> is a variation of a campaign that's used for A/B testing.</p>
    public let treatmentName: String?

    public init (
        additionalTreatments: [WriteTreatmentResource]? = nil,
        customDeliveryConfiguration: CustomDeliveryConfiguration? = nil,
        description: String? = nil,
        holdoutPercent: Int = 0,
        hook: CampaignHook? = nil,
        isPaused: Bool = false,
        limits: CampaignLimits? = nil,
        messageConfiguration: MessageConfiguration? = nil,
        name: String? = nil,
        schedule: Schedule? = nil,
        segmentId: String? = nil,
        segmentVersion: Int = 0,
        tags: [String:String]? = nil,
        templateConfiguration: TemplateConfiguration? = nil,
        treatmentDescription: String? = nil,
        treatmentName: String? = nil
    )
    {
        self.additionalTreatments = additionalTreatments
        self.customDeliveryConfiguration = customDeliveryConfiguration
        self.description = description
        self.holdoutPercent = holdoutPercent
        self.hook = hook
        self.isPaused = isPaused
        self.limits = limits
        self.messageConfiguration = messageConfiguration
        self.name = name
        self.schedule = schedule
        self.segmentId = segmentId
        self.segmentVersion = segmentVersion
        self.tags = tags
        self.templateConfiguration = templateConfiguration
        self.treatmentDescription = treatmentDescription
        self.treatmentName = treatmentName
    }
}

extension WriteEventStream: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationStreamArn = "DestinationStreamArn"
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationStreamArn = destinationStreamArn {
            try encodeContainer.encode(destinationStreamArn, forKey: .destinationStreamArn)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationStreamArn)
        destinationStreamArn = destinationStreamArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension WriteEventStream: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteEventStream(destinationStreamArn: \(String(describing: destinationStreamArn)), roleArn: \(String(describing: roleArn)))"}
}

/// <p>Specifies the Amazon Resource Name (ARN) of an event stream to publish events to and the AWS Identity and Access Management (IAM) role to use when publishing those events.</p>
public struct WriteEventStream: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon Kinesis data stream or Amazon Kinesis Data Firehose delivery stream that you want to publish event data to.</p> <p>For a Kinesis data stream, the ARN format is: arn:aws:kinesis:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:stream/<replaceable>stream_name</replaceable>
    ///                </p> <p>For a Kinesis Data Firehose delivery stream, the ARN format is: arn:aws:firehose:<replaceable>region</replaceable>:<replaceable>account-id</replaceable>:deliverystream/<replaceable>stream_name</replaceable>
    ///                </p>
    public let destinationStreamArn: String?
    /// <p>The AWS Identity and Access Management (IAM) role that authorizes Amazon Pinpoint to publish event data to the stream in your AWS account.</p>
    public let roleArn: String?

    public init (
        destinationStreamArn: String? = nil,
        roleArn: String? = nil
    )
    {
        self.destinationStreamArn = destinationStreamArn
        self.roleArn = roleArn
    }
}

extension WriteJourneyRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activities = "Activities"
        case creationDate = "CreationDate"
        case lastModifiedDate = "LastModifiedDate"
        case limits = "Limits"
        case localTime = "LocalTime"
        case name = "Name"
        case quietTime = "QuietTime"
        case refreshFrequency = "RefreshFrequency"
        case refreshOnSegmentUpdate = "RefreshOnSegmentUpdate"
        case schedule = "Schedule"
        case startActivity = "StartActivity"
        case startCondition = "StartCondition"
        case state = "State"
        case waitForQuietTime = "WaitForQuietTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activities = activities {
            var activitiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .activities)
            for (dictKey0, mapofactivity0) in activities {
                try activitiesContainer.encode(mapofactivity0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let limits = limits {
            try encodeContainer.encode(limits, forKey: .limits)
        }
        if localTime != false {
            try encodeContainer.encode(localTime, forKey: .localTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quietTime = quietTime {
            try encodeContainer.encode(quietTime, forKey: .quietTime)
        }
        if let refreshFrequency = refreshFrequency {
            try encodeContainer.encode(refreshFrequency, forKey: .refreshFrequency)
        }
        if refreshOnSegmentUpdate != false {
            try encodeContainer.encode(refreshOnSegmentUpdate, forKey: .refreshOnSegmentUpdate)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let startActivity = startActivity {
            try encodeContainer.encode(startActivity, forKey: .startActivity)
        }
        if let startCondition = startCondition {
            try encodeContainer.encode(startCondition, forKey: .startCondition)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if waitForQuietTime != false {
            try encodeContainer.encode(waitForQuietTime, forKey: .waitForQuietTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activitiesContainer = try containerValues.decodeIfPresent([String: Activity?].self, forKey: .activities)
        var activitiesDecoded0: [String:Activity]? = nil
        if let activitiesContainer = activitiesContainer {
            activitiesDecoded0 = [String:Activity]()
            for (key0, activity0) in activitiesContainer {
                if let activity0 = activity0 {
                    activitiesDecoded0?[key0] = activity0
                }
            }
        }
        activities = activitiesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(JourneyLimits.self, forKey: .limits)
        limits = limitsDecoded
        let localTimeDecoded = try containerValues.decode(Bool.self, forKey: .localTime)
        localTime = localTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let quietTimeDecoded = try containerValues.decodeIfPresent(QuietTime.self, forKey: .quietTime)
        quietTime = quietTimeDecoded
        let refreshFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshFrequency)
        refreshFrequency = refreshFrequencyDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(JourneySchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let startActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startActivity)
        startActivity = startActivityDecoded
        let startConditionDecoded = try containerValues.decodeIfPresent(StartCondition.self, forKey: .startCondition)
        startCondition = startConditionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let waitForQuietTimeDecoded = try containerValues.decode(Bool.self, forKey: .waitForQuietTime)
        waitForQuietTime = waitForQuietTimeDecoded
        let refreshOnSegmentUpdateDecoded = try containerValues.decode(Bool.self, forKey: .refreshOnSegmentUpdate)
        refreshOnSegmentUpdate = refreshOnSegmentUpdateDecoded
    }
}

extension WriteJourneyRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteJourneyRequest(activities: \(String(describing: activities)), creationDate: \(String(describing: creationDate)), lastModifiedDate: \(String(describing: lastModifiedDate)), limits: \(String(describing: limits)), localTime: \(String(describing: localTime)), name: \(String(describing: name)), quietTime: \(String(describing: quietTime)), refreshFrequency: \(String(describing: refreshFrequency)), refreshOnSegmentUpdate: \(String(describing: refreshOnSegmentUpdate)), schedule: \(String(describing: schedule)), startActivity: \(String(describing: startActivity)), startCondition: \(String(describing: startCondition)), state: \(String(describing: state)), waitForQuietTime: \(String(describing: waitForQuietTime)))"}
}

/// <p>Specifies the configuration and other settings for a journey.</p>
public struct WriteJourneyRequest: Equatable {
    /// <p>A map that contains a set of Activity objects, one object for each activity in the journey. For each Activity object, the key is the unique identifier (string) for an activity and the value is the settings for the activity. An activity identifier can contain a maximum of 100 characters. The characters must be alphanumeric characters.</p>
    public let activities: [String:Activity]?
    /// <p>The date, in ISO 8601 format, when the journey was created.</p>
    public let creationDate: String?
    /// <p>The date, in ISO 8601 format, when the journey was last modified.</p>
    public let lastModifiedDate: String?
    /// <p>The messaging and entry limits for the journey.</p>
    public let limits: JourneyLimits?
    /// <p>Specifies whether the journey's scheduled start and end times use each participant's local time. To base the schedule on each participant's local time, set this value to true.</p>
    public let localTime: Bool
    /// <p>The name of the journey. A journey name can contain a maximum of 150 characters. The characters can be alphanumeric characters or symbols, such as underscores (_) or hyphens (-). A journey name can't contain any spaces.</p>
    public let name: String?
    /// <p>The quiet time settings for the journey. Quiet time is a specific time range when a journey doesn't send messages to participants, if all the following conditions are met:</p> <ul><li><p>The EndpointDemographic.Timezone property of the endpoint for the participant is set to a valid value.</p></li> <li><p>The current time in the participant's time zone is later than or equal to the time specified by the QuietTime.Start property for the journey.</p></li> <li><p>The current time in the participant's time zone is earlier than or equal to the time specified by the QuietTime.End property for the journey.</p></li></ul> <p>If any of the preceding conditions isn't met, the participant will receive messages from the journey, even if quiet time is enabled.</p>
    public let quietTime: QuietTime?
    /// <p>The frequency with which Amazon Pinpoint evaluates segment and event data for the journey, as a duration in ISO 8601 format.</p>
    public let refreshFrequency: String?
    /// <p>Specifies whether a journey should be refreshed on segment update.</p>
    public let refreshOnSegmentUpdate: Bool
    /// <p>The schedule settings for the journey.</p>
    public let schedule: JourneySchedule?
    /// <p>The unique identifier for the first activity in the journey. The identifier for this activity can contain a maximum of 128 characters. The characters must be alphanumeric characters.</p>
    public let startActivity: String?
    /// <p>The segment that defines which users are participants in the journey.</p>
    public let startCondition: StartCondition?
    /// <p>The status of the journey. Valid values are:</p> <ul><li><p>DRAFT - Saves the journey and doesn't publish it.</p></li> <li><p>ACTIVE - Saves and publishes the journey. Depending on the journey's schedule, the journey starts running immediately or at the scheduled start time. If a journey's status is ACTIVE, you can't add, change, or remove activities from it.</p></li></ul> <p>PAUSED, CANCELLED, COMPLETED, and CLOSED states are not supported in requests to create or update a journey. To cancel, pause, or resume a journey, use the <link  linkend="apps-application-id-journeys-journey-id-state">Journey State</link> resource.</p>
    public let state: State?
    /// <p>Specifies whether endpoints in quiet hours should enter a wait till the end of their quiet hours.</p>
    public let waitForQuietTime: Bool

    public init (
        activities: [String:Activity]? = nil,
        creationDate: String? = nil,
        lastModifiedDate: String? = nil,
        limits: JourneyLimits? = nil,
        localTime: Bool = false,
        name: String? = nil,
        quietTime: QuietTime? = nil,
        refreshFrequency: String? = nil,
        refreshOnSegmentUpdate: Bool = false,
        schedule: JourneySchedule? = nil,
        startActivity: String? = nil,
        startCondition: StartCondition? = nil,
        state: State? = nil,
        waitForQuietTime: Bool = false
    )
    {
        self.activities = activities
        self.creationDate = creationDate
        self.lastModifiedDate = lastModifiedDate
        self.limits = limits
        self.localTime = localTime
        self.name = name
        self.quietTime = quietTime
        self.refreshFrequency = refreshFrequency
        self.refreshOnSegmentUpdate = refreshOnSegmentUpdate
        self.schedule = schedule
        self.startActivity = startActivity
        self.startCondition = startCondition
        self.state = state
        self.waitForQuietTime = waitForQuietTime
    }
}

extension WriteSegmentRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dimensions = "Dimensions"
        case name = "Name"
        case segmentGroups = "SegmentGroups"
        case tags = "tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimensions = dimensions {
            try encodeContainer.encode(dimensions, forKey: .dimensions)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let segmentGroups = segmentGroups {
            try encodeContainer.encode(segmentGroups, forKey: .segmentGroups)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, mapof__string0) in tags {
                try tagsContainer.encode(mapof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionsDecoded = try containerValues.decodeIfPresent(SegmentDimensions.self, forKey: .dimensions)
        dimensions = dimensionsDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let segmentGroupsDecoded = try containerValues.decodeIfPresent(SegmentGroupList.self, forKey: .segmentGroups)
        segmentGroups = segmentGroupsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension WriteSegmentRequest: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteSegmentRequest(dimensions: \(String(describing: dimensions)), name: \(String(describing: name)), segmentGroups: \(String(describing: segmentGroups)), tags: \(String(describing: tags)))"}
}

/// <p>Specifies the configuration, dimension, and other settings for a segment. A WriteSegmentRequest object can include a Dimensions object or a SegmentGroups object, but not both.</p>
public struct WriteSegmentRequest: Equatable {
    /// <p>The criteria that define the dimensions for the segment.</p>
    public let dimensions: SegmentDimensions?
    /// <p>The name of the segment.</p>
    public let name: String?
    /// <p>The segment group to use and the dimensions to apply to the group's base segments in order to build the segment. A segment group can consist of zero or more base segments. Your request can include only one segment group.</p>
    public let segmentGroups: SegmentGroupList?
    /// <p>A string-to-string map of key-value pairs that defines the tags to associate with the segment. Each tag consists of a required tag key and an associated tag value.</p>
    public let tags: [String:String]?

    public init (
        dimensions: SegmentDimensions? = nil,
        name: String? = nil,
        segmentGroups: SegmentGroupList? = nil,
        tags: [String:String]? = nil
    )
    {
        self.dimensions = dimensions
        self.name = name
        self.segmentGroups = segmentGroups
        self.tags = tags
    }
}

extension WriteTreatmentResource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customDeliveryConfiguration = "CustomDeliveryConfiguration"
        case messageConfiguration = "MessageConfiguration"
        case schedule = "Schedule"
        case sizePercent = "SizePercent"
        case templateConfiguration = "TemplateConfiguration"
        case treatmentDescription = "TreatmentDescription"
        case treatmentName = "TreatmentName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customDeliveryConfiguration = customDeliveryConfiguration {
            try encodeContainer.encode(customDeliveryConfiguration, forKey: .customDeliveryConfiguration)
        }
        if let messageConfiguration = messageConfiguration {
            try encodeContainer.encode(messageConfiguration, forKey: .messageConfiguration)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if sizePercent != 0 {
            try encodeContainer.encode(sizePercent, forKey: .sizePercent)
        }
        if let templateConfiguration = templateConfiguration {
            try encodeContainer.encode(templateConfiguration, forKey: .templateConfiguration)
        }
        if let treatmentDescription = treatmentDescription {
            try encodeContainer.encode(treatmentDescription, forKey: .treatmentDescription)
        }
        if let treatmentName = treatmentName {
            try encodeContainer.encode(treatmentName, forKey: .treatmentName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customDeliveryConfigurationDecoded = try containerValues.decodeIfPresent(CustomDeliveryConfiguration.self, forKey: .customDeliveryConfiguration)
        customDeliveryConfiguration = customDeliveryConfigurationDecoded
        let messageConfigurationDecoded = try containerValues.decodeIfPresent(MessageConfiguration.self, forKey: .messageConfiguration)
        messageConfiguration = messageConfigurationDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(Schedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let sizePercentDecoded = try containerValues.decode(Int.self, forKey: .sizePercent)
        sizePercent = sizePercentDecoded
        let templateConfigurationDecoded = try containerValues.decodeIfPresent(TemplateConfiguration.self, forKey: .templateConfiguration)
        templateConfiguration = templateConfigurationDecoded
        let treatmentDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentDescription)
        treatmentDescription = treatmentDescriptionDecoded
        let treatmentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .treatmentName)
        treatmentName = treatmentNameDecoded
    }
}

extension WriteTreatmentResource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "WriteTreatmentResource(customDeliveryConfiguration: \(String(describing: customDeliveryConfiguration)), messageConfiguration: \(String(describing: messageConfiguration)), schedule: \(String(describing: schedule)), sizePercent: \(String(describing: sizePercent)), templateConfiguration: \(String(describing: templateConfiguration)), treatmentDescription: \(String(describing: treatmentDescription)), treatmentName: \(String(describing: treatmentName)))"}
}

/// <p>Specifies the settings for a campaign treatment. A <i>treatment</i> is a variation of a campaign that's used for A/B testing of a campaign.</p>
public struct WriteTreatmentResource: Equatable {
    /// <p>The delivery configuration settings for sending the treatment through a custom channel. This object is required if the MessageConfiguration object for the treatment specifies a CustomMessage object.</p>
    public let customDeliveryConfiguration: CustomDeliveryConfiguration?
    /// <p>The message configuration settings for the treatment.</p>
    public let messageConfiguration: MessageConfiguration?
    /// <p>The schedule settings for the treatment.</p>
    public let schedule: Schedule?
    /// <p>The allocated percentage of users (segment members) to send the treatment to.</p>
    public let sizePercent: Int
    /// <p>The message template to use for the treatment.</p>
    public let templateConfiguration: TemplateConfiguration?
    /// <p>A custom description of the treatment.</p>
    public let treatmentDescription: String?
    /// <p>A custom name for the treatment.</p>
    public let treatmentName: String?

    public init (
        customDeliveryConfiguration: CustomDeliveryConfiguration? = nil,
        messageConfiguration: MessageConfiguration? = nil,
        schedule: Schedule? = nil,
        sizePercent: Int = 0,
        templateConfiguration: TemplateConfiguration? = nil,
        treatmentDescription: String? = nil,
        treatmentName: String? = nil
    )
    {
        self.customDeliveryConfiguration = customDeliveryConfiguration
        self.messageConfiguration = messageConfiguration
        self.schedule = schedule
        self.sizePercent = sizePercent
        self.templateConfiguration = templateConfiguration
        self.treatmentDescription = treatmentDescription
        self.treatmentName = treatmentName
    }
}

public enum __EndpointTypesElement {
    case adm
    case apns
    case apnsSandbox
    case apnsVoip
    case apnsVoipSandbox
    case baidu
    case custom
    case email
    case gcm
    case push
    case sms
    case voice
    case sdkUnknown(String)
}

extension __EndpointTypesElement : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [__EndpointTypesElement] {
        return [
            .adm,
            .apns,
            .apnsSandbox,
            .apnsVoip,
            .apnsVoipSandbox,
            .baidu,
            .custom,
            .email,
            .gcm,
            .push,
            .sms,
            .voice,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .adm: return "ADM"
        case .apns: return "APNS"
        case .apnsSandbox: return "APNS_SANDBOX"
        case .apnsVoip: return "APNS_VOIP"
        case .apnsVoipSandbox: return "APNS_VOIP_SANDBOX"
        case .baidu: return "BAIDU"
        case .custom: return "CUSTOM"
        case .email: return "EMAIL"
        case .gcm: return "GCM"
        case .push: return "PUSH"
        case .sms: return "SMS"
        case .voice: return "VOICE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = __EndpointTypesElement(rawValue: rawValue) ?? __EndpointTypesElement.sdkUnknown(rawValue)
    }
}
