// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension PublicEndpoint: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case attributes = "Attributes"
        case channelType = "ChannelType"
        case demographic = "Demographic"
        case effectiveDate = "EffectiveDate"
        case endpointStatus = "EndpointStatus"
        case location = "Location"
        case metrics = "Metrics"
        case optOut = "OptOut"
        case requestId = "RequestId"
        case user = "User"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .attributes)
            for (dictKey0, mapoflistof__string0) in attributes {
                try attributesContainer.encode(mapoflistof__string0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let channelType = channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let demographic = demographic {
            try encodeContainer.encode(demographic, forKey: .demographic)
        }
        if let effectiveDate = effectiveDate {
            try encodeContainer.encode(effectiveDate, forKey: .effectiveDate)
        }
        if let endpointStatus = endpointStatus {
            try encodeContainer.encode(endpointStatus, forKey: .endpointStatus)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let metrics = metrics {
            var metricsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .metrics)
            for (dictKey0, mapof__double0) in metrics {
                try metricsContainer.encode(mapof__double0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let optOut = optOut {
            try encodeContainer.encode(optOut, forKey: .optOut)
        }
        if let requestId = requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let attributesContainer = try containerValues.decodeIfPresent([String:[String]?].self, forKey: .attributes)
        var attributesDecoded0: [String:[String]?]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [String:[String]?]()
            for (key0, listof__string0) in attributesContainer {
                var listof__string0Decoded0 = [String]()
                if let listof__string0 = listof__string0 {
                    for string1 in listof__string0 {
                        listof__string0Decoded0.append(string1)
                    }
                }
                attributesDecoded0?[key0] = listof__string0Decoded0
            }
        }
        attributes = attributesDecoded0
        let channelTypeDecoded = try containerValues.decodeIfPresent(ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let demographicDecoded = try containerValues.decodeIfPresent(EndpointDemographic.self, forKey: .demographic)
        demographic = demographicDecoded
        let effectiveDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .effectiveDate)
        effectiveDate = effectiveDateDecoded
        let endpointStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointStatus)
        endpointStatus = endpointStatusDecoded
        let locationDecoded = try containerValues.decodeIfPresent(EndpointLocation.self, forKey: .location)
        location = locationDecoded
        let metricsContainer = try containerValues.decodeIfPresent([String:Double].self, forKey: .metrics)
        var metricsDecoded0: [String:Double]? = nil
        if let metricsContainer = metricsContainer {
            metricsDecoded0 = [String:Double]()
            for (key0, __double0) in metricsContainer {
                metricsDecoded0?[key0] = __double0
            }
        }
        metrics = metricsDecoded0
        let optOutDecoded = try containerValues.decodeIfPresent(String.self, forKey: .optOut)
        optOut = optOutDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let userDecoded = try containerValues.decodeIfPresent(EndpointUser.self, forKey: .user)
        user = userDecoded
    }
}
