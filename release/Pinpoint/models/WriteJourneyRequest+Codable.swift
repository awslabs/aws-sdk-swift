// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension WriteJourneyRequest: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case activities = "Activities"
        case creationDate = "CreationDate"
        case lastModifiedDate = "LastModifiedDate"
        case limits = "Limits"
        case localTime = "LocalTime"
        case name = "Name"
        case quietTime = "QuietTime"
        case refreshFrequency = "RefreshFrequency"
        case refreshOnSegmentUpdate = "RefreshOnSegmentUpdate"
        case schedule = "Schedule"
        case startActivity = "StartActivity"
        case startCondition = "StartCondition"
        case state = "State"
        case waitForQuietTime = "WaitForQuietTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activities = activities {
            var activitiesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .activities)
            for (dictKey0, mapofactivity0) in activities {
                try activitiesContainer.encode(mapofactivity0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate, forKey: .creationDate)
        }
        if let lastModifiedDate = lastModifiedDate {
            try encodeContainer.encode(lastModifiedDate, forKey: .lastModifiedDate)
        }
        if let limits = limits {
            try encodeContainer.encode(limits, forKey: .limits)
        }
        if localTime != false {
            try encodeContainer.encode(localTime, forKey: .localTime)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let quietTime = quietTime {
            try encodeContainer.encode(quietTime, forKey: .quietTime)
        }
        if let refreshFrequency = refreshFrequency {
            try encodeContainer.encode(refreshFrequency, forKey: .refreshFrequency)
        }
        if refreshOnSegmentUpdate != false {
            try encodeContainer.encode(refreshOnSegmentUpdate, forKey: .refreshOnSegmentUpdate)
        }
        if let schedule = schedule {
            try encodeContainer.encode(schedule, forKey: .schedule)
        }
        if let startActivity = startActivity {
            try encodeContainer.encode(startActivity, forKey: .startActivity)
        }
        if let startCondition = startCondition {
            try encodeContainer.encode(startCondition, forKey: .startCondition)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if waitForQuietTime != false {
            try encodeContainer.encode(waitForQuietTime, forKey: .waitForQuietTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let activitiesContainer = try containerValues.decodeIfPresent([String:Activity].self, forKey: .activities)
        var activitiesDecoded0: [String:Activity]? = nil
        if let activitiesContainer = activitiesContainer {
            activitiesDecoded0 = [String:Activity]()
            for (key0, activity0) in activitiesContainer {
                activitiesDecoded0?[key0] = activity0
            }
        }
        activities = activitiesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastModifiedDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedDate)
        lastModifiedDate = lastModifiedDateDecoded
        let limitsDecoded = try containerValues.decodeIfPresent(JourneyLimits.self, forKey: .limits)
        limits = limitsDecoded
        let localTimeDecoded = try containerValues.decode(Bool.self, forKey: .localTime)
        localTime = localTimeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let quietTimeDecoded = try containerValues.decodeIfPresent(QuietTime.self, forKey: .quietTime)
        quietTime = quietTimeDecoded
        let refreshFrequencyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .refreshFrequency)
        refreshFrequency = refreshFrequencyDecoded
        let scheduleDecoded = try containerValues.decodeIfPresent(JourneySchedule.self, forKey: .schedule)
        schedule = scheduleDecoded
        let startActivityDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startActivity)
        startActivity = startActivityDecoded
        let startConditionDecoded = try containerValues.decodeIfPresent(StartCondition.self, forKey: .startCondition)
        startCondition = startConditionDecoded
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let waitForQuietTimeDecoded = try containerValues.decode(Bool.self, forKey: .waitForQuietTime)
        waitForQuietTime = waitForQuietTimeDecoded
        let refreshOnSegmentUpdateDecoded = try containerValues.decode(Bool.self, forKey: .refreshOnSegmentUpdate)
        refreshOnSegmentUpdate = refreshOnSegmentUpdateDecoded
    }
}
