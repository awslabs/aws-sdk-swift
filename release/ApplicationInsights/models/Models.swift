// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             User does not have permissions to perform this action.
///          </p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ApplicationComponent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case componentRemarks = "ComponentRemarks"
        case detectedWorkload = "DetectedWorkload"
        case monitor = "Monitor"
        case osType = "OsType"
        case resourceType = "ResourceType"
        case tier = "Tier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let componentRemarks = componentRemarks {
            try encodeContainer.encode(componentRemarks, forKey: .componentRemarks)
        }
        if let detectedWorkload = detectedWorkload {
            var detectedWorkloadContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .detectedWorkload)
            for (dictKey0, detectedworkload0) in detectedWorkload {
                try detectedWorkloadContainer.encode(detectedworkload0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let monitor = monitor {
            try encodeContainer.encode(monitor, forKey: .monitor)
        }
        if let osType = osType {
            try encodeContainer.encode(osType.rawValue, forKey: .osType)
        }
        if let resourceType = resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let componentRemarksDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentRemarks)
        componentRemarks = componentRemarksDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let osTypeDecoded = try containerValues.decodeIfPresent(OsType.self, forKey: .osType)
        osType = osTypeDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Tier.self, forKey: .tier)
        tier = tierDecoded
        let monitorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let detectedWorkloadContainer = try containerValues.decodeIfPresent([String: [String: String?]?].self, forKey: .detectedWorkload)
        var detectedWorkloadDecoded0: [String:[String:String]]? = nil
        if let detectedWorkloadContainer = detectedWorkloadContainer {
            detectedWorkloadDecoded0 = [String:[String:String]]()
            for (key0, workloadmetadata0) in detectedWorkloadContainer {
                var workloadmetadata0Decoded0: [String: String]? = nil
                if let workloadmetadata0 = workloadmetadata0 {
                    workloadmetadata0Decoded0 = [String: String]()
                    for (key1, metadatavalue1) in workloadmetadata0 {
                        if let metadatavalue1 = metadatavalue1 {
                            workloadmetadata0Decoded0?[key1] = metadatavalue1
                        }
                    }
                }
                detectedWorkloadDecoded0?[key0] = workloadmetadata0Decoded0
            }
        }
        detectedWorkload = detectedWorkloadDecoded0
    }
}

extension ApplicationComponent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationComponent(componentName: \(String(describing: componentName)), componentRemarks: \(String(describing: componentRemarks)), detectedWorkload: \(String(describing: detectedWorkload)), monitor: \(String(describing: monitor)), osType: \(String(describing: osType)), resourceType: \(String(describing: resourceType)), tier: \(String(describing: tier)))"}
}

/// <p>Describes a standalone resource or similarly grouped resources that the application is made
///          up of.</p>
public struct ApplicationComponent: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>
    ///          If logging is supported for the resource type, indicates whether the component has configured logs to be monitored.
    ///       </p>
    public let componentRemarks: String?
    /// <p>
    ///          Workloads detected in the application component.
    ///       </p>
    public let detectedWorkload: [String:[String:String]]?
    /// <p>Indicates whether the application component is monitored. </p>
    public let monitor: Bool?
    /// <p>
    ///          The operating system of the component.
    ///       </p>
    public let osType: OsType?
    /// <p>The resource type. Supported resource types include EC2 instances, Auto Scaling group, Classic ELB, Application ELB, and SQS Queue.</p>
    public let resourceType: String?
    /// <p>The stack tier of the application component.</p>
    public let tier: Tier?

    public init (
        componentName: String? = nil,
        componentRemarks: String? = nil,
        detectedWorkload: [String:[String:String]]? = nil,
        monitor: Bool? = nil,
        osType: OsType? = nil,
        resourceType: String? = nil,
        tier: Tier? = nil
    )
    {
        self.componentName = componentName
        self.componentRemarks = componentRemarks
        self.detectedWorkload = detectedWorkload
        self.monitor = monitor
        self.osType = osType
        self.resourceType = resourceType
        self.tier = tier
    }
}

extension ApplicationInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cWEMonitorEnabled = "CWEMonitorEnabled"
        case lifeCycle = "LifeCycle"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case remarks = "Remarks"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cWEMonitorEnabled = cWEMonitorEnabled {
            try encodeContainer.encode(cWEMonitorEnabled, forKey: .cWEMonitorEnabled)
        }
        if let lifeCycle = lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let opsCenterEnabled = opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let remarks = remarks {
            try encodeContainer.encode(remarks, forKey: .remarks)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cWEMonitorEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cWEMonitorEnabled)
        cWEMonitorEnabled = cWEMonitorEnabledDecoded
        let remarksDecoded = try containerValues.decodeIfPresent(String.self, forKey: .remarks)
        remarks = remarksDecoded
    }
}

extension ApplicationInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ApplicationInfo(cWEMonitorEnabled: \(String(describing: cWEMonitorEnabled)), lifeCycle: \(String(describing: lifeCycle)), opsCenterEnabled: \(String(describing: opsCenterEnabled)), opsItemSNSTopicArn: \(String(describing: opsItemSNSTopicArn)), remarks: \(String(describing: remarks)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

/// <p>Describes the status of the application.</p>
public struct ApplicationInfo: Equatable {
    /// <p>
    ///          Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as <code>instance terminated</code>, <code>failed deployment</code>, and others.
    ///       </p>
    public let cWEMonitorEnabled: Bool?
    /// <p>The lifecycle of the application. </p>
    public let lifeCycle: String?
    /// <p>
    ///          Indicates whether Application Insights will create opsItems for any problem detected by Application
    ///          Insights for an application.
    ///       </p>
    public let opsCenterEnabled: Bool?
    /// <p>
    ///          The SNS topic provided to Application Insights that is associated to the created opsItems to receive SNS notifications
    ///          for opsItem updates.
    ///       </p>
    public let opsItemSNSTopicArn: String?
    /// <p>The issues on the user side that block Application Insights from successfully monitoring
    ///          an application. Example remarks include:</p>
    ///          <ul>
    ///             <li>
    ///                <p>“Configuring application, detected 1 Errors, 3 Warnings”</p>
    ///             </li>
    ///             <li>
    ///                <p>“Configuring application, detected 1 Unconfigured Components”</p>
    ///             </li>
    ///          </ul>
    public let remarks: String?
    /// <p>The name of the resource group used for the application.</p>
    public let resourceGroupName: String?

    public init (
        cWEMonitorEnabled: Bool? = nil,
        lifeCycle: String? = nil,
        opsCenterEnabled: Bool? = nil,
        opsItemSNSTopicArn: String? = nil,
        remarks: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.cWEMonitorEnabled = cWEMonitorEnabled
        self.lifeCycle = lifeCycle
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.remarks = remarks
        self.resourceGroupName = resourceGroupName
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is not understood by the server.</p>
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum CloudWatchEventSource {
    case codeDeploy
    case ec2
    case health
    case rds
    case sdkUnknown(String)
}

extension CloudWatchEventSource : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CloudWatchEventSource] {
        return [
            .codeDeploy,
            .ec2,
            .health,
            .rds,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .codeDeploy: return "CODE_DEPLOY"
        case .ec2: return "EC2"
        case .health: return "HEALTH"
        case .rds: return "RDS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CloudWatchEventSource(rawValue: rawValue) ?? CloudWatchEventSource.sdkUnknown(rawValue)
    }
}

extension ConfigurationEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventDetail = "EventDetail"
        case eventResourceName = "EventResourceName"
        case eventResourceType = "EventResourceType"
        case eventStatus = "EventStatus"
        case eventTime = "EventTime"
        case monitoredResourceARN = "MonitoredResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDetail = eventDetail {
            try encodeContainer.encode(eventDetail, forKey: .eventDetail)
        }
        if let eventResourceName = eventResourceName {
            try encodeContainer.encode(eventResourceName, forKey: .eventResourceName)
        }
        if let eventResourceType = eventResourceType {
            try encodeContainer.encode(eventResourceType.rawValue, forKey: .eventResourceType)
        }
        if let eventStatus = eventStatus {
            try encodeContainer.encode(eventStatus.rawValue, forKey: .eventStatus)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let monitoredResourceARN = monitoredResourceARN {
            try encodeContainer.encode(monitoredResourceARN, forKey: .monitoredResourceARN)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitoredResourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .monitoredResourceARN)
        monitoredResourceARN = monitoredResourceARNDecoded
        let eventStatusDecoded = try containerValues.decodeIfPresent(ConfigurationEventStatus.self, forKey: .eventStatus)
        eventStatus = eventStatusDecoded
        let eventResourceTypeDecoded = try containerValues.decodeIfPresent(ConfigurationEventResourceType.self, forKey: .eventResourceType)
        eventResourceType = eventResourceTypeDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventDetailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDetail)
        eventDetail = eventDetailDecoded
        let eventResourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventResourceName)
        eventResourceName = eventResourceNameDecoded
    }
}

extension ConfigurationEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConfigurationEvent(eventDetail: \(String(describing: eventDetail)), eventResourceName: \(String(describing: eventResourceName)), eventResourceType: \(String(describing: eventResourceType)), eventStatus: \(String(describing: eventStatus)), eventTime: \(String(describing: eventTime)), monitoredResourceARN: \(String(describing: monitoredResourceARN)))"}
}

/// <p>
///          The event information.
///       </p>
public struct ConfigurationEvent: Equatable {
    /// <p>
    ///          The details of the event in plain text.
    ///       </p>
    public let eventDetail: String?
    /// <p>
    ///          The name of the resource Application Insights attempted to configure.
    ///       </p>
    public let eventResourceName: String?
    /// <p>
    ///          The resource type that Application Insights attempted to configure, for example, CLOUDWATCH_ALARM.
    ///       </p>
    public let eventResourceType: ConfigurationEventResourceType?
    /// <p>
    ///          The status of the configuration update event. Possible values include INFO, WARN, and ERROR.
    ///       </p>
    public let eventStatus: ConfigurationEventStatus?
    /// <p>
    ///          The timestamp of the event.
    ///       </p>
    public let eventTime: Date?
    /// <p>
    ///          The resource monitored by Application Insights.
    ///       </p>
    public let monitoredResourceARN: String?

    public init (
        eventDetail: String? = nil,
        eventResourceName: String? = nil,
        eventResourceType: ConfigurationEventResourceType? = nil,
        eventStatus: ConfigurationEventStatus? = nil,
        eventTime: Date? = nil,
        monitoredResourceARN: String? = nil
    )
    {
        self.eventDetail = eventDetail
        self.eventResourceName = eventResourceName
        self.eventResourceType = eventResourceType
        self.eventStatus = eventStatus
        self.eventTime = eventTime
        self.monitoredResourceARN = monitoredResourceARN
    }
}

public enum ConfigurationEventResourceType {
    case cloudformation
    case cloudwatchAlarm
    case cloudwatchLog
    case ssmAssociation
    case sdkUnknown(String)
}

extension ConfigurationEventResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationEventResourceType] {
        return [
            .cloudformation,
            .cloudwatchAlarm,
            .cloudwatchLog,
            .ssmAssociation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cloudformation: return "CLOUDFORMATION"
        case .cloudwatchAlarm: return "CLOUDWATCH_ALARM"
        case .cloudwatchLog: return "CLOUDWATCH_LOG"
        case .ssmAssociation: return "SSM_ASSOCIATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationEventResourceType(rawValue: rawValue) ?? ConfigurationEventResourceType.sdkUnknown(rawValue)
    }
}

public enum ConfigurationEventStatus {
    case error
    case info
    case warn
    case sdkUnknown(String)
}

extension ConfigurationEventStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConfigurationEventStatus] {
        return [
            .error,
            .info,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .info: return "INFO"
        case .warn: return "WARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConfigurationEventStatus(rawValue: rawValue) ?? ConfigurationEventStatus.sdkUnknown(rawValue)
    }
}

public struct CreateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "CreateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

extension CreateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationInput(cWEMonitorEnabled: \(String(describing: cWEMonitorEnabled)), opsCenterEnabled: \(String(describing: opsCenterEnabled)), opsItemSNSTopicArn: \(String(describing: opsItemSNSTopicArn)), resourceGroupName: \(String(describing: resourceGroupName)), tags: \(String(describing: tags)))"}
}

extension CreateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cWEMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case resourceGroupName = "ResourceGroupName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cWEMonitorEnabled = cWEMonitorEnabled {
            try encodeContainer.encode(cWEMonitorEnabled, forKey: .cWEMonitorEnabled)
        }
        if let opsCenterEnabled = opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateApplicationInput>
    public typealias MOutput = OperationOutput<CreateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateApplicationOutputError>
}

public struct CreateApplicationInput: Equatable {
    /// <p>
    ///          Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as <code>instance terminated</code>, <code>failed deployment</code>, and others.
    ///       </p>
    public let cWEMonitorEnabled: Bool?
    /// <p>
    ///          When set to <code>true</code>, creates opsItems for any problems detected on an application.
    ///       </p>
    public let opsCenterEnabled: Bool?
    /// <p>
    ///          The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to
    ///          receive notifications for updates to the opsItem.
    ///       </p>
    public let opsItemSNSTopicArn: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?
    /// <p>List of tags to add to the application.
    ///          tag key (<code>Key</code>) and an associated tag value (<code>Value</code>). The maximum
    ///          length of a tag key is 128 characters. The maximum length of a tag value is 256
    ///          characters.</p>
    public let tags: [Tag]?

    public init (
        cWEMonitorEnabled: Bool? = nil,
        opsCenterEnabled: Bool? = nil,
        opsItemSNSTopicArn: String? = nil,
        resourceGroupName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.cWEMonitorEnabled = cWEMonitorEnabled
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.resourceGroupName = resourceGroupName
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Equatable {
    public let resourceGroupName: String?
    public let opsCenterEnabled: Bool?
    public let cWEMonitorEnabled: Bool?
    public let opsItemSNSTopicArn: String?
    public let tags: [Tag]?
}

extension CreateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cWEMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case resourceGroupName = "ResourceGroupName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cWEMonitorEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cWEMonitorEnabled)
        cWEMonitorEnabled = cWEMonitorEnabledDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsAlreadyExistException" : self = .tagsAlreadyExistException(try TagsAlreadyExistException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateApplicationOutputError: Swift.Error, Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsAlreadyExistException(TagsAlreadyExistException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateApplicationOutputResponse(applicationInfo: \(String(describing: applicationInfo)))"}
}

extension CreateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct CreateApplicationOutputResponse: Equatable {
    /// <p>Information about the application.</p>
    public let applicationInfo: ApplicationInfo?

    public init (
        applicationInfo: ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct CreateApplicationOutputResponseBody: Equatable {
    public let applicationInfo: ApplicationInfo?
}

extension CreateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

public struct CreateComponentInputBodyMiddleware: Middleware {
    public let id: String = "CreateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentInput>
    public typealias MOutput = OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentOutputError>
}

extension CreateComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComponentInput(componentName: \(String(describing: componentName)), resourceGroupName: \(String(describing: resourceGroupName)), resourceList: \(String(describing: resourceList)))"}
}

extension CreateComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceList = resourceList {
            var resourceListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceList)
            for resourcelist0 in resourceList {
                try resourceListContainer.encode(resourcelist0)
            }
        }
    }
}

public struct CreateComponentInputHeadersMiddleware: Middleware {
    public let id: String = "CreateComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentInput>
    public typealias MOutput = OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentOutputError>
}

public struct CreateComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateComponentInput>
    public typealias MOutput = OperationOutput<CreateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateComponentOutputError>
}

public struct CreateComponentInput: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?
    /// <p>The list of resource ARNs that belong to the component.</p>
    public let resourceList: [String]?

    public init (
        componentName: String? = nil,
        resourceGroupName: String? = nil,
        resourceList: [String]? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

struct CreateComponentInputBody: Equatable {
    public let resourceGroupName: String?
    public let componentName: String?
    public let resourceList: [String]?
}

extension CreateComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceList)
        var resourceListDecoded0:[String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

extension CreateComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateComponentOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateComponentOutputResponse()"}
}

extension CreateComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct CreateComponentOutputResponse: Equatable {

    public init() {}
}

struct CreateComponentOutputResponseBody: Equatable {
}

extension CreateComponentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateLogPatternInputBodyMiddleware: Middleware {
    public let id: String = "CreateLogPatternInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLogPatternInput>
    public typealias MOutput = OperationOutput<CreateLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLogPatternOutputError>
}

extension CreateLogPatternInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLogPatternInput(pattern: \(String(describing: pattern)), patternName: \(String(describing: patternName)), patternSetName: \(String(describing: patternSetName)), rank: \(String(describing: rank)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension CreateLogPatternInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct CreateLogPatternInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLogPatternInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLogPatternInput>
    public typealias MOutput = OperationOutput<CreateLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLogPatternOutputError>
}

public struct CreateLogPatternInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLogPatternInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLogPatternInput>
    public typealias MOutput = OperationOutput<CreateLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLogPatternOutputError>
}

public struct CreateLogPatternInput: Equatable {
    /// <p>The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.</p>
    public let pattern: String?
    /// <p>The name of the log pattern.</p>
    public let patternName: String?
    /// <p>The name of the log pattern set.</p>
    public let patternSetName: String?
    /// <p>Rank of the log pattern. Must be a value between <code>1</code> and <code>1,000,000</code>. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank <code>1</code> will be the first to get matched to a log line. A pattern of rank <code>1,000,000</code> will be last to get matched. When you configure custom log patterns from the console, a <code>Low</code> severity pattern translates to a <code>750,000</code> rank. A <code>Medium</code> severity pattern translates to a <code>500,000</code> rank. And a <code>High</code> severity pattern translates to a <code>250,000</code> rank.
    ///          Rank values less than <code>1</code> or greater than <code>1,000,000</code> are reserved for AWS-provided patterns.
    ///       </p>
    public let rank: Int
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        pattern: String? = nil,
        patternName: String? = nil,
        patternSetName: String? = nil,
        rank: Int = 0,
        resourceGroupName: String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

struct CreateLogPatternInputBody: Equatable {
    public let resourceGroupName: String?
    public let patternSetName: String?
    public let patternName: String?
    public let pattern: String?
    public let rank: Int
}

extension CreateLogPatternInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension CreateLogPatternOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLogPatternOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLogPatternOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLogPatternOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLogPatternOutputResponse(logPattern: \(String(describing: logPattern)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension CreateLogPatternOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateLogPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct CreateLogPatternOutputResponse: Equatable {
    /// <p>The successfully created log pattern.</p>
    public let logPattern: LogPattern?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        logPattern: LogPattern? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct CreateLogPatternOutputResponseBody: Equatable {
    public let logPattern: LogPattern?
    public let resourceGroupName: String?
}

extension CreateLogPatternOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logPatternDecoded = try containerValues.decodeIfPresent(LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

public struct DeleteApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

extension DeleteApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationInput(resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DeleteApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct DeleteApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteApplicationInput>
    public typealias MOutput = OperationOutput<DeleteApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteApplicationOutputError>
}

public struct DeleteApplicationInput: Equatable {
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        resourceGroupName: String? = nil
    )
    {
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteApplicationInputBody: Equatable {
    public let resourceGroupName: String?
}

extension DeleteApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension DeleteApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteApplicationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteApplicationOutputResponse()"}
}

extension DeleteApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteApplicationOutputResponse: Equatable {

    public init() {}
}

struct DeleteApplicationOutputResponseBody: Equatable {
}

extension DeleteApplicationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteComponentInputBodyMiddleware: Middleware {
    public let id: String = "DeleteComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteComponentOutputError>
}

extension DeleteComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteComponentInput(componentName: \(String(describing: componentName)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DeleteComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct DeleteComponentInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteComponentInput>
    public typealias MOutput = OperationOutput<DeleteComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteComponentOutputError>
}

public struct DeleteComponentInput: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        componentName: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteComponentInputBody: Equatable {
    public let resourceGroupName: String?
    public let componentName: String?
}

extension DeleteComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension DeleteComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteComponentOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteComponentOutputResponse()"}
}

extension DeleteComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteComponentOutputResponse: Equatable {

    public init() {}
}

struct DeleteComponentOutputResponseBody: Equatable {
}

extension DeleteComponentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteLogPatternInputBodyMiddleware: Middleware {
    public let id: String = "DeleteLogPatternInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLogPatternInput>
    public typealias MOutput = OperationOutput<DeleteLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLogPatternOutputError>
}

extension DeleteLogPatternInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLogPatternInput(patternName: \(String(describing: patternName)), patternSetName: \(String(describing: patternSetName)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DeleteLogPatternInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patternName = patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct DeleteLogPatternInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLogPatternInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLogPatternInput>
    public typealias MOutput = OperationOutput<DeleteLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLogPatternOutputError>
}

public struct DeleteLogPatternInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLogPatternInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLogPatternInput>
    public typealias MOutput = OperationOutput<DeleteLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLogPatternOutputError>
}

public struct DeleteLogPatternInput: Equatable {
    /// <p>The name of the log pattern.</p>
    public let patternName: String?
    /// <p>The name of the log pattern set.</p>
    public let patternSetName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        patternName: String? = nil,
        patternSetName: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct DeleteLogPatternInputBody: Equatable {
    public let resourceGroupName: String?
    public let patternSetName: String?
    public let patternName: String?
}

extension DeleteLogPatternInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternName)
        patternName = patternNameDecoded
    }
}

extension DeleteLogPatternOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLogPatternOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLogPatternOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLogPatternOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLogPatternOutputResponse()"}
}

extension DeleteLogPatternOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLogPatternOutputResponse: Equatable {

    public init() {}
}

struct DeleteLogPatternOutputResponseBody: Equatable {
}

extension DeleteLogPatternOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeApplicationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

extension DescribeApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationInput(resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DescribeApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct DescribeApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

public struct DescribeApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeApplicationInput>
    public typealias MOutput = OperationOutput<DescribeApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeApplicationOutputError>
}

public struct DescribeApplicationInput: Equatable {
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        resourceGroupName: String? = nil
    )
    {
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeApplicationInputBody: Equatable {
    public let resourceGroupName: String?
}

extension DescribeApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
    }
}

extension DescribeApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeApplicationOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeApplicationOutputResponse(applicationInfo: \(String(describing: applicationInfo)))"}
}

extension DescribeApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct DescribeApplicationOutputResponse: Equatable {
    /// <p>Information about the application.</p>
    public let applicationInfo: ApplicationInfo?

    public init (
        applicationInfo: ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct DescribeApplicationOutputResponseBody: Equatable {
    public let applicationInfo: ApplicationInfo?
}

extension DescribeApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

public struct DescribeComponentConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeComponentConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeComponentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentConfigurationOutputError>
}

extension DescribeComponentConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentConfigurationInput(componentName: \(String(describing: componentName)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DescribeComponentConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct DescribeComponentConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeComponentConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeComponentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentConfigurationOutputError>
}

public struct DescribeComponentConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeComponentConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentConfigurationInput>
    public typealias MOutput = OperationOutput<DescribeComponentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentConfigurationOutputError>
}

public struct DescribeComponentConfigurationInput: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        componentName: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeComponentConfigurationInputBody: Equatable {
    public let resourceGroupName: String?
    public let componentName: String?
}

extension DescribeComponentConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension DescribeComponentConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeComponentConfigurationOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentConfigurationOutputResponse(componentConfiguration: \(String(describing: componentConfiguration)), monitor: \(String(describing: monitor)), tier: \(String(describing: tier)))"}
}

extension DescribeComponentConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeComponentConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentConfiguration = output.componentConfiguration
            self.monitor = output.monitor
            self.tier = output.tier
        } else {
            self.componentConfiguration = nil
            self.monitor = nil
            self.tier = nil
        }
    }
}

public struct DescribeComponentConfigurationOutputResponse: Equatable {
    /// <p>The configuration settings of the component. The value is the escaped JSON of the configuration.</p>
    public let componentConfiguration: String?
    /// <p>Indicates whether the application component is monitored.</p>
    public let monitor: Bool?
    /// <p>The tier of the application component. Supported tiers include
    ///          <code>DOT_NET_CORE</code>, <code>DOT_NET_WORKER</code>, <code>DOT_NET_WEB</code>,
    ///          <code>SQL_SERVER</code>, and <code>DEFAULT</code>
    ///          </p>
    public let tier: Tier?

    public init (
        componentConfiguration: String? = nil,
        monitor: Bool? = nil,
        tier: Tier? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
        self.monitor = monitor
        self.tier = tier
    }
}

struct DescribeComponentConfigurationOutputResponseBody: Equatable {
    public let monitor: Bool?
    public let tier: Tier?
    public let componentConfiguration: String?
}

extension DescribeComponentConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentConfiguration = "ComponentConfiguration"
        case monitor = "Monitor"
        case tier = "Tier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monitorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Tier.self, forKey: .tier)
        tier = tierDecoded
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
    }
}

public struct DescribeComponentConfigurationRecommendationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeComponentConfigurationRecommendationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentConfigurationRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentConfigurationRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentConfigurationRecommendationInput>
    public typealias MOutput = OperationOutput<DescribeComponentConfigurationRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentConfigurationRecommendationOutputError>
}

extension DescribeComponentConfigurationRecommendationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentConfigurationRecommendationInput(componentName: \(String(describing: componentName)), resourceGroupName: \(String(describing: resourceGroupName)), tier: \(String(describing: tier)))"}
}

extension DescribeComponentConfigurationRecommendationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

public struct DescribeComponentConfigurationRecommendationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeComponentConfigurationRecommendationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentConfigurationRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentConfigurationRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentConfigurationRecommendationInput>
    public typealias MOutput = OperationOutput<DescribeComponentConfigurationRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentConfigurationRecommendationOutputError>
}

public struct DescribeComponentConfigurationRecommendationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeComponentConfigurationRecommendationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentConfigurationRecommendationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentConfigurationRecommendationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentConfigurationRecommendationInput>
    public typealias MOutput = OperationOutput<DescribeComponentConfigurationRecommendationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentConfigurationRecommendationOutputError>
}

public struct DescribeComponentConfigurationRecommendationInput: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?
    /// <p>The tier of the application component. Supported tiers include
    ///          <code>DOT_NET_CORE</code>, <code>DOT_NET_WORKER</code>, <code>DOT_NET_WEB</code>, <code>SQL_SERVER</code>,
    ///          and <code>DEFAULT</code>.</p>
    public let tier: Tier?

    public init (
        componentName: String? = nil,
        resourceGroupName: String? = nil,
        tier: Tier? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
        self.tier = tier
    }
}

struct DescribeComponentConfigurationRecommendationInputBody: Equatable {
    public let resourceGroupName: String?
    public let componentName: String?
    public let tier: Tier?
}

extension DescribeComponentConfigurationRecommendationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Tier.self, forKey: .tier)
        tier = tierDecoded
    }
}

extension DescribeComponentConfigurationRecommendationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentConfigurationRecommendationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeComponentConfigurationRecommendationOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentConfigurationRecommendationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentConfigurationRecommendationOutputResponse(componentConfiguration: \(String(describing: componentConfiguration)))"}
}

extension DescribeComponentConfigurationRecommendationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeComponentConfigurationRecommendationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.componentConfiguration = output.componentConfiguration
        } else {
            self.componentConfiguration = nil
        }
    }
}

public struct DescribeComponentConfigurationRecommendationOutputResponse: Equatable {
    /// <p>The recommended configuration settings of the component. The value is the escaped JSON of the configuration.</p>
    public let componentConfiguration: String?

    public init (
        componentConfiguration: String? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
    }
}

struct DescribeComponentConfigurationRecommendationOutputResponseBody: Equatable {
    public let componentConfiguration: String?
}

extension DescribeComponentConfigurationRecommendationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentConfiguration = "ComponentConfiguration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
    }
}

public struct DescribeComponentInputBodyMiddleware: Middleware {
    public let id: String = "DescribeComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentInput>
    public typealias MOutput = OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentOutputError>
}

extension DescribeComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentInput(componentName: \(String(describing: componentName)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DescribeComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct DescribeComponentInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentInput>
    public typealias MOutput = OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentOutputError>
}

public struct DescribeComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeComponentInput>
    public typealias MOutput = OperationOutput<DescribeComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeComponentOutputError>
}

public struct DescribeComponentInput: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        componentName: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.componentName = componentName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeComponentInputBody: Equatable {
    public let resourceGroupName: String?
    public let componentName: String?
}

extension DescribeComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
    }
}

extension DescribeComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeComponentOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeComponentOutputResponse(applicationComponent: \(String(describing: applicationComponent)), resourceList: \(String(describing: resourceList)))"}
}

extension DescribeComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeComponentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponent = output.applicationComponent
            self.resourceList = output.resourceList
        } else {
            self.applicationComponent = nil
            self.resourceList = nil
        }
    }
}

public struct DescribeComponentOutputResponse: Equatable {
    /// <p>Describes a standalone resource or similarly grouped resources that the application is made
    ///          up of.</p>
    public let applicationComponent: ApplicationComponent?
    /// <p>The list of resource ARNs that belong to the component.</p>
    public let resourceList: [String]?

    public init (
        applicationComponent: ApplicationComponent? = nil,
        resourceList: [String]? = nil
    )
    {
        self.applicationComponent = applicationComponent
        self.resourceList = resourceList
    }
}

struct DescribeComponentOutputResponseBody: Equatable {
    public let applicationComponent: ApplicationComponent?
    public let resourceList: [String]?
}

extension DescribeComponentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationComponent = "ApplicationComponent"
        case resourceList = "ResourceList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentDecoded = try containerValues.decodeIfPresent(ApplicationComponent.self, forKey: .applicationComponent)
        applicationComponent = applicationComponentDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceList)
        var resourceListDecoded0:[String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

public struct DescribeLogPatternInputBodyMiddleware: Middleware {
    public let id: String = "DescribeLogPatternInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLogPatternInput>
    public typealias MOutput = OperationOutput<DescribeLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLogPatternOutputError>
}

extension DescribeLogPatternInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLogPatternInput(patternName: \(String(describing: patternName)), patternSetName: \(String(describing: patternSetName)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DescribeLogPatternInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let patternName = patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct DescribeLogPatternInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeLogPatternInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLogPatternInput>
    public typealias MOutput = OperationOutput<DescribeLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLogPatternOutputError>
}

public struct DescribeLogPatternInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeLogPatternInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeLogPatternInput>
    public typealias MOutput = OperationOutput<DescribeLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeLogPatternOutputError>
}

public struct DescribeLogPatternInput: Equatable {
    /// <p>The name of the log pattern.</p>
    public let patternName: String?
    /// <p>The name of the log pattern set.</p>
    public let patternSetName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        patternName: String? = nil,
        patternSetName: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeLogPatternInputBody: Equatable {
    public let resourceGroupName: String?
    public let patternSetName: String?
    public let patternName: String?
}

extension DescribeLogPatternInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternName)
        patternName = patternNameDecoded
    }
}

extension DescribeLogPatternOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLogPatternOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLogPatternOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLogPatternOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeLogPatternOutputResponse(logPattern: \(String(describing: logPattern)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension DescribeLogPatternOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLogPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct DescribeLogPatternOutputResponse: Equatable {
    /// <p>The successfully created log pattern.</p>
    public let logPattern: LogPattern?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        logPattern: LogPattern? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct DescribeLogPatternOutputResponseBody: Equatable {
    public let resourceGroupName: String?
    public let logPattern: LogPattern?
}

extension DescribeLogPatternOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternDecoded = try containerValues.decodeIfPresent(LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
    }
}

public struct DescribeObservationInputBodyMiddleware: Middleware {
    public let id: String = "DescribeObservationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObservationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObservationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObservationInput>
    public typealias MOutput = OperationOutput<DescribeObservationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObservationOutputError>
}

extension DescribeObservationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeObservationInput(observationId: \(String(describing: observationId)))"}
}

extension DescribeObservationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case observationId = "ObservationId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observationId = observationId {
            try encodeContainer.encode(observationId, forKey: .observationId)
        }
    }
}

public struct DescribeObservationInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeObservationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObservationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObservationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObservationInput>
    public typealias MOutput = OperationOutput<DescribeObservationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObservationOutputError>
}

public struct DescribeObservationInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeObservationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeObservationInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeObservationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeObservationInput>
    public typealias MOutput = OperationOutput<DescribeObservationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeObservationOutputError>
}

public struct DescribeObservationInput: Equatable {
    /// <p>The ID of the observation.</p>
    public let observationId: String?

    public init (
        observationId: String? = nil
    )
    {
        self.observationId = observationId
    }
}

struct DescribeObservationInputBody: Equatable {
    public let observationId: String?
}

extension DescribeObservationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case observationId = "ObservationId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .observationId)
        observationId = observationIdDecoded
    }
}

extension DescribeObservationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeObservationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeObservationOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeObservationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeObservationOutputResponse(observation: \(String(describing: observation)))"}
}

extension DescribeObservationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeObservationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.observation = output.observation
        } else {
            self.observation = nil
        }
    }
}

public struct DescribeObservationOutputResponse: Equatable {
    /// <p>Information about the observation.</p>
    public let observation: Observation?

    public init (
        observation: Observation? = nil
    )
    {
        self.observation = observation
    }
}

struct DescribeObservationOutputResponseBody: Equatable {
    public let observation: Observation?
}

extension DescribeObservationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case observation = "Observation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationDecoded = try containerValues.decodeIfPresent(Observation.self, forKey: .observation)
        observation = observationDecoded
    }
}

public struct DescribeProblemInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProblemInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProblemInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProblemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProblemInput>
    public typealias MOutput = OperationOutput<DescribeProblemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProblemOutputError>
}

extension DescribeProblemInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProblemInput(problemId: \(String(describing: problemId)))"}
}

extension DescribeProblemInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case problemId = "ProblemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let problemId = problemId {
            try encodeContainer.encode(problemId, forKey: .problemId)
        }
    }
}

public struct DescribeProblemInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProblemInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProblemInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProblemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProblemInput>
    public typealias MOutput = OperationOutput<DescribeProblemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProblemOutputError>
}

public struct DescribeProblemInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProblemInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProblemInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProblemOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProblemInput>
    public typealias MOutput = OperationOutput<DescribeProblemOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProblemOutputError>
}

public struct DescribeProblemInput: Equatable {
    /// <p>The ID of the problem.</p>
    public let problemId: String?

    public init (
        problemId: String? = nil
    )
    {
        self.problemId = problemId
    }
}

struct DescribeProblemInputBody: Equatable {
    public let problemId: String?
}

extension DescribeProblemInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case problemId = "ProblemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .problemId)
        problemId = problemIdDecoded
    }
}

public struct DescribeProblemObservationsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeProblemObservationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProblemObservationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProblemObservationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProblemObservationsInput>
    public typealias MOutput = OperationOutput<DescribeProblemObservationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProblemObservationsOutputError>
}

extension DescribeProblemObservationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProblemObservationsInput(problemId: \(String(describing: problemId)))"}
}

extension DescribeProblemObservationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case problemId = "ProblemId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let problemId = problemId {
            try encodeContainer.encode(problemId, forKey: .problemId)
        }
    }
}

public struct DescribeProblemObservationsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeProblemObservationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProblemObservationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProblemObservationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProblemObservationsInput>
    public typealias MOutput = OperationOutput<DescribeProblemObservationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProblemObservationsOutputError>
}

public struct DescribeProblemObservationsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeProblemObservationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeProblemObservationsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeProblemObservationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeProblemObservationsInput>
    public typealias MOutput = OperationOutput<DescribeProblemObservationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeProblemObservationsOutputError>
}

public struct DescribeProblemObservationsInput: Equatable {
    /// <p>The ID of the problem.</p>
    public let problemId: String?

    public init (
        problemId: String? = nil
    )
    {
        self.problemId = problemId
    }
}

struct DescribeProblemObservationsInputBody: Equatable {
    public let problemId: String?
}

extension DescribeProblemObservationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case problemId = "ProblemId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .problemId)
        problemId = problemIdDecoded
    }
}

extension DescribeProblemObservationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProblemObservationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProblemObservationsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProblemObservationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProblemObservationsOutputResponse(relatedObservations: \(String(describing: relatedObservations)))"}
}

extension DescribeProblemObservationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProblemObservationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.relatedObservations = output.relatedObservations
        } else {
            self.relatedObservations = nil
        }
    }
}

public struct DescribeProblemObservationsOutputResponse: Equatable {
    /// <p>Observations related to the problem.</p>
    public let relatedObservations: RelatedObservations?

    public init (
        relatedObservations: RelatedObservations? = nil
    )
    {
        self.relatedObservations = relatedObservations
    }
}

struct DescribeProblemObservationsOutputResponseBody: Equatable {
    public let relatedObservations: RelatedObservations?
}

extension DescribeProblemObservationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case relatedObservations = "RelatedObservations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedObservationsDecoded = try containerValues.decodeIfPresent(RelatedObservations.self, forKey: .relatedObservations)
        relatedObservations = relatedObservationsDecoded
    }
}

extension DescribeProblemOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProblemOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProblemOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProblemOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeProblemOutputResponse(problem: \(String(describing: problem)))"}
}

extension DescribeProblemOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProblemOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.problem = output.problem
        } else {
            self.problem = nil
        }
    }
}

public struct DescribeProblemOutputResponse: Equatable {
    /// <p>Information about the problem. </p>
    public let problem: Problem?

    public init (
        problem: Problem? = nil
    )
    {
        self.problem = problem
    }
}

struct DescribeProblemOutputResponseBody: Equatable {
    public let problem: Problem?
}

extension DescribeProblemOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case problem = "Problem"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemDecoded = try containerValues.decodeIfPresent(Problem.self, forKey: .problem)
        problem = problemDecoded
    }
}

public enum FeedbackKey {
    case insightsFeedback
    case sdkUnknown(String)
}

extension FeedbackKey : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FeedbackKey] {
        return [
            .insightsFeedback,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .insightsFeedback: return "INSIGHTS_FEEDBACK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FeedbackKey(rawValue: rawValue) ?? FeedbackKey.sdkUnknown(rawValue)
    }
}

public enum FeedbackValue {
    case notSpecified
    case notUseful
    case useful
    case sdkUnknown(String)
}

extension FeedbackValue : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FeedbackValue] {
        return [
            .notSpecified,
            .notUseful,
            .useful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .notSpecified: return "NOT_SPECIFIED"
        case .notUseful: return "NOT_USEFUL"
        case .useful: return "USEFUL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FeedbackValue(rawValue: rawValue) ?? FeedbackValue.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The server encountered an internal error and is unable to complete the request.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListApplicationsInputBodyMiddleware: Middleware {
    public let id: String = "ListApplicationsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

extension ListApplicationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListApplicationsInputHeadersMiddleware: Middleware {
    public let id: String = "ListApplicationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListApplicationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListApplicationsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListApplicationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListApplicationsInput>
    public typealias MOutput = OperationOutput<ListApplicationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListApplicationsOutputError>
}

public struct ListApplicationsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///          results, make another call with the returned <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListApplicationsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListApplicationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListApplicationsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListApplicationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListApplicationsOutputResponse(applicationInfoList: \(String(describing: applicationInfoList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListApplicationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListApplicationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfoList = output.applicationInfoList
            self.nextToken = output.nextToken
        } else {
            self.applicationInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutputResponse: Equatable {
    /// <p>The list of applications.</p>
    public let applicationInfoList: [ApplicationInfo]?
    /// <p>The token used to retrieve the next page of results. This value is <code>null</code>
    ///          when there are no more results to return. </p>
    public let nextToken: String?

    public init (
        applicationInfoList: [ApplicationInfo]? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationInfoList = applicationInfoList
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputResponseBody: Equatable {
    public let applicationInfoList: [ApplicationInfo]?
    public let nextToken: String?
}

extension ListApplicationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationInfoList = "ApplicationInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoListContainer = try containerValues.decodeIfPresent([ApplicationInfo?].self, forKey: .applicationInfoList)
        var applicationInfoListDecoded0:[ApplicationInfo]? = nil
        if let applicationInfoListContainer = applicationInfoListContainer {
            applicationInfoListDecoded0 = [ApplicationInfo]()
            for structure0 in applicationInfoListContainer {
                if let structure0 = structure0 {
                    applicationInfoListDecoded0?.append(structure0)
                }
            }
        }
        applicationInfoList = applicationInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListComponentsInputBodyMiddleware: Middleware {
    public let id: String = "ListComponentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

extension ListComponentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension ListComponentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct ListComponentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListComponentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

public struct ListComponentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListComponentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListComponentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListComponentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListComponentsInput>
    public typealias MOutput = OperationOutput<ListComponentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListComponentsOutputError>
}

public struct ListComponentsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///          results, make another call with the returned <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListComponentsInputBody: Equatable {
    public let resourceGroupName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListComponentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListComponentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListComponentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListComponentsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListComponentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListComponentsOutputResponse(applicationComponentList: \(String(describing: applicationComponentList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListComponentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListComponentsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentList = output.applicationComponentList
            self.nextToken = output.nextToken
        } else {
            self.applicationComponentList = nil
            self.nextToken = nil
        }
    }
}

public struct ListComponentsOutputResponse: Equatable {
    /// <p>The list of application components.</p>
    public let applicationComponentList: [ApplicationComponent]?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?

    public init (
        applicationComponentList: [ApplicationComponent]? = nil,
        nextToken: String? = nil
    )
    {
        self.applicationComponentList = applicationComponentList
        self.nextToken = nextToken
    }
}

struct ListComponentsOutputResponseBody: Equatable {
    public let applicationComponentList: [ApplicationComponent]?
    public let nextToken: String?
}

extension ListComponentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationComponentList = "ApplicationComponentList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentListContainer = try containerValues.decodeIfPresent([ApplicationComponent?].self, forKey: .applicationComponentList)
        var applicationComponentListDecoded0:[ApplicationComponent]? = nil
        if let applicationComponentListContainer = applicationComponentListContainer {
            applicationComponentListDecoded0 = [ApplicationComponent]()
            for structure0 in applicationComponentListContainer {
                if let structure0 = structure0 {
                    applicationComponentListDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentList = applicationComponentListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListConfigurationHistoryInputBodyMiddleware: Middleware {
    public let id: String = "ListConfigurationHistoryInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationHistoryInput>
    public typealias MOutput = OperationOutput<ListConfigurationHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationHistoryOutputError>
}

extension ListConfigurationHistoryInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationHistoryInput(endTime: \(String(describing: endTime)), eventStatus: \(String(describing: eventStatus)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceGroupName: \(String(describing: resourceGroupName)), startTime: \(String(describing: startTime)))"}
}

extension ListConfigurationHistoryInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case eventStatus = "EventStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let eventStatus = eventStatus {
            try encodeContainer.encode(eventStatus.rawValue, forKey: .eventStatus)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct ListConfigurationHistoryInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationHistoryInput>
    public typealias MOutput = OperationOutput<ListConfigurationHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationHistoryOutputError>
}

public struct ListConfigurationHistoryInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationHistoryInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationHistoryInput>
    public typealias MOutput = OperationOutput<ListConfigurationHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationHistoryOutputError>
}

public struct ListConfigurationHistoryInput: Equatable {
    /// <p>The end time of the event.</p>
    public let endTime: Date?
    /// <p>The status of the configuration update event. Possible values include INFO, WARN, and ERROR.</p>
    public let eventStatus: ConfigurationEventStatus?
    /// <p> The maximum number of results returned by <code>ListConfigurationHistory</code> in
    ///          paginated output. When this parameter is used, <code>ListConfigurationHistory</code>
    ///          returns only <code>MaxResults</code> in a single page along with a <code>NextToken</code>
    ///          response element. The remaining results of the initial request can be seen by sending
    ///          another <code>ListConfigurationHistory</code> request with the returned
    ///             <code>NextToken</code> value. If this parameter is not used, then
    ///             <code>ListConfigurationHistory</code> returns all results. </p>
    public let maxResults: Int?
    /// <p>The <code>NextToken</code> value returned from a previous paginated <code>ListConfigurationHistory</code> request where
    ///          <code>MaxResults</code> was used and the results exceeded the value of that parameter. Pagination
    ///          continues from the end of the previous results that returned the <code>NextToken</code> value. This
    ///          value is <code>null</code> when there are no more results to return.</p>
    public let nextToken: String?
    /// <p>Resource group to which the application belongs. </p>
    public let resourceGroupName: String?
    /// <p>The start time of the event. </p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        eventStatus: ConfigurationEventStatus? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceGroupName: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.eventStatus = eventStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
    }
}

struct ListConfigurationHistoryInputBody: Equatable {
    public let resourceGroupName: String?
    public let startTime: Date?
    public let endTime: Date?
    public let eventStatus: ConfigurationEventStatus?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListConfigurationHistoryInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case eventStatus = "EventStatus"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let eventStatusDecoded = try containerValues.decodeIfPresent(ConfigurationEventStatus.self, forKey: .eventStatus)
        eventStatus = eventStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListConfigurationHistoryOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationHistoryOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationHistoryOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationHistoryOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationHistoryOutputResponse(eventList: \(String(describing: eventList)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationHistoryOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListConfigurationHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventList = output.eventList
            self.nextToken = output.nextToken
        } else {
            self.eventList = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfigurationHistoryOutputResponse: Equatable {
    /// <p> The list of configuration events and their corresponding details. </p>
    public let eventList: [ConfigurationEvent]?
    /// <p>The <code>NextToken</code> value to include in a future
    ///             <code>ListConfigurationHistory</code> request. When the results of a
    ///             <code>ListConfigurationHistory</code> request exceed <code>MaxResults</code>, this value
    ///          can be used to retrieve the next page of results. This value is <code>null</code> when
    ///          there are no more results to return.</p>
    public let nextToken: String?

    public init (
        eventList: [ConfigurationEvent]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventList = eventList
        self.nextToken = nextToken
    }
}

struct ListConfigurationHistoryOutputResponseBody: Equatable {
    public let eventList: [ConfigurationEvent]?
    public let nextToken: String?
}

extension ListConfigurationHistoryOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventList = "EventList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventListContainer = try containerValues.decodeIfPresent([ConfigurationEvent?].self, forKey: .eventList)
        var eventListDecoded0:[ConfigurationEvent]? = nil
        if let eventListContainer = eventListContainer {
            eventListDecoded0 = [ConfigurationEvent]()
            for structure0 in eventListContainer {
                if let structure0 = structure0 {
                    eventListDecoded0?.append(structure0)
                }
            }
        }
        eventList = eventListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLogPatternSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListLogPatternSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogPatternSetsInput>
    public typealias MOutput = OperationOutput<ListLogPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogPatternSetsOutputError>
}

extension ListLogPatternSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLogPatternSetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension ListLogPatternSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct ListLogPatternSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLogPatternSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogPatternSetsInput>
    public typealias MOutput = OperationOutput<ListLogPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogPatternSetsOutputError>
}

public struct ListLogPatternSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLogPatternSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogPatternSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogPatternSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogPatternSetsInput>
    public typealias MOutput = OperationOutput<ListLogPatternSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogPatternSetsOutputError>
}

public struct ListLogPatternSetsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///          results, make another call with the returned <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternSetsInputBody: Equatable {
    public let resourceGroupName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListLogPatternSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogPatternSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLogPatternSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLogPatternSetsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLogPatternSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLogPatternSetsOutputResponse(logPatternSets: \(String(describing: logPatternSets)), nextToken: \(String(describing: nextToken)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension ListLogPatternSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLogPatternSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPatternSets = output.logPatternSets
            self.nextToken = output.nextToken
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPatternSets = nil
            self.nextToken = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListLogPatternSetsOutputResponse: Equatable {
    /// <p>The list of log pattern sets.</p>
    public let logPatternSets: [String]?
    /// <p>The token used to retrieve the next page of results. This value is <code>null</code>
    ///          when there are no more results to return. </p>
    public let nextToken: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        logPatternSets: [String]? = nil,
        nextToken: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.logPatternSets = logPatternSets
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternSetsOutputResponseBody: Equatable {
    public let resourceGroupName: String?
    public let logPatternSets: [String]?
    public let nextToken: String?
}

extension ListLogPatternSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logPatternSets = "LogPatternSets"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternSetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .logPatternSets)
        var logPatternSetsDecoded0:[String]? = nil
        if let logPatternSetsContainer = logPatternSetsContainer {
            logPatternSetsDecoded0 = [String]()
            for string0 in logPatternSetsContainer {
                if let string0 = string0 {
                    logPatternSetsDecoded0?.append(string0)
                }
            }
        }
        logPatternSets = logPatternSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListLogPatternsInputBodyMiddleware: Middleware {
    public let id: String = "ListLogPatternsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogPatternsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogPatternsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogPatternsInput>
    public typealias MOutput = OperationOutput<ListLogPatternsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogPatternsOutputError>
}

extension ListLogPatternsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLogPatternsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), patternSetName: \(String(describing: patternSetName)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension ListLogPatternsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let patternSetName = patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct ListLogPatternsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLogPatternsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogPatternsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogPatternsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogPatternsInput>
    public typealias MOutput = OperationOutput<ListLogPatternsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogPatternsOutputError>
}

public struct ListLogPatternsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLogPatternsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLogPatternsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLogPatternsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLogPatternsInput>
    public typealias MOutput = OperationOutput<ListLogPatternsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLogPatternsOutputError>
}

public struct ListLogPatternsInput: Equatable {
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///          results, make another call with the returned <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The name of the log pattern set.</p>
    public let patternSetName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        patternSetName: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.patternSetName = patternSetName
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternsInputBody: Equatable {
    public let resourceGroupName: String?
    public let patternSetName: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListLogPatternsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case patternSetName = "PatternSetName"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLogPatternsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLogPatternsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLogPatternsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLogPatternsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLogPatternsOutputResponse(logPatterns: \(String(describing: logPatterns)), nextToken: \(String(describing: nextToken)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension ListLogPatternsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListLogPatternsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPatterns = output.logPatterns
            self.nextToken = output.nextToken
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPatterns = nil
            self.nextToken = nil
            self.resourceGroupName = nil
        }
    }
}

public struct ListLogPatternsOutputResponse: Equatable {
    /// <p>The list of log patterns.</p>
    public let logPatterns: [LogPattern]?
    /// <p>The token used to retrieve the next page of results. This value is <code>null</code>
    ///          when there are no more results to return. </p>
    public let nextToken: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        logPatterns: [LogPattern]? = nil,
        nextToken: String? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.logPatterns = logPatterns
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
    }
}

struct ListLogPatternsOutputResponseBody: Equatable {
    public let resourceGroupName: String?
    public let logPatterns: [LogPattern]?
    public let nextToken: String?
}

extension ListLogPatternsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logPatterns = "LogPatterns"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternsContainer = try containerValues.decodeIfPresent([LogPattern?].self, forKey: .logPatterns)
        var logPatternsDecoded0:[LogPattern]? = nil
        if let logPatternsContainer = logPatternsContainer {
            logPatternsDecoded0 = [LogPattern]()
            for structure0 in logPatternsContainer {
                if let structure0 = structure0 {
                    logPatternsDecoded0?.append(structure0)
                }
            }
        }
        logPatterns = logPatternsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListProblemsInputBodyMiddleware: Middleware {
    public let id: String = "ListProblemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProblemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProblemsInput>
    public typealias MOutput = OperationOutput<ListProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProblemsOutputError>
}

extension ListProblemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProblemsInput(endTime: \(String(describing: endTime)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceGroupName: \(String(describing: resourceGroupName)), startTime: \(String(describing: startTime)))"}
}

extension ListProblemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
    }
}

public struct ListProblemsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProblemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProblemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProblemsInput>
    public typealias MOutput = OperationOutput<ListProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProblemsOutputError>
}

public struct ListProblemsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProblemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProblemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProblemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProblemsInput>
    public typealias MOutput = OperationOutput<ListProblemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProblemsOutputError>
}

public struct ListProblemsInput: Equatable {
    /// <p>The time when the problem ended, in epoch seconds. If not specified, problems within the
    ///          past seven days are returned.</p>
    public let endTime: Date?
    /// <p>The maximum number of results to return in a single call. To retrieve the remaining
    ///          results, make another call with the returned <code>NextToken</code> value.</p>
    public let maxResults: Int?
    /// <p>The token to request the next page of results.</p>
    public let nextToken: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?
    /// <p>The time when the problem was detected, in epoch
    ///          seconds. If you don't specify a time frame for the request, problems within the past seven days are returned.</p>
    public let startTime: Date?

    public init (
        endTime: Date? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceGroupName: String? = nil,
        startTime: Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceGroupName = resourceGroupName
        self.startTime = startTime
    }
}

struct ListProblemsInputBody: Equatable {
    public let resourceGroupName: String?
    public let startTime: Date?
    public let endTime: Date?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListProblemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceGroupName = "ResourceGroupName"
        case startTime = "StartTime"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProblemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProblemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProblemsOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProblemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProblemsOutputResponse(nextToken: \(String(describing: nextToken)), problemList: \(String(describing: problemList)))"}
}

extension ListProblemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProblemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.problemList = output.problemList
        } else {
            self.nextToken = nil
            self.problemList = nil
        }
    }
}

public struct ListProblemsOutputResponse: Equatable {
    /// <p>The token used to retrieve the next page of results. This value is <code>null</code>
    ///          when there are no more results to return. </p>
    public let nextToken: String?
    /// <p>The list of problems. </p>
    public let problemList: [Problem]?

    public init (
        nextToken: String? = nil,
        problemList: [Problem]? = nil
    )
    {
        self.nextToken = nextToken
        self.problemList = problemList
    }
}

struct ListProblemsOutputResponseBody: Equatable {
    public let problemList: [Problem]?
    public let nextToken: String?
}

extension ListProblemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case problemList = "ProblemList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let problemListContainer = try containerValues.decodeIfPresent([Problem?].self, forKey: .problemList)
        var problemListDecoded0:[Problem]? = nil
        if let problemListContainer = problemListContainer {
            problemListDecoded0 = [Problem]()
            for structure0 in problemListContainer {
                if let structure0 = structure0 {
                    problemListDecoded0?.append(structure0)
                }
            }
        }
        problemList = problemListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceARN: \(String(describing: resourceARN)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application that you want to retrieve tag
    ///          information for.</p>
    public let resourceARN: String?

    public init (
        resourceARN: String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceARN: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>An array that lists all the tags that are associated with the application. Each tag
    ///          consists of a required tag key (<code>Key</code>) and an associated tag value
    ///          (<code>Value</code>).</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum LogFilter {
    case error
    case info
    case warn
    case sdkUnknown(String)
}

extension LogFilter : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogFilter] {
        return [
            .error,
            .info,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .error: return "ERROR"
        case .info: return "INFO"
        case .warn: return "WARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogFilter(rawValue: rawValue) ?? LogFilter.sdkUnknown(rawValue)
    }
}

extension LogPattern: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let patternSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension LogPattern: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LogPattern(pattern: \(String(describing: pattern)), patternName: \(String(describing: patternName)), patternSetName: \(String(describing: patternSetName)), rank: \(String(describing: rank)))"}
}

/// <p>An object that defines the log patterns that belongs to a <code>LogPatternSet</code>.</p>
public struct LogPattern: Equatable {
    /// <p>A regular expression that defines the log pattern. A log pattern can contain as many as 50 characters, and it cannot
    ///          be empty. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.</p>
    public let pattern: String?
    /// <p>The name of the log pattern. A log pattern name can contain as many as 50 characters, and it cannot
    ///          be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.</p>
    public let patternName: String?
    /// <p>The name of the log pattern. A log pattern name can contain as many as 30 characters, and it cannot
    ///          be empty. The characters can be Unicode letters, digits, or one of the following symbols: period, dash, underscore.</p>
    public let patternSetName: String?
    /// <p>Rank of the log pattern. Must be a value between <code>1</code> and <code>1,000,000</code>. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank <code>1</code> will be the first to get matched to a log line. A pattern of rank <code>1,000,000</code> will be last to get matched. When you configure custom log patterns from the console, a <code>Low</code> severity pattern translates to a <code>750,000</code> rank. A <code>Medium</code> severity pattern translates to a <code>500,000</code> rank. And a <code>High</code> severity pattern translates to a <code>250,000</code> rank.
    ///          Rank values less than <code>1</code> or greater than <code>1,000,000</code> are reserved for AWS-provided patterns.
    ///       </p>
    public let rank: Int

    public init (
        pattern: String? = nil,
        patternName: String? = nil,
        patternSetName: String? = nil,
        rank: Int = 0
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
    }
}

extension Observation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchEventDetailType = "CloudWatchEventDetailType"
        case cloudWatchEventId = "CloudWatchEventId"
        case cloudWatchEventSource = "CloudWatchEventSource"
        case codeDeployApplication = "CodeDeployApplication"
        case codeDeployDeploymentGroup = "CodeDeployDeploymentGroup"
        case codeDeployDeploymentId = "CodeDeployDeploymentId"
        case codeDeployInstanceGroupId = "CodeDeployInstanceGroupId"
        case codeDeployState = "CodeDeployState"
        case ebsCause = "EbsCause"
        case ebsEvent = "EbsEvent"
        case ebsRequestId = "EbsRequestId"
        case ebsResult = "EbsResult"
        case ec2State = "Ec2State"
        case endTime = "EndTime"
        case healthEventArn = "HealthEventArn"
        case healthEventDescription = "HealthEventDescription"
        case healthEventTypeCategory = "HealthEventTypeCategory"
        case healthEventTypeCode = "HealthEventTypeCode"
        case healthService = "HealthService"
        case id = "Id"
        case lineTime = "LineTime"
        case logFilter = "LogFilter"
        case logGroup = "LogGroup"
        case logText = "LogText"
        case metricName = "MetricName"
        case metricNamespace = "MetricNamespace"
        case rdsEventCategories = "RdsEventCategories"
        case rdsEventMessage = "RdsEventMessage"
        case s3EventName = "S3EventName"
        case sourceARN = "SourceARN"
        case sourceType = "SourceType"
        case startTime = "StartTime"
        case statesArn = "StatesArn"
        case statesExecutionArn = "StatesExecutionArn"
        case statesInput = "StatesInput"
        case statesStatus = "StatesStatus"
        case unit = "Unit"
        case value = "Value"
        case xRayErrorPercent = "XRayErrorPercent"
        case xRayFaultPercent = "XRayFaultPercent"
        case xRayNodeName = "XRayNodeName"
        case xRayNodeType = "XRayNodeType"
        case xRayRequestAverageLatency = "XRayRequestAverageLatency"
        case xRayRequestCount = "XRayRequestCount"
        case xRayThrottlePercent = "XRayThrottlePercent"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchEventDetailType = cloudWatchEventDetailType {
            try encodeContainer.encode(cloudWatchEventDetailType, forKey: .cloudWatchEventDetailType)
        }
        if let cloudWatchEventId = cloudWatchEventId {
            try encodeContainer.encode(cloudWatchEventId, forKey: .cloudWatchEventId)
        }
        if let cloudWatchEventSource = cloudWatchEventSource {
            try encodeContainer.encode(cloudWatchEventSource.rawValue, forKey: .cloudWatchEventSource)
        }
        if let codeDeployApplication = codeDeployApplication {
            try encodeContainer.encode(codeDeployApplication, forKey: .codeDeployApplication)
        }
        if let codeDeployDeploymentGroup = codeDeployDeploymentGroup {
            try encodeContainer.encode(codeDeployDeploymentGroup, forKey: .codeDeployDeploymentGroup)
        }
        if let codeDeployDeploymentId = codeDeployDeploymentId {
            try encodeContainer.encode(codeDeployDeploymentId, forKey: .codeDeployDeploymentId)
        }
        if let codeDeployInstanceGroupId = codeDeployInstanceGroupId {
            try encodeContainer.encode(codeDeployInstanceGroupId, forKey: .codeDeployInstanceGroupId)
        }
        if let codeDeployState = codeDeployState {
            try encodeContainer.encode(codeDeployState, forKey: .codeDeployState)
        }
        if let ebsCause = ebsCause {
            try encodeContainer.encode(ebsCause, forKey: .ebsCause)
        }
        if let ebsEvent = ebsEvent {
            try encodeContainer.encode(ebsEvent, forKey: .ebsEvent)
        }
        if let ebsRequestId = ebsRequestId {
            try encodeContainer.encode(ebsRequestId, forKey: .ebsRequestId)
        }
        if let ebsResult = ebsResult {
            try encodeContainer.encode(ebsResult, forKey: .ebsResult)
        }
        if let ec2State = ec2State {
            try encodeContainer.encode(ec2State, forKey: .ec2State)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let healthEventArn = healthEventArn {
            try encodeContainer.encode(healthEventArn, forKey: .healthEventArn)
        }
        if let healthEventDescription = healthEventDescription {
            try encodeContainer.encode(healthEventDescription, forKey: .healthEventDescription)
        }
        if let healthEventTypeCategory = healthEventTypeCategory {
            try encodeContainer.encode(healthEventTypeCategory, forKey: .healthEventTypeCategory)
        }
        if let healthEventTypeCode = healthEventTypeCode {
            try encodeContainer.encode(healthEventTypeCode, forKey: .healthEventTypeCode)
        }
        if let healthService = healthService {
            try encodeContainer.encode(healthService, forKey: .healthService)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lineTime = lineTime {
            try encodeContainer.encode(lineTime.timeIntervalSince1970, forKey: .lineTime)
        }
        if let logFilter = logFilter {
            try encodeContainer.encode(logFilter.rawValue, forKey: .logFilter)
        }
        if let logGroup = logGroup {
            try encodeContainer.encode(logGroup, forKey: .logGroup)
        }
        if let logText = logText {
            try encodeContainer.encode(logText, forKey: .logText)
        }
        if let metricName = metricName {
            try encodeContainer.encode(metricName, forKey: .metricName)
        }
        if let metricNamespace = metricNamespace {
            try encodeContainer.encode(metricNamespace, forKey: .metricNamespace)
        }
        if let rdsEventCategories = rdsEventCategories {
            try encodeContainer.encode(rdsEventCategories, forKey: .rdsEventCategories)
        }
        if let rdsEventMessage = rdsEventMessage {
            try encodeContainer.encode(rdsEventMessage, forKey: .rdsEventMessage)
        }
        if let s3EventName = s3EventName {
            try encodeContainer.encode(s3EventName, forKey: .s3EventName)
        }
        if let sourceARN = sourceARN {
            try encodeContainer.encode(sourceARN, forKey: .sourceARN)
        }
        if let sourceType = sourceType {
            try encodeContainer.encode(sourceType, forKey: .sourceType)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let statesArn = statesArn {
            try encodeContainer.encode(statesArn, forKey: .statesArn)
        }
        if let statesExecutionArn = statesExecutionArn {
            try encodeContainer.encode(statesExecutionArn, forKey: .statesExecutionArn)
        }
        if let statesInput = statesInput {
            try encodeContainer.encode(statesInput, forKey: .statesInput)
        }
        if let statesStatus = statesStatus {
            try encodeContainer.encode(statesStatus, forKey: .statesStatus)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let xRayErrorPercent = xRayErrorPercent {
            try encodeContainer.encode(xRayErrorPercent, forKey: .xRayErrorPercent)
        }
        if let xRayFaultPercent = xRayFaultPercent {
            try encodeContainer.encode(xRayFaultPercent, forKey: .xRayFaultPercent)
        }
        if let xRayNodeName = xRayNodeName {
            try encodeContainer.encode(xRayNodeName, forKey: .xRayNodeName)
        }
        if let xRayNodeType = xRayNodeType {
            try encodeContainer.encode(xRayNodeType, forKey: .xRayNodeType)
        }
        if let xRayRequestAverageLatency = xRayRequestAverageLatency {
            try encodeContainer.encode(xRayRequestAverageLatency, forKey: .xRayRequestAverageLatency)
        }
        if let xRayRequestCount = xRayRequestCount {
            try encodeContainer.encode(xRayRequestCount, forKey: .xRayRequestCount)
        }
        if let xRayThrottlePercent = xRayThrottlePercent {
            try encodeContainer.encode(xRayThrottlePercent, forKey: .xRayThrottlePercent)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let sourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceType)
        sourceType = sourceTypeDecoded
        let sourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceARN)
        sourceARN = sourceARNDecoded
        let logGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroup)
        logGroup = logGroupDecoded
        let lineTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lineTime)
        lineTime = lineTimeDecoded
        let logTextDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logText)
        logText = logTextDecoded
        let logFilterDecoded = try containerValues.decodeIfPresent(LogFilter.self, forKey: .logFilter)
        logFilter = logFilterDecoded
        let metricNamespaceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricNamespace)
        metricNamespace = metricNamespaceDecoded
        let metricNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .metricName)
        metricName = metricNameDecoded
        let unitDecoded = try containerValues.decodeIfPresent(String.self, forKey: .unit)
        unit = unitDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .value)
        value = valueDecoded
        let cloudWatchEventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchEventId)
        cloudWatchEventId = cloudWatchEventIdDecoded
        let cloudWatchEventSourceDecoded = try containerValues.decodeIfPresent(CloudWatchEventSource.self, forKey: .cloudWatchEventSource)
        cloudWatchEventSource = cloudWatchEventSourceDecoded
        let cloudWatchEventDetailTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudWatchEventDetailType)
        cloudWatchEventDetailType = cloudWatchEventDetailTypeDecoded
        let healthEventArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthEventArn)
        healthEventArn = healthEventArnDecoded
        let healthServiceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthService)
        healthService = healthServiceDecoded
        let healthEventTypeCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthEventTypeCode)
        healthEventTypeCode = healthEventTypeCodeDecoded
        let healthEventTypeCategoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthEventTypeCategory)
        healthEventTypeCategory = healthEventTypeCategoryDecoded
        let healthEventDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .healthEventDescription)
        healthEventDescription = healthEventDescriptionDecoded
        let codeDeployDeploymentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeDeployDeploymentId)
        codeDeployDeploymentId = codeDeployDeploymentIdDecoded
        let codeDeployDeploymentGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeDeployDeploymentGroup)
        codeDeployDeploymentGroup = codeDeployDeploymentGroupDecoded
        let codeDeployStateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeDeployState)
        codeDeployState = codeDeployStateDecoded
        let codeDeployApplicationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeDeployApplication)
        codeDeployApplication = codeDeployApplicationDecoded
        let codeDeployInstanceGroupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeDeployInstanceGroupId)
        codeDeployInstanceGroupId = codeDeployInstanceGroupIdDecoded
        let ec2StateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ec2State)
        ec2State = ec2StateDecoded
        let rdsEventCategoriesDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rdsEventCategories)
        rdsEventCategories = rdsEventCategoriesDecoded
        let rdsEventMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rdsEventMessage)
        rdsEventMessage = rdsEventMessageDecoded
        let s3EventNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3EventName)
        s3EventName = s3EventNameDecoded
        let statesExecutionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statesExecutionArn)
        statesExecutionArn = statesExecutionArnDecoded
        let statesArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statesArn)
        statesArn = statesArnDecoded
        let statesStatusDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statesStatus)
        statesStatus = statesStatusDecoded
        let statesInputDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statesInput)
        statesInput = statesInputDecoded
        let ebsEventDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsEvent)
        ebsEvent = ebsEventDecoded
        let ebsResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsResult)
        ebsResult = ebsResultDecoded
        let ebsCauseDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsCause)
        ebsCause = ebsCauseDecoded
        let ebsRequestIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ebsRequestId)
        ebsRequestId = ebsRequestIdDecoded
        let xRayFaultPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .xRayFaultPercent)
        xRayFaultPercent = xRayFaultPercentDecoded
        let xRayThrottlePercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .xRayThrottlePercent)
        xRayThrottlePercent = xRayThrottlePercentDecoded
        let xRayErrorPercentDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .xRayErrorPercent)
        xRayErrorPercent = xRayErrorPercentDecoded
        let xRayRequestCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .xRayRequestCount)
        xRayRequestCount = xRayRequestCountDecoded
        let xRayRequestAverageLatencyDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .xRayRequestAverageLatency)
        xRayRequestAverageLatency = xRayRequestAverageLatencyDecoded
        let xRayNodeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .xRayNodeName)
        xRayNodeName = xRayNodeNameDecoded
        let xRayNodeTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .xRayNodeType)
        xRayNodeType = xRayNodeTypeDecoded
    }
}

extension Observation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Observation(cloudWatchEventDetailType: \(String(describing: cloudWatchEventDetailType)), cloudWatchEventId: \(String(describing: cloudWatchEventId)), cloudWatchEventSource: \(String(describing: cloudWatchEventSource)), codeDeployApplication: \(String(describing: codeDeployApplication)), codeDeployDeploymentGroup: \(String(describing: codeDeployDeploymentGroup)), codeDeployDeploymentId: \(String(describing: codeDeployDeploymentId)), codeDeployInstanceGroupId: \(String(describing: codeDeployInstanceGroupId)), codeDeployState: \(String(describing: codeDeployState)), ebsCause: \(String(describing: ebsCause)), ebsEvent: \(String(describing: ebsEvent)), ebsRequestId: \(String(describing: ebsRequestId)), ebsResult: \(String(describing: ebsResult)), ec2State: \(String(describing: ec2State)), endTime: \(String(describing: endTime)), healthEventArn: \(String(describing: healthEventArn)), healthEventDescription: \(String(describing: healthEventDescription)), healthEventTypeCategory: \(String(describing: healthEventTypeCategory)), healthEventTypeCode: \(String(describing: healthEventTypeCode)), healthService: \(String(describing: healthService)), id: \(String(describing: id)), lineTime: \(String(describing: lineTime)), logFilter: \(String(describing: logFilter)), logGroup: \(String(describing: logGroup)), logText: \(String(describing: logText)), metricName: \(String(describing: metricName)), metricNamespace: \(String(describing: metricNamespace)), rdsEventCategories: \(String(describing: rdsEventCategories)), rdsEventMessage: \(String(describing: rdsEventMessage)), s3EventName: \(String(describing: s3EventName)), sourceARN: \(String(describing: sourceARN)), sourceType: \(String(describing: sourceType)), startTime: \(String(describing: startTime)), statesArn: \(String(describing: statesArn)), statesExecutionArn: \(String(describing: statesExecutionArn)), statesInput: \(String(describing: statesInput)), statesStatus: \(String(describing: statesStatus)), unit: \(String(describing: unit)), value: \(String(describing: value)), xRayErrorPercent: \(String(describing: xRayErrorPercent)), xRayFaultPercent: \(String(describing: xRayFaultPercent)), xRayNodeName: \(String(describing: xRayNodeName)), xRayNodeType: \(String(describing: xRayNodeType)), xRayRequestAverageLatency: \(String(describing: xRayRequestAverageLatency)), xRayRequestCount: \(String(describing: xRayRequestCount)), xRayThrottlePercent: \(String(describing: xRayThrottlePercent)))"}
}

/// <p>Describes an anomaly or error with the application.</p>
public struct Observation: Equatable {
    /// <p> The detail type of the CloudWatch Event-based observation, for example, <code>EC2
    ///             Instance State-change Notification</code>. </p>
    public let cloudWatchEventDetailType: String?
    /// <p> The ID of the CloudWatch Event-based observation related to the detected problem. </p>
    public let cloudWatchEventId: String?
    /// <p> The source of the CloudWatch Event. </p>
    public let cloudWatchEventSource: CloudWatchEventSource?
    /// <p>
    ///          The CodeDeploy application to which the deployment belongs.
    ///       </p>
    public let codeDeployApplication: String?
    /// <p>
    ///          The deployment group to which the CodeDeploy deployment belongs.
    ///       </p>
    public let codeDeployDeploymentGroup: String?
    /// <p> The deployment ID of the CodeDeploy-based observation related to the detected problem. </p>
    public let codeDeployDeploymentId: String?
    /// <p>
    ///          The instance group to which the CodeDeploy instance belongs.
    ///       </p>
    public let codeDeployInstanceGroupId: String?
    /// <p>
    ///          The status of the CodeDeploy deployment, for example <code>SUCCESS</code> or <code> FAILURE</code>.
    ///       </p>
    public let codeDeployState: String?
    /// <p>
    ///          The cause of an EBS CloudWatch event.
    ///       </p>
    public let ebsCause: String?
    /// <p>
    ///          The type of EBS CloudWatch event, such as <code>createVolume</code>, <code>deleteVolume</code> or <code>attachVolume</code>.
    ///       </p>
    public let ebsEvent: String?
    /// <p>
    ///             The request ID of an EBS CloudWatch event.
    ///          </p>
    public let ebsRequestId: String?
    /// <p>
    ///          The result of an EBS CloudWatch event, such as <code>failed</code> or <code>succeeded</code>.
    ///       </p>
    public let ebsResult: String?
    /// <p>
    ///          The state of the instance, such as <code>STOPPING</code> or <code>TERMINATING</code>.
    ///       </p>
    public let ec2State: String?
    /// <p>The time when the observation ended, in epoch seconds.</p>
    public let endTime: Date?
    /// <p> The Amazon Resource Name (ARN) of the AWS Health Event-based observation.</p>
    public let healthEventArn: String?
    /// <p> The description of the AWS Health event provided by the service, such as Amazon EC2. </p>
    public let healthEventDescription: String?
    /// <p> The category of the AWS Health event, such as <code>issue</code>. </p>
    public let healthEventTypeCategory: String?
    /// <p> The type of the AWS Health event, for example,
    ///             <code>AWS_EC2_POWER_CONNECTIVITY_ISSUE</code>. </p>
    public let healthEventTypeCode: String?
    /// <p> The service to which the AWS Health Event belongs, such as EC2. </p>
    public let healthService: String?
    /// <p>The ID of the observation type.</p>
    public let id: String?
    /// <p>The timestamp in the CloudWatch Logs that specifies when the matched line occurred.</p>
    public let lineTime: Date?
    /// <p>The log filter of the observation.</p>
    public let logFilter: LogFilter?
    /// <p>The log group name.</p>
    public let logGroup: String?
    /// <p>The log text of the observation.</p>
    public let logText: String?
    /// <p>The name of the observation metric.</p>
    public let metricName: String?
    /// <p>The namespace of the observation metric.</p>
    public let metricNamespace: String?
    /// <p>
    ///          The category of an RDS event.
    ///       </p>
    public let rdsEventCategories: String?
    /// <p>
    ///          The message of an RDS event.
    ///       </p>
    public let rdsEventMessage: String?
    /// <p>
    ///          The name of the S3 CloudWatch Event-based observation.
    ///       </p>
    public let s3EventName: String?
    /// <p>The source resource ARN of the observation.</p>
    public let sourceARN: String?
    /// <p>The source type of the observation.</p>
    public let sourceType: String?
    /// <p>The time when the observation was  first detected, in epoch seconds.</p>
    public let startTime: Date?
    /// <p>
    ///          The Amazon Resource Name (ARN)  of the step function-based observation.
    ///       </p>
    public let statesArn: String?
    /// <p>
    ///          The Amazon Resource Name (ARN) of the step function execution-based observation.
    ///       </p>
    public let statesExecutionArn: String?
    /// <p>
    ///          The input to the step function-based observation.
    ///       </p>
    public let statesInput: String?
    /// <p>
    ///          The status of the step function-related observation.
    ///       </p>
    public let statesStatus: String?
    /// <p>The unit of the source observation metric.</p>
    public let unit: String?
    /// <p>The value of the source observation metric.</p>
    public let value: Double?
    /// <p>
    ///          The X-Ray request error percentage for this node.
    ///       </p>
    public let xRayErrorPercent: Int?
    /// <p>
    ///          The X-Ray request fault percentage for this node.
    ///       </p>
    public let xRayFaultPercent: Int?
    /// <p>
    ///          The name of the X-Ray node.
    ///       </p>
    public let xRayNodeName: String?
    /// <p>
    ///          The type of the  X-Ray node.      </p>
    public let xRayNodeType: String?
    /// <p>
    ///          The X-Ray node request average latency for this node.
    ///       </p>
    public let xRayRequestAverageLatency: Int?
    /// <p>
    ///          The X-Ray request count for this node.
    ///       </p>
    public let xRayRequestCount: Int?
    /// <p>
    ///          The X-Ray request throttle percentage for this node.
    ///       </p>
    public let xRayThrottlePercent: Int?

    public init (
        cloudWatchEventDetailType: String? = nil,
        cloudWatchEventId: String? = nil,
        cloudWatchEventSource: CloudWatchEventSource? = nil,
        codeDeployApplication: String? = nil,
        codeDeployDeploymentGroup: String? = nil,
        codeDeployDeploymentId: String? = nil,
        codeDeployInstanceGroupId: String? = nil,
        codeDeployState: String? = nil,
        ebsCause: String? = nil,
        ebsEvent: String? = nil,
        ebsRequestId: String? = nil,
        ebsResult: String? = nil,
        ec2State: String? = nil,
        endTime: Date? = nil,
        healthEventArn: String? = nil,
        healthEventDescription: String? = nil,
        healthEventTypeCategory: String? = nil,
        healthEventTypeCode: String? = nil,
        healthService: String? = nil,
        id: String? = nil,
        lineTime: Date? = nil,
        logFilter: LogFilter? = nil,
        logGroup: String? = nil,
        logText: String? = nil,
        metricName: String? = nil,
        metricNamespace: String? = nil,
        rdsEventCategories: String? = nil,
        rdsEventMessage: String? = nil,
        s3EventName: String? = nil,
        sourceARN: String? = nil,
        sourceType: String? = nil,
        startTime: Date? = nil,
        statesArn: String? = nil,
        statesExecutionArn: String? = nil,
        statesInput: String? = nil,
        statesStatus: String? = nil,
        unit: String? = nil,
        value: Double? = nil,
        xRayErrorPercent: Int? = nil,
        xRayFaultPercent: Int? = nil,
        xRayNodeName: String? = nil,
        xRayNodeType: String? = nil,
        xRayRequestAverageLatency: Int? = nil,
        xRayRequestCount: Int? = nil,
        xRayThrottlePercent: Int? = nil
    )
    {
        self.cloudWatchEventDetailType = cloudWatchEventDetailType
        self.cloudWatchEventId = cloudWatchEventId
        self.cloudWatchEventSource = cloudWatchEventSource
        self.codeDeployApplication = codeDeployApplication
        self.codeDeployDeploymentGroup = codeDeployDeploymentGroup
        self.codeDeployDeploymentId = codeDeployDeploymentId
        self.codeDeployInstanceGroupId = codeDeployInstanceGroupId
        self.codeDeployState = codeDeployState
        self.ebsCause = ebsCause
        self.ebsEvent = ebsEvent
        self.ebsRequestId = ebsRequestId
        self.ebsResult = ebsResult
        self.ec2State = ec2State
        self.endTime = endTime
        self.healthEventArn = healthEventArn
        self.healthEventDescription = healthEventDescription
        self.healthEventTypeCategory = healthEventTypeCategory
        self.healthEventTypeCode = healthEventTypeCode
        self.healthService = healthService
        self.id = id
        self.lineTime = lineTime
        self.logFilter = logFilter
        self.logGroup = logGroup
        self.logText = logText
        self.metricName = metricName
        self.metricNamespace = metricNamespace
        self.rdsEventCategories = rdsEventCategories
        self.rdsEventMessage = rdsEventMessage
        self.s3EventName = s3EventName
        self.sourceARN = sourceARN
        self.sourceType = sourceType
        self.startTime = startTime
        self.statesArn = statesArn
        self.statesExecutionArn = statesExecutionArn
        self.statesInput = statesInput
        self.statesStatus = statesStatus
        self.unit = unit
        self.value = value
        self.xRayErrorPercent = xRayErrorPercent
        self.xRayFaultPercent = xRayFaultPercent
        self.xRayNodeName = xRayNodeName
        self.xRayNodeType = xRayNodeType
        self.xRayRequestAverageLatency = xRayRequestAverageLatency
        self.xRayRequestCount = xRayRequestCount
        self.xRayThrottlePercent = xRayThrottlePercent
    }
}

public enum OsType {
    case linux
    case windows
    case sdkUnknown(String)
}

extension OsType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [OsType] {
        return [
            .linux,
            .windows,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .linux: return "LINUX"
        case .windows: return "WINDOWS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = OsType(rawValue: rawValue) ?? OsType.sdkUnknown(rawValue)
    }
}

extension Problem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case affectedResource = "AffectedResource"
        case endTime = "EndTime"
        case feedback = "Feedback"
        case id = "Id"
        case insights = "Insights"
        case resourceGroupName = "ResourceGroupName"
        case severityLevel = "SeverityLevel"
        case startTime = "StartTime"
        case status = "Status"
        case title = "Title"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let affectedResource = affectedResource {
            try encodeContainer.encode(affectedResource, forKey: .affectedResource)
        }
        if let endTime = endTime {
            try encodeContainer.encode(endTime.timeIntervalSince1970, forKey: .endTime)
        }
        if let feedback = feedback {
            var feedbackContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .feedback)
            for (dictKey0, feedback0) in feedback {
                try feedbackContainer.encode(feedback0.rawValue, forKey: Key(stringValue: dictKey0))
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let insights = insights {
            try encodeContainer.encode(insights, forKey: .insights)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let severityLevel = severityLevel {
            try encodeContainer.encode(severityLevel.rawValue, forKey: .severityLevel)
        }
        if let startTime = startTime {
            try encodeContainer.encode(startTime.timeIntervalSince1970, forKey: .startTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let insightsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .insights)
        insights = insightsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Status.self, forKey: .status)
        status = statusDecoded
        let affectedResourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .affectedResource)
        affectedResource = affectedResourceDecoded
        let startTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endTime)
        endTime = endTimeDecoded
        let severityLevelDecoded = try containerValues.decodeIfPresent(SeverityLevel.self, forKey: .severityLevel)
        severityLevel = severityLevelDecoded
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let feedbackContainer = try containerValues.decodeIfPresent([String: FeedbackValue?].self, forKey: .feedback)
        var feedbackDecoded0: [String:FeedbackValue]? = nil
        if let feedbackContainer = feedbackContainer {
            feedbackDecoded0 = [String:FeedbackValue]()
            for (key0, feedbackvalue0) in feedbackContainer {
                if let feedbackvalue0 = feedbackvalue0 {
                    feedbackDecoded0?[key0] = feedbackvalue0
                }
            }
        }
        feedback = feedbackDecoded0
    }
}

extension Problem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Problem(affectedResource: \(String(describing: affectedResource)), endTime: \(String(describing: endTime)), feedback: \(String(describing: feedback)), id: \(String(describing: id)), insights: \(String(describing: insights)), resourceGroupName: \(String(describing: resourceGroupName)), severityLevel: \(String(describing: severityLevel)), startTime: \(String(describing: startTime)), status: \(String(describing: status)), title: \(String(describing: title)))"}
}

/// <p>Describes a problem that is detected by correlating observations.</p>
public struct Problem: Equatable {
    /// <p>The resource affected by the problem.</p>
    public let affectedResource: String?
    /// <p>The time when the problem ended, in epoch seconds.</p>
    public let endTime: Date?
    /// <p>Feedback provided by the user about the problem.</p>
    public let feedback: [String:FeedbackValue]?
    /// <p>The ID of the problem.</p>
    public let id: String?
    /// <p>A detailed analysis of the problem using machine learning.</p>
    public let insights: String?
    /// <p>The name of the resource group affected by the problem.</p>
    public let resourceGroupName: String?
    /// <p>A measure of the level of impact of the problem.</p>
    public let severityLevel: SeverityLevel?
    /// <p>The time when the problem started, in epoch seconds.</p>
    public let startTime: Date?
    /// <p>The status of the problem.</p>
    public let status: Status?
    /// <p>The name of the problem.</p>
    public let title: String?

    public init (
        affectedResource: String? = nil,
        endTime: Date? = nil,
        feedback: [String:FeedbackValue]? = nil,
        id: String? = nil,
        insights: String? = nil,
        resourceGroupName: String? = nil,
        severityLevel: SeverityLevel? = nil,
        startTime: Date? = nil,
        status: Status? = nil,
        title: String? = nil
    )
    {
        self.affectedResource = affectedResource
        self.endTime = endTime
        self.feedback = feedback
        self.id = id
        self.insights = insights
        self.resourceGroupName = resourceGroupName
        self.severityLevel = severityLevel
        self.startTime = startTime
        self.status = status
        self.title = title
    }
}

extension RelatedObservations: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case observationList = "ObservationList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let observationList = observationList {
            var observationListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .observationList)
            for observationlist0 in observationList {
                try observationListContainer.encode(observationlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let observationListContainer = try containerValues.decodeIfPresent([Observation?].self, forKey: .observationList)
        var observationListDecoded0:[Observation]? = nil
        if let observationListContainer = observationListContainer {
            observationListDecoded0 = [Observation]()
            for structure0 in observationListContainer {
                if let structure0 = structure0 {
                    observationListDecoded0?.append(structure0)
                }
            }
        }
        observationList = observationListDecoded0
    }
}

extension RelatedObservations: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelatedObservations(observationList: \(String(describing: observationList)))"}
}

/// <p>Describes observations related to the problem.</p>
public struct RelatedObservations: Equatable {
    /// <p>The list of observations related to the problem.</p>
    public let observationList: [Observation]?

    public init (
        observationList: [Observation]? = nil
    )
    {
        self.observationList = observationList
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is already created or in use.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource does not exist in the customer account.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SeverityLevel {
    case high
    case low
    case medium
    case sdkUnknown(String)
}

extension SeverityLevel : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SeverityLevel] {
        return [
            .high,
            .low,
            .medium,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "High"
        case .low: return "Low"
        case .medium: return "Medium"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SeverityLevel(rawValue: rawValue) ?? SeverityLevel.sdkUnknown(rawValue)
    }
}

public enum Status {
    case ignore
    case pending
    case resolved
    case sdkUnknown(String)
}

extension Status : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Status] {
        return [
            .ignore,
            .pending,
            .resolved,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ignore: return "IGNORE"
        case .pending: return "PENDING"
        case .resolved: return "RESOLVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>An object that defines the tags associated with an application.
///          A <i>tag</i> is a label that you optionally define and associate with
///          an application. Tags can help you categorize and manage resources in different ways, such as
///          by purpose, owner, environment, or other criteria.</p>
///          <p>Each tag consists of a required <i>tag key</i> and an
///          associated <i>tag value</i>, both of which you define. A tag key is a
///          general label that acts as a category for a more specific tag value. A tag value acts as
///          a descriptor within a tag key. A tag key can contain as many as 128 characters. A tag
///          value can contain as many as 256 characters. The characters can be Unicode letters,
///          digits, white space, or one of the following symbols: _ . : / = + -. The following
///          additional restrictions apply to tags:</p>
///          <ul>
///             <li>
///                <p>Tag keys and values are case sensitive.</p>
///             </li>
///             <li>
///                <p>For each associated resource, each tag key must be unique and it can have only
///                one value.</p>
///             </li>
///             <li>
///                <p>The <code>aws:</code> prefix is reserved for use by AWS; you can’t use it in
///                any tag keys or values that you define. In addition, you can't edit or remove
///                tag keys or values that use this prefix. </p>
///             </li>
///          </ul>
public struct Tag: Equatable {
    /// <p>One part of a key-value pair that defines a tag. The maximum length of a tag key is
    ///          128 characters. The minimum length is 1 character.</p>
    public let key: String?
    /// <p>The optional part of a key-value pair that defines a tag. The maximum length of a tag
    ///          value is 256 characters. The minimum length is 0 characters. If you don't want an
    ///          application to have a specific tag value, don't specify a value for this parameter.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceARN: \(String(describing: resourceARN)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application that you want to add one or more tags to.</p>
    public let resourceARN: String?
    /// <p>A list of tags that to add to the application. A tag consists of a required
    ///          tag key (<code>Key</code>) and an associated tag value (<code>Value</code>). The maximum
    ///          length of a tag key is 128 characters. The maximum length of a tag value is 256
    ///          characters.</p>
    public let tags: [Tag]?

    public init (
        resourceARN: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case tooManyTagsException(TooManyTagsException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension TagsAlreadyExistException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagsAlreadyExistException(message: \(String(describing: message)))"}
}

extension TagsAlreadyExistException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TagsAlreadyExistExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Tags are already registered for the specified application ARN.</p>
public struct TagsAlreadyExistException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TagsAlreadyExistExceptionBody: Equatable {
    public let message: String?
}

extension TagsAlreadyExistExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Tier {
    case custom
    case `default`
    case dotNetCore
    case dotNetWeb
    case dotNetWebTier
    case dotNetWorker
    case javaJmx
    case mysql
    case oracle
    case postgresql
    case sqlServer
    case sqlServerAlwaysonAvailabilityGroup
    case sdkUnknown(String)
}

extension Tier : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Tier] {
        return [
            .custom,
            .default,
            .dotNetCore,
            .dotNetWeb,
            .dotNetWebTier,
            .dotNetWorker,
            .javaJmx,
            .mysql,
            .oracle,
            .postgresql,
            .sqlServer,
            .sqlServerAlwaysonAvailabilityGroup,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .custom: return "CUSTOM"
        case .default: return "DEFAULT"
        case .dotNetCore: return "DOT_NET_CORE"
        case .dotNetWeb: return "DOT_NET_WEB"
        case .dotNetWebTier: return "DOT_NET_WEB_TIER"
        case .dotNetWorker: return "DOT_NET_WORKER"
        case .javaJmx: return "JAVA_JMX"
        case .mysql: return "MYSQL"
        case .oracle: return "ORACLE"
        case .postgresql: return "POSTGRESQL"
        case .sqlServer: return "SQL_SERVER"
        case .sqlServerAlwaysonAvailabilityGroup: return "SQL_SERVER_ALWAYSON_AVAILABILITY_GROUP"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Tier(rawValue: rawValue) ?? Tier.sdkUnknown(rawValue)
    }
}

extension TooManyTagsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyTagsException(message: \(String(describing: message)), resourceName: \(String(describing: resourceName)))"}
}

extension TooManyTagsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The number of the provided tags is beyond the limit, or
///          the number of total tags you are trying to attach to the specified resource exceeds the limit.</p>
public struct TooManyTagsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The name of the resource with too many tags.</p>
    public var resourceName: String?

    public init (
        message: String? = nil,
        resourceName: String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Equatable {
    public let message: String?
    public let resourceName: String?
}

extension TooManyTagsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceARN: \(String(describing: resourceARN)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the application that you want to remove one or more tags from.</p>
    public let resourceARN: String?
    /// <p>The tags (tag keys) that you want to remove from the resource. When you specify a tag
    ///          key, the action removes both that key and its associated tag value.</p>
    ///          <p>To remove more than one tag from the application, append the <code>TagKeys</code>
    ///          parameter and argument for each additional tag to remove, separated by an ampersand.
    ///       </p>
    public let tagKeys: [String]?

    public init (
        resourceARN: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceARN: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateApplicationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

extension UpdateApplicationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationInput(cWEMonitorEnabled: \(String(describing: cWEMonitorEnabled)), opsCenterEnabled: \(String(describing: opsCenterEnabled)), opsItemSNSTopicArn: \(String(describing: opsItemSNSTopicArn)), removeSNSTopic: \(String(describing: removeSNSTopic)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension UpdateApplicationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cWEMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case removeSNSTopic = "RemoveSNSTopic"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cWEMonitorEnabled = cWEMonitorEnabled {
            try encodeContainer.encode(cWEMonitorEnabled, forKey: .cWEMonitorEnabled)
        }
        if let opsCenterEnabled = opsCenterEnabled {
            try encodeContainer.encode(opsCenterEnabled, forKey: .opsCenterEnabled)
        }
        if let opsItemSNSTopicArn = opsItemSNSTopicArn {
            try encodeContainer.encode(opsItemSNSTopicArn, forKey: .opsItemSNSTopicArn)
        }
        if let removeSNSTopic = removeSNSTopic {
            try encodeContainer.encode(removeSNSTopic, forKey: .removeSNSTopic)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct UpdateApplicationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateApplicationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateApplicationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateApplicationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateApplicationInput>
    public typealias MOutput = OperationOutput<UpdateApplicationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateApplicationOutputError>
}

public struct UpdateApplicationInput: Equatable {
    /// <p>
    ///          Indicates whether Application Insights can listen to CloudWatch events for the application resources, such as <code>instance terminated</code>, <code>failed deployment</code>, and others.
    ///       </p>
    public let cWEMonitorEnabled: Bool?
    /// <p>
    ///          When set to <code>true</code>, creates opsItems for any problems detected on an application.
    ///       </p>
    public let opsCenterEnabled: Bool?
    /// <p>
    ///          The SNS topic provided to Application Insights that is associated to the created opsItem. Allows you to
    ///          receive notifications for updates to the opsItem.</p>
    public let opsItemSNSTopicArn: String?
    /// <p>
    ///          Disassociates the SNS topic from the opsItem created for detected problems.</p>
    public let removeSNSTopic: Bool?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        cWEMonitorEnabled: Bool? = nil,
        opsCenterEnabled: Bool? = nil,
        opsItemSNSTopicArn: String? = nil,
        removeSNSTopic: Bool? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.cWEMonitorEnabled = cWEMonitorEnabled
        self.opsCenterEnabled = opsCenterEnabled
        self.opsItemSNSTopicArn = opsItemSNSTopicArn
        self.removeSNSTopic = removeSNSTopic
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateApplicationInputBody: Equatable {
    public let resourceGroupName: String?
    public let opsCenterEnabled: Bool?
    public let cWEMonitorEnabled: Bool?
    public let opsItemSNSTopicArn: String?
    public let removeSNSTopic: Bool?
}

extension UpdateApplicationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case cWEMonitorEnabled = "CWEMonitorEnabled"
        case opsCenterEnabled = "OpsCenterEnabled"
        case opsItemSNSTopicArn = "OpsItemSNSTopicArn"
        case removeSNSTopic = "RemoveSNSTopic"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let opsCenterEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .opsCenterEnabled)
        opsCenterEnabled = opsCenterEnabledDecoded
        let cWEMonitorEnabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .cWEMonitorEnabled)
        cWEMonitorEnabled = cWEMonitorEnabledDecoded
        let opsItemSNSTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .opsItemSNSTopicArn)
        opsItemSNSTopicArn = opsItemSNSTopicArnDecoded
        let removeSNSTopicDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .removeSNSTopic)
        removeSNSTopic = removeSNSTopicDecoded
    }
}

extension UpdateApplicationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateApplicationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateApplicationOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateApplicationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateApplicationOutputResponse(applicationInfo: \(String(describing: applicationInfo)))"}
}

extension UpdateApplicationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateApplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.applicationInfo = output.applicationInfo
        } else {
            self.applicationInfo = nil
        }
    }
}

public struct UpdateApplicationOutputResponse: Equatable {
    /// <p>Information about the application. </p>
    public let applicationInfo: ApplicationInfo?

    public init (
        applicationInfo: ApplicationInfo? = nil
    )
    {
        self.applicationInfo = applicationInfo
    }
}

struct UpdateApplicationOutputResponseBody: Equatable {
    public let applicationInfo: ApplicationInfo?
}

extension UpdateApplicationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case applicationInfo = "ApplicationInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationInfoDecoded = try containerValues.decodeIfPresent(ApplicationInfo.self, forKey: .applicationInfo)
        applicationInfo = applicationInfoDecoded
    }
}

public struct UpdateComponentConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateComponentConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateComponentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateComponentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateComponentConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateComponentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateComponentConfigurationOutputError>
}

extension UpdateComponentConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateComponentConfigurationInput(componentConfiguration: \(String(describing: componentConfiguration)), componentName: \(String(describing: componentName)), monitor: \(String(describing: monitor)), resourceGroupName: \(String(describing: resourceGroupName)), tier: \(String(describing: tier)))"}
}

extension UpdateComponentConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentConfiguration = "ComponentConfiguration"
        case componentName = "ComponentName"
        case monitor = "Monitor"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentConfiguration = componentConfiguration {
            try encodeContainer.encode(componentConfiguration, forKey: .componentConfiguration)
        }
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let monitor = monitor {
            try encodeContainer.encode(monitor, forKey: .monitor)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let tier = tier {
            try encodeContainer.encode(tier.rawValue, forKey: .tier)
        }
    }
}

public struct UpdateComponentConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateComponentConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateComponentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateComponentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateComponentConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateComponentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateComponentConfigurationOutputError>
}

public struct UpdateComponentConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateComponentConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateComponentConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateComponentConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateComponentConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateComponentConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateComponentConfigurationOutputError>
}

public struct UpdateComponentConfigurationInput: Equatable {
    /// <p>The configuration settings of the component. The value is the escaped JSON of the configuration. For
    ///          more information about the JSON format, see <a href="https://docs.aws.amazon.com/sdk-for-javascript/v2/developer-guide/working-with-json.html">Working with JSON</a>.
    ///          You can send a request to <code>DescribeComponentConfigurationRecommendation</code> to see the recommended configuration for a component. For the complete
    ///          format of the component configuration file, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/component-config.html">Component Configuration</a>.</p>
    public let componentConfiguration: String?
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>Indicates whether the application component is monitored.</p>
    public let monitor: Bool?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?
    /// <p>The tier of the application component. Supported tiers include <code>DOT_NET_WORKER</code>,
    ///          <code>DOT_NET_WEB</code>, <code>DOT_NET_CORE</code>, <code>SQL_SERVER</code>, and <code>DEFAULT</code>.</p>
    public let tier: Tier?

    public init (
        componentConfiguration: String? = nil,
        componentName: String? = nil,
        monitor: Bool? = nil,
        resourceGroupName: String? = nil,
        tier: Tier? = nil
    )
    {
        self.componentConfiguration = componentConfiguration
        self.componentName = componentName
        self.monitor = monitor
        self.resourceGroupName = resourceGroupName
        self.tier = tier
    }
}

struct UpdateComponentConfigurationInputBody: Equatable {
    public let resourceGroupName: String?
    public let componentName: String?
    public let monitor: Bool?
    public let tier: Tier?
    public let componentConfiguration: String?
}

extension UpdateComponentConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentConfiguration = "ComponentConfiguration"
        case componentName = "ComponentName"
        case monitor = "Monitor"
        case resourceGroupName = "ResourceGroupName"
        case tier = "Tier"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let monitorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .monitor)
        monitor = monitorDecoded
        let tierDecoded = try containerValues.decodeIfPresent(Tier.self, forKey: .tier)
        tier = tierDecoded
        let componentConfigurationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentConfiguration)
        componentConfiguration = componentConfigurationDecoded
    }
}

extension UpdateComponentConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateComponentConfigurationOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateComponentConfigurationOutputResponse()"}
}

extension UpdateComponentConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateComponentConfigurationOutputResponse: Equatable {

    public init() {}
}

struct UpdateComponentConfigurationOutputResponseBody: Equatable {
}

extension UpdateComponentConfigurationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateComponentInputBodyMiddleware: Middleware {
    public let id: String = "UpdateComponentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateComponentInput>
    public typealias MOutput = OperationOutput<UpdateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateComponentOutputError>
}

extension UpdateComponentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateComponentInput(componentName: \(String(describing: componentName)), newComponentName: \(String(describing: newComponentName)), resourceGroupName: \(String(describing: resourceGroupName)), resourceList: \(String(describing: resourceList)))"}
}

extension UpdateComponentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case newComponentName = "NewComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let componentName = componentName {
            try encodeContainer.encode(componentName, forKey: .componentName)
        }
        if let newComponentName = newComponentName {
            try encodeContainer.encode(newComponentName, forKey: .newComponentName)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
        if let resourceList = resourceList {
            var resourceListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceList)
            for resourcelist0 in resourceList {
                try resourceListContainer.encode(resourcelist0)
            }
        }
    }
}

public struct UpdateComponentInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateComponentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateComponentInput>
    public typealias MOutput = OperationOutput<UpdateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateComponentOutputError>
}

public struct UpdateComponentInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateComponentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateComponentInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateComponentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateComponentInput>
    public typealias MOutput = OperationOutput<UpdateComponentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateComponentOutputError>
}

public struct UpdateComponentInput: Equatable {
    /// <p>The name of the component.</p>
    public let componentName: String?
    /// <p>The new name of the component.</p>
    public let newComponentName: String?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?
    /// <p>The list of resource ARNs that belong to the component.</p>
    public let resourceList: [String]?

    public init (
        componentName: String? = nil,
        newComponentName: String? = nil,
        resourceGroupName: String? = nil,
        resourceList: [String]? = nil
    )
    {
        self.componentName = componentName
        self.newComponentName = newComponentName
        self.resourceGroupName = resourceGroupName
        self.resourceList = resourceList
    }
}

struct UpdateComponentInputBody: Equatable {
    public let resourceGroupName: String?
    public let componentName: String?
    public let newComponentName: String?
    public let resourceList: [String]?
}

extension UpdateComponentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case componentName = "ComponentName"
        case newComponentName = "NewComponentName"
        case resourceGroupName = "ResourceGroupName"
        case resourceList = "ResourceList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let componentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .componentName)
        componentName = componentNameDecoded
        let newComponentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .newComponentName)
        newComponentName = newComponentNameDecoded
        let resourceListContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceList)
        var resourceListDecoded0:[String]? = nil
        if let resourceListContainer = resourceListContainer {
            resourceListDecoded0 = [String]()
            for string0 in resourceListContainer {
                if let string0 = string0 {
                    resourceListDecoded0?.append(string0)
                }
            }
        }
        resourceList = resourceListDecoded0
    }
}

extension UpdateComponentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateComponentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateComponentOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateComponentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateComponentOutputResponse()"}
}

extension UpdateComponentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateComponentOutputResponse: Equatable {

    public init() {}
}

struct UpdateComponentOutputResponseBody: Equatable {
}

extension UpdateComponentOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateLogPatternInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLogPatternInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLogPatternInput>
    public typealias MOutput = OperationOutput<UpdateLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLogPatternOutputError>
}

extension UpdateLogPatternInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLogPatternInput(pattern: \(String(describing: pattern)), patternName: \(String(describing: patternName)), patternSetName: \(String(describing: patternSetName)), rank: \(String(describing: rank)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension UpdateLogPatternInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pattern = pattern {
            try encodeContainer.encode(pattern, forKey: .pattern)
        }
        if let patternName = patternName {
            try encodeContainer.encode(patternName, forKey: .patternName)
        }
        if let patternSetName = patternSetName {
            try encodeContainer.encode(patternSetName, forKey: .patternSetName)
        }
        if rank != 0 {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let resourceGroupName = resourceGroupName {
            try encodeContainer.encode(resourceGroupName, forKey: .resourceGroupName)
        }
    }
}

public struct UpdateLogPatternInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLogPatternInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLogPatternInput>
    public typealias MOutput = OperationOutput<UpdateLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLogPatternOutputError>
}

public struct UpdateLogPatternInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLogPatternInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLogPatternInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLogPatternOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLogPatternInput>
    public typealias MOutput = OperationOutput<UpdateLogPatternOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLogPatternOutputError>
}

public struct UpdateLogPatternInput: Equatable {
    /// <p>The log pattern. The pattern must be DFA compatible. Patterns that utilize forward lookahead or backreference constructions are not supported.</p>
    public let pattern: String?
    /// <p>The name of the log pattern.</p>
    public let patternName: String?
    /// <p>The name of the log pattern set.</p>
    public let patternSetName: String?
    /// <p>Rank of the log pattern. Must be a value between <code>1</code> and <code>1,000,000</code>. The patterns are sorted by rank, so we recommend that you set your highest priority patterns with the lowest rank. A pattern of rank <code>1</code> will be the first to get matched to a log line. A pattern of rank <code>1,000,000</code> will be last to get matched. When you configure custom log patterns from the console, a <code>Low</code> severity pattern translates to a <code>750,000</code> rank. A <code>Medium</code> severity pattern translates to a <code>500,000</code> rank. And a <code>High</code> severity pattern translates to a <code>250,000</code> rank.
    ///          Rank values less than <code>1</code> or greater than <code>1,000,000</code> are reserved for AWS-provided patterns.
    ///       </p>
    public let rank: Int
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        pattern: String? = nil,
        patternName: String? = nil,
        patternSetName: String? = nil,
        rank: Int = 0,
        resourceGroupName: String? = nil
    )
    {
        self.pattern = pattern
        self.patternName = patternName
        self.patternSetName = patternSetName
        self.rank = rank
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateLogPatternInputBody: Equatable {
    public let resourceGroupName: String?
    public let patternSetName: String?
    public let patternName: String?
    public let pattern: String?
    public let rank: Int
}

extension UpdateLogPatternInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case pattern = "Pattern"
        case patternName = "PatternName"
        case patternSetName = "PatternSetName"
        case rank = "Rank"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let patternSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternSetName)
        patternSetName = patternSetNameDecoded
        let patternNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .patternName)
        patternName = patternNameDecoded
        let patternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .pattern)
        pattern = patternDecoded
        let rankDecoded = try containerValues.decode(Int.self, forKey: .rank)
        rank = rankDecoded
    }
}

extension UpdateLogPatternOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLogPatternOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLogPatternOutputError: Swift.Error, Equatable {
    case internalServerException(InternalServerException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLogPatternOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLogPatternOutputResponse(logPattern: \(String(describing: logPattern)), resourceGroupName: \(String(describing: resourceGroupName)))"}
}

extension UpdateLogPatternOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLogPatternOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.logPattern = output.logPattern
            self.resourceGroupName = output.resourceGroupName
        } else {
            self.logPattern = nil
            self.resourceGroupName = nil
        }
    }
}

public struct UpdateLogPatternOutputResponse: Equatable {
    /// <p>The successfully created log pattern.</p>
    public let logPattern: LogPattern?
    /// <p>The name of the resource group.</p>
    public let resourceGroupName: String?

    public init (
        logPattern: LogPattern? = nil,
        resourceGroupName: String? = nil
    )
    {
        self.logPattern = logPattern
        self.resourceGroupName = resourceGroupName
    }
}

struct UpdateLogPatternOutputResponseBody: Equatable {
    public let resourceGroupName: String?
    public let logPattern: LogPattern?
}

extension UpdateLogPatternOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case logPattern = "LogPattern"
        case resourceGroupName = "ResourceGroupName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupName)
        resourceGroupName = resourceGroupNameDecoded
        let logPatternDecoded = try containerValues.decodeIfPresent(LogPattern.self, forKey: .logPattern)
        logPattern = logPatternDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The parameter is not valid.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
