// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTSiteWiseClientTypes.AccessPolicySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case id
        case identity
        case lastUpdateDate
        case permission
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identity = identity {
            try encodeContainer.encode(identity, forKey: .identity)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let permission = permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let resource = resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let identityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .identity)
        identity = identityDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes.AccessPolicySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccessPolicySummary(creationDate: \(Swift.String(describing: creationDate)), id: \(Swift.String(describing: id)), identity: \(Swift.String(describing: identity)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), permission: \(Swift.String(describing: permission)), resource: \(Swift.String(describing: resource)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an access policy that defines an identity's access to an IoT SiteWise Monitor
    ///       resource.
    public struct AccessPolicySummary: Swift.Equatable {
        /// The date the access policy was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The ID of the access policy.
        /// This member is required.
        public var id: Swift.String?
        /// The identity (an Amazon Web Services SSO user, an Amazon Web Services SSO group, or an IAM user).
        /// This member is required.
        public var identity: IoTSiteWiseClientTypes.Identity?
        /// The date the access policy was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is
        ///       also known as a project owner.
        /// This member is required.
        public var permission: IoTSiteWiseClientTypes.Permission?
        /// The IoT SiteWise Monitor resource (a portal or project).
        /// This member is required.
        public var resource: IoTSiteWiseClientTypes.Resource?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            identity: IoTSiteWiseClientTypes.Identity? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            permission: IoTSiteWiseClientTypes.Permission? = nil,
            resource: IoTSiteWiseClientTypes.Resource? = nil
        )
        {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AggregateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateType] {
            return [
                .average,
                .count,
                .maximum,
                .minimum,
                .standardDeviation,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .maximum: return "MAXIMUM"
            case .minimum: return "MINIMUM"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregateType(rawValue: rawValue) ?? AggregateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AggregatedValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Quality.self, forKey: .quality)
        quality = qualityDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Aggregates.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes.AggregatedValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AggregatedValue(quality: \(Swift.String(describing: quality)), timestamp: \(Swift.String(describing: timestamp)), value: \(Swift.String(describing: value)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains aggregated asset property values (for example, average, minimum, and
    ///       maximum).
    public struct AggregatedValue: Swift.Equatable {
        /// The quality of the aggregated data.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The value of the aggregates.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Aggregates?

        public init (
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: ClientRuntime.Date? = nil,
            value: IoTSiteWiseClientTypes.Aggregates? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.Aggregates: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let average = average {
            try encodeContainer.encode(average, forKey: .average)
        }
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let maximum = maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let standardDeviation = standardDeviation {
            try encodeContainer.encode(standardDeviation, forKey: .standardDeviation)
        }
        if let sum = sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .average)
        average = averageDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .count)
        count = countDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximum)
        maximum = maximumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sum)
        sum = sumDecoded
        let standardDeviationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .standardDeviation)
        standardDeviation = standardDeviationDecoded
    }
}

extension IoTSiteWiseClientTypes.Aggregates: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Aggregates(average: \(Swift.String(describing: average)), count: \(Swift.String(describing: count)), maximum: \(Swift.String(describing: maximum)), minimum: \(Swift.String(describing: minimum)), standardDeviation: \(Swift.String(describing: standardDeviation)), sum: \(Swift.String(describing: sum)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains the (pre-calculated) aggregate values for an asset property.
    public struct Aggregates: Swift.Equatable {
        /// The average (mean) value of the time series over a time interval window.
        public var average: Swift.Double?
        /// The count of data points in the time series over a time interval window.
        public var count: Swift.Double?
        /// The maximum value of the time series over a time interval window.
        public var maximum: Swift.Double?
        /// The minimum value of the time series over a time interval window.
        public var minimum: Swift.Double?
        /// The standard deviation of the time series over a time interval window.
        public var standardDeviation: Swift.Double?
        /// The sum of the time series over a time interval window.
        public var sum: Swift.Double?

        public init (
            average: Swift.Double? = nil,
            count: Swift.Double? = nil,
            maximum: Swift.Double? = nil,
            minimum: Swift.Double? = nil,
            standardDeviation: Swift.Double? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }
    }

}

extension IoTSiteWiseClientTypes.Alarms: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmRoleArn
        case notificationLambdaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmRoleArn = alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
        if let notificationLambdaArn = notificationLambdaArn {
            try encodeContainer.encode(notificationLambdaArn, forKey: .notificationLambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
        let notificationLambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationLambdaArn)
        notificationLambdaArn = notificationLambdaArnDecoded
    }
}

extension IoTSiteWiseClientTypes.Alarms: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Alarms(alarmRoleArn: \(Swift.String(describing: alarmRoleArn)), notificationLambdaArn: \(Swift.String(describing: notificationLambdaArn)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
    ///   You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.
    ///   For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms in the IoT SiteWise Application Guide.
    public struct Alarms: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the IAM role that allows the alarm to perform actions and access Amazon Web Services
        ///       resources and services, such as IoT Events.
        /// This member is required.
        public var alarmRoleArn: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the Lambda function that manages alarm notifications. For more
        ///       information, see <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">Managing alarm
        ///         notifications in the IoT Events Developer Guide.
        public var notificationLambdaArn: Swift.String?

        public init (
            alarmRoleArn: Swift.String? = nil,
            notificationLambdaArn: Swift.String? = nil
        )
        {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }
    }

}

extension IoTSiteWiseClientTypes.AssetCompositeModel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetproperties0 in properties {
                try propertiesContainer.encode(assetproperties0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetProperty?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension IoTSiteWiseClientTypes.AssetCompositeModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetCompositeModel(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), type: \(Swift.String(describing: type)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model in an asset. This object contains the asset's
    ///       properties that you define in the composite model.
    public struct AssetCompositeModel: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset properties that this composite model defines.
        /// This member is required.
        public var properties: [IoTSiteWiseClientTypes.AssetProperty]?
        /// The type of the composite model. For alarm composite models, this type is
        ///         AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetErrorCode] {
            return [
                .internalFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetErrorCode(rawValue: rawValue) ?? AssetErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetErrorDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetErrorDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetErrorDetails(assetId: \(Swift.String(describing: assetId)), code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains error details for the requested associate project asset action.
    public struct AssetErrorDetails: Swift.Equatable {
        /// The ID of the asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.AssetErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            assetId: Swift.String? = nil,
            code: IoTSiteWiseClientTypes.AssetErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.AssetHierarchy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetHierarchy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetHierarchy(id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension IoTSiteWiseClientTypes {
    /// Describes an asset hierarchy that contains a hierarchy's name and ID.
    public struct AssetHierarchy: Swift.Equatable {
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public var id: Swift.String?
        /// The hierarchy name provided in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel
        ///       API operation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetHierarchyInfo: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case parentAssetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let parentAssetId = parentAssetId {
            try encodeContainer.encode(parentAssetId, forKey: .parentAssetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentAssetId)
        parentAssetId = parentAssetIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetHierarchyInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetHierarchyInfo(childAssetId: \(Swift.String(describing: childAssetId)), parentAssetId: \(Swift.String(describing: parentAssetId)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a parent asset and a child asset that are related through an
    ///       asset hierarchy.
    public struct AssetHierarchyInfo: Swift.Equatable {
        /// The ID of the child asset in this asset relationship.
        public var childAssetId: Swift.String?
        /// The ID of the parent asset in this asset relationship.
        public var parentAssetId: Swift.String?

        public init (
            childAssetId: Swift.String? = nil,
            parentAssetId: Swift.String? = nil
        )
        {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelCompositeModel: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelproperties0 in properties {
                try propertiesContainer.encode(assetmodelproperties0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension IoTSiteWiseClientTypes.AssetModelCompositeModel: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelCompositeModel(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), type: \(Swift.String(describing: type)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model in an asset model. This object contains the
    ///       asset property definitions that you define in the composite model.
    public struct AssetModelCompositeModel: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is
        ///         AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelpropertydefinitions0 in properties {
                try propertiesContainer.encode(assetmodelpropertydefinitions0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertyDefinition?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelCompositeModelDefinition(description: \(Swift.String(describing: description)), name: \(Swift.String(describing: name)), properties: \(Swift.String(describing: properties)), type: \(Swift.String(describing: type)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a composite model definition in an asset model. This composite model definition
    ///       is applied to all assets created from the asset model.
    public struct AssetModelCompositeModelDefinition: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is
        ///         AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelHierarchy: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetModelId
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetModelHierarchy: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelHierarchy(childAssetModelId: \(Swift.String(describing: childAssetModelId)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)))"}
}

extension IoTSiteWiseClientTypes {
    /// Describes an asset hierarchy that contains a hierarchy's name, ID, and child asset model
    ///       ID that specifies the type of asset that can be in this hierarchy.
    public struct AssetModelHierarchy: Swift.Equatable {
        /// The ID of the asset model. All assets in this hierarchy must be instances of the
        ///         childAssetModelId asset model.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.
        public var id: Swift.String?
        /// The name of the asset model hierarchy that you specify by using the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel or
        ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel API operation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            childAssetModelId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.id = id
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelHierarchyDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetModelId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetModelHierarchyDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelHierarchyDefinition(childAssetModelId: \(Swift.String(describing: childAssetModelId)), name: \(Swift.String(describing: name)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset model hierarchy used in asset model creation. An asset model hierarchy
    ///       determines the kind (or type) of asset that can belong to a hierarchy.
    public struct AssetModelHierarchyDefinition: Swift.Equatable {
        /// The ID of an asset model for this hierarchy.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// The name of the asset model hierarchy definition (as specified in the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html">CreateAssetModel or
        ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html">UpdateAssetModel API operation).
        /// This member is required.
        public var name: Swift.String?

        public init (
            childAssetModelId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelProperty: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case dataTypeSpec
        case id
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetModelProperty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelProperty(dataType: \(Swift.String(describing: dataType)), dataTypeSpec: \(Swift.String(describing: dataTypeSpec)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), unit: \(Swift.String(describing: unit)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an asset model property.
    public struct AssetModelProperty: Swift.Equatable {
        /// The data type of the asset model property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that
        ///       have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset model property.
        public var id: Swift.String?
        /// The name of the asset model property.
        /// This member is required.
        public var name: Swift.String?
        /// The property type (see PropertyType).
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the asset model property, such as Newtons or
        ///       RPM.
        public var unit: Swift.String?

        public init (
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelPropertyDefinition: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case dataTypeSpec
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetModelPropertyDefinition: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelPropertyDefinition(dataType: \(Swift.String(describing: dataType)), dataTypeSpec: \(Swift.String(describing: dataTypeSpec)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)), unit: \(Swift.String(describing: unit)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset model property definition. This property definition is applied to all
    ///       assets created from the asset model.
    public struct AssetModelPropertyDefinition: Swift.Equatable {
        /// The data type of the property definition.
        ///          If you specify STRUCT, you must also specify dataTypeSpec to
        ///       identify the type of the structure for this property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter is required on properties
        ///       that have the STRUCT data type.
        ///          The options for this parameter depend on the type of the composite model in which you
        ///       define this property. Use AWS/ALARM_STATE for alarm state in alarm composite
        ///       models.
        public var dataTypeSpec: Swift.String?
        /// The name of the property definition.
        /// This member is required.
        public var name: Swift.String?
        /// The property definition type (see PropertyType). You can only specify one
        ///       type in a property definition.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the property definition, such as Newtons or
        ///       RPM.
        public var unit: Swift.String?

        public init (
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetModelState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case propagating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetModelState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .propagating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .propagating: return "PROPAGATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetModelState(rawValue: rawValue) ?? AssetModelState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetModelStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetModelStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelStatus(error: \(Swift.String(describing: error)), state: \(Swift.String(describing: state)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains current status information for an asset model. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html">Asset and model
    ///         states in the IoT SiteWise User Guide.
    public struct AssetModelStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current state of the asset model.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetModelState?

        public init (
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetModelState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetModelSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetModelSummary(arn: \(Swift.String(describing: arn)), creationDate: \(Swift.String(describing: creationDate)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an asset model.
    public struct AssetModelSummary: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the asset model, which has the following format.
        ///
        ///             arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        ///
        /// This member is required.
        public var arn: Swift.String?
        /// The date the asset model was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The asset model description.
        /// This member is required.
        public var description: Swift.String?
        /// The ID of the asset model (used with IoT SiteWise APIs).
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset model was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset model.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset model.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetModelStatus?

        public init (
            arn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetModelStatus? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.AssetProperty: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case dataType
        case dataTypeSpec
        case id
        case name
        case notification
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetProperty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetProperty(alias: \(Swift.String(describing: alias)), dataType: \(Swift.String(describing: dataType)), dataTypeSpec: \(Swift.String(describing: dataTypeSpec)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), notification: \(Swift.String(describing: notification)), unit: \(Swift.String(describing: unit)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property information.
    public struct AssetProperty: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path
        ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
        ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
        ///         IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The data type of the asset property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that
        ///       have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty.
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init (
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.notification = notification
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetPropertyValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Variant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Quality.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetPropertyValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetPropertyValue(quality: \(Swift.String(describing: quality)), timestamp: \(Swift.String(describing: timestamp)), value: \(Swift.String(describing: value)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property value information.
    public struct AssetPropertyValue: Swift.Equatable {
        /// The quality of the asset property value.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The timestamp of the asset property value.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// The value of the asset property (see Variant).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init (
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.AssetRelationshipSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyInfo
        case relationshipType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyInfo = hierarchyInfo {
            try encodeContainer.encode(hierarchyInfo, forKey: .hierarchyInfo)
        }
        if let relationshipType = relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetHierarchyInfo.self, forKey: .hierarchyInfo)
        hierarchyInfo = hierarchyInfoDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetRelationshipSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetRelationshipSummary(hierarchyInfo: \(Swift.String(describing: hierarchyInfo)), relationshipType: \(Swift.String(describing: relationshipType)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about assets that are related to one another.
    public struct AssetRelationshipSummary: Swift.Equatable {
        /// The assets that are related through an asset hierarchy.
        ///          This object is present if the relationshipType is
        ///       HIERARCHY.
        public var hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the
        ///       following:
        ///
        ///
        ///
        ///                   HIERARCHY  The assets are related through an asset hierarchy. If
        ///           you specify this relationship type, this asset relationship includes the
        ///             hierarchyInfo object.
        ///
        ///
        /// This member is required.
        public var relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType?

        public init (
            hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo? = nil,
            relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType? = nil
        )
        {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hierarchy
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetRelationshipType] {
            return [
                .hierarchy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hierarchy: return "HIERARCHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetRelationshipType(rawValue: rawValue) ?? AssetRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum AssetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetState(rawValue: rawValue) ?? AssetState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes.AssetStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetStatus(error: \(Swift.String(describing: error)), state: \(Swift.String(describing: state)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the current status of an asset. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html">Asset and model
    ///         states in the IoT SiteWise User Guide.
    public struct AssetStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current status of the asset.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetState?

        public init (
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.AssetSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetModelId
        case creationDate
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchies0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchies0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
    }
}

extension IoTSiteWiseClientTypes.AssetSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssetSummary(arn: \(Swift.String(describing: arn)), assetModelId: \(Swift.String(describing: assetModelId)), creationDate: \(Swift.String(describing: creationDate)), hierarchies: \(Swift.String(describing: hierarchies)), id: \(Swift.String(describing: id)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an asset.
    public struct AssetSummary: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the asset, which has the following format.
        ///
        ///             arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        ///
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create this asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init (
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

public struct AssociateAssetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAssetsOutputError>
}

extension AssociateAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAssetsInput(assetId: \(Swift.String(describing: assetId)), childAssetId: \(Swift.String(describing: childAssetId)), clientToken: \(Swift.String(describing: clientToken)), hierarchyId: \(Swift.String(describing: hierarchyId)))"}
}

extension AssociateAssetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

public struct AssociateAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAssetsOutputError>
}

public struct AssociateAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAssetsOutputError>
}

public struct AssociateAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: AssociateAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())/associate"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = AssociateAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateAssetsOutputError>
}

public struct AssociateAssetsInput: Swift.Equatable {
    /// The ID of the parent asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to be associated.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings
    ///       of assets to be formed that all come from the same asset model. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct AssociateAssetsInputBody: Swift.Equatable {
    public let hierarchyId: Swift.String?
    public let childAssetId: Swift.String?
    public let clientToken: Swift.String?
}

extension AssociateAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateAssetsOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAssetsOutputResponse()"}
}

extension AssociateAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAssetsOutputResponse: Swift.Equatable {

    public init() {}
}

struct AssociateAssetsOutputResponseBody: Swift.Equatable {
}

extension AssociateAssetsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTSiteWiseClientTypes.AssociatedAssetsSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetModelId
        case creationDate
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchies0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchies0)
            }
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
    }
}

extension IoTSiteWiseClientTypes.AssociatedAssetsSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociatedAssetsSummary(arn: \(Swift.String(describing: arn)), assetModelId: \(Swift.String(describing: assetModelId)), creationDate: \(Swift.String(describing: creationDate)), hierarchies: \(Swift.String(describing: hierarchies)), id: \(Swift.String(describing: id)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), name: \(Swift.String(describing: name)), status: \(Swift.String(describing: status)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an associated asset.
    public struct AssociatedAssetsSummary: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the asset, which has the following format.
        ///
        ///             arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        ///
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create the asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init (
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.Attribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension IoTSiteWiseClientTypes.Attribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Attribute(defaultValue: \(Swift.String(describing: defaultValue)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset attribute property. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#attributes">Attributes in the IoT SiteWise User Guide.
    public struct Attribute: Swift.Equatable {
        /// The default value of the asset model property attribute. All assets that you create from
        ///       the asset model contain this attribute value. You can update an attribute's value after you
        ///       create an asset. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html">Updating attribute values in the
        ///         IoT SiteWise User Guide.
        public var defaultValue: Swift.String?

        public init (
            defaultValue: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AuthMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case sso
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMode] {
            return [
                .iam,
                .sso,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .sso: return "SSO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthMode(rawValue: rawValue) ?? AuthMode.sdkUnknown(rawValue)
        }
    }
}

public struct BatchAssociateProjectAssetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateProjectAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateProjectAssetsOutputError>
}

extension BatchAssociateProjectAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateProjectAssetsInput(assetIds: \(Swift.String(describing: assetIds)), clientToken: \(Swift.String(describing: clientToken)), projectId: \(Swift.String(describing: projectId)))"}
}

extension BatchAssociateProjectAssetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for ids0 in assetIds {
                try assetIdsContainer.encode(ids0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct BatchAssociateProjectAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateProjectAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateProjectAssetsOutputError>
}

public struct BatchAssociateProjectAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateProjectAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchAssociateProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchAssociateProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateProjectAssetsOutputError>
}

public struct BatchAssociateProjectAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchAssociateProjectAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchAssociateProjectAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectId = input.projectId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectId.urlPercentEncoding())/assets/associate"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchAssociateProjectAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchAssociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchAssociateProjectAssetsOutputError>
}

public struct BatchAssociateProjectAssetsInput: Swift.Equatable {
    /// The IDs of the assets to be associated to the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project to which to associate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchAssociateProjectAssetsInputBody: Swift.Equatable {
    public let assetIds: [Swift.String]?
    public let clientToken: Swift.String?
}

extension BatchAssociateProjectAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchAssociateProjectAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateProjectAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchAssociateProjectAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateProjectAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchAssociateProjectAssetsOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchAssociateProjectAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchAssociateProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateProjectAssetsOutputResponse: Swift.Equatable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init (
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateProjectAssetsOutputResponseBody: Swift.Equatable {
    public let errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?
}

extension BatchAssociateProjectAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

public struct BatchDisassociateProjectAssetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateProjectAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateProjectAssetsOutputError>
}

extension BatchDisassociateProjectAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateProjectAssetsInput(assetIds: \(Swift.String(describing: assetIds)), clientToken: \(Swift.String(describing: clientToken)), projectId: \(Swift.String(describing: projectId)))"}
}

extension BatchDisassociateProjectAssetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for ids0 in assetIds {
                try assetIdsContainer.encode(ids0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct BatchDisassociateProjectAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateProjectAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateProjectAssetsOutputError>
}

public struct BatchDisassociateProjectAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateProjectAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchDisassociateProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchDisassociateProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateProjectAssetsOutputError>
}

public struct BatchDisassociateProjectAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchDisassociateProjectAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchDisassociateProjectAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectId = input.projectId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectId.urlPercentEncoding())/assets/disassociate"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchDisassociateProjectAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchDisassociateProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchDisassociateProjectAssetsOutputError>
}

public struct BatchDisassociateProjectAssetsInput: Swift.Equatable {
    /// The IDs of the assets to be disassociated from the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project from which to disassociate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchDisassociateProjectAssetsInputBody: Swift.Equatable {
    public let assetIds: [Swift.String]?
    public let clientToken: Swift.String?
}

extension BatchDisassociateProjectAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchDisassociateProjectAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateProjectAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDisassociateProjectAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateProjectAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchDisassociateProjectAssetsOutputResponse(errors: \(Swift.String(describing: errors)))"}
}

extension BatchDisassociateProjectAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchDisassociateProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateProjectAssetsOutputResponse: Swift.Equatable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init (
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateProjectAssetsOutputResponseBody: Swift.Equatable {
    public let errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?
}

extension BatchDisassociateProjectAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case timestamps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let timestamps = timestamps {
            var timestampsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timestamps)
            for timestamps0 in timestamps {
                try timestampsContainer.encode(timestamps0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let timestampsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.TimeInNanos?].self, forKey: .timestamps)
        var timestampsDecoded0:[IoTSiteWiseClientTypes.TimeInNanos]? = nil
        if let timestampsContainer = timestampsContainer {
            timestampsDecoded0 = [IoTSiteWiseClientTypes.TimeInNanos]()
            for structure0 in timestampsContainer {
                if let structure0 = structure0 {
                    timestampsDecoded0?.append(structure0)
                }
            }
        }
        timestamps = timestampsDecoded0
    }
}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutAssetPropertyError(errorCode: \(Swift.String(describing: errorCode)), errorMessage: \(Swift.String(describing: errorMessage)), timestamps: \(Swift.String(describing: timestamps)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains error information from updating a batch of asset property values.
    public struct BatchPutAssetPropertyError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// A list of timestamps for each  error, if any.
        /// This member is required.
        public var timestamps: [IoTSiteWiseClientTypes.TimeInNanos]?

        public init (
            errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            timestamps: [IoTSiteWiseClientTypes.TimeInNanos]? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }
    }

}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for batchputassetpropertyerrors0 in errors {
                try errorsContainer.encode(batchputassetpropertyerrors0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchPutAssetPropertyError?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.BatchPutAssetPropertyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutAssetPropertyErrorEntry(entryId: \(Swift.String(describing: entryId)), errors: \(Swift.String(describing: errors)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains error information for asset property value entries that are associated with the
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html">BatchPutAssetPropertyValue API.
    public struct BatchPutAssetPropertyErrorEntry: Swift.Equatable {
        /// The ID of the failed entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The list of update property value errors.
        /// This member is required.
        public var errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]?

        public init (
            entryId: Swift.String? = nil,
            errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]? = nil
        )
        {
            self.entryId = entryId
            self.errors = errors
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchPutAssetPropertyValueErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case conflictingoperationexception
        case internalfailureexception
        case invalidrequestexception
        case limitexceededexception
        case resourcenotfoundexception
        case serviceunavailableexception
        case throttlingexception
        case timestampoutofrangeexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchPutAssetPropertyValueErrorCode] {
            return [
                .accessdeniedexception,
                .conflictingoperationexception,
                .internalfailureexception,
                .invalidrequestexception,
                .limitexceededexception,
                .resourcenotfoundexception,
                .serviceunavailableexception,
                .throttlingexception,
                .timestampoutofrangeexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .conflictingoperationexception: return "ConflictingOperationException"
            case .internalfailureexception: return "InternalFailureException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .limitexceededexception: return "LimitExceededException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .serviceunavailableexception: return "ServiceUnavailableException"
            case .throttlingexception: return "ThrottlingException"
            case .timestampoutofrangeexception: return "TimestampOutOfRangeException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchPutAssetPropertyValueErrorCode(rawValue: rawValue) ?? BatchPutAssetPropertyValueErrorCode.sdkUnknown(rawValue)
        }
    }
}

public struct BatchPutAssetPropertyValueInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutAssetPropertyValueInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutAssetPropertyValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutAssetPropertyValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutAssetPropertyValueOutputError>
}

extension BatchPutAssetPropertyValueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutAssetPropertyValueInput(entries: \(Swift.String(describing: entries)))"}
}

extension BatchPutAssetPropertyValueInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for putassetpropertyvalueentries0 in entries {
                try entriesContainer.encode(putassetpropertyvalueentries0)
            }
        }
    }
}

public struct BatchPutAssetPropertyValueInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutAssetPropertyValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutAssetPropertyValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutAssetPropertyValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutAssetPropertyValueOutputError>
}

public struct BatchPutAssetPropertyValueInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutAssetPropertyValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<BatchPutAssetPropertyValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<BatchPutAssetPropertyValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutAssetPropertyValueOutputError>
}

public struct BatchPutAssetPropertyValueInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "BatchPutAssetPropertyValueInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: BatchPutAssetPropertyValueInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/properties"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = BatchPutAssetPropertyValueInput
    public typealias MOutput = ClientRuntime.OperationOutput<BatchPutAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<BatchPutAssetPropertyValueOutputError>
}

public struct BatchPutAssetPropertyValueInput: Swift.Equatable {
    /// The list of asset property value entries for the batch put request. You can specify up to
    ///       10 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]?

    public init (
        entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct BatchPutAssetPropertyValueInputBody: Swift.Equatable {
    public let entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]?
}

extension BatchPutAssetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.PutAssetPropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutAssetPropertyValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutAssetPropertyValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchPutAssetPropertyValueOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutAssetPropertyValueOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BatchPutAssetPropertyValueOutputResponse(errorEntries: \(Swift.String(describing: errorEntries)))"}
}

extension BatchPutAssetPropertyValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: BatchPutAssetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchPutAssetPropertyValueOutputResponse: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch put request. Each error entry
    ///       contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]?

    public init (
        errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchPutAssetPropertyValueOutputResponseBody: Swift.Equatable {
    public let errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]?
}

extension BatchPutAssetPropertyValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    public enum CapabilitySyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inSync
        case outOfSync
        case syncFailed
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilitySyncStatus] {
            return [
                .inSync,
                .outOfSync,
                .syncFailed,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inSync: return "IN_SYNC"
            case .outOfSync: return "OUT_OF_SYNC"
            case .syncFailed: return "SYNC_FAILED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapabilitySyncStatus(rawValue: rawValue) ?? CapabilitySyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.CompositeModelProperty: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetProperty
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetProperty = assetProperty {
            try encodeContainer.encode(assetProperty, forKey: .assetProperty)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
    }
}

extension IoTSiteWiseClientTypes.CompositeModelProperty: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CompositeModelProperty(assetProperty: \(Swift.String(describing: assetProperty)), name: \(Swift.String(describing: name)), type: \(Swift.String(describing: type)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model property on an asset.
    public struct CompositeModelProperty: Swift.Equatable {
        /// Contains asset property information.
        /// This member is required.
        public var assetProperty: IoTSiteWiseClientTypes.Property?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the composite model that defines this property.
        /// This member is required.
        public var type: Swift.String?

        public init (
            assetProperty: IoTSiteWiseClientTypes.Property? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.assetProperty = assetProperty
            self.name = name
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ComputeLocation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case edge
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeLocation] {
            return [
                .cloud,
                .edge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .edge: return "EDGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputeLocation(rawValue: rawValue) ?? ComputeLocation.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ConfigurationErrorDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.ConfigurationErrorDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationErrorDetails(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains the details of an IoT SiteWise configuration error.
    public struct ConfigurationErrorDetails: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .active,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationState(rawValue: rawValue) ?? ConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ConfigurationStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes.ConfigurationStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConfigurationStatus(error: \(Swift.String(describing: error)), state: \(Swift.String(describing: state)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains current status information for the configuration.
    public struct ConfigurationStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ConfigurationErrorDetails?
        /// The current state of the configuration.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ConfigurationState?

        public init (
            error: IoTSiteWiseClientTypes.ConfigurationErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.ConfigurationState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension ConflictingOperationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConflictingOperationException(message: \(Swift.String(describing: message)), resourceArn: \(Swift.String(describing: resourceArn)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension ConflictingOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictingOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more
///       than one operation on the same resource at the same time.
public struct ConflictingOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ARN of the resource that conflicts with this operation.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource that conflicts with this operation.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ConflictingOperationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceArn: Swift.String?
}

extension ConflictingOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

public struct CreateAccessPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPolicyOutputError>
}

extension CreateAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessPolicyInput(accessPolicyIdentity: \(Swift.String(describing: accessPolicyIdentity)), accessPolicyPermission: \(Swift.String(describing: accessPolicyPermission)), accessPolicyResource: \(Swift.String(describing: accessPolicyResource)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPolicyOutputError>
}

public struct CreateAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPolicyOutputError>
}

public struct CreateAccessPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAccessPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/access-policies"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAccessPolicyOutputError>
}

public struct CreateAccessPolicyInput: Swift.Equatable {
    /// The identity for this access policy. Choose an Amazon Web Services SSO user, an Amazon Web Services SSO group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the access policy. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your
    ///         IoT SiteWise resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAccessPolicyInputBody: Swift.Equatable {
    public let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    public let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    public let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAccessPolicyOutputResponse(accessPolicyArn: \(Swift.String(describing: accessPolicyArn)), accessPolicyId: \(Swift.String(describing: accessPolicyId)))"}
}

extension CreateAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyId = output.accessPolicyId
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyId = nil
        }
    }
}

public struct CreateAccessPolicyOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the access policy, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    ///
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init (
        accessPolicyArn: Swift.String? = nil,
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyId = accessPolicyId
    }
}

struct CreateAccessPolicyOutputResponseBody: Swift.Equatable {
    public let accessPolicyId: Swift.String?
    public let accessPolicyArn: Swift.String?
}

extension CreateAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyArn
        case accessPolicyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
    }
}

public struct CreateAssetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetOutputError>
}

extension CreateAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetInput(assetModelId: \(Swift.String(describing: assetModelId)), assetName: \(Swift.String(describing: assetName)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAssetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelId = assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetOutputError>
}

public struct CreateAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetOutputError>
}

public struct CreateAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/assets"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetOutputError>
}

public struct CreateAssetInput: Swift.Equatable {
    /// The ID of the asset model from which to create the asset.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique, friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetInputBody: Swift.Equatable {
    public let assetName: Swift.String?
    public let assetModelId: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct CreateAssetModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetModelOutputError>
}

extension CreateAssetModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetModelInput(assetModelCompositeModels: \(Swift.String(describing: assetModelCompositeModels)), assetModelDescription: \(Swift.String(describing: assetModelDescription)), assetModelHierarchies: \(Swift.String(describing: assetModelHierarchies)), assetModelName: \(Swift.String(describing: assetModelName)), assetModelProperties: \(Swift.String(describing: assetModelProperties)), clientToken: \(Swift.String(describing: clientToken)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateAssetModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodeldefinitions0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodeldefinitions0)
            }
        }
        if let assetModelDescription = assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchydefinitions0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchydefinitions0)
            }
        }
        if let assetModelName = assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelpropertydefinitions0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelpropertydefinitions0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateAssetModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetModelOutputError>
}

public struct CreateAssetModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetModelOutputError>
}

public struct CreateAssetModelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateAssetModelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateAssetModelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/asset-models"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateAssetModelInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateAssetModelOutputError>
}

public struct CreateAssetModelInput: Swift.Equatable {
    /// The composite asset models that are part of this asset model.
    ///       Composite asset models are asset models that contain specific properties. Each composite model
    ///       has a type that defines the properties that the composite model supports. Use composite asset
    ///       models to define alarms on this asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model
    ///       whose assets can be children of any other assets created from this asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies in the IoT SiteWise User Guide.
    ///          You can specify up to 10 hierarchies per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]?
    /// A unique, friendly name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The property definitions of the asset model. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties in the IoT SiteWise User Guide.
    ///          You can specify up to 200 properties per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset model. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetModelInputBody: Swift.Equatable {
    public let assetModelName: Swift.String?
    public let assetModelDescription: Swift.String?
    public let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    public let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]?
    public let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateAssetModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertyDefinition?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchyDefinition?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssetModelOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetModelOutputResponse(assetModelArn: \(Swift.String(describing: assetModelArn)), assetModelId: \(Swift.String(describing: assetModelId)), assetModelStatus: \(Swift.String(describing: assetModelStatus)))"}
}

extension CreateAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelArn = output.assetModelArn
            self.assetModelId = output.assetModelId
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelId = nil
            self.assetModelStatus = nil
        }
    }
}

public struct CreateAssetModelOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the asset model, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    ///
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The ID of the asset model. You can use this ID when you call other IoT SiteWise APIs.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The status of the asset model, which contains a state (CREATING after
    ///       successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelArn: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelId = assetModelId
        self.assetModelStatus = assetModelStatus
    }
}

struct CreateAssetModelOutputResponseBody: Swift.Equatable {
    public let assetModelId: Swift.String?
    public let assetModelArn: Swift.String?
    public let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension CreateAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelArn
        case assetModelId
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension CreateAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssetOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAssetOutputResponse(assetArn: \(Swift.String(describing: assetArn)), assetId: \(Swift.String(describing: assetId)), assetStatus: \(Swift.String(describing: assetStatus)))"}
}

extension CreateAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetArn = output.assetArn
            self.assetId = output.assetId
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetId = nil
            self.assetStatus = nil
        }
    }
}

public struct CreateAssetOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the asset, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    ///
    /// This member is required.
    public var assetArn: Swift.String?
    /// The ID of the asset. This ID uniquely identifies the asset within IoT SiteWise and can be used with other
    ///       IoT SiteWise APIs.
    /// This member is required.
    public var assetId: Swift.String?
    /// The status of the asset, which contains a state (CREATING after successfully
    ///       calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetArn: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetId = assetId
        self.assetStatus = assetStatus
    }
}

struct CreateAssetOutputResponseBody: Swift.Equatable {
    public let assetId: Swift.String?
    public let assetArn: Swift.String?
    public let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension CreateAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetArn
        case assetId
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

public struct CreateDashboardInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDashboardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDashboardOutputError>
}

extension CreateDashboardInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDashboardInput(clientToken: \(Swift.String(describing: clientToken)), dashboardDefinition: \(Swift.String(describing: dashboardDefinition)), dashboardDescription: \(Swift.String(describing: dashboardDescription)), dashboardName: \(Swift.String(describing: dashboardName)), projectId: \(Swift.String(describing: projectId)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateDashboardInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
        if let projectId = projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateDashboardInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDashboardOutputError>
}

public struct CreateDashboardInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDashboardOutputError>
}

public struct CreateDashboardInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateDashboardInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateDashboardInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/dashboards"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateDashboardInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateDashboardOutputError>
}

public struct CreateDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The dashboard definition specified in a JSON literal. For detailed information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// A friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project in which to create the dashboard.
    /// This member is required.
    public var projectId: Swift.String?
    /// A list of key-value pairs that contain metadata for the dashboard. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardName = dashboardName
        self.projectId = projectId
        self.tags = tags
    }
}

struct CreateDashboardInputBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let dashboardName: Swift.String?
    public let dashboardDescription: Swift.String?
    public let dashboardDefinition: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDashboardOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateDashboardOutputResponse(dashboardArn: \(Swift.String(describing: dashboardArn)), dashboardId: \(Swift.String(describing: dashboardId)))"}
}

extension CreateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
        }
    }
}

public struct CreateDashboardOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the dashboard, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    ///
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
    }
}

struct CreateDashboardOutputResponseBody: Swift.Equatable {
    public let dashboardId: Swift.String?
    public let dashboardArn: Swift.String?
}

extension CreateDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn
        case dashboardId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
    }
}

public struct CreateGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGatewayOutputError>
}

extension CreateGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGatewayInput(gatewayName: \(Swift.String(describing: gatewayName)), gatewayPlatform: \(Swift.String(describing: gatewayPlatform)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayPlatform = gatewayPlatform {
            try encodeContainer.encode(gatewayPlatform, forKey: .gatewayPlatform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGatewayOutputError>
}

public struct CreateGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGatewayOutputError>
}

public struct CreateGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/20200301/gateways"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateGatewayOutputError>
}

public struct CreateGatewayInput: Swift.Equatable {
    /// A unique, friendly name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform. You can only specify one platform in a gateway.
    /// This member is required.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// A list of key-value pairs that contain metadata for the gateway. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.tags = tags
    }
}

struct CreateGatewayInputBody: Swift.Equatable {
    public let gatewayName: Swift.String?
    public let gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateGatewayOutputResponse(gatewayArn: \(Swift.String(describing: gatewayArn)), gatewayId: \(Swift.String(describing: gatewayId)))"}
}

extension CreateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
            self.gatewayId = output.gatewayId
        } else {
            self.gatewayArn = nil
            self.gatewayId = nil
        }
    }
}

public struct CreateGatewayOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the gateway, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    ///
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise APIs.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
    }
}

struct CreateGatewayOutputResponseBody: Swift.Equatable {
    public let gatewayId: Swift.String?
    public let gatewayArn: Swift.String?
}

extension CreateGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn
        case gatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

public struct CreatePortalInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

extension CreatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalInput(alarms: \(Swift.String(describing: alarms)), clientToken: \(Swift.String(describing: clientToken)), notificationSenderEmail: \(Swift.String(describing: notificationSenderEmail)), portalAuthMode: \(Swift.String(describing: portalAuthMode)), portalContactEmail: \(Swift.String(describing: portalContactEmail)), portalDescription: \(Swift.String(describing: portalDescription)), portalLogoImageFile: \(Swift.String(describing: portalLogoImageFile)), portalName: \(Swift.String(describing: portalName)), roleArn: \(Swift.String(describing: roleArn)), tags: \(Swift.String(describing: tags)))"}
}

extension CreatePortalInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalAuthMode = portalAuthMode {
            try encodeContainer.encode(portalAuthMode.rawValue, forKey: .portalAuthMode)
        }
        if let portalContactEmail = portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImageFile = portalLogoImageFile {
            try encodeContainer.encode(portalLogoImageFile, forKey: .portalLogoImageFile)
        }
        if let portalName = portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreatePortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

public struct CreatePortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

public struct CreatePortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreatePortalInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreatePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/portals"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreatePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreatePortalOutputError>
}

public struct CreatePortalInput: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
    ///   You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.
    ///   For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications.
    ///
    ///             If you use the <a href="https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html">IoT Events managed Lambda
    ///           function to manage your emails, you must <a href="https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html">verify the sender email
    ///           address in Amazon SES.
    ///
    public var notificationSenderEmail: Swift.String?
    /// The service to use to authenticate users to the portal. Choose from the following
    ///       options:
    ///
    ///
    ///
    ///                   SSO  The portal uses Amazon Web Services Single Sign On to authenticate users and manage
    ///           user permissions. Before you can create a portal that uses Amazon Web Services SSO, you must enable Amazon Web Services SSO.
    ///           For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso">Enabling Amazon Web Services SSO in the
    ///             IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than
    ///           the China Regions.
    ///
    ///
    ///
    ///                   IAM  The portal uses Identity and Access Management to authenticate users and manage
    ///           user permissions. This option is only available in the China Regions.
    ///
    ///
    ///          You can't change this value after you create a portal.
    ///          Default: SSO
    ///
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A description for the portal.
    public var portalDescription: Swift.String?
    /// A logo image to display in the portal. Upload a square, high-resolution image. The
    ///       image is displayed on a dark background.
    public var portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile?
    /// A friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of a service role that allows the portal's users to access your IoT SiteWise
    ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor in the
    ///         IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the portal. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalAuthMode = portalAuthMode
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalLogoImageFile = portalLogoImageFile
        self.portalName = portalName
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreatePortalInputBody: Swift.Equatable {
    public let portalName: Swift.String?
    public let portalDescription: Swift.String?
    public let portalContactEmail: Swift.String?
    public let clientToken: Swift.String?
    public let portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile?
    public let roleArn: Swift.String?
    public let tags: [Swift.String:Swift.String]?
    public let portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    public let notificationSenderEmail: Swift.String?
    public let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension CreatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let portalLogoImageFileDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFile.self, forKey: .portalLogoImageFile)
        portalLogoImageFile = portalLogoImageFileDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension CreatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreatePortalOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePortalOutputResponse(portalArn: \(Swift.String(describing: portalArn)), portalId: \(Swift.String(describing: portalId)), portalStartUrl: \(Swift.String(describing: portalStartUrl)), portalStatus: \(Swift.String(describing: portalStatus)), ssoApplicationId: \(Swift.String(describing: ssoApplicationId)))"}
}

extension CreatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.portalId = output.portalId
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.ssoApplicationId = output.ssoApplicationId
        } else {
            self.portalArn = nil
            self.portalId = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.ssoApplicationId = nil
        }
    }
}

public struct CreatePortalOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the portal, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    ///
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ID of the created portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that
    ///       use Amazon Web Services SSO for authentication. For portals that use IAM for authentication, you must use the
    ///       IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The status of the portal, which contains a state (CREATING after successfully
    ///       calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The associated Amazon Web Services SSO application ID, if the portal uses Amazon Web Services SSO.
    /// This member is required.
    public var ssoApplicationId: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        ssoApplicationId: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalId = portalId
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.ssoApplicationId = ssoApplicationId
    }
}

struct CreatePortalOutputResponseBody: Swift.Equatable {
    public let portalId: Swift.String?
    public let portalArn: Swift.String?
    public let portalStartUrl: Swift.String?
    public let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    public let ssoApplicationId: Swift.String?
}

extension CreatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case portalId
        case portalStartUrl
        case portalStatus
        case ssoApplicationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let ssoApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoApplicationId)
        ssoApplicationId = ssoApplicationIdDecoded
    }
}

public struct CreateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

extension CreateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectInput(clientToken: \(Swift.String(describing: clientToken)), portalId: \(Swift.String(describing: portalId)), projectDescription: \(Swift.String(describing: projectDescription)), projectName: \(Swift.String(describing: projectName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let portalId = portalId {
            try encodeContainer.encode(portalId, forKey: .portalId)
        }
        if let projectDescription = projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: CreateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/projects"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = CreateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<CreateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateProjectOutputError>
}

public struct CreateProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal in which to create the project.
    /// This member is required.
    public var portalId: Swift.String?
    /// A description for the project.
    public var projectDescription: Swift.String?
    /// A friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?
    /// A list of key-value pairs that contain metadata for the project. For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
        self.projectDescription = projectDescription
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    public let portalId: Swift.String?
    public let projectName: Swift.String?
    public let projectDescription: Swift.String?
    public let clientToken: Swift.String?
    public let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateProjectOutputResponse(projectArn: \(Swift.String(describing: projectArn)), projectId: \(Swift.String(describing: projectId)))"}
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
            self.projectId = output.projectId
        } else {
            self.projectArn = nil
            self.projectId = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the project, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    ///
    /// This member is required.
    public var projectArn: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectId = projectId
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let projectArn: Swift.String?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension IoTSiteWiseClientTypes.CustomerManagedS3Storage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case s3ResourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ResourceArn = s3ResourceArn {
            try encodeContainer.encode(s3ResourceArn, forKey: .s3ResourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ResourceArn)
        s3ResourceArn = s3ResourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTSiteWiseClientTypes.CustomerManagedS3Storage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CustomerManagedS3Storage(roleArn: \(Swift.String(describing: roleArn)), s3ResourceArn: \(Swift.String(describing: s3ResourceArn)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a customer managed Amazon S3 bucket.
    public struct CustomerManagedS3Storage: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the Amazon S3 object. For more information about how to find the ARN for an
        ///       Amazon S3 object, see <a href="https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html">Amazon S3 resources in the
        ///       Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var s3ResourceArn: Swift.String?

        public init (
            roleArn: Swift.String? = nil,
            s3ResourceArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }
    }

}

extension IoTSiteWiseClientTypes.DashboardSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes.DashboardSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DashboardSummary(creationDate: \(Swift.String(describing: creationDate)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), name: \(Swift.String(describing: name)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a dashboard summary.
    public struct DashboardSummary: Swift.Equatable {
        /// The date the dashboard was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The dashboard's description.
        public var description: Swift.String?
        /// The ID of the dashboard.
        /// This member is required.
        public var id: Swift.String?
        /// The date the dashboard was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the dashboard
        /// This member is required.
        public var name: Swift.String?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }

}

extension DeleteAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessPolicyInput(accessPolicyId: \(Swift.String(describing: accessPolicyId)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension DeleteAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessPolicyOutputError>
}

public struct DeleteAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessPolicyOutputError>
}

public struct DeleteAccessPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAccessPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accessPolicyId = input.accessPolicyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accessPolicyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/access-policies/\(accessPolicyId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAccessPolicyOutputError>
}

public struct DeleteAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy to be deleted.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        accessPolicyId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.clientToken = clientToken
    }
}

struct DeleteAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAccessPolicyOutputResponse()"}
}

extension DeleteAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteAccessPolicyOutputResponseBody: Swift.Equatable {
}

extension DeleteAccessPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssetInput(assetId: \(Swift.String(describing: assetId)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension DeleteAssetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetOutputError>
}

public struct DeleteAssetInput: Swift.Equatable {
    /// The ID of the asset to delete.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
    }
}

struct DeleteAssetInputBody: Swift.Equatable {
}

extension DeleteAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssetModelInput(assetModelId: \(Swift.String(describing: assetModelId)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension DeleteAssetModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteAssetModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetModelOutputError>
}

public struct DeleteAssetModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetModelOutputError>
}

public struct DeleteAssetModelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteAssetModelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteAssetModelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetModelId = input.assetModelId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetModelId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/asset-models/\(assetModelId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteAssetModelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteAssetModelOutputError>
}

public struct DeleteAssetModelInput: Swift.Equatable {
    /// The ID of the asset model to delete.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetModelId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.clientToken = clientToken
    }
}

struct DeleteAssetModelInputBody: Swift.Equatable {
}

extension DeleteAssetModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssetModelOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssetModelOutputResponse(assetModelStatus: \(Swift.String(describing: assetModelStatus)))"}
}

extension DeleteAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct DeleteAssetModelOutputResponse: Swift.Equatable {
    /// The status of the asset model, which contains a state (DELETING after
    ///       successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct DeleteAssetModelOutputResponseBody: Swift.Equatable {
    public let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension DeleteAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension DeleteAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssetOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteAssetOutputResponse(assetStatus: \(Swift.String(describing: assetStatus)))"}
}

extension DeleteAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeleteAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct DeleteAssetOutputResponse: Swift.Equatable {
    /// The status of the asset, which contains a state (DELETING after successfully
    ///       calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct DeleteAssetOutputResponseBody: Swift.Equatable {
    public let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension DeleteAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

extension DeleteDashboardInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDashboardInput(clientToken: \(Swift.String(describing: clientToken)), dashboardId: \(Swift.String(describing: dashboardId)))"}
}

extension DeleteDashboardInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteDashboardInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDashboardOutputError>
}

public struct DeleteDashboardInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDashboardOutputError>
}

public struct DeleteDashboardInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteDashboardInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteDashboardInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dashboardId = input.dashboardId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dashboardId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/dashboards/\(dashboardId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteDashboardInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteDashboardOutputError>
}

public struct DeleteDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the dashboard to delete.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardId = dashboardId
    }
}

struct DeleteDashboardInputBody: Swift.Equatable {
}

extension DeleteDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDashboardOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteDashboardOutputResponse()"}
}

extension DeleteDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDashboardOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteDashboardOutputResponseBody: Swift.Equatable {
}

extension DeleteDashboardOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGatewayInput(gatewayId: \(Swift.String(describing: gatewayId)))"}
}

extension DeleteGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let gatewayId = input.gatewayId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("gatewayId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteGatewayOutputError>
}

public struct DeleteGatewayInput: Swift.Equatable {
    /// The ID of the gateway to delete.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
}

extension DeleteGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteGatewayOutputResponse()"}
}

extension DeleteGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGatewayOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteGatewayOutputResponseBody: Swift.Equatable {
}

extension DeleteGatewayOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortalInput(clientToken: \(Swift.String(describing: clientToken)), portalId: \(Swift.String(describing: portalId)))"}
}

extension DeletePortalInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeletePortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortalOutputError>
}

public struct DeletePortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeletePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeletePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortalOutputError>
}

public struct DeletePortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeletePortalInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeletePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeletePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalId = input.portalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeletePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeletePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeletePortalOutputError>
}

public struct DeletePortalInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal to delete.
    /// This member is required.
    public var portalId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
    }
}

struct DeletePortalInputBody: Swift.Equatable {
}

extension DeletePortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeletePortalOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeletePortalOutputResponse(portalStatus: \(Swift.String(describing: portalStatus)))"}
}

extension DeletePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DeletePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct DeletePortalOutputResponse: Swift.Equatable {
    /// The status of the portal, which contains a state (DELETING after successfully
    ///       calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init (
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct DeletePortalOutputResponseBody: Swift.Equatable {
    public let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
}

extension DeletePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

extension DeleteProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectInput(clientToken: \(Swift.String(describing: clientToken)), projectId: \(Swift.String(describing: projectId)))"}
}

extension DeleteProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DeleteProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientToken = input.operationInput.clientToken {
            let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            input.builder.withQueryItem(clientTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DeleteProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectId = input.projectId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DeleteProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteProjectOutputError>
}

public struct DeleteProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteProjectOutputResponse()"}
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteProjectOutputResponseBody: Swift.Equatable {
}

extension DeleteProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccessPolicyInput(accessPolicyId: \(Swift.String(describing: accessPolicyId)))"}
}

extension DescribeAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessPolicyOutputError>
}

public struct DescribeAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessPolicyOutputError>
}

public struct DescribeAccessPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccessPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accessPolicyId = input.accessPolicyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accessPolicyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/access-policies/\(accessPolicyId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccessPolicyOutputError>
}

public struct DescribeAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init (
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
    }
}

struct DescribeAccessPolicyInputBody: Swift.Equatable {
}

extension DescribeAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccessPolicyOutputResponse(accessPolicyArn: \(Swift.String(describing: accessPolicyArn)), accessPolicyCreationDate: \(Swift.String(describing: accessPolicyCreationDate)), accessPolicyId: \(Swift.String(describing: accessPolicyId)), accessPolicyIdentity: \(Swift.String(describing: accessPolicyIdentity)), accessPolicyLastUpdateDate: \(Swift.String(describing: accessPolicyLastUpdateDate)), accessPolicyPermission: \(Swift.String(describing: accessPolicyPermission)), accessPolicyResource: \(Swift.String(describing: accessPolicyResource)))"}
}

extension DescribeAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyCreationDate = output.accessPolicyCreationDate
            self.accessPolicyId = output.accessPolicyId
            self.accessPolicyIdentity = output.accessPolicyIdentity
            self.accessPolicyLastUpdateDate = output.accessPolicyLastUpdateDate
            self.accessPolicyPermission = output.accessPolicyPermission
            self.accessPolicyResource = output.accessPolicyResource
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyCreationDate = nil
            self.accessPolicyId = nil
            self.accessPolicyIdentity = nil
            self.accessPolicyLastUpdateDate = nil
            self.accessPolicyPermission = nil
            self.accessPolicyResource = nil
        }
    }
}

public struct DescribeAccessPolicyOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the access policy, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    ///
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The date the access policy was created, in Unix epoch time.
    /// This member is required.
    public var accessPolicyCreationDate: ClientRuntime.Date?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity (Amazon Web Services SSO user, Amazon Web Services SSO group, or IAM user) to which this access policy
    ///       applies.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The date the access policy was last updated, in Unix epoch time.
    /// This member is required.
    public var accessPolicyLastUpdateDate: ClientRuntime.Date?
    /// The access policy permission. Note that a project ADMINISTRATOR is also known
    ///       as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides
    ///       access.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?

    public init (
        accessPolicyArn: Swift.String? = nil,
        accessPolicyCreationDate: ClientRuntime.Date? = nil,
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyLastUpdateDate: ClientRuntime.Date? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyCreationDate = accessPolicyCreationDate
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
    }
}

struct DescribeAccessPolicyOutputResponseBody: Swift.Equatable {
    public let accessPolicyId: Swift.String?
    public let accessPolicyArn: Swift.String?
    public let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    public let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    public let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    public let accessPolicyCreationDate: ClientRuntime.Date?
    public let accessPolicyLastUpdateDate: ClientRuntime.Date?
}

extension DescribeAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyArn
        case accessPolicyCreationDate
        case accessPolicyId
        case accessPolicyIdentity
        case accessPolicyLastUpdateDate
        case accessPolicyPermission
        case accessPolicyResource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let accessPolicyCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .accessPolicyCreationDate)
        accessPolicyCreationDate = accessPolicyCreationDateDecoded
        let accessPolicyLastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .accessPolicyLastUpdateDate)
        accessPolicyLastUpdateDate = accessPolicyLastUpdateDateDecoded
    }
}

extension DescribeAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssetInput(assetId: \(Swift.String(describing: assetId)))"}
}

extension DescribeAssetInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetOutputError>
}

public struct DescribeAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetOutputError>
}

public struct DescribeAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetOutputError>
}

public struct DescribeAssetInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?

    public init (
        assetId: Swift.String? = nil
    )
    {
        self.assetId = assetId
    }
}

struct DescribeAssetInputBody: Swift.Equatable {
}

extension DescribeAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssetModelInput(assetModelId: \(Swift.String(describing: assetModelId)))"}
}

extension DescribeAssetModelInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAssetModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetModelOutputError>
}

public struct DescribeAssetModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetModelOutputError>
}

public struct DescribeAssetModelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetModelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAssetModelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetModelId = input.assetModelId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetModelId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/asset-models/\(assetModelId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssetModelInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetModelOutputError>
}

public struct DescribeAssetModelInput: Swift.Equatable {
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?

    public init (
        assetModelId: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
    }
}

struct DescribeAssetModelInputBody: Swift.Equatable {
}

extension DescribeAssetModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssetModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssetModelOutputResponse(assetModelArn: \(Swift.String(describing: assetModelArn)), assetModelCompositeModels: \(Swift.String(describing: assetModelCompositeModels)), assetModelCreationDate: \(Swift.String(describing: assetModelCreationDate)), assetModelDescription: \(Swift.String(describing: assetModelDescription)), assetModelHierarchies: \(Swift.String(describing: assetModelHierarchies)), assetModelId: \(Swift.String(describing: assetModelId)), assetModelLastUpdateDate: \(Swift.String(describing: assetModelLastUpdateDate)), assetModelName: \(Swift.String(describing: assetModelName)), assetModelProperties: \(Swift.String(describing: assetModelProperties)), assetModelStatus: \(Swift.String(describing: assetModelStatus)))"}
}

extension DescribeAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelArn = output.assetModelArn
            self.assetModelCompositeModels = output.assetModelCompositeModels
            self.assetModelCreationDate = output.assetModelCreationDate
            self.assetModelDescription = output.assetModelDescription
            self.assetModelHierarchies = output.assetModelHierarchies
            self.assetModelId = output.assetModelId
            self.assetModelLastUpdateDate = output.assetModelLastUpdateDate
            self.assetModelName = output.assetModelName
            self.assetModelProperties = output.assetModelProperties
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelCompositeModels = nil
            self.assetModelCreationDate = nil
            self.assetModelDescription = nil
            self.assetModelHierarchies = nil
            self.assetModelId = nil
            self.assetModelLastUpdateDate = nil
            self.assetModelName = nil
            self.assetModelProperties = nil
            self.assetModelStatus = nil
        }
    }
}

public struct DescribeAssetModelOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the asset model, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    ///
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The list of composite asset models for the asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// The date the asset model was created, in Unix epoch time.
    /// This member is required.
    public var assetModelCreationDate: ClientRuntime.Date?
    /// The asset model's description.
    /// This member is required.
    public var assetModelDescription: Swift.String?
    /// A list of asset model hierarchies that each contain a childAssetModelId and a
    ///         hierarchyId (named id). A hierarchy specifies allowed parent/child
    ///       asset relationships for an asset model.
    /// This member is required.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The date the asset model was last updated, in Unix epoch time.
    /// This member is required.
    public var assetModelLastUpdateDate: ClientRuntime.Date?
    /// The name of the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The list of asset properties for the asset model.
    ///          This object doesn't include properties that you define in composite models. You can find
    ///       composite model properties in the assetModelCompositeModels object.
    /// This member is required.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// The current status of the asset model, which contains a state and any error
    ///       message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelArn: Swift.String? = nil,
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelCreationDate: ClientRuntime.Date? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelLastUpdateDate: ClientRuntime.Date? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelCreationDate = assetModelCreationDate
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelLastUpdateDate = assetModelLastUpdateDate
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.assetModelStatus = assetModelStatus
    }
}

struct DescribeAssetModelOutputResponseBody: Swift.Equatable {
    public let assetModelId: Swift.String?
    public let assetModelArn: Swift.String?
    public let assetModelName: Swift.String?
    public let assetModelDescription: Swift.String?
    public let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    public let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    public let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    public let assetModelCreationDate: ClientRuntime.Date?
    public let assetModelLastUpdateDate: ClientRuntime.Date?
    public let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension DescribeAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelArn
        case assetModelCompositeModels
        case assetModelCreationDate
        case assetModelDescription
        case assetModelHierarchies
        case assetModelId
        case assetModelLastUpdateDate
        case assetModelName
        case assetModelProperties
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let assetModelCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .assetModelCreationDate)
        assetModelCreationDate = assetModelCreationDateDecoded
        let assetModelLastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .assetModelLastUpdateDate)
        assetModelLastUpdateDate = assetModelLastUpdateDateDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension DescribeAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssetOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssetOutputResponse(assetArn: \(Swift.String(describing: assetArn)), assetCompositeModels: \(Swift.String(describing: assetCompositeModels)), assetCreationDate: \(Swift.String(describing: assetCreationDate)), assetHierarchies: \(Swift.String(describing: assetHierarchies)), assetId: \(Swift.String(describing: assetId)), assetLastUpdateDate: \(Swift.String(describing: assetLastUpdateDate)), assetModelId: \(Swift.String(describing: assetModelId)), assetName: \(Swift.String(describing: assetName)), assetProperties: \(Swift.String(describing: assetProperties)), assetStatus: \(Swift.String(describing: assetStatus)))"}
}

extension DescribeAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetArn = output.assetArn
            self.assetCompositeModels = output.assetCompositeModels
            self.assetCreationDate = output.assetCreationDate
            self.assetHierarchies = output.assetHierarchies
            self.assetId = output.assetId
            self.assetLastUpdateDate = output.assetLastUpdateDate
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperties = output.assetProperties
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetCompositeModels = nil
            self.assetCreationDate = nil
            self.assetHierarchies = nil
            self.assetId = nil
            self.assetLastUpdateDate = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperties = nil
            self.assetStatus = nil
        }
    }
}

public struct DescribeAssetOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the asset, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    ///
    /// This member is required.
    public var assetArn: Swift.String?
    /// The composite models for the asset.
    public var assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]?
    /// The date the asset was created, in Unix epoch time.
    /// This member is required.
    public var assetCreationDate: ClientRuntime.Date?
    /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
    /// This member is required.
    public var assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The date the asset was last updated, in Unix epoch time.
    /// This member is required.
    public var assetLastUpdateDate: ClientRuntime.Date?
    /// The ID of the asset model that was used to create the asset.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The list of asset properties for the asset.
    ///          This object doesn't include properties that you define in composite models. You can find
    ///       composite model properties in the assetCompositeModels object.
    /// This member is required.
    public var assetProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    /// The current status of the asset, which contains a state and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetArn: Swift.String? = nil,
        assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]? = nil,
        assetCreationDate: ClientRuntime.Date? = nil,
        assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
        assetId: Swift.String? = nil,
        assetLastUpdateDate: ClientRuntime.Date? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetCompositeModels = assetCompositeModels
        self.assetCreationDate = assetCreationDate
        self.assetHierarchies = assetHierarchies
        self.assetId = assetId
        self.assetLastUpdateDate = assetLastUpdateDate
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperties = assetProperties
        self.assetStatus = assetStatus
    }
}

struct DescribeAssetOutputResponseBody: Swift.Equatable {
    public let assetId: Swift.String?
    public let assetArn: Swift.String?
    public let assetName: Swift.String?
    public let assetModelId: Swift.String?
    public let assetProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    public let assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
    public let assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]?
    public let assetCreationDate: ClientRuntime.Date?
    public let assetLastUpdateDate: ClientRuntime.Date?
    public let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension DescribeAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetArn
        case assetCompositeModels
        case assetCreationDate
        case assetHierarchies
        case assetId
        case assetLastUpdateDate
        case assetModelId
        case assetName
        case assetProperties
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetProperty?].self, forKey: .assetProperties)
        var assetPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetProperty]? = nil
        if let assetPropertiesContainer = assetPropertiesContainer {
            assetPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetProperty]()
            for structure0 in assetPropertiesContainer {
                if let structure0 = structure0 {
                    assetPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetProperties = assetPropertiesDecoded0
        let assetHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .assetHierarchies)
        var assetHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let assetHierarchiesContainer = assetHierarchiesContainer {
            assetHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in assetHierarchiesContainer {
                if let structure0 = structure0 {
                    assetHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetHierarchies = assetHierarchiesDecoded0
        let assetCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetCompositeModel?].self, forKey: .assetCompositeModels)
        var assetCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetCompositeModel]? = nil
        if let assetCompositeModelsContainer = assetCompositeModelsContainer {
            assetCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetCompositeModel]()
            for structure0 in assetCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetCompositeModels = assetCompositeModelsDecoded0
        let assetCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .assetCreationDate)
        assetCreationDate = assetCreationDateDecoded
        let assetLastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .assetLastUpdateDate)
        assetLastUpdateDate = assetLastUpdateDateDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

extension DescribeAssetPropertyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssetPropertyInput(assetId: \(Swift.String(describing: assetId)), propertyId: \(Swift.String(describing: propertyId)))"}
}

extension DescribeAssetPropertyInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAssetPropertyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetPropertyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssetPropertyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssetPropertyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetPropertyOutputError>
}

public struct DescribeAssetPropertyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetPropertyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAssetPropertyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAssetPropertyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetPropertyOutputError>
}

public struct DescribeAssetPropertyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAssetPropertyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeAssetPropertyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        guard let propertyId = input.propertyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("propertyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeAssetPropertyInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAssetPropertyOutputError>
}

public struct DescribeAssetPropertyInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset property.
    /// This member is required.
    public var propertyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

struct DescribeAssetPropertyInputBody: Swift.Equatable {
}

extension DescribeAssetPropertyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetPropertyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetPropertyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssetPropertyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetPropertyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAssetPropertyOutputResponse(assetId: \(Swift.String(describing: assetId)), assetModelId: \(Swift.String(describing: assetModelId)), assetName: \(Swift.String(describing: assetName)), assetProperty: \(Swift.String(describing: assetProperty)), compositeModel: \(Swift.String(describing: compositeModel)))"}
}

extension DescribeAssetPropertyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAssetPropertyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetId = output.assetId
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperty = output.assetProperty
            self.compositeModel = output.compositeModel
        } else {
            self.assetId = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperty = nil
            self.compositeModel = nil
        }
    }
}

public struct DescribeAssetPropertyOutputResponse: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The asset property's definition, alias, and notification state.
    ///          This response includes this object for normal asset properties. If you describe an asset
    ///       property in a composite model, this response includes the asset property information in
    ///         compositeModel.
    public var assetProperty: IoTSiteWiseClientTypes.Property?
    /// The composite asset model that declares this asset property, if this asset property exists
    ///       in a composite model.
    public var compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty?

    public init (
        assetId: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperty: IoTSiteWiseClientTypes.Property? = nil,
        compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty? = nil
    )
    {
        self.assetId = assetId
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperty = assetProperty
        self.compositeModel = compositeModel
    }
}

struct DescribeAssetPropertyOutputResponseBody: Swift.Equatable {
    public let assetId: Swift.String?
    public let assetName: Swift.String?
    public let assetModelId: Swift.String?
    public let assetProperty: IoTSiteWiseClientTypes.Property?
    public let compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty?
}

extension DescribeAssetPropertyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case assetModelId
        case assetName
        case assetProperty
        case compositeModel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
        let compositeModelDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CompositeModelProperty.self, forKey: .compositeModel)
        compositeModel = compositeModelDecoded
    }
}

extension DescribeDashboardInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDashboardInput(dashboardId: \(Swift.String(describing: dashboardId)))"}
}

extension DescribeDashboardInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDashboardInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDashboardOutputError>
}

public struct DescribeDashboardInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDashboardOutputError>
}

public struct DescribeDashboardInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDashboardInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDashboardInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dashboardId = input.dashboardId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dashboardId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/dashboards/\(dashboardId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDashboardInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDashboardOutputError>
}

public struct DescribeDashboardInput: Swift.Equatable {
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardId = dashboardId
    }
}

struct DescribeDashboardInputBody: Swift.Equatable {
}

extension DescribeDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDashboardOutputResponse(dashboardArn: \(Swift.String(describing: dashboardArn)), dashboardCreationDate: \(Swift.String(describing: dashboardCreationDate)), dashboardDefinition: \(Swift.String(describing: dashboardDefinition)), dashboardDescription: \(Swift.String(describing: dashboardDescription)), dashboardId: \(Swift.String(describing: dashboardId)), dashboardLastUpdateDate: \(Swift.String(describing: dashboardLastUpdateDate)), dashboardName: \(Swift.String(describing: dashboardName)), projectId: \(Swift.String(describing: projectId)))"}
}

extension DescribeDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardCreationDate = output.dashboardCreationDate
            self.dashboardDefinition = output.dashboardDefinition
            self.dashboardDescription = output.dashboardDescription
            self.dashboardId = output.dashboardId
            self.dashboardLastUpdateDate = output.dashboardLastUpdateDate
            self.dashboardName = output.dashboardName
            self.projectId = output.projectId
        } else {
            self.dashboardArn = nil
            self.dashboardCreationDate = nil
            self.dashboardDefinition = nil
            self.dashboardDescription = nil
            self.dashboardId = nil
            self.dashboardLastUpdateDate = nil
            self.dashboardName = nil
            self.projectId = nil
        }
    }
}

public struct DescribeDashboardOutputResponse: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the dashboard, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    ///
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The date the dashboard was created, in Unix epoch time.
    /// This member is required.
    public var dashboardCreationDate: ClientRuntime.Date?
    /// The dashboard's definition JSON literal. For detailed information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating
    ///         dashboards (CLI) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// The dashboard's description.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The date the dashboard was last updated, in Unix epoch time.
    /// This member is required.
    public var dashboardLastUpdateDate: ClientRuntime.Date?
    /// The name of the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project that the dashboard is in.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardCreationDate: ClientRuntime.Date? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardLastUpdateDate: ClientRuntime.Date? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardCreationDate = dashboardCreationDate
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardLastUpdateDate = dashboardLastUpdateDate
        self.dashboardName = dashboardName
        self.projectId = projectId
    }
}

struct DescribeDashboardOutputResponseBody: Swift.Equatable {
    public let dashboardId: Swift.String?
    public let dashboardArn: Swift.String?
    public let dashboardName: Swift.String?
    public let projectId: Swift.String?
    public let dashboardDescription: Swift.String?
    public let dashboardDefinition: Swift.String?
    public let dashboardCreationDate: ClientRuntime.Date?
    public let dashboardLastUpdateDate: ClientRuntime.Date?
}

extension DescribeDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn
        case dashboardCreationDate
        case dashboardDefinition
        case dashboardDescription
        case dashboardId
        case dashboardLastUpdateDate
        case dashboardName
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let dashboardCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dashboardCreationDate)
        dashboardCreationDate = dashboardCreationDateDecoded
        let dashboardLastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .dashboardLastUpdateDate)
        dashboardLastUpdateDate = dashboardLastUpdateDateDecoded
    }
}

extension DescribeDefaultEncryptionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultEncryptionConfigurationInput()"}
}

extension DescribeDefaultEncryptionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeDefaultEncryptionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultEncryptionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultEncryptionConfigurationOutputError>
}

public struct DescribeDefaultEncryptionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultEncryptionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeDefaultEncryptionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultEncryptionConfigurationOutputError>
}

public struct DescribeDefaultEncryptionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeDefaultEncryptionConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeDefaultEncryptionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/configuration/account/encryption"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeDefaultEncryptionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeDefaultEncryptionConfigurationOutputError>
}

public struct DescribeDefaultEncryptionConfigurationInput: Swift.Equatable {

    public init() {}
}

struct DescribeDefaultEncryptionConfigurationInputBody: Swift.Equatable {
}

extension DescribeDefaultEncryptionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDefaultEncryptionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultEncryptionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeDefaultEncryptionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultEncryptionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeDefaultEncryptionConfigurationOutputResponse(configurationStatus: \(Swift.String(describing: configurationStatus)), encryptionType: \(Swift.String(describing: encryptionType)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)))"}
}

extension DescribeDefaultEncryptionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeDefaultEncryptionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct DescribeDefaultEncryptionConfigurationOutputResponse: Swift.Equatable {
    /// The status of the account configuration. This contains the
    ///       ConfigurationState. If there's an error, it also contains the
    ///         ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The key ARN of the customer managed customer master key (CMK) used for KMS encryption if
    ///       you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct DescribeDefaultEncryptionConfigurationOutputResponseBody: Swift.Equatable {
    public let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    public let kmsKeyArn: Swift.String?
    public let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension DescribeDefaultEncryptionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

extension DescribeGatewayCapabilityConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGatewayCapabilityConfigurationInput(capabilityNamespace: \(Swift.String(describing: capabilityNamespace)), gatewayId: \(Swift.String(describing: gatewayId)))"}
}

extension DescribeGatewayCapabilityConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeGatewayCapabilityConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayCapabilityConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayCapabilityConfigurationOutputError>
}

public struct DescribeGatewayCapabilityConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayCapabilityConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGatewayCapabilityConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayCapabilityConfigurationOutputError>
}

public struct DescribeGatewayCapabilityConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayCapabilityConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeGatewayCapabilityConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let gatewayId = input.gatewayId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("gatewayId is nil and needs a value for the path of this operation"))))
        }
        guard let capabilityNamespace = input.capabilityNamespace else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("capabilityNamespace is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability/\(capabilityNamespace.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGatewayCapabilityConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayCapabilityConfigurationOutputError>
}

public struct DescribeGatewayCapabilityConfigurationInput: Swift.Equatable {
    /// The namespace of the capability configuration.
    ///       For example, if you configure OPC-UA
    ///       sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace
    ///         iotsitewise:opcuacollector:version, where version is a number such as
    ///         1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationInputBody: Swift.Equatable {
}

extension DescribeGatewayCapabilityConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayCapabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayCapabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGatewayCapabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayCapabilityConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGatewayCapabilityConfigurationOutputResponse(capabilityConfiguration: \(Swift.String(describing: capabilityConfiguration)), capabilityNamespace: \(Swift.String(describing: capabilityNamespace)), capabilitySyncStatus: \(Swift.String(describing: capabilitySyncStatus)), gatewayId: \(Swift.String(describing: gatewayId)))"}
}

extension DescribeGatewayCapabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGatewayCapabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.capabilityConfiguration = output.capabilityConfiguration
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
            self.gatewayId = output.gatewayId
        } else {
            self.capabilityConfiguration = nil
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
            self.gatewayId = nil
        }
    }
}

public struct DescribeGatewayCapabilityConfigurationOutputResponse: Swift.Equatable {
    /// The JSON document that defines the gateway capability's configuration. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    ///
    ///
    ///                   IN_SYNC  The gateway is running the capability configuration.
    ///
    ///
    ///
    ///                   OUT_OF_SYNC  The gateway hasn't received the capability configuration.
    ///
    ///
    ///
    ///                   SYNC_FAILED  The gateway rejected the capability configuration.
    ///
    ///
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationOutputResponseBody: Swift.Equatable {
    public let gatewayId: Swift.String?
    public let capabilityNamespace: Swift.String?
    public let capabilityConfiguration: Swift.String?
    public let capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
}

extension DescribeGatewayCapabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
        case capabilitySyncStatus
        case gatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension DescribeGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGatewayInput(gatewayId: \(Swift.String(describing: gatewayId)))"}
}

extension DescribeGatewayInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayOutputError>
}

public struct DescribeGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayOutputError>
}

public struct DescribeGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let gatewayId = input.gatewayId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("gatewayId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeGatewayOutputError>
}

public struct DescribeGatewayInput: Swift.Equatable {
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayInputBody: Swift.Equatable {
}

extension DescribeGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeGatewayOutputResponse(creationDate: \(Swift.String(describing: creationDate)), gatewayArn: \(Swift.String(describing: gatewayArn)), gatewayCapabilitySummaries: \(Swift.String(describing: gatewayCapabilitySummaries)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayName: \(Swift.String(describing: gatewayName)), gatewayPlatform: \(Swift.String(describing: gatewayPlatform)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)))"}
}

extension DescribeGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.gatewayArn = output.gatewayArn
            self.gatewayCapabilitySummaries = output.gatewayCapabilitySummaries
            self.gatewayId = output.gatewayId
            self.gatewayName = output.gatewayName
            self.gatewayPlatform = output.gatewayPlatform
            self.lastUpdateDate = output.lastUpdateDate
        } else {
            self.creationDate = nil
            self.gatewayArn = nil
            self.gatewayCapabilitySummaries = nil
            self.gatewayId = nil
            self.gatewayName = nil
            self.gatewayPlatform = nil
            self.lastUpdateDate = nil
        }
    }
}

public struct DescribeGatewayOutputResponse: Swift.Equatable {
    /// The date the gateway was created, in Unix epoch time.
    /// This member is required.
    public var creationDate: ClientRuntime.Date?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the gateway, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    ///
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// A list of gateway capability summaries that each contain a namespace and status. Each
    ///       gateway capability defines data sources for the gateway. To retrieve a capability
    ///       configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration.
    /// This member is required.
    public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The name of the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// The date the gateway was last updated, in Unix epoch time.
    /// This member is required.
    public var lastUpdateDate: ClientRuntime.Date?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        gatewayArn: Swift.String? = nil,
        gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        lastUpdateDate: ClientRuntime.Date? = nil
    )
    {
        self.creationDate = creationDate
        self.gatewayArn = gatewayArn
        self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.lastUpdateDate = lastUpdateDate
    }
}

struct DescribeGatewayOutputResponseBody: Swift.Equatable {
    public let gatewayId: Swift.String?
    public let gatewayName: Swift.String?
    public let gatewayArn: Swift.String?
    public let gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    public let gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
    public let creationDate: ClientRuntime.Date?
    public let lastUpdateDate: ClientRuntime.Date?
}

extension DescribeGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case gatewayArn
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case gatewayPlatform
        case lastUpdateDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension DescribeLoggingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingOptionsInput()"}
}

extension DescribeLoggingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeLoggingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeLoggingOptionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeLoggingOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/logging"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeLoggingOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeLoggingOptionsOutputError>
}

public struct DescribeLoggingOptionsInput: Swift.Equatable {

    public init() {}
}

struct DescribeLoggingOptionsInputBody: Swift.Equatable {
}

extension DescribeLoggingOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeLoggingOptionsOutputResponse(loggingOptions: \(Swift.String(describing: loggingOptions)))"}
}

extension DescribeLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Swift.Equatable {
    /// The current logging options.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Swift.Equatable {
    public let loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension DescribePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortalInput(portalId: \(Swift.String(describing: portalId)))"}
}

extension DescribePortalInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribePortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortalOutputError>
}

public struct DescribePortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortalOutputError>
}

public struct DescribePortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribePortalInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalId = input.portalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribePortalOutputError>
}

public struct DescribePortalInput: Swift.Equatable {
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init (
        portalId: Swift.String? = nil
    )
    {
        self.portalId = portalId
    }
}

struct DescribePortalInputBody: Swift.Equatable {
}

extension DescribePortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribePortalOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribePortalOutputResponse(alarms: \(Swift.String(describing: alarms)), notificationSenderEmail: \(Swift.String(describing: notificationSenderEmail)), portalArn: \(Swift.String(describing: portalArn)), portalAuthMode: \(Swift.String(describing: portalAuthMode)), portalClientId: \(Swift.String(describing: portalClientId)), portalContactEmail: \(Swift.String(describing: portalContactEmail)), portalCreationDate: \(Swift.String(describing: portalCreationDate)), portalDescription: \(Swift.String(describing: portalDescription)), portalId: \(Swift.String(describing: portalId)), portalLastUpdateDate: \(Swift.String(describing: portalLastUpdateDate)), portalLogoImageLocation: \(Swift.String(describing: portalLogoImageLocation)), portalName: \(Swift.String(describing: portalName)), portalStartUrl: \(Swift.String(describing: portalStartUrl)), portalStatus: \(Swift.String(describing: portalStatus)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension DescribePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarms = output.alarms
            self.notificationSenderEmail = output.notificationSenderEmail
            self.portalArn = output.portalArn
            self.portalAuthMode = output.portalAuthMode
            self.portalClientId = output.portalClientId
            self.portalContactEmail = output.portalContactEmail
            self.portalCreationDate = output.portalCreationDate
            self.portalDescription = output.portalDescription
            self.portalId = output.portalId
            self.portalLastUpdateDate = output.portalLastUpdateDate
            self.portalLogoImageLocation = output.portalLogoImageLocation
            self.portalName = output.portalName
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.roleArn = output.roleArn
        } else {
            self.alarms = nil
            self.notificationSenderEmail = nil
            self.portalArn = nil
            self.portalAuthMode = nil
            self.portalClientId = nil
            self.portalContactEmail = nil
            self.portalCreationDate = nil
            self.portalDescription = nil
            self.portalId = nil
            self.portalLastUpdateDate = nil
            self.portalLogoImageLocation = nil
            self.portalName = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.roleArn = nil
        }
    }
}

public struct DescribePortalOutputResponse: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the portal, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    ///
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service to use to authenticate users to the portal.
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The Amazon Web Services SSO application generated client ID (used with Amazon Web Services SSO APIs). IoT SiteWise includes
    ///         portalClientId for only portals that use Amazon Web Services SSO to authenticate users.
    /// This member is required.
    public var portalClientId: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// The date the portal was created, in Unix epoch time.
    /// This member is required.
    public var portalCreationDate: ClientRuntime.Date?
    /// The portal's description.
    public var portalDescription: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The date the portal was last updated, in Unix epoch time.
    /// This member is required.
    public var portalLastUpdateDate: ClientRuntime.Date?
    /// The portal's logo image, which is available at a URL.
    public var portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation?
    /// The name of the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that
    ///       use Amazon Web Services SSO for authentication. For portals that use IAM for authentication, you must use the
    ///       IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The current status of the portal, which contains a state and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the service role that allows the portal's users to access your IoT SiteWise
    ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor in the
    ///         IoT SiteWise User Guide.
    public var roleArn: Swift.String?

    public init (
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalArn: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalClientId: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalCreationDate: ClientRuntime.Date? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLastUpdateDate: ClientRuntime.Date? = nil,
        portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation? = nil,
        portalName: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.notificationSenderEmail = notificationSenderEmail
        self.portalArn = portalArn
        self.portalAuthMode = portalAuthMode
        self.portalClientId = portalClientId
        self.portalContactEmail = portalContactEmail
        self.portalCreationDate = portalCreationDate
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLastUpdateDate = portalLastUpdateDate
        self.portalLogoImageLocation = portalLogoImageLocation
        self.portalName = portalName
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.roleArn = roleArn
    }
}

struct DescribePortalOutputResponseBody: Swift.Equatable {
    public let portalId: Swift.String?
    public let portalArn: Swift.String?
    public let portalName: Swift.String?
    public let portalDescription: Swift.String?
    public let portalClientId: Swift.String?
    public let portalStartUrl: Swift.String?
    public let portalContactEmail: Swift.String?
    public let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    public let portalCreationDate: ClientRuntime.Date?
    public let portalLastUpdateDate: ClientRuntime.Date?
    public let portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation?
    public let roleArn: Swift.String?
    public let portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    public let notificationSenderEmail: Swift.String?
    public let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension DescribePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case notificationSenderEmail
        case portalArn
        case portalAuthMode
        case portalClientId
        case portalContactEmail
        case portalCreationDate
        case portalDescription
        case portalId
        case portalLastUpdateDate
        case portalLogoImageLocation
        case portalName
        case portalStartUrl
        case portalStatus
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalClientId)
        portalClientId = portalClientIdDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .portalCreationDate)
        portalCreationDate = portalCreationDateDecoded
        let portalLastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .portalLastUpdateDate)
        portalLastUpdateDate = portalLastUpdateDateDecoded
        let portalLogoImageLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageLocation.self, forKey: .portalLogoImageLocation)
        portalLogoImageLocation = portalLogoImageLocationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension DescribeProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectInput(projectId: \(Swift.String(describing: projectId)))"}
}

extension DescribeProjectInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectId = input.projectId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeProjectOutputError>
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeProjectOutputResponse(portalId: \(Swift.String(describing: portalId)), projectArn: \(Swift.String(describing: projectArn)), projectCreationDate: \(Swift.String(describing: projectCreationDate)), projectDescription: \(Swift.String(describing: projectDescription)), projectId: \(Swift.String(describing: projectId)), projectLastUpdateDate: \(Swift.String(describing: projectLastUpdateDate)), projectName: \(Swift.String(describing: projectName)))"}
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalId = output.portalId
            self.projectArn = output.projectArn
            self.projectCreationDate = output.projectCreationDate
            self.projectDescription = output.projectDescription
            self.projectId = output.projectId
            self.projectLastUpdateDate = output.projectLastUpdateDate
            self.projectName = output.projectName
        } else {
            self.portalId = nil
            self.projectArn = nil
            self.projectCreationDate = nil
            self.projectDescription = nil
            self.projectId = nil
            self.projectLastUpdateDate = nil
            self.projectName = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// The ID of the portal that the project is in.
    /// This member is required.
    public var portalId: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the project, which has the following format.
    ///
    ///             arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    ///
    /// This member is required.
    public var projectArn: Swift.String?
    /// The date the project was created, in Unix epoch time.
    /// This member is required.
    public var projectCreationDate: ClientRuntime.Date?
    /// The project's description.
    public var projectDescription: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The date the project was last updated, in Unix epoch time.
    /// This member is required.
    public var projectLastUpdateDate: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        portalId: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        projectCreationDate: ClientRuntime.Date? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectLastUpdateDate: ClientRuntime.Date? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.portalId = portalId
        self.projectArn = projectArn
        self.projectCreationDate = projectCreationDate
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectLastUpdateDate = projectLastUpdateDate
        self.projectName = projectName
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    public let projectId: Swift.String?
    public let projectArn: Swift.String?
    public let projectName: Swift.String?
    public let portalId: Swift.String?
    public let projectDescription: Swift.String?
    public let projectCreationDate: ClientRuntime.Date?
    public let projectLastUpdateDate: ClientRuntime.Date?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalId
        case projectArn
        case projectCreationDate
        case projectDescription
        case projectId
        case projectLastUpdateDate
        case projectName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let projectCreationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .projectCreationDate)
        projectCreationDate = projectCreationDateDecoded
        let projectLastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .projectLastUpdateDate)
        projectLastUpdateDate = projectLastUpdateDateDecoded
    }
}

extension DescribeStorageConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStorageConfigurationInput()"}
}

extension DescribeStorageConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeStorageConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorageConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorageConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorageConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorageConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorageConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorageConfigurationOutputError>
}

public struct DescribeStorageConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorageConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeStorageConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorageConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeStorageConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorageConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorageConfigurationOutputError>
}

public struct DescribeStorageConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeStorageConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DescribeStorageConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeStorageConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/configuration/account/storage"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DescribeStorageConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeStorageConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeStorageConfigurationOutputError>
}

public struct DescribeStorageConfigurationInput: Swift.Equatable {

    public init() {}
}

struct DescribeStorageConfigurationInputBody: Swift.Equatable {
}

extension DescribeStorageConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeStorageConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStorageConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeStorageConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStorageConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeStorageConfigurationOutputResponse(configurationStatus: \(Swift.String(describing: configurationStatus)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), multiLayerStorage: \(Swift.String(describing: multiLayerStorage)), storageType: \(Swift.String(describing: storageType)))"}
}

extension DescribeStorageConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeStorageConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.lastUpdateDate = output.lastUpdateDate
            self.multiLayerStorage = output.multiLayerStorage
            self.storageType = output.storageType
        } else {
            self.configurationStatus = nil
            self.lastUpdateDate = nil
            self.multiLayerStorage = nil
            self.storageType = nil
        }
    }
}

public struct DescribeStorageConfigurationOutputResponse: Swift.Equatable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The date the storage configuration was last updated, in Unix epoch time.
    public var lastUpdateDate: ClientRuntime.Date?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// The type of storage that you specified for your data. The storage type can be one of the following values:
    ///
    ///
    ///
    ///                   SITEWISE_DEFAULT_STORAGE  IoT SiteWise replicates your data into a service managed database.
    ///
    ///
    ///
    ///                   MULTI_LAYER_STORAGE  IoT SiteWise replicates your data into a service managed database and saves a copy of your raw data and metadata in an Amazon S3 object that you specified.
    ///
    ///
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        lastUpdateDate: ClientRuntime.Date? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.lastUpdateDate = lastUpdateDate
        self.multiLayerStorage = multiLayerStorage
        self.storageType = storageType
    }
}

struct DescribeStorageConfigurationOutputResponseBody: Swift.Equatable {
    public let storageType: IoTSiteWiseClientTypes.StorageType?
    public let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    public let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    public let lastUpdateDate: ClientRuntime.Date?
}

extension DescribeStorageConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case lastUpdateDate
        case multiLayerStorage
        case storageType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes.DetailedError: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DetailedErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.DetailedError: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DetailedError(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains detailed error information.
    public struct DetailedError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.DetailedErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.DetailedErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum DetailedErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case incompatibleComputeLocation
        case incompatibleForwardingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailedErrorCode] {
            return [
                .incompatibleComputeLocation,
                .incompatibleForwardingConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .incompatibleComputeLocation: return "INCOMPATIBLE_COMPUTE_LOCATION"
            case .incompatibleForwardingConfiguration: return "INCOMPATIBLE_FORWARDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailedErrorCode(rawValue: rawValue) ?? DetailedErrorCode.sdkUnknown(rawValue)
        }
    }
}

public struct DisassociateAssetsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAssetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAssetsOutputError>
}

extension DisassociateAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateAssetsInput(assetId: \(Swift.String(describing: assetId)), childAssetId: \(Swift.String(describing: childAssetId)), clientToken: \(Swift.String(describing: clientToken)), hierarchyId: \(Swift.String(describing: hierarchyId)))"}
}

extension DisassociateAssetsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

public struct DisassociateAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAssetsOutputError>
}

public struct DisassociateAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAssetsOutputError>
}

public struct DisassociateAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: DisassociateAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())/disassociate"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = DisassociateAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateAssetsOutputError>
}

public struct DisassociateAssetsInput: Swift.Equatable {
    /// The ID of the parent asset from which to disassociate the child asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to disassociate.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings
    ///       of assets to be formed that all come from the same asset model. You can use the hierarchy ID
    ///       to identify the correct asset to disassociate. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct DisassociateAssetsInputBody: Swift.Equatable {
    public let hierarchyId: Swift.String?
    public let childAssetId: Swift.String?
    public let clientToken: Swift.String?
}

extension DisassociateAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateAssetsOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateAssetsOutputResponse()"}
}

extension DisassociateAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAssetsOutputResponse: Swift.Equatable {

    public init() {}
}

struct DisassociateAssetsOutputResponseBody: Swift.Equatable {
}

extension DisassociateAssetsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTSiteWiseClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kmsBasedEncryption
        case sitewiseDefaultEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kmsBasedEncryption,
                .sitewiseDefaultEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kmsBasedEncryption: return "KMS_BASED_ENCRYPTION"
            case .sitewiseDefaultEncryption: return "SITEWISE_DEFAULT_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalFailure,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ErrorDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case details
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .details)
            for detailederrors0 in details {
                try detailsContainer.encode(detailederrors0)
            }
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let detailsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.DetailedError?].self, forKey: .details)
        var detailsDecoded0:[IoTSiteWiseClientTypes.DetailedError]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [IoTSiteWiseClientTypes.DetailedError]()
            for structure0 in detailsContainer {
                if let structure0 = structure0 {
                    detailsDecoded0?.append(structure0)
                }
            }
        }
        details = detailsDecoded0
    }
}

extension IoTSiteWiseClientTypes.ErrorDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ErrorDetails(code: \(Swift.String(describing: code)), details: \(Swift.String(describing: details)), message: \(Swift.String(describing: message)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains the details of an IoT SiteWise error.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        ///  A list of detailed errors.
        public var details: [IoTSiteWiseClientTypes.DetailedError]?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            details: [IoTSiteWiseClientTypes.DetailedError]? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.details = details
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.ExpressionVariable: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes.ExpressionVariable: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpressionVariable(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains expression variable information.
    public struct ExpressionVariable: Swift.Equatable {
        /// The friendly name of the variable to be used in the expression.
        /// This member is required.
        public var name: Swift.String?
        /// The variable that identifies an asset property from which to use values.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.VariableValue?

        public init (
            name: Swift.String? = nil,
            value: IoTSiteWiseClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.ForwardingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfigState.self, forKey: .state)
        state = stateDecoded
    }
}

extension IoTSiteWiseClientTypes.ForwardingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ForwardingConfig(state: \(Swift.String(describing: state)))"}
}

extension IoTSiteWiseClientTypes {
    /// The forwarding configuration for a given property.
    public struct ForwardingConfig: Swift.Equatable {
        /// The forwarding state for the given property.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ForwardingConfigState?

        public init (
            state: IoTSiteWiseClientTypes.ForwardingConfigState? = nil
        )
        {
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ForwardingConfigState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ForwardingConfigState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ForwardingConfigState(rawValue: rawValue) ?? ForwardingConfigState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.GatewayCapabilitySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityNamespace = capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
        if let capabilitySyncStatus = capabilitySyncStatus {
            try encodeContainer.encode(capabilitySyncStatus.rawValue, forKey: .capabilitySyncStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension IoTSiteWiseClientTypes.GatewayCapabilitySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GatewayCapabilitySummary(capabilityNamespace: \(Swift.String(describing: capabilityNamespace)), capabilitySyncStatus: \(Swift.String(describing: capabilitySyncStatus)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a gateway capability configuration.
    public struct GatewayCapabilitySummary: Swift.Equatable {
        /// The namespace of the capability configuration.
        ///       For example, if you configure OPC-UA
        ///       sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace
        ///         iotsitewise:opcuacollector:version, where version is a number such as
        ///         1.
        /// This member is required.
        public var capabilityNamespace: Swift.String?
        /// The synchronization status of the capability configuration. The sync status can be one of the following:
        ///
        ///
        ///
        ///                   IN_SYNC  The gateway is running the capability configuration.
        ///
        ///
        ///
        ///                   OUT_OF_SYNC  The gateway hasn't received the capability configuration.
        ///
        ///
        ///
        ///                   SYNC_FAILED  The gateway rejected the capability configuration.
        ///
        ///
        /// This member is required.
        public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

        public init (
            capabilityNamespace: Swift.String? = nil,
            capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
        )
        {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }
    }

}

extension IoTSiteWiseClientTypes.GatewayPlatform: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case greengrass
        case greengrassV2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let greengrass = greengrass {
            try encodeContainer.encode(greengrass, forKey: .greengrass)
        }
        if let greengrassV2 = greengrassV2 {
            try encodeContainer.encode(greengrassV2, forKey: .greengrassV2)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let greengrassDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Greengrass.self, forKey: .greengrass)
        greengrass = greengrassDecoded
        let greengrassV2Decoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GreengrassV2.self, forKey: .greengrassV2)
        greengrassV2 = greengrassV2Decoded
    }
}

extension IoTSiteWiseClientTypes.GatewayPlatform: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GatewayPlatform(greengrass: \(Swift.String(describing: greengrass)), greengrassV2: \(Swift.String(describing: greengrassV2)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a gateway's platform information.
    public struct GatewayPlatform: Swift.Equatable {
        /// A gateway that runs on IoT Greengrass.
        public var greengrass: IoTSiteWiseClientTypes.Greengrass?
        /// A gateway that runs on IoT Greengrass V2.
        public var greengrassV2: IoTSiteWiseClientTypes.GreengrassV2?

        public init (
            greengrass: IoTSiteWiseClientTypes.Greengrass? = nil,
            greengrassV2: IoTSiteWiseClientTypes.GreengrassV2? = nil
        )
        {
            self.greengrass = greengrass
            self.greengrassV2 = greengrassV2
        }
    }

}

extension IoTSiteWiseClientTypes.GatewaySummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case gatewayPlatform
        case lastUpdateDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let gatewayCapabilitySummaries = gatewayCapabilitySummaries {
            var gatewayCapabilitySummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayCapabilitySummaries)
            for gatewaycapabilitysummaries0 in gatewayCapabilitySummaries {
                try gatewayCapabilitySummariesContainer.encode(gatewaycapabilitysummaries0)
            }
        }
        if let gatewayId = gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayPlatform = gatewayPlatform {
            try encodeContainer.encode(gatewayPlatform, forKey: .gatewayPlatform)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes.GatewaySummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GatewaySummary(creationDate: \(Swift.String(describing: creationDate)), gatewayCapabilitySummaries: \(Swift.String(describing: gatewayCapabilitySummaries)), gatewayId: \(Swift.String(describing: gatewayId)), gatewayName: \(Swift.String(describing: gatewayName)), gatewayPlatform: \(Swift.String(describing: gatewayPlatform)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a gateway.
    public struct GatewaySummary: Swift.Equatable {
        /// The date the gateway was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A list of gateway capability summaries that each contain a namespace and status. Each
        ///       gateway capability defines data sources for the gateway. To retrieve a capability
        ///       configuration's definition, use <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html">DescribeGatewayCapabilityConfiguration.
        public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        /// This member is required.
        public var gatewayId: Swift.String?
        /// The name of the asset.
        /// This member is required.
        public var gatewayName: Swift.String?
        /// Contains a gateway's platform information.
        public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
            gatewayId: Swift.String? = nil,
            gatewayName: Swift.String? = nil,
            gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil
        )
        {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }
    }

}

extension GetAssetPropertyAggregatesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetPropertyAggregatesInput(aggregateTypes: \(Swift.String(describing: aggregateTypes)), assetId: \(Swift.String(describing: assetId)), endDate: \(Swift.String(describing: endDate)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), propertyAlias: \(Swift.String(describing: propertyAlias)), propertyId: \(Swift.String(describing: propertyId)), qualities: \(Swift.String(describing: qualities)), resolution: \(Swift.String(describing: resolution)), startDate: \(Swift.String(describing: startDate)), timeOrdering: \(Swift.String(describing: timeOrdering)))"}
}

extension GetAssetPropertyAggregatesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAssetPropertyAggregatesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyAggregatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetPropertyAggregatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetPropertyAggregatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyAggregatesOutputError>
}

public struct GetAssetPropertyAggregatesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyAggregatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetPropertyAggregatesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let aggregateTypes = input.operationInput.aggregateTypes {
            aggregateTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "aggregateTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let qualities = input.operationInput.qualities {
            qualities.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let timeOrdering = input.operationInput.timeOrdering {
            let timeOrderingQueryItem = ClientRuntime.URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(timeOrderingQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        if let resolution = input.operationInput.resolution {
            let resolutionQueryItem = ClientRuntime.URLQueryItem(name: "resolution".urlPercentEncoding(), value: Swift.String(resolution).urlPercentEncoding())
            input.builder.withQueryItem(resolutionQueryItem)
        }
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetPropertyAggregatesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyAggregatesOutputError>
}

public struct GetAssetPropertyAggregatesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyAggregatesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAssetPropertyAggregatesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyAggregatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/properties/aggregates"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssetPropertyAggregatesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyAggregatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyAggregatesOutputError>
}

public struct GetAssetPropertyAggregatesInput: Swift.Equatable {
    /// The data aggregating function.
    /// This member is required.
    public var aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]?
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var endDate: ClientRuntime.Date?
    /// The maximum number of results to return for each paginated request.
    ///          Default: 100
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
    ///         IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The time interval over which to aggregate data.
    /// This member is required.
    public var resolution: Swift.String?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var startDate: ClientRuntime.Date?
    /// The chronological sorting order of the requested information.
    ///          Default: ASCENDING
    ///
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init (
        aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]? = nil,
        assetId: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        resolution: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.aggregateTypes = aggregateTypes
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.resolution = resolution
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyAggregatesInputBody: Swift.Equatable {
}

extension GetAssetPropertyAggregatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyAggregatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyAggregatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetPropertyAggregatesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyAggregatesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetPropertyAggregatesOutputResponse(aggregatedValues: \(Swift.String(describing: aggregatedValues)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetAssetPropertyAggregatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssetPropertyAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregatedValues = output.aggregatedValues
            self.nextToken = output.nextToken
        } else {
            self.aggregatedValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyAggregatesOutputResponse: Swift.Equatable {
    /// The requested aggregated values.
    /// This member is required.
    public var aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregatedValues = aggregatedValues
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyAggregatesOutputResponseBody: Swift.Equatable {
    public let aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
    public let nextToken: Swift.String?
}

extension GetAssetPropertyAggregatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedValues
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatedValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AggregatedValue?].self, forKey: .aggregatedValues)
        var aggregatedValuesDecoded0:[IoTSiteWiseClientTypes.AggregatedValue]? = nil
        if let aggregatedValuesContainer = aggregatedValuesContainer {
            aggregatedValuesDecoded0 = [IoTSiteWiseClientTypes.AggregatedValue]()
            for structure0 in aggregatedValuesContainer {
                if let structure0 = structure0 {
                    aggregatedValuesDecoded0?.append(structure0)
                }
            }
        }
        aggregatedValues = aggregatedValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAssetPropertyValueHistoryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetPropertyValueHistoryInput(assetId: \(Swift.String(describing: assetId)), endDate: \(Swift.String(describing: endDate)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), propertyAlias: \(Swift.String(describing: propertyAlias)), propertyId: \(Swift.String(describing: propertyId)), qualities: \(Swift.String(describing: qualities)), startDate: \(Swift.String(describing: startDate)), timeOrdering: \(Swift.String(describing: timeOrdering)))"}
}

extension GetAssetPropertyValueHistoryInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAssetPropertyValueHistoryInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyValueHistoryInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetPropertyValueHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyValueHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetPropertyValueHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyValueHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyValueHistoryOutputError>
}

public struct GetAssetPropertyValueHistoryInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyValueHistoryInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetPropertyValueHistoryInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyValueHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let endDate = input.operationInput.endDate {
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(endDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(endDateQueryItem)
        }
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let qualities = input.operationInput.qualities {
            qualities.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let timeOrdering = input.operationInput.timeOrdering {
            let timeOrderingQueryItem = ClientRuntime.URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(timeOrderingQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        if let startDate = input.operationInput.startDate {
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(startDate.iso8601WithoutFractionalSeconds()).urlPercentEncoding())
            input.builder.withQueryItem(startDateQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetPropertyValueHistoryInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyValueHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyValueHistoryOutputError>
}

public struct GetAssetPropertyValueHistoryInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyValueHistoryInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAssetPropertyValueHistoryInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyValueHistoryOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/properties/history"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssetPropertyValueHistoryInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyValueHistoryOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyValueHistoryOutputError>
}

public struct GetAssetPropertyValueHistoryInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var endDate: ClientRuntime.Date?
    /// The maximum number of results to return for each paginated request.
    ///          Default: 100
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
    ///         IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var startDate: ClientRuntime.Date?
    /// The chronological sorting order of the requested information.
    ///          Default: ASCENDING
    ///
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init (
        assetId: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        startDate: ClientRuntime.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyValueHistoryInputBody: Swift.Equatable {
}

extension GetAssetPropertyValueHistoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyValueHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetPropertyValueHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyValueHistoryOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetPropertyValueHistoryOutputResponse(assetPropertyValueHistory: \(Swift.String(describing: assetPropertyValueHistory)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetAssetPropertyValueHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssetPropertyValueHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetPropertyValueHistory = output.assetPropertyValueHistory
            self.nextToken = output.nextToken
        } else {
            self.assetPropertyValueHistory = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyValueHistoryOutputResponse: Swift.Equatable {
    /// The asset property's value history.
    /// This member is required.
    public var assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetPropertyValueHistory = assetPropertyValueHistory
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyValueHistoryOutputResponseBody: Swift.Equatable {
    public let assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
    public let nextToken: Swift.String?
}

extension GetAssetPropertyValueHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertyValueHistory
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetPropertyValueHistoryContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .assetPropertyValueHistory)
        var assetPropertyValueHistoryDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let assetPropertyValueHistoryContainer = assetPropertyValueHistoryContainer {
            assetPropertyValueHistoryDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in assetPropertyValueHistoryContainer {
                if let structure0 = structure0 {
                    assetPropertyValueHistoryDecoded0?.append(structure0)
                }
            }
        }
        assetPropertyValueHistory = assetPropertyValueHistoryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAssetPropertyValueInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetPropertyValueInput(assetId: \(Swift.String(describing: assetId)), propertyAlias: \(Swift.String(describing: propertyAlias)), propertyId: \(Swift.String(describing: propertyId)))"}
}

extension GetAssetPropertyValueInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetAssetPropertyValueInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyValueInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetPropertyValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetPropertyValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyValueOutputError>
}

public struct GetAssetPropertyValueInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyValueInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetAssetPropertyValueInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetAssetPropertyValueInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyValueOutputError>
}

public struct GetAssetPropertyValueInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetAssetPropertyValueInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetAssetPropertyValueInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetAssetPropertyValueOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/properties/latest"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetAssetPropertyValueInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetAssetPropertyValueOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetAssetPropertyValueOutputError>
}

public struct GetAssetPropertyValueInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
    ///         IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
    }
}

struct GetAssetPropertyValueInputBody: Swift.Equatable {
}

extension GetAssetPropertyValueInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssetPropertyValueOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyValueOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetAssetPropertyValueOutputResponse(propertyValue: \(Swift.String(describing: propertyValue)))"}
}

extension GetAssetPropertyValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetAssetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.propertyValue = output.propertyValue
        } else {
            self.propertyValue = nil
        }
    }
}

public struct GetAssetPropertyValueOutputResponse: Swift.Equatable {
    /// The current asset property value.
    public var propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?

    public init (
        propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue? = nil
    )
    {
        self.propertyValue = propertyValue
    }
}

struct GetAssetPropertyValueOutputResponseBody: Swift.Equatable {
    public let propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?
}

extension GetAssetPropertyValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetPropertyValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension GetInterpolatedAssetPropertyValuesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInterpolatedAssetPropertyValuesInput(assetId: \(Swift.String(describing: assetId)), endTimeInSeconds: \(Swift.String(describing: endTimeInSeconds)), endTimeOffsetInNanos: \(Swift.String(describing: endTimeOffsetInNanos)), intervalInSeconds: \(Swift.String(describing: intervalInSeconds)), intervalWindowInSeconds: \(Swift.String(describing: intervalWindowInSeconds)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), propertyAlias: \(Swift.String(describing: propertyAlias)), propertyId: \(Swift.String(describing: propertyId)), quality: \(Swift.String(describing: quality)), startTimeInSeconds: \(Swift.String(describing: startTimeInSeconds)), startTimeOffsetInNanos: \(Swift.String(describing: startTimeOffsetInNanos)), type: \(Swift.String(describing: type)))"}
}

extension GetInterpolatedAssetPropertyValuesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct GetInterpolatedAssetPropertyValuesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInterpolatedAssetPropertyValuesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInterpolatedAssetPropertyValuesOutputError>
}

public struct GetInterpolatedAssetPropertyValuesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInterpolatedAssetPropertyValuesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let startTimeOffsetInNanos = input.operationInput.startTimeOffsetInNanos {
            let startTimeOffsetInNanosQueryItem = ClientRuntime.URLQueryItem(name: "startTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(startTimeOffsetInNanos).urlPercentEncoding())
            input.builder.withQueryItem(startTimeOffsetInNanosQueryItem)
        }
        if let endTimeInSeconds = input.operationInput.endTimeInSeconds {
            let endTimeInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "endTimeInSeconds".urlPercentEncoding(), value: Swift.String(endTimeInSeconds).urlPercentEncoding())
            input.builder.withQueryItem(endTimeInSecondsQueryItem)
        }
        if let endTimeOffsetInNanos = input.operationInput.endTimeOffsetInNanos {
            let endTimeOffsetInNanosQueryItem = ClientRuntime.URLQueryItem(name: "endTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(endTimeOffsetInNanos).urlPercentEncoding())
            input.builder.withQueryItem(endTimeOffsetInNanosQueryItem)
        }
        if let propertyAlias = input.operationInput.propertyAlias {
            let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            input.builder.withQueryItem(propertyAliasQueryItem)
        }
        if let intervalWindowInSeconds = input.operationInput.intervalWindowInSeconds {
            let intervalWindowInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "intervalWindowInSeconds".urlPercentEncoding(), value: Swift.String(intervalWindowInSeconds).urlPercentEncoding())
            input.builder.withQueryItem(intervalWindowInSecondsQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let quality = input.operationInput.quality {
            let qualityQueryItem = ClientRuntime.URLQueryItem(name: "quality".urlPercentEncoding(), value: Swift.String(quality.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(qualityQueryItem)
        }
        if let startTimeInSeconds = input.operationInput.startTimeInSeconds {
            let startTimeInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "startTimeInSeconds".urlPercentEncoding(), value: Swift.String(startTimeInSeconds).urlPercentEncoding())
            input.builder.withQueryItem(startTimeInSecondsQueryItem)
        }
        if let assetId = input.operationInput.assetId {
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            input.builder.withQueryItem(assetIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let intervalInSeconds = input.operationInput.intervalInSeconds {
            let intervalInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "intervalInSeconds".urlPercentEncoding(), value: Swift.String(intervalInSeconds).urlPercentEncoding())
            input.builder.withQueryItem(intervalInSecondsQueryItem)
        }
        if let propertyId = input.operationInput.propertyId {
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            input.builder.withQueryItem(propertyIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<GetInterpolatedAssetPropertyValuesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInterpolatedAssetPropertyValuesOutputError>
}

public struct GetInterpolatedAssetPropertyValuesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "GetInterpolatedAssetPropertyValuesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: GetInterpolatedAssetPropertyValuesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/properties/interpolated"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = GetInterpolatedAssetPropertyValuesInput
    public typealias MOutput = ClientRuntime.OperationOutput<GetInterpolatedAssetPropertyValuesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<GetInterpolatedAssetPropertyValuesOutputError>
}

public struct GetInterpolatedAssetPropertyValuesInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to interpolate data, expressed in seconds in
    ///       Unix epoch time.
    /// This member is required.
    public var endTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from endTimeInSeconds.
    public var endTimeOffsetInNanos: Swift.Int?
    /// The time interval in seconds over which to interpolate data. Each interval starts when the
    ///       previous one ends.
    /// This member is required.
    public var intervalInSeconds: Swift.Int?
    /// The query interval for the window in seconds. IoT SiteWise computes each interpolated value by using data points
    ///       from the timestamp of each interval minus the window to the timestamp of each interval plus the window.
    ///       If not specified, the window is between the start time minus the interval and the end time plus the interval.
    ///
    ///
    ///
    ///                   If you specify a value for the intervalWindowInSeconds parameter,
    ///             the type parameter must be LINEAR_INTERPOLATION.
    ///
    ///
    ///                   If no data point is found during the specified query window,
    ///             IoT SiteWise won't return an interpolated value for the interval.
    ///             This indicates that there's a gap in the ingested data points.
    ///
    ///
    ///
    ///          For example, you can get the interpolated temperature values for a wind turbine
    ///       every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021,
    ///       at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM - 2 hours)
    ///       to 11 AM (9 AM + 2 hours) on July 2, 2021 to compute the first interpolated value,
    ///       uses the data points from 7 AM (9 AM - 2 hours) to 11 AM (9 AM + 2 hours) on July 3, 2021
    ///       to compute the second interpolated value, and so on.
    public var intervalWindowInSeconds: Swift.Int?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
    ///         IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality of the asset property value. You can use this parameter as a filter to choose
    ///       only the asset property values that have a specific quality.
    /// This member is required.
    public var quality: IoTSiteWiseClientTypes.Quality?
    /// The exclusive start of the range from which to interpolate data, expressed in seconds in
    ///       Unix epoch time.
    /// This member is required.
    public var startTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from startTimeInSeconds.
    public var startTimeOffsetInNanos: Swift.Int?
    /// The interpolation type.
    ///          Valid values: LINEAR_INTERPOLATION | LOCF_INTERPOLATION
    ///
    ///
    ///
    ///
    ///                   LINEAR_INTERPOLATION  Estimates missing data using <a href="https://en.wikipedia.org/wiki/Linear_interpolation">linear interpolation.
    ///                For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days.
    ///           If the interpolation starts on July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value
    ///           on July 3, 2021, at 9 AM, and so on.
    ///
    ///
    ///
    ///                   LOCF_INTERPOLATION  Estimates missing data using last observation carried forward interpolation
    ///                If no data point is found for an interval,
    ///           IoT SiteWise returns the last observed data point for the previous interval
    ///           and carries forward this interpolated value until a new data point is found.
    ///                For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days.
    ///           If the interpolation starts on July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021,
    ///           at 9 AM and July 2, 2021, at 9 AM as the first interpolated value.
    ///           If no data point is found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.
    ///
    ///
    /// This member is required.
    public var type: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        endTimeInSeconds: Swift.Int? = nil,
        endTimeOffsetInNanos: Swift.Int? = nil,
        intervalInSeconds: Swift.Int? = nil,
        intervalWindowInSeconds: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        quality: IoTSiteWiseClientTypes.Quality? = nil,
        startTimeInSeconds: Swift.Int? = nil,
        startTimeOffsetInNanos: Swift.Int? = nil,
        type: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.endTimeInSeconds = endTimeInSeconds
        self.endTimeOffsetInNanos = endTimeOffsetInNanos
        self.intervalInSeconds = intervalInSeconds
        self.intervalWindowInSeconds = intervalWindowInSeconds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.quality = quality
        self.startTimeInSeconds = startTimeInSeconds
        self.startTimeOffsetInNanos = startTimeOffsetInNanos
        self.type = type
    }
}

struct GetInterpolatedAssetPropertyValuesInputBody: Swift.Equatable {
}

extension GetInterpolatedAssetPropertyValuesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInterpolatedAssetPropertyValuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInterpolatedAssetPropertyValuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetInterpolatedAssetPropertyValuesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInterpolatedAssetPropertyValuesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetInterpolatedAssetPropertyValuesOutputResponse(interpolatedAssetPropertyValues: \(Swift.String(describing: interpolatedAssetPropertyValues)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension GetInterpolatedAssetPropertyValuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetInterpolatedAssetPropertyValuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interpolatedAssetPropertyValues = output.interpolatedAssetPropertyValues
            self.nextToken = output.nextToken
        } else {
            self.interpolatedAssetPropertyValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetInterpolatedAssetPropertyValuesOutputResponse: Swift.Equatable {
    /// The requested interpolated values.
    /// This member is required.
    public var interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
        self.nextToken = nextToken
    }
}

struct GetInterpolatedAssetPropertyValuesOutputResponseBody: Swift.Equatable {
    public let interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]?
    public let nextToken: Swift.String?
}

extension GetInterpolatedAssetPropertyValuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpolatedAssetPropertyValues
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpolatedAssetPropertyValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue?].self, forKey: .interpolatedAssetPropertyValues)
        var interpolatedAssetPropertyValuesDecoded0:[IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]? = nil
        if let interpolatedAssetPropertyValuesContainer = interpolatedAssetPropertyValuesContainer {
            interpolatedAssetPropertyValuesDecoded0 = [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]()
            for structure0 in interpolatedAssetPropertyValuesContainer {
                if let structure0 = structure0 {
                    interpolatedAssetPropertyValuesDecoded0?.append(structure0)
                }
            }
        }
        interpolatedAssetPropertyValues = interpolatedAssetPropertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes.Greengrass: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupArn = groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension IoTSiteWiseClientTypes.Greengrass: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Greengrass(groupArn: \(Swift.String(describing: groupArn)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains details for a gateway that runs on IoT Greengrass. To create a gateway that runs on IoT Greengrass,
    ///       you must add the IoT SiteWise connector to a Greengrass group and deploy it. Your Greengrass
    ///       group must also have permissions to upload data to IoT SiteWise. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/gateway-connector.html">Ingesting data using a
    ///         gateway in the IoT SiteWise User Guide.
    public struct Greengrass: Swift.Equatable {
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the Greengrass group. For more information about how to find a group's
        ///       ARN, see <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html">ListGroups and <a href="https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html">GetGroup in the
        ///         IoT Greengrass API Reference.
        /// This member is required.
        public var groupArn: Swift.String?

        public init (
            groupArn: Swift.String? = nil
        )
        {
            self.groupArn = groupArn
        }
    }

}

extension IoTSiteWiseClientTypes.GreengrassV2: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDeviceThingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceThingName = coreDeviceThingName {
            try encodeContainer.encode(coreDeviceThingName, forKey: .coreDeviceThingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
    }
}

extension IoTSiteWiseClientTypes.GreengrassV2: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GreengrassV2(coreDeviceThingName: \(Swift.String(describing: coreDeviceThingName)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains details for a gateway that runs on IoT Greengrass V2. To create a gateway that runs on IoT Greengrass V2,
    ///       you must deploy the IoT SiteWise Edge component to your gateway device.
    ///       Your <a href="https://docs.aws.amazon.com/greengrass/v2/developerguide/device-service-role.html">Greengrass device role
    ///       must use the AWSIoTSiteWiseEdgeAccess policy. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/sw-gateways.html">Using IoT SiteWise at the edge
    ///       in the IoT SiteWise User Guide.
    public struct GreengrassV2: Swift.Equatable {
        /// The name of the IoT thing for your IoT Greengrass V2 core device.
        /// This member is required.
        public var coreDeviceThingName: Swift.String?

        public init (
            coreDeviceThingName: Swift.String? = nil
        )
        {
            self.coreDeviceThingName = coreDeviceThingName
        }
    }

}

extension IoTSiteWiseClientTypes.GroupIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes.GroupIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GroupIdentity(id: \(Swift.String(describing: id)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information for a group identity in an access policy.
    public struct GroupIdentity: Swift.Equatable {
        /// The Amazon Web Services SSO ID of the group.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.IAMRoleIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTSiteWiseClientTypes.IAMRoleIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IAMRoleIdentity(arn: \(Swift.String(describing: arn)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an Identity and Access Management role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html">IAM roles in the
    ///         IAM User Guide.
    public struct IAMRoleIdentity: Swift.Equatable {
        /// The ARN of the IAM role. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs in the
        ///         IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTSiteWiseClientTypes.IAMUserIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTSiteWiseClientTypes.IAMUserIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IAMUserIdentity(arn: \(Swift.String(describing: arn)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an Identity and Access Management user.
    public struct IAMUserIdentity: Swift.Equatable {
        /// The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs in the
        ///         IAM User Guide.
        ///
        ///             If you delete the IAM user, access policies that contain this identity include an
        ///         empty arn. You can delete the access policy for the IAM user that no longer
        ///         exists.
        ///
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTSiteWiseClientTypes.Identity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group
        case iamRole
        case iamUser
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let iamRole = iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let iamUser = iamUser {
            try encodeContainer.encode(iamUser, forKey: .iamUser)
        }
        if let user = user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.UserIdentity.self, forKey: .user)
        user = userDecoded
        let groupDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GroupIdentity.self, forKey: .group)
        group = groupDecoded
        let iamUserDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.IAMUserIdentity.self, forKey: .iamUser)
        iamUser = iamUserDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.IAMRoleIdentity.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

extension IoTSiteWiseClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(group: \(Swift.String(describing: group)), iamRole: \(Swift.String(describing: iamRole)), iamUser: \(Swift.String(describing: iamUser)), user: \(Swift.String(describing: user)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an identity that can access an IoT SiteWise Monitor resource.
    ///
    ///             Currently, you can't use Amazon Web Services APIs to retrieve Amazon Web Services SSO identity IDs. You can find the
    ///         Amazon Web Services SSO identity IDs in the URL of user and group pages in the <a href="https://console.aws.amazon.com/singlesignon">Amazon Web Services SSO console.
    ///
    public struct Identity: Swift.Equatable {
        /// An Amazon Web Services SSO group identity.
        public var group: IoTSiteWiseClientTypes.GroupIdentity?
        /// An IAM role identity.
        public var iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity?
        /// An IAM user identity.
        public var iamUser: IoTSiteWiseClientTypes.IAMUserIdentity?
        /// An Amazon Web Services SSO user identity.
        public var user: IoTSiteWiseClientTypes.UserIdentity?

        public init (
            group: IoTSiteWiseClientTypes.GroupIdentity? = nil,
            iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity? = nil,
            iamUser: IoTSiteWiseClientTypes.IAMUserIdentity? = nil,
            user: IoTSiteWiseClientTypes.UserIdentity? = nil
        )
        {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum IdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case iam
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .group,
                .iam,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .iam: return "IAM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.Image: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = file {
            try encodeContainer.encode(file, forKey: .file)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fileDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFile.self, forKey: .file)
        file = fileDecoded
    }
}

extension IoTSiteWiseClientTypes.Image: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Image(file: \(Swift.String(describing: file)), id: \(Swift.String(describing: id)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an image that is one of the following:
    ///
    ///
    ///                An image file. Choose this option to upload a new image.
    ///
    ///
    ///                The ID of an existing image. Choose this option to keep an existing image.
    ///
    ///
    public struct Image: Swift.Equatable {
        /// Contains an image file.
        public var file: IoTSiteWiseClientTypes.ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public var id: Swift.String?

        public init (
            file: IoTSiteWiseClientTypes.ImageFile? = nil,
            id: Swift.String? = nil
        )
        {
            self.file = file
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.ImageFile: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFileType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes.ImageFile: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageFile(data: \(Swift.String(describing: data)), type: \(Swift.String(describing: type)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an image file.
    public struct ImageFile: Swift.Equatable {
        /// The image file contents, represented as a base64-encoded string. The file size must be
        ///       less than 1 MB.
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The file type of the image.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.ImageFileType?

        public init (
            data: ClientRuntime.Data? = nil,
            type: IoTSiteWiseClientTypes.ImageFileType? = nil
        )
        {
            self.data = data
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ImageFileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case png
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFileType] {
            return [
                .png,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .png: return "PNG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFileType(rawValue: rawValue) ?? ImageFileType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ImageLocation: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let url = url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension IoTSiteWiseClientTypes.ImageLocation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImageLocation(id: \(Swift.String(describing: id)), url: \(Swift.String(describing: url)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an image that is uploaded to IoT SiteWise and available at a URL.
    public struct ImageLocation: Swift.Equatable {
        /// The ID of the image.
        /// This member is required.
        public var id: Swift.String?
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view
        ///       and download the image
        /// This member is required.
        public var url: Swift.String?

        public init (
            id: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.id = id
            self.url = url
        }
    }

}

extension InternalFailureException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InternalFailureException(message: \(Swift.String(describing: message)))"}
}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// IoT SiteWise can't process your request right now. Try again later.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Variant.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InterpolatedAssetPropertyValue(timestamp: \(Swift.String(describing: timestamp)), value: \(Swift.String(describing: value)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an interpolated asset property value.
    public struct InterpolatedAssetPropertyValue: Swift.Equatable {
        /// Contains a timestamp with optional nanosecond granularity.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// Contains an asset property value (of a single type only).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init (
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension InvalidRequestException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidRequestException(message: \(Swift.String(describing: message)))"}
}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or
///       unsupported characters. Check your request and try again.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've reached the limit for a resource. For example, this can occur if you're trying to
///       associate more than the allowed number of child assets or attempting to create more than the
///       allowed number of properties for an asset model.
///          For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessPoliciesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessPoliciesInput(iamArn: \(Swift.String(describing: iamArn)), identityId: \(Swift.String(describing: identityId)), identityType: \(Swift.String(describing: identityType)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)))"}
}

extension ListAccessPoliciesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAccessPoliciesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPoliciesOutputError>
}

public struct ListAccessPoliciesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAccessPoliciesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceId = input.operationInput.resourceId {
            let resourceIdQueryItem = ClientRuntime.URLQueryItem(name: "resourceId".urlPercentEncoding(), value: Swift.String(resourceId).urlPercentEncoding())
            input.builder.withQueryItem(resourceIdQueryItem)
        }
        if let identityType = input.operationInput.identityType {
            let identityTypeQueryItem = ClientRuntime.URLQueryItem(name: "identityType".urlPercentEncoding(), value: Swift.String(identityType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(identityTypeQueryItem)
        }
        if let identityId = input.operationInput.identityId {
            let identityIdQueryItem = ClientRuntime.URLQueryItem(name: "identityId".urlPercentEncoding(), value: Swift.String(identityId).urlPercentEncoding())
            input.builder.withQueryItem(identityIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let iamArn = input.operationInput.iamArn {
            let iamArnQueryItem = ClientRuntime.URLQueryItem(name: "iamArn".urlPercentEncoding(), value: Swift.String(iamArn).urlPercentEncoding())
            input.builder.withQueryItem(iamArnQueryItem)
        }
        if let resourceType = input.operationInput.resourceType {
            let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(resourceTypeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAccessPoliciesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPoliciesOutputError>
}

public struct ListAccessPoliciesInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAccessPoliciesInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAccessPoliciesInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAccessPoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/access-policies"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAccessPoliciesInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAccessPoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAccessPoliciesOutputError>
}

public struct ListAccessPoliciesInput: Swift.Equatable {
    /// The ARN of the IAM user. For more information, see <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html">IAM ARNs in the
    ///         IAM User Guide. This parameter is required if you specify
    ///         IAM for identityType.
    public var iamArn: Swift.String?
    /// The ID of the identity. This parameter is required if you specify USER or
    ///         GROUP for identityType.
    public var identityId: Swift.String?
    /// The type of identity (Amazon Web Services SSO user, Amazon Web Services SSO group, or IAM user). This parameter is required
    ///       if you specify identityId.
    public var identityType: IoTSiteWiseClientTypes.IdentityType?
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the resource. This parameter is required if you specify
    ///         resourceType.
    public var resourceId: Swift.String?
    /// The type of resource (portal or project). This parameter is required if you specify
    ///         resourceId.
    public var resourceType: IoTSiteWiseClientTypes.ResourceType?

    public init (
        iamArn: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityType: IoTSiteWiseClientTypes.IdentityType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IoTSiteWiseClientTypes.ResourceType? = nil
    )
    {
        self.iamArn = iamArn
        self.identityId = identityId
        self.identityType = identityType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ListAccessPoliciesInputBody: Swift.Equatable {
}

extension ListAccessPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAccessPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPoliciesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAccessPoliciesOutputResponse(accessPolicySummaries: \(Swift.String(describing: accessPolicySummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAccessPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicySummaries = output.accessPolicySummaries
            self.nextToken = output.nextToken
        } else {
            self.accessPolicySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPoliciesOutputResponse: Swift.Equatable {
    /// A list that summarizes each access policy.
    /// This member is required.
    public var accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

struct ListAccessPoliciesOutputResponseBody: Swift.Equatable {
    public let accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]?
    public let nextToken: Swift.String?
}

extension ListAccessPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AccessPolicySummary?].self, forKey: .accessPolicySummaries)
        var accessPolicySummariesDecoded0:[IoTSiteWiseClientTypes.AccessPolicySummary]? = nil
        if let accessPolicySummariesContainer = accessPolicySummariesContainer {
            accessPolicySummariesDecoded0 = [IoTSiteWiseClientTypes.AccessPolicySummary]()
            for structure0 in accessPolicySummariesContainer {
                if let structure0 = structure0 {
                    accessPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        accessPolicySummaries = accessPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssetModelsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssetModelsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssetModelsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssetModelsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetModelsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssetModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssetModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetModelsOutputError>
}

public struct ListAssetModelsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetModelsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssetModelsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssetModelsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetModelsOutputError>
}

public struct ListAssetModelsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetModelsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssetModelsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetModelsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/asset-models"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssetModelsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetModelsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetModelsOutputError>
}

public struct ListAssetModelsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetModelsInputBody: Swift.Equatable {
}

extension ListAssetModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssetModelsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetModelsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssetModelsOutputResponse(assetModelSummaries: \(Swift.String(describing: assetModelSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssetModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssetModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelSummaries = output.assetModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetModelsOutputResponse: Swift.Equatable {
    /// A list that summarizes each asset model.
    /// This member is required.
    public var assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelSummaries = assetModelSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetModelsOutputResponseBody: Swift.Equatable {
    public let assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]?
    public let nextToken: Swift.String?
}

extension ListAssetModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelSummary?].self, forKey: .assetModelSummaries)
        var assetModelSummariesDecoded0:[IoTSiteWiseClientTypes.AssetModelSummary]? = nil
        if let assetModelSummariesContainer = assetModelSummariesContainer {
            assetModelSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetModelSummary]()
            for structure0 in assetModelSummariesContainer {
                if let structure0 = structure0 {
                    assetModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetModelSummaries = assetModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssetRelationshipsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssetRelationshipsInput(assetId: \(Swift.String(describing: assetId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), traversalType: \(Swift.String(describing: traversalType)))"}
}

extension ListAssetRelationshipsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssetRelationshipsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetRelationshipsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssetRelationshipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssetRelationshipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetRelationshipsOutputError>
}

public struct ListAssetRelationshipsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetRelationshipsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssetRelationshipsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let traversalType = input.operationInput.traversalType {
            let traversalTypeQueryItem = ClientRuntime.URLQueryItem(name: "traversalType".urlPercentEncoding(), value: Swift.String(traversalType.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(traversalTypeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssetRelationshipsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetRelationshipsOutputError>
}

public struct ListAssetRelationshipsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetRelationshipsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssetRelationshipsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetRelationshipsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())/assetRelationships"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssetRelationshipsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetRelationshipsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetRelationshipsOutputError>
}

public struct ListAssetRelationshipsInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The type of traversal to use to identify asset relationships. Choose the following
    ///       option:
    ///
    ///
    ///
    ///                   PATH_TO_ROOT  Identify the asset's parent assets up to the root
    ///           asset. The asset that you specify in assetId is the first result in the list
    ///           of assetRelationshipSummaries, and the root asset is the last result.
    ///
    ///
    /// This member is required.
    public var traversalType: IoTSiteWiseClientTypes.TraversalType?

    public init (
        assetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalType: IoTSiteWiseClientTypes.TraversalType? = nil
    )
    {
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalType = traversalType
    }
}

struct ListAssetRelationshipsInputBody: Swift.Equatable {
}

extension ListAssetRelationshipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetRelationshipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetRelationshipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssetRelationshipsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetRelationshipsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssetRelationshipsOutputResponse(assetRelationshipSummaries: \(Swift.String(describing: assetRelationshipSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssetRelationshipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssetRelationshipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetRelationshipSummaries = output.assetRelationshipSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetRelationshipSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetRelationshipsOutputResponse: Swift.Equatable {
    /// A list that summarizes each asset relationship.
    /// This member is required.
    public var assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetRelationshipSummaries = assetRelationshipSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetRelationshipsOutputResponseBody: Swift.Equatable {
    public let assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]?
    public let nextToken: Swift.String?
}

extension ListAssetRelationshipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetRelationshipSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetRelationshipSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetRelationshipSummary?].self, forKey: .assetRelationshipSummaries)
        var assetRelationshipSummariesDecoded0:[IoTSiteWiseClientTypes.AssetRelationshipSummary]? = nil
        if let assetRelationshipSummariesContainer = assetRelationshipSummariesContainer {
            assetRelationshipSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetRelationshipSummary]()
            for structure0 in assetRelationshipSummariesContainer {
                if let structure0 = structure0 {
                    assetRelationshipSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetRelationshipSummaries = assetRelationshipSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListAssetsFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case topLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetsFilter] {
            return [
                .all,
                .topLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .topLevel: return "TOP_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListAssetsFilter(rawValue: rawValue) ?? ListAssetsFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssetsInput(assetModelId: \(Swift.String(describing: assetModelId)), filter: \(Swift.String(describing: filter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetsOutputError>
}

public struct ListAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let filter = input.operationInput.filter {
            let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(filterQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let assetModelId = input.operationInput.assetModelId {
            let assetModelIdQueryItem = ClientRuntime.URLQueryItem(name: "assetModelId".urlPercentEncoding(), value: Swift.String(assetModelId).urlPercentEncoding())
            input.builder.withQueryItem(assetModelIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetsOutputError>
}

public struct ListAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/assets"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssetsOutputError>
}

public struct ListAssetsInput: Swift.Equatable {
    /// The ID of the asset model by which to filter the list of assets. This parameter is
    ///       required if you choose ALL for filter.
    public var assetModelId: Swift.String?
    /// The filter for the requested list of assets. Choose one of the following options:
    ///
    ///
    ///
    ///                   ALL  The list includes all assets for a given asset model ID. The
    ///             assetModelId parameter is required if you filter by
    ///           ALL.
    ///
    ///
    ///
    ///                   TOP_LEVEL  The list includes only top-level assets in the asset
    ///           hierarchy tree.
    ///
    ///
    ///          Default: ALL
    ///
    public var filter: IoTSiteWiseClientTypes.ListAssetsFilter?
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        assetModelId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetsInputBody: Swift.Equatable {
}

extension ListAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssetsOutputResponse(assetSummaries: \(Swift.String(describing: assetSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetsOutputResponse: Swift.Equatable {
    /// A list that summarizes each asset.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetsOutputResponseBody: Swift.Equatable {
    public let assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]?
    public let nextToken: Swift.String?
}

extension ListAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[IoTSiteWiseClientTypes.AssetSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedAssetsInput(assetId: \(Swift.String(describing: assetId)), hierarchyId: \(Swift.String(describing: hierarchyId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), traversalDirection: \(Swift.String(describing: traversalDirection)))"}
}

extension ListAssociatedAssetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListAssociatedAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedAssetsOutputError>
}

public struct ListAssociatedAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListAssociatedAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let traversalDirection = input.operationInput.traversalDirection {
            let traversalDirectionQueryItem = ClientRuntime.URLQueryItem(name: "traversalDirection".urlPercentEncoding(), value: Swift.String(traversalDirection.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(traversalDirectionQueryItem)
        }
        if let hierarchyId = input.operationInput.hierarchyId {
            let hierarchyIdQueryItem = ClientRuntime.URLQueryItem(name: "hierarchyId".urlPercentEncoding(), value: Swift.String(hierarchyId).urlPercentEncoding())
            input.builder.withQueryItem(hierarchyIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListAssociatedAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedAssetsOutputError>
}

public struct ListAssociatedAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListAssociatedAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListAssociatedAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListAssociatedAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())/hierarchies"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListAssociatedAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListAssociatedAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListAssociatedAssetsOutputError>
}

public struct ListAssociatedAssetsInput: Swift.Equatable {
    /// The ID of the asset to query.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the hierarchy by which child assets are associated to the asset. To find a
    ///       hierarchy ID, use the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html">DescribeAsset or <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html">DescribeAssetModel operations. This
    ///       parameter is required if you choose CHILD for
    ///       traversalDirection.
    ///          For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies in the IoT SiteWise User Guide.
    public var hierarchyId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The direction to list associated assets. Choose one of the following options:
    ///
    ///
    ///
    ///                   CHILD  The list includes all child assets associated to the
    ///           asset. The hierarchyId parameter is required if you choose
    ///           CHILD.
    ///
    ///
    ///
    ///                   PARENT  The list includes the asset's parent asset.
    ///
    ///
    ///          Default: CHILD
    ///
    public var traversalDirection: IoTSiteWiseClientTypes.TraversalDirection?

    public init (
        assetId: Swift.String? = nil,
        hierarchyId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalDirection: IoTSiteWiseClientTypes.TraversalDirection? = nil
    )
    {
        self.assetId = assetId
        self.hierarchyId = hierarchyId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalDirection = traversalDirection
    }
}

struct ListAssociatedAssetsInputBody: Swift.Equatable {
}

extension ListAssociatedAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssociatedAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssociatedAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAssociatedAssetsOutputResponse(assetSummaries: \(Swift.String(describing: assetSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListAssociatedAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListAssociatedAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedAssetsOutputResponse: Swift.Equatable {
    /// A list that summarizes the associated assets.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssociatedAssetsOutputResponseBody: Swift.Equatable {
    public let assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]?
    public let nextToken: Swift.String?
}

extension ListAssociatedAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssociatedAssetsSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[IoTSiteWiseClientTypes.AssociatedAssetsSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [IoTSiteWiseClientTypes.AssociatedAssetsSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDashboardsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDashboardsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectId: \(Swift.String(describing: projectId)))"}
}

extension ListDashboardsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListDashboardsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDashboardsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDashboardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDashboardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDashboardsOutputError>
}

public struct ListDashboardsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDashboardsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListDashboardsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let projectId = input.operationInput.projectId {
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            input.builder.withQueryItem(projectIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListDashboardsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDashboardsOutputError>
}

public struct ListDashboardsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListDashboardsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListDashboardsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListDashboardsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/dashboards"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListDashboardsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListDashboardsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListDashboardsOutputError>
}

public struct ListDashboardsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListDashboardsInputBody: Swift.Equatable {
}

extension ListDashboardsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDashboardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListDashboardsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListDashboardsOutputResponse(dashboardSummaries: \(Swift.String(describing: dashboardSummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListDashboardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardSummaries = output.dashboardSummaries
            self.nextToken = output.nextToken
        } else {
            self.dashboardSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDashboardsOutputResponse: Swift.Equatable {
    /// A list that summarizes each dashboard in the project.
    /// This member is required.
    public var dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dashboardSummaries = dashboardSummaries
        self.nextToken = nextToken
    }
}

struct ListDashboardsOutputResponseBody: Swift.Equatable {
    public let dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]?
    public let nextToken: Swift.String?
}

extension ListDashboardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.DashboardSummary?].self, forKey: .dashboardSummaries)
        var dashboardSummariesDecoded0:[IoTSiteWiseClientTypes.DashboardSummary]? = nil
        if let dashboardSummariesContainer = dashboardSummariesContainer {
            dashboardSummariesDecoded0 = [IoTSiteWiseClientTypes.DashboardSummary]()
            for structure0 in dashboardSummariesContainer {
                if let structure0 = structure0 {
                    dashboardSummariesDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaries = dashboardSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGatewaysInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGatewaysInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGatewaysInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListGatewaysInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGatewaysInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGatewaysInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListGatewaysInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListGatewaysInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListGatewaysInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListGatewaysInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListGatewaysOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/20200301/gateways"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListGatewaysInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListGatewaysOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListGatewaysOutputError>
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
}

extension ListGatewaysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListGatewaysOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListGatewaysOutputResponse(gatewaySummaries: \(Swift.String(describing: gatewaySummaries)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewaySummaries = output.gatewaySummaries
            self.nextToken = output.nextToken
        } else {
            self.gatewaySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Swift.Equatable {
    /// A list that summarizes each gateway.
    /// This member is required.
    public var gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewaySummaries = gatewaySummaries
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputResponseBody: Swift.Equatable {
    public let gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]?
    public let nextToken: Swift.String?
}

extension ListGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewaySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewaySummary?].self, forKey: .gatewaySummaries)
        var gatewaySummariesDecoded0:[IoTSiteWiseClientTypes.GatewaySummary]? = nil
        if let gatewaySummariesContainer = gatewaySummariesContainer {
            gatewaySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewaySummary]()
            for structure0 in gatewaySummariesContainer {
                if let structure0 = structure0 {
                    gatewaySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewaySummaries = gatewaySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPortalsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortalsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListPortalsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListPortalsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortalsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortalsOutputError>
}

public struct ListPortalsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortalsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListPortalsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListPortalsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortalsOutputError>
}

public struct ListPortalsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListPortalsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListPortalsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListPortalsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/portals"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListPortalsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListPortalsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListPortalsOutputError>
}

public struct ListPortalsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Swift.Equatable {
}

extension ListPortalsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPortalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListPortalsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortalsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListPortalsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), portalSummaries: \(Swift.String(describing: portalSummaries)))"}
}

extension ListPortalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListPortalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portalSummaries = output.portalSummaries
        } else {
            self.nextToken = nil
            self.portalSummaries = nil
        }
    }
}

public struct ListPortalsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each portal.
    public var portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]?

    public init (
        nextToken: Swift.String? = nil,
        portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portalSummaries = portalSummaries
    }
}

struct ListPortalsOutputResponseBody: Swift.Equatable {
    public let portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]?
    public let nextToken: Swift.String?
}

extension ListPortalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case portalSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.PortalSummary?].self, forKey: .portalSummaries)
        var portalSummariesDecoded0:[IoTSiteWiseClientTypes.PortalSummary]? = nil
        if let portalSummariesContainer = portalSummariesContainer {
            portalSummariesDecoded0 = [IoTSiteWiseClientTypes.PortalSummary]()
            for structure0 in portalSummariesContainer {
                if let structure0 = structure0 {
                    portalSummariesDecoded0?.append(structure0)
                }
            }
        }
        portalSummaries = portalSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectAssetsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectAssetsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), projectId: \(Swift.String(describing: projectId)))"}
}

extension ListProjectAssetsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProjectAssetsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectAssetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectAssetsOutputError>
}

public struct ListProjectAssetsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectAssetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectAssetsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectAssetsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectAssetsOutputError>
}

public struct ListProjectAssetsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectAssetsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListProjectAssetsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectAssetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectId = input.projectId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectId.urlPercentEncoding())/assets"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProjectAssetsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectAssetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectAssetsOutputError>
}

public struct ListProjectAssetsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListProjectAssetsInputBody: Swift.Equatable {
}

extension ListProjectAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectAssetsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectAssetsOutputResponse(assetIds: \(Swift.String(describing: assetIds)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension ListProjectAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetIds = output.assetIds
            self.nextToken = output.nextToken
        } else {
            self.assetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectAssetsOutputResponse: Swift.Equatable {
    /// A list that contains the IDs of each asset associated with the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.nextToken = nextToken
    }
}

struct ListProjectAssetsOutputResponseBody: Swift.Equatable {
    public let assetIds: [Swift.String]?
    public let nextToken: Swift.String?
}

extension ListProjectAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), portalId: \(Swift.String(describing: portalId)))"}
}

extension ListProjectsInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListProjectsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListProjectsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let portalId = input.operationInput.portalId {
            let portalIdQueryItem = ClientRuntime.URLQueryItem(name: "portalId".urlPercentEncoding(), value: Swift.String(portalId).urlPercentEncoding())
            input.builder.withQueryItem(portalIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListProjectsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListProjectsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListProjectsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListProjectsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/projects"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListProjectsInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListProjectsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListProjectsOutputError>
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request.
    ///          Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalId = portalId
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListProjectsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), projectSummaries: \(Swift.String(describing: projectSummaries)))"}
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projectSummaries = output.projectSummaries
        } else {
            self.nextToken = nil
            self.projectSummaries = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each project in the portal.
    /// This member is required.
    public var projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projectSummaries = projectSummaries
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    public let projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]?
    public let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projectSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ProjectSummary?].self, forKey: .projectSummaries)
        var projectSummariesDecoded0:[IoTSiteWiseClientTypes.ProjectSummary]? = nil
        if let projectSummariesContainer = projectSummariesContainer {
            projectSummariesDecoded0 = [IoTSiteWiseClientTypes.ProjectSummary]()
            for structure0 in projectSummariesContainer {
                if let structure0 = structure0 {
                    projectSummariesDecoded0?.append(structure0)
                }
            }
        }
        projectSummaries = projectSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ListTagsForResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = ListTagsForResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of key-value pairs that contain metadata for the resource. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.LoggingOptions: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case level
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingLevel.self, forKey: .level)
        level = levelDecoded
    }
}

extension IoTSiteWiseClientTypes.LoggingOptions: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LoggingOptions(level: \(Swift.String(describing: level)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains logging options.
    public struct LoggingOptions: Swift.Equatable {
        /// The IoT SiteWise logging verbosity level.
        /// This member is required.
        public var level: IoTSiteWiseClientTypes.LoggingLevel?

        public init (
            level: IoTSiteWiseClientTypes.LoggingLevel? = nil
        )
        {
            self.level = level
        }
    }

}

extension IoTSiteWiseClientTypes.Measurement: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let processingConfig = processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MeasurementProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes.Measurement: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Measurement(processingConfig: \(Swift.String(describing: processingConfig)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset measurement property. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#measurements">Measurements in the IoT SiteWise User Guide.
    public struct Measurement: Swift.Equatable {
        /// The processing configuration for the given measurement property.
        ///       You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud.
        ///       By default, measurements are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig?

        public init (
            processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig? = nil
        )
        {
            self.processingConfig = processingConfig
        }
    }

}

extension IoTSiteWiseClientTypes.MeasurementProcessingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forwardingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forwardingConfig = forwardingConfig {
            try encodeContainer.encode(forwardingConfig, forKey: .forwardingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfig.self, forKey: .forwardingConfig)
        forwardingConfig = forwardingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes.MeasurementProcessingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MeasurementProcessingConfig(forwardingConfig: \(Swift.String(describing: forwardingConfig)))"}
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given measurement property.
    ///       You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud.
    ///       By default, measurements are forwarded to the cloud.
    public struct MeasurementProcessingConfig: Swift.Equatable {
        /// The forwarding configuration for the given measurement property.
        /// This member is required.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init (
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.forwardingConfig = forwardingConfig
        }
    }

}

extension IoTSiteWiseClientTypes.Metric: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case processingConfig
        case variables
        case window
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let processingConfig = processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariables0 in variables {
                try variablesContainer.encode(expressionvariables0)
            }
        }
        if let window = window {
            try encodeContainer.encode(window, forKey: .window)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTSiteWiseClientTypes.ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let windowDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MetricWindow.self, forKey: .window)
        window = windowDecoded
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MetricProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes.Metric: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Metric(expression: \(Swift.String(describing: expression)), processingConfig: \(Swift.String(describing: processingConfig)), variables: \(Swift.String(describing: variables)), window: \(Swift.String(describing: window)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset metric property. With metrics, you can calculate aggregate functions,
    ///       such as an average, maximum, or minimum, as specified through an expression. A metric maps
    ///       several values to a single value (such as a sum).
    ///          The maximum number of dependent/cascading variables used in any one metric calculation is
    ///       10. Therefore, a root metric can have
    ///       up to 10 cascading metrics in its computational dependency
    ///       tree. Additionally, a metric can only have a data type of DOUBLE and consume
    ///       properties with data types of INTEGER or DOUBLE.
    ///          For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#metrics">Metrics in the IoT SiteWise User Guide.
    public struct Metric: Swift.Equatable {
        /// The mathematical expression that defines the metric aggregation function. You can specify
        ///       up to 10 variables per expression. You can specify up to 10 functions
        ///       per expression.
        ///          For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given metric property.
        ///       You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud.
        ///       By default, metrics are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression.
        ///       IoT SiteWise computes one data point per window.
        /// This member is required.
        public var window: IoTSiteWiseClientTypes.MetricWindow?

        public init (
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil,
            window: IoTSiteWiseClientTypes.MetricWindow? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
            self.window = window
        }
    }

}

extension IoTSiteWiseClientTypes.MetricProcessingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeLocation = computeLocation {
            try encodeContainer.encode(computeLocation.rawValue, forKey: .computeLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ComputeLocation.self, forKey: .computeLocation)
        computeLocation = computeLocationDecoded
    }
}

extension IoTSiteWiseClientTypes.MetricProcessingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetricProcessingConfig(computeLocation: \(Swift.String(describing: computeLocation)))"}
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given metric property.
    ///       You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud.
    ///       By default, metrics are forwarded to the cloud.
    public struct MetricProcessingConfig: Swift.Equatable {
        /// The compute location for the given metric property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?

        public init (
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil
        )
        {
            self.computeLocation = computeLocation
        }
    }

}

extension IoTSiteWiseClientTypes.MetricWindow: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tumbling
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tumbling = tumbling {
            try encodeContainer.encode(tumbling, forKey: .tumbling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tumblingDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TumblingWindow.self, forKey: .tumbling)
        tumbling = tumblingDecoded
    }
}

extension IoTSiteWiseClientTypes.MetricWindow: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MetricWindow(tumbling: \(Swift.String(describing: tumbling)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a time interval window used for data aggregate computations (for example,
    ///       average, sum, count, and so on).
    public struct MetricWindow: Swift.Equatable {
        /// The tumbling time interval window.
        public var tumbling: IoTSiteWiseClientTypes.TumblingWindow?

        public init (
            tumbling: IoTSiteWiseClientTypes.TumblingWindow? = nil
        )
        {
            self.tumbling = tumbling
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum MonitorErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case limitExceeded
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorErrorCode] {
            return [
                .internalFailure,
                .limitExceeded,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorErrorCode(rawValue: rawValue) ?? MonitorErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.MonitorErrorDetails: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MonitorErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.MonitorErrorDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MonitorErrorDetails(code: \(Swift.String(describing: code)), message: \(Swift.String(describing: message)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains IoT SiteWise Monitor error details.
    public struct MonitorErrorDetails: Swift.Equatable {
        /// The error code.
        public var code: IoTSiteWiseClientTypes.MonitorErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.MonitorErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.MultiLayerStorage: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedS3Storage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3Storage = customerManagedS3Storage {
            try encodeContainer.encode(customerManagedS3Storage, forKey: .customerManagedS3Storage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedS3StorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CustomerManagedS3Storage.self, forKey: .customerManagedS3Storage)
        customerManagedS3Storage = customerManagedS3StorageDecoded
    }
}

extension IoTSiteWiseClientTypes.MultiLayerStorage: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MultiLayerStorage(customerManagedS3Storage: \(Swift.String(describing: customerManagedS3Storage)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the storage destination.
    public struct MultiLayerStorage: Swift.Equatable {
        /// Contains information about a customer managed Amazon S3 bucket.
        /// This member is required.
        public var customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage?

        public init (
            customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage? = nil
        )
        {
            self.customerManagedS3Storage = customerManagedS3Storage
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .administrator,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PortalResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes.PortalResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalResource(id: \(Swift.String(describing: id)))"}
}

extension IoTSiteWiseClientTypes {
    /// Identifies an IoT SiteWise Monitor portal.
    public struct PortalResource: Swift.Equatable {
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PortalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortalState(rawValue: rawValue) ?? PortalState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PortalStatus: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MonitorErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes.PortalStatus: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalStatus(error: \(Swift.String(describing: error)), state: \(Swift.String(describing: state)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the current status of a portal.
    public struct PortalStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.MonitorErrorDetails?
        /// The current state of the portal.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PortalState?

        public init (
            error: IoTSiteWiseClientTypes.MonitorErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.PortalState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.PortalSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case roleArn
        case startUrl
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startUrl = startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
        if let status = status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes.PortalSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PortalSummary(creationDate: \(Swift.String(describing: creationDate)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), name: \(Swift.String(describing: name)), roleArn: \(Swift.String(describing: roleArn)), startUrl: \(Swift.String(describing: startUrl)), status: \(Swift.String(describing: status)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a portal summary.
    public struct PortalSummary: Swift.Equatable {
        /// The date the portal was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The portal's description.
        public var description: Swift.String?
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?
        /// The date the portal was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the portal.
        /// This member is required.
        public var name: Swift.String?
        /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the service role that allows the portal's users to access your IoT SiteWise
        ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor in the
        ///         IoT SiteWise User Guide.
        public var roleArn: Swift.String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that
        ///       use Amazon Web Services SSO for authentication. For portals that use IAM for authentication, you must use the
        ///       IoT SiteWise console to get a URL that you can use to access the portal.
        /// This member is required.
        public var startUrl: Swift.String?
        /// Contains information about the current status of a portal.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.PortalStatus?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            startUrl: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.PortalStatus? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.ProjectResource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes.ProjectResource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectResource(id: \(Swift.String(describing: id)))"}
}

extension IoTSiteWiseClientTypes {
    /// Identifies a specific IoT SiteWise Monitor project.
    public struct ProjectResource: Swift.Equatable {
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.ProjectSummary: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = creationDate {
            try encodeContainer.encode(creationDate.timeIntervalSince1970, forKey: .creationDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = lastUpdateDate {
            try encodeContainer.encode(lastUpdateDate.timeIntervalSince1970, forKey: .lastUpdateDate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes.ProjectSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectSummary(creationDate: \(Swift.String(describing: creationDate)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdateDate: \(Swift.String(describing: lastUpdateDate)), name: \(Swift.String(describing: name)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains project summary information.
    public struct ProjectSummary: Swift.Equatable {
        /// The date the project was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The project's description.
        public var description: Swift.String?
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?
        /// The date the project was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.Property: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case dataType
        case id
        case name
        case notification
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes.Property: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Property(alias: \(Swift.String(describing: alias)), dataType: \(Swift.String(describing: dataType)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), notification: \(Swift.String(describing: notification)), type: \(Swift.String(describing: type)), unit: \(Swift.String(describing: unit)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property information.
    public struct Property: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path
        ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
        ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
        ///         IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The property data type.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html">UpdateAssetProperty.
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The property type (see PropertyType). A property contains one type.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init (
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.id = id
            self.name = name
            self.notification = notification
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PropertyDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case integer
        case string
        case `struct`
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyDataType] {
            return [
                .boolean,
                .double,
                .integer,
                .string,
                .struct,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case .struct: return "STRUCT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyDataType(rawValue: rawValue) ?? PropertyDataType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PropertyNotification: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case topic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let topic = topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotificationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension IoTSiteWiseClientTypes.PropertyNotification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PropertyNotification(state: \(Swift.String(describing: state)), topic: \(Swift.String(describing: topic)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value
    ///       updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services in the IoT SiteWise User Guide.
    public struct PropertyNotification: Swift.Equatable {
        /// The current notification state.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PropertyNotificationState?
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        /// This member is required.
        public var topic: Swift.String?

        public init (
            state: IoTSiteWiseClientTypes.PropertyNotificationState? = nil,
            topic: Swift.String? = nil
        )
        {
            self.state = state
            self.topic = topic
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PropertyNotificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyNotificationState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyNotificationState(rawValue: rawValue) ?? PropertyNotificationState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PropertyType: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case measurement
        case metric
        case transform
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let measurement = measurement {
            try encodeContainer.encode(measurement, forKey: .measurement)
        }
        if let metric = metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let transform = transform {
            try encodeContainer.encode(transform, forKey: .transform)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let measurementDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Measurement.self, forKey: .measurement)
        measurement = measurementDecoded
        let transformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Transform.self, forKey: .transform)
        transform = transformDecoded
        let metricDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
    }
}

extension IoTSiteWiseClientTypes.PropertyType: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PropertyType(attribute: \(Swift.String(describing: attribute)), measurement: \(Swift.String(describing: measurement)), metric: \(Swift.String(describing: metric)), transform: \(Swift.String(describing: transform)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a property type, which can be one of attribute,
    ///         measurement, metric, or transform.
    public struct PropertyType: Swift.Equatable {
        /// Specifies an asset attribute property. An attribute generally contains static information,
        ///       such as the serial number of an <a href="https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications">IIoT wind turbine.
        public var attribute: IoTSiteWiseClientTypes.Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor
        ///       data stream, such as timestamped temperature values or timestamped power values.
        public var measurement: IoTSiteWiseClientTypes.Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses
        ///       aggregate functions to process all input data points over a time interval and output a single
        ///       data point, such as to calculate the average hourly temperature.
        public var metric: IoTSiteWiseClientTypes.Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that
        ///       maps a property's data points from one form to another, such as a unit conversion from Celsius
        ///       to Fahrenheit.
        public var transform: IoTSiteWiseClientTypes.Transform?

        public init (
            attribute: IoTSiteWiseClientTypes.Attribute? = nil,
            measurement: IoTSiteWiseClientTypes.Measurement? = nil,
            metric: IoTSiteWiseClientTypes.Metric? = nil,
            transform: IoTSiteWiseClientTypes.Transform? = nil
        )
        {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }
    }

}

extension IoTSiteWiseClientTypes.PutAssetPropertyValueEntry: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for assetpropertyvalues0 in propertyValues {
                try propertyValuesContainer.encode(assetpropertyvalues0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension IoTSiteWiseClientTypes.PutAssetPropertyValueEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAssetPropertyValueEntry(assetId: \(Swift.String(describing: assetId)), entryId: \(Swift.String(describing: entryId)), propertyAlias: \(Swift.String(describing: propertyAlias)), propertyId: \(Swift.String(describing: propertyId)), propertyValues: \(Swift.String(describing: propertyValues)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a list of value updates for an asset property in the list of asset entries
    ///       consumed by the <a href="https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html">BatchPutAssetPropertyValue API
    ///       operation.
    public struct PutAssetPropertyValueEntry: Swift.Equatable {
        /// The ID of the asset to update.
        public var assetId: Swift.String?
        /// The user specified ID for the entry. You can use this ID to identify which entries
        ///       failed.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path
        ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
        ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
        ///         IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property for this entry.
        public var propertyId: Swift.String?
        /// The list of property values to upload. You can specify up to 10
        ///         propertyValues array elements.
        /// This member is required.
        public var propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]?

        public init (
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }
    }

}

public struct PutDefaultEncryptionConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDefaultEncryptionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDefaultEncryptionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDefaultEncryptionConfigurationOutputError>
}

extension PutDefaultEncryptionConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDefaultEncryptionConfigurationInput(encryptionType: \(Swift.String(describing: encryptionType)), kmsKeyId: \(Swift.String(describing: kmsKeyId)))"}
}

extension PutDefaultEncryptionConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKeyId = kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

public struct PutDefaultEncryptionConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDefaultEncryptionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDefaultEncryptionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDefaultEncryptionConfigurationOutputError>
}

public struct PutDefaultEncryptionConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDefaultEncryptionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutDefaultEncryptionConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutDefaultEncryptionConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDefaultEncryptionConfigurationOutputError>
}

public struct PutDefaultEncryptionConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutDefaultEncryptionConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutDefaultEncryptionConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/configuration/account/encryption"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutDefaultEncryptionConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutDefaultEncryptionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutDefaultEncryptionConfigurationOutputError>
}

public struct PutDefaultEncryptionConfigurationInput: Swift.Equatable {
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ID of the customer managed customer master key (CMK) used for KMS encryption.
    ///       This is required if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyId: Swift.String?

    public init (
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

struct PutDefaultEncryptionConfigurationInputBody: Swift.Equatable {
    public let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    public let kmsKeyId: Swift.String?
}

extension PutDefaultEncryptionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension PutDefaultEncryptionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDefaultEncryptionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutDefaultEncryptionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDefaultEncryptionConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutDefaultEncryptionConfigurationOutputResponse(configurationStatus: \(Swift.String(describing: configurationStatus)), encryptionType: \(Swift.String(describing: encryptionType)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)))"}
}

extension PutDefaultEncryptionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutDefaultEncryptionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct PutDefaultEncryptionConfigurationOutputResponse: Swift.Equatable {
    /// The status of the account configuration. This contains the
    ///       ConfigurationState. If there is an error, it also contains the
    ///         ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ARN of the KMS CMK used for KMS encryption if you use
    ///         KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct PutDefaultEncryptionConfigurationOutputResponseBody: Swift.Equatable {
    public let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    public let kmsKeyArn: Swift.String?
    public let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension PutDefaultEncryptionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

public struct PutLoggingOptionsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

extension PutLoggingOptionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLoggingOptionsInput(loggingOptions: \(Swift.String(describing: loggingOptions)))"}
}

extension PutLoggingOptionsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

public struct PutLoggingOptionsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutLoggingOptionsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutLoggingOptionsInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutLoggingOptionsInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/logging"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutLoggingOptionsInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutLoggingOptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutLoggingOptionsOutputError>
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// The logging options to set.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    public let loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutLoggingOptionsOutputResponse()"}
}

extension PutLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Swift.Equatable {

    public init() {}
}

struct PutLoggingOptionsOutputResponseBody: Swift.Equatable {
}

extension PutLoggingOptionsOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct PutStorageConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStorageConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutStorageConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutStorageConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStorageConfigurationOutputError>
}

extension PutStorageConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutStorageConfigurationInput(multiLayerStorage: \(Swift.String(describing: multiLayerStorage)), storageType: \(Swift.String(describing: storageType)))"}
}

extension PutStorageConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multiLayerStorage
        case storageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let multiLayerStorage = multiLayerStorage {
            try encodeContainer.encode(multiLayerStorage, forKey: .multiLayerStorage)
        }
        if let storageType = storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }
}

public struct PutStorageConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStorageConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutStorageConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutStorageConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStorageConfigurationOutputError>
}

public struct PutStorageConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStorageConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PutStorageConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PutStorageConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStorageConfigurationOutputError>
}

public struct PutStorageConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PutStorageConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: PutStorageConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/configuration/account/storage"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = PutStorageConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<PutStorageConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<PutStorageConfigurationOutputError>
}

public struct PutStorageConfigurationInput: Swift.Equatable {
    /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type,
    ///       you must specify a MultiLayerStorage object.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// The type of storage that you specified for your data. The storage type can be one of the following values:
    ///
    ///
    ///
    ///                   SITEWISE_DEFAULT_STORAGE  IoT SiteWise replicates your data into a service managed database.
    ///
    ///
    ///
    ///                   MULTI_LAYER_STORAGE  IoT SiteWise replicates your data into a service managed database and saves a copy of your raw data and metadata in an Amazon S3 object that you specified.
    ///
    ///
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init (
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.multiLayerStorage = multiLayerStorage
        self.storageType = storageType
    }
}

struct PutStorageConfigurationInputBody: Swift.Equatable {
    public let storageType: IoTSiteWiseClientTypes.StorageType?
    public let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
}

extension PutStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case multiLayerStorage
        case storageType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
    }
}

extension PutStorageConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutStorageConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutStorageConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStorageConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutStorageConfigurationOutputResponse(configurationStatus: \(Swift.String(describing: configurationStatus)), multiLayerStorage: \(Swift.String(describing: multiLayerStorage)), storageType: \(Swift.String(describing: storageType)))"}
}

extension PutStorageConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: PutStorageConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.multiLayerStorage = output.multiLayerStorage
            self.storageType = output.storageType
        } else {
            self.configurationStatus = nil
            self.multiLayerStorage = nil
            self.storageType = nil
        }
    }
}

public struct PutStorageConfigurationOutputResponse: Swift.Equatable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// The type of storage that you specified for your data. The storage type can be one of the following values:
    ///
    ///
    ///
    ///                   SITEWISE_DEFAULT_STORAGE  IoT SiteWise replicates your data into a service managed database.
    ///
    ///
    ///
    ///                   MULTI_LAYER_STORAGE  IoT SiteWise replicates your data into a service managed database and saves a copy of your raw data and metadata in an Amazon S3 object that you specified.
    ///
    ///
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.multiLayerStorage = multiLayerStorage
        self.storageType = storageType
    }
}

struct PutStorageConfigurationOutputResponseBody: Swift.Equatable {
    public let storageType: IoTSiteWiseClientTypes.StorageType?
    public let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    public let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension PutStorageConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case multiLayerStorage
        case storageType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum Quality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bad
        case good
        case uncertain
        case sdkUnknown(Swift.String)

        public static var allCases: [Quality] {
            return [
                .bad,
                .good,
                .uncertain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bad: return "BAD"
            case .good: return "GOOD"
            case .uncertain: return "UNCERTAIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Quality(rawValue: rawValue) ?? Quality.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.Resource: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
        case project
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portal = portal {
            try encodeContainer.encode(portal, forKey: .portal)
        }
        if let project = project {
            try encodeContainer.encode(project, forKey: .project)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalResource.self, forKey: .portal)
        portal = portalDecoded
        let projectDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ProjectResource.self, forKey: .project)
        project = projectDecoded
    }
}

extension IoTSiteWiseClientTypes.Resource: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Resource(portal: \(Swift.String(describing: portal)), project: \(Swift.String(describing: project)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an IoT SiteWise Monitor resource ID for a portal or project.
    public struct Resource: Swift.Equatable {
        /// A portal resource.
        public var portal: IoTSiteWiseClientTypes.PortalResource?
        /// A project resource.
        public var project: IoTSiteWiseClientTypes.ProjectResource?

        public init (
            portal: IoTSiteWiseClientTypes.PortalResource? = nil,
            project: IoTSiteWiseClientTypes.ProjectResource? = nil
        )
        {
            self.portal = portal
            self.project = project
        }
    }

}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)), resourceArn: \(Swift.String(describing: resourceArn)), resourceId: \(Swift.String(describing: resourceId)))"}
}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ARN of the resource that already exists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource that already exists.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceId: Swift.String?
    public let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case portal
        case project
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .portal,
                .project,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .portal: return "PORTAL"
            case .project: return "PROJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceUnavailableException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServiceUnavailableException(message: \(Swift.String(describing: message)))"}
}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested service is unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiLayerStorage
        case sitewiseDefaultStorage
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .multiLayerStorage,
                .sitewiseDefaultStorage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiLayerStorage: return "MULTI_LAYER_STORAGE"
            case .sitewiseDefaultStorage: return "SITEWISE_DEFAULT_STORAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: TagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = TagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html">Tagging your IoT SiteWise
    ///         resources in the IoT SiteWise User Guide.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ThrottlingException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ThrottlingException(message: \(Swift.String(describing: message)))"}
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request exceeded a rate limit. For example, you might have exceeded the number of
///       IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so
///       on.
///          For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.TimeInNanos: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension IoTSiteWiseClientTypes.TimeInNanos: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TimeInNanos(offsetInNanos: \(Swift.String(describing: offsetInNanos)), timeInSeconds: \(Swift.String(describing: timeInSeconds)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a timestamp with optional nanosecond granularity.
    public struct TimeInNanos: Swift.Equatable {
        /// The nanosecond offset from timeInSeconds.
        public var offsetInNanos: Swift.Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is
        ///       provided by offsetInNanos.
        /// This member is required.
        public var timeInSeconds: Swift.Int?

        public init (
            offsetInNanos: Swift.Int? = nil,
            timeInSeconds: Swift.Int? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum TimeOrdering: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeOrdering] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeOrdering(rawValue: rawValue) ?? TimeOrdering.sdkUnknown(rawValue)
        }
    }
}

extension TooManyTagsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TooManyTagsException(message: \(Swift.String(describing: message)), resourceName: \(Swift.String(describing: resourceName)))"}
}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've reached the limit for the number of tags allowed for a resource. For more
///       information, see <a href="https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions">Tag naming limits and
///         requirements in the Amazon Web Services General Reference.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The name of the resource with too many tags.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
    public let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension IoTSiteWiseClientTypes.Transform: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case processingConfig
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let processingConfig = processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariables0 in variables {
                try variablesContainer.encode(expressionvariables0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTSiteWiseClientTypes.ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TransformProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes.Transform: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Transform(expression: \(Swift.String(describing: expression)), processingConfig: \(Swift.String(describing: processingConfig)), variables: \(Swift.String(describing: variables)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset transform property. A transform is a one-to-one mapping of a property's
    ///       data points from one form to another. For example, you can use a transform to convert a
    ///       Celsius data stream to Fahrenheit by applying the transformation expression to each data point
    ///       of the Celsius stream. A transform can only have a data type of DOUBLE and
    ///       consume properties with data types of INTEGER or DOUBLE.
    ///          For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#transforms">Transforms in the IoT SiteWise User Guide.
    public struct Transform: Swift.Equatable {
        /// The mathematical expression that defines the transformation function. You can specify up
        ///       to 10 variables per expression. You can specify up to 10 functions per
        ///       expression.
        ///          For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given transform property.
        ///       You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud.
        ///       You can also configure transforms to be computed at the edge or in the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?

        public init (
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
        }
    }

}

extension IoTSiteWiseClientTypes.TransformProcessingConfig: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeLocation
        case forwardingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeLocation = computeLocation {
            try encodeContainer.encode(computeLocation.rawValue, forKey: .computeLocation)
        }
        if let forwardingConfig = forwardingConfig {
            try encodeContainer.encode(forwardingConfig, forKey: .forwardingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ComputeLocation.self, forKey: .computeLocation)
        computeLocation = computeLocationDecoded
        let forwardingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfig.self, forKey: .forwardingConfig)
        forwardingConfig = forwardingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes.TransformProcessingConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TransformProcessingConfig(computeLocation: \(Swift.String(describing: computeLocation)), forwardingConfig: \(Swift.String(describing: forwardingConfig)))"}
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given transform property.
    ///       You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud.
    ///       You can also configure transforms to be computed at the edge or in the cloud.
    public struct TransformProcessingConfig: Swift.Equatable {
        /// The compute location for the given transform property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?
        /// The forwarding configuration for a given property.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init (
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil,
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.computeLocation = computeLocation
            self.forwardingConfig = forwardingConfig
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum TraversalDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case child
        case parent
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalDirection] {
            return [
                .child,
                .parent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .parent: return "PARENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TraversalDirection(rawValue: rawValue) ?? TraversalDirection.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum TraversalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pathToRoot
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalType] {
            return [
                .pathToRoot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pathToRoot: return "PATH_TO_ROOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TraversalType(rawValue: rawValue) ?? TraversalType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.TumblingWindow: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval
        case offset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let offset = offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interval)
        interval = intervalDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension IoTSiteWiseClientTypes.TumblingWindow: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TumblingWindow(interval: \(Swift.String(describing: interval)), offset: \(Swift.String(describing: offset)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and
    ///       contiguous time window. You use this window in metrics to aggregate data from properties and other assets.
    ///          You can use m, h, d, and w
    ///       when you specify an interval or offset. Note that m represents minutes,
    ///       and w represents weeks. You can also use s to represent seconds
    ///       in offset.
    ///          The interval and offset parameters support the
    ///       <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601 format.
    ///       For example, PT5S represents five seconds, PT5M represents five minutes,
    ///       and PT5H represents five hours.
    public struct TumblingWindow: Swift.Equatable {
        /// The time interval for the tumbling window. The interval time must be between 1 minute and 1 week.
        ///          IoT SiteWise computes the 1w interval the end of Sunday at midnight
        ///       each week (UTC), the 1d interval at the end of each day at midnight (UTC), the
        ///       1h interval at the end of each hour, and so on.
        ///          When IoT SiteWise aggregates data points for metric computations, the start of each interval is
        ///       exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at
        ///       the end of the interval.
        /// This member is required.
        public var interval: Swift.String?
        /// The offset for the tumbling window. The offset parameter accepts the following:
        ///
        ///
        ///                The offset time.
        ///                For example, if you specify 18h for offset
        ///           and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        ///
        ///                      If you create the metric before or at 6:00 PM (UTC),
        ///               you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        ///
        ///                      If you create the metric after 6:00 PM (UTC),
        ///               you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        ///                The ISO 8601 format.
        ///                For example, if you specify PT18H for offset
        ///           and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        ///
        ///                      If you create the metric before or at 6:00 PM (UTC),
        ///               you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        ///
        ///                      If you create the metric after 6:00 PM (UTC),
        ///               you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        ///                The 24-hour clock.
        ///                For example, if you specify 00:03:00 for offset
        ///           and 5m for interval, and you create the metric at 2 PM (UTC),
        ///           you get the first aggregation result at 2:03 PM (UTC).
        ///           You get the second aggregation result at 2:08 PM (UTC).
        ///
        ///
        ///                The offset time zone.
        ///                For example, if you specify 2021-07-23T18:00-08 for offset
        ///           and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        ///
        ///                      If you create the metric before or at 6:00 PM (PST),
        ///               you get the first aggregation result at 6 PM (PST) on the day when you create the metric.
        ///
        ///
        ///                      If you create the metric after 6:00 PM (PST),
        ///               you get the first aggregation result at 6 PM (PST) the next day.
        ///
        ///
        ///
        ///
        public var offset: Swift.String?

        public init (
            interval: Swift.String? = nil,
            offset: Swift.String? = nil
        )
        {
            self.interval = interval
            self.offset = offset
        }
    }

}

extension UnauthorizedException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UnauthorizedException(message: \(Swift.String(describing: message)))"}
}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UntagResourceInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        var urlPath = "/tags"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UntagResourceInput
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAccessPolicyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccessPolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccessPolicyOutputError>
}

extension UpdateAccessPolicyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccessPolicyInput(accessPolicyId: \(Swift.String(describing: accessPolicyId)), accessPolicyIdentity: \(Swift.String(describing: accessPolicyIdentity)), accessPolicyPermission: \(Swift.String(describing: accessPolicyPermission)), accessPolicyResource: \(Swift.String(describing: accessPolicyResource)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension UpdateAccessPolicyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateAccessPolicyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccessPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccessPolicyOutputError>
}

public struct UpdateAccessPolicyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccessPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAccessPolicyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAccessPolicyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccessPolicyOutputError>
}

public struct UpdateAccessPolicyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAccessPolicyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAccessPolicyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let accessPolicyId = input.accessPolicyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("accessPolicyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/access-policies/\(accessPolicyId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAccessPolicyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAccessPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAccessPolicyOutputError>
}

public struct UpdateAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity for this access policy. Choose an Amazon Web Services SSO user, an Amazon Web Services SSO group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
    }
}

struct UpdateAccessPolicyInputBody: Swift.Equatable {
    public let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    public let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    public let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    public let clientToken: Swift.String?
}

extension UpdateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessPolicyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAccessPolicyOutputResponse()"}
}

extension UpdateAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccessPolicyOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateAccessPolicyOutputResponseBody: Swift.Equatable {
}

extension UpdateAccessPolicyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateAssetInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

extension UpdateAssetInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetInput(assetId: \(Swift.String(describing: assetId)), assetName: \(Swift.String(describing: assetName)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension UpdateAssetInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetName = assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateAssetInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAssetInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssetInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetOutputError>
}

public struct UpdateAssetInput: Swift.Equatable {
    /// The ID of the asset to update.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique, friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.assetName = assetName
        self.clientToken = clientToken
    }
}

struct UpdateAssetInputBody: Swift.Equatable {
    public let assetName: Swift.String?
    public let clientToken: Swift.String?
}

extension UpdateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetName
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

public struct UpdateAssetModelInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetModelInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetModelOutputError>
}

extension UpdateAssetModelInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetModelInput(assetModelCompositeModels: \(Swift.String(describing: assetModelCompositeModels)), assetModelDescription: \(Swift.String(describing: assetModelDescription)), assetModelHierarchies: \(Swift.String(describing: assetModelHierarchies)), assetModelId: \(Swift.String(describing: assetModelId)), assetModelName: \(Swift.String(describing: assetModelName)), assetModelProperties: \(Swift.String(describing: assetModelProperties)), clientToken: \(Swift.String(describing: clientToken)))"}
}

extension UpdateAssetModelInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodels0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodels0)
            }
        }
        if let assetModelDescription = assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchies0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchies0)
            }
        }
        if let assetModelName = assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelproperties0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelproperties0)
            }
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateAssetModelInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetModelInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetModelOutputError>
}

public struct UpdateAssetModelInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetModelInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetModelInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetModelInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetModelOutputError>
}

public struct UpdateAssetModelInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetModelInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAssetModelInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetModelId = input.assetModelId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetModelId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/asset-models/\(assetModelId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssetModelInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetModelOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetModelOutputError>
}

public struct UpdateAssetModelInput: Swift.Equatable {
    /// The composite asset models that are part of this asset model.
    ///       Composite asset models are asset models that contain specific properties. Each composite model
    ///       has a type that defines the properties that the composite model supports. Use composite asset
    ///       models to define alarms on this asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset
    ///       model whose assets can be children of any other assets created from this asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies in the IoT SiteWise User Guide.
    ///          You can specify up to 10 hierarchies per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model to update.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique, friendly name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The updated property definitions of the asset model. For more information, see
    ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html">Asset properties in the IoT SiteWise User Guide.
    ///          You can specify up to 200 properties per asset model. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html">Quotas in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
    }
}

struct UpdateAssetModelInputBody: Swift.Equatable {
    public let assetModelName: Swift.String?
    public let assetModelDescription: Swift.String?
    public let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    public let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    public let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    public let clientToken: Swift.String?
}

extension UpdateAssetModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetModelOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetModelOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetModelOutputResponse(assetModelStatus: \(Swift.String(describing: assetModelStatus)))"}
}

extension UpdateAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct UpdateAssetModelOutputResponse: Swift.Equatable {
    /// The status of the asset model, which contains a state (UPDATING after
    ///       successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct UpdateAssetModelOutputResponseBody: Swift.Equatable {
    public let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension UpdateAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension UpdateAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetOutputResponse(assetStatus: \(Swift.String(describing: assetStatus)))"}
}

extension UpdateAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct UpdateAssetOutputResponse: Swift.Equatable {
    /// The status of the asset, which contains a state (UPDATING after successfully
    ///       calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct UpdateAssetOutputResponseBody: Swift.Equatable {
    public let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension UpdateAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

public struct UpdateAssetPropertyInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetPropertyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetPropertyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetPropertyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetPropertyOutputError>
}

extension UpdateAssetPropertyInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetPropertyInput(assetId: \(Swift.String(describing: assetId)), clientToken: \(Swift.String(describing: clientToken)), propertyAlias: \(Swift.String(describing: propertyAlias)), propertyId: \(Swift.String(describing: propertyId)), propertyNotificationState: \(Swift.String(describing: propertyNotificationState)))"}
}

extension UpdateAssetPropertyInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let propertyAlias = propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyNotificationState = propertyNotificationState {
            try encodeContainer.encode(propertyNotificationState.rawValue, forKey: .propertyNotificationState)
        }
    }
}

public struct UpdateAssetPropertyInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetPropertyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetPropertyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetPropertyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetPropertyOutputError>
}

public struct UpdateAssetPropertyInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetPropertyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateAssetPropertyInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateAssetPropertyInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetPropertyOutputError>
}

public struct UpdateAssetPropertyInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateAssetPropertyInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateAssetPropertyInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let assetId = input.assetId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("assetId is nil and needs a value for the path of this operation"))))
        }
        guard let propertyId = input.propertyId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("propertyId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateAssetPropertyInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateAssetPropertyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateAssetPropertyOutputError>
}

public struct UpdateAssetPropertyInput: Swift.Equatable {
    /// The ID of the asset to be updated.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path
    ///         (for example, /company/windfarm/3/turbine/7/temperature). For more information, see
    ///         <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html">Mapping industrial data streams to asset properties in the
    ///         IoT SiteWise User Guide.
    ///          If you omit this parameter, the alias is removed from the property.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property to be updated.
    /// This member is required.
    public var propertyId: Swift.String?
    /// The MQTT notification state (enabled or disabled) for this asset property.
    ///       When the notification state is enabled, IoT SiteWise publishes property value
    ///       updates to a unique MQTT topic. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html">Interacting with other services in the IoT SiteWise User Guide.
    ///          If you omit this parameter, the notification state is set to DISABLED.
    public var propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState?

    public init (
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyNotificationState = propertyNotificationState
    }
}

struct UpdateAssetPropertyInputBody: Swift.Equatable {
    public let propertyAlias: Swift.String?
    public let propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState?
    public let clientToken: Swift.String?
}

extension UpdateAssetPropertyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyNotificationStateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotificationState.self, forKey: .propertyNotificationState)
        propertyNotificationState = propertyNotificationStateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAssetPropertyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetPropertyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssetPropertyOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetPropertyOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAssetPropertyOutputResponse()"}
}

extension UpdateAssetPropertyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAssetPropertyOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateAssetPropertyOutputResponseBody: Swift.Equatable {
}

extension UpdateAssetPropertyOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateDashboardInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDashboardInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDashboardOutputError>
}

extension UpdateDashboardInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDashboardInput(clientToken: \(Swift.String(describing: clientToken)), dashboardDefinition: \(Swift.String(describing: dashboardDefinition)), dashboardDescription: \(Swift.String(describing: dashboardDescription)), dashboardId: \(Swift.String(describing: dashboardId)), dashboardName: \(Swift.String(describing: dashboardName)))"}
}

extension UpdateDashboardInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
    }
}

public struct UpdateDashboardInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDashboardInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDashboardOutputError>
}

public struct UpdateDashboardInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDashboardInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateDashboardInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateDashboardInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDashboardOutputError>
}

public struct UpdateDashboardInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateDashboardInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateDashboardInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let dashboardId = input.dashboardId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("dashboardId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/dashboards/\(dashboardId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateDashboardInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateDashboardOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateDashboardOutputError>
}

public struct UpdateDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The new dashboard definition, as specified in a JSON literal. For detailed information,
    ///       see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html">Creating dashboards (CLI) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A new description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard to update.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// A new friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardName = dashboardName
    }
}

struct UpdateDashboardInputBody: Swift.Equatable {
    public let dashboardName: Swift.String?
    public let dashboardDescription: Swift.String?
    public let dashboardDefinition: Swift.String?
    public let clientToken: Swift.String?
}

extension UpdateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDashboardOutputResponse()"}
}

extension UpdateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDashboardOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateDashboardOutputResponseBody: Swift.Equatable {
}

extension UpdateDashboardOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateGatewayCapabilityConfigurationInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayCapabilityConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayCapabilityConfigurationOutputError>
}

extension UpdateGatewayCapabilityConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayCapabilityConfigurationInput(capabilityConfiguration: \(Swift.String(describing: capabilityConfiguration)), capabilityNamespace: \(Swift.String(describing: capabilityNamespace)), gatewayId: \(Swift.String(describing: gatewayId)))"}
}

extension UpdateGatewayCapabilityConfigurationInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityConfiguration = capabilityConfiguration {
            try encodeContainer.encode(capabilityConfiguration, forKey: .capabilityConfiguration)
        }
        if let capabilityNamespace = capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
    }
}

public struct UpdateGatewayCapabilityConfigurationInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayCapabilityConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayCapabilityConfigurationOutputError>
}

public struct UpdateGatewayCapabilityConfigurationInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayCapabilityConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayCapabilityConfigurationInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayCapabilityConfigurationOutputError>
}

public struct UpdateGatewayCapabilityConfigurationInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayCapabilityConfigurationInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateGatewayCapabilityConfigurationInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let gatewayId = input.gatewayId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("gatewayId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGatewayCapabilityConfigurationInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayCapabilityConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayCapabilityConfigurationOutputError>
}

public struct UpdateGatewayCapabilityConfigurationInput: Swift.Equatable {
    /// The JSON document that defines the configuration for the gateway capability. For more
    ///       information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli">Configuring data sources (CLI) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability configuration to be updated.
    ///       For example, if you configure OPC-UA
    ///       sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace
    ///         iotsitewise:opcuacollector:version, where version is a number such as
    ///         1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway to be updated.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct UpdateGatewayCapabilityConfigurationInputBody: Swift.Equatable {
    public let capabilityNamespace: Swift.String?
    public let capabilityConfiguration: Swift.String?
}

extension UpdateGatewayCapabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
    }
}

extension UpdateGatewayCapabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayCapabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayCapabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayCapabilityConfigurationOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayCapabilityConfigurationOutputResponse(capabilityNamespace: \(Swift.String(describing: capabilityNamespace)), capabilitySyncStatus: \(Swift.String(describing: capabilitySyncStatus)))"}
}

extension UpdateGatewayCapabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateGatewayCapabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
        } else {
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
        }
    }
}

public struct UpdateGatewayCapabilityConfigurationOutputResponse: Swift.Equatable {
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    ///
    ///
    ///                   IN_SYNC  The gateway is running the capability configuration.
    ///
    ///
    ///
    ///                   OUT_OF_SYNC  The gateway hasn't received the capability configuration.
    ///
    ///
    ///
    ///                   SYNC_FAILED  The gateway rejected the capability configuration.
    ///
    ///
    ///          After you update a capability configuration, its sync status is OUT_OF_SYNC
    ///       until the gateway receives and applies or rejects the updated configuration.
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

    public init (
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
    }
}

struct UpdateGatewayCapabilityConfigurationOutputResponseBody: Swift.Equatable {
    public let capabilityNamespace: Swift.String?
    public let capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
}

extension UpdateGatewayCapabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

public struct UpdateGatewayInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayOutputError>
}

extension UpdateGatewayInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayInput(gatewayId: \(Swift.String(describing: gatewayId)), gatewayName: \(Swift.String(describing: gatewayName)))"}
}

extension UpdateGatewayInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
    }
}

public struct UpdateGatewayInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayOutputError>
}

public struct UpdateGatewayInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateGatewayInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateGatewayInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayOutputError>
}

public struct UpdateGatewayInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateGatewayInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateGatewayInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let gatewayId = input.gatewayId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("gatewayId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateGatewayInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateGatewayOutputError>
}

public struct UpdateGatewayInput: Swift.Equatable {
    /// The ID of the gateway to update.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// A unique, friendly name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?

    public init (
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
    }
}

struct UpdateGatewayInputBody: Swift.Equatable {
    public let gatewayName: Swift.String?
}

extension UpdateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
    }
}

extension UpdateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGatewayOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateGatewayOutputResponse()"}
}

extension UpdateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGatewayOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateGatewayOutputResponseBody: Swift.Equatable {
}

extension UpdateGatewayOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdatePortalInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

extension UpdatePortalInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalInput(alarms: \(Swift.String(describing: alarms)), clientToken: \(Swift.String(describing: clientToken)), notificationSenderEmail: \(Swift.String(describing: notificationSenderEmail)), portalContactEmail: \(Swift.String(describing: portalContactEmail)), portalDescription: \(Swift.String(describing: portalDescription)), portalId: \(Swift.String(describing: portalId)), portalLogoImage: \(Swift.String(describing: portalLogoImage)), portalName: \(Swift.String(describing: portalName)), roleArn: \(Swift.String(describing: roleArn)))"}
}

extension UpdatePortalInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalContactEmail = portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImage = portalLogoImage {
            try encodeContainer.encode(portalLogoImage, forKey: .portalLogoImage)
        }
        if let portalName = portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct UpdatePortalInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdatePortalInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdatePortalInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdatePortalInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdatePortalInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdatePortalOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let portalId = input.portalId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("portalId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/portals/\(portalId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdatePortalInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdatePortalOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdatePortalOutputError>
}

public struct UpdatePortalInput: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
    ///   You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range.
    ///   For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html">Monitoring with alarms in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A new description for the portal.
    public var portalDescription: Swift.String?
    /// The ID of the portal to update.
    /// This member is required.
    public var portalId: Swift.String?
    /// Contains an image that is one of the following:
    ///
    ///
    ///                An image file. Choose this option to upload a new image.
    ///
    ///
    ///                The ID of an existing image. Choose this option to keep an existing image.
    ///
    ///
    public var portalLogoImage: IoTSiteWiseClientTypes.Image?
    /// A new friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The <a href="https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html">ARN of a service role that allows the portal's users to access your IoT SiteWise
    ///       resources on your behalf. For more information, see <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html">Using service roles for IoT SiteWise Monitor in the
    ///         IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLogoImage: IoTSiteWiseClientTypes.Image? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLogoImage = portalLogoImage
        self.portalName = portalName
        self.roleArn = roleArn
    }
}

struct UpdatePortalInputBody: Swift.Equatable {
    public let portalName: Swift.String?
    public let portalDescription: Swift.String?
    public let portalContactEmail: Swift.String?
    public let portalLogoImage: IoTSiteWiseClientTypes.Image?
    public let roleArn: Swift.String?
    public let clientToken: Swift.String?
    public let notificationSenderEmail: Swift.String?
    public let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension UpdatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalLogoImageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Image.self, forKey: .portalLogoImage)
        portalLogoImage = portalLogoImageDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension UpdatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdatePortalOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortalOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePortalOutputResponse(portalStatus: \(Swift.String(describing: portalStatus)))"}
}

extension UpdatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct UpdatePortalOutputResponse: Swift.Equatable {
    /// The status of the portal, which contains a state (UPDATING after successfully
    ///       calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init (
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct UpdatePortalOutputResponseBody: Swift.Equatable {
    public let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
}

extension UpdatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

public struct UpdateProjectInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

extension UpdateProjectInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectInput(clientToken: \(Swift.String(describing: clientToken)), projectDescription: \(Swift.String(describing: projectDescription)), projectId: \(Swift.String(describing: projectId)), projectName: \(Swift.String(describing: projectName)))"}
}

extension UpdateProjectInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let projectDescription = projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

public struct UpdateProjectInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateProjectInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateProjectInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInputURLPathMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateProjectInputURLPathMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: UpdateProjectInput,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateProjectOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        guard let projectId = input.projectId else {
            return .failure(.client(ClientRuntime.ClientError.pathCreationFailed(("projectId is nil and needs a value for the path of this operation"))))
        }
        var urlPath = "/projects/\(projectId.urlPercentEncoding())"
        if let host = context.getHost(), let hostCustomPath = URL(string: "http://\(host)")?.path, !hostCustomPath.isEmpty {
            urlPath = "\(hostCustomPath)\(urlPath)"
        }
        var copiedContext = context
        copiedContext.attributes.set(key: AttributeKey<String>(name: "Path"), value: urlPath)
        return next.handle(context: copiedContext, input: input)
    }

    public typealias MInput = UpdateProjectInput
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateProjectOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateProjectOutputError>
}

public struct UpdateProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A new description for the project.
    public var projectDescription: Swift.String?
    /// The ID of the project to update.
    /// This member is required.
    public var projectId: Swift.String?
    /// A new friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectName = projectName
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    public let projectName: Swift.String?
    public let projectDescription: Swift.String?
    public let clientToken: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateProjectOutputResponse()"}
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Swift.Equatable {

    public init() {}
}

struct UpdateProjectOutputResponseBody: Swift.Equatable {
}

extension UpdateProjectOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension IoTSiteWiseClientTypes.UserIdentity: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes.UserIdentity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserIdentity(id: \(Swift.String(describing: id)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains information for a user identity in an access policy.
    public struct UserIdentity: Swift.Equatable {
        /// The Amazon Web Services SSO ID of the user.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.VariableValue: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyId
        case propertyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyId = hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
        if let propertyId = propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
    }
}

extension IoTSiteWiseClientTypes.VariableValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "VariableValue(hierarchyId: \(Swift.String(describing: hierarchyId)), propertyId: \(Swift.String(describing: propertyId)))"}
}

extension IoTSiteWiseClientTypes {
    /// Identifies a property value used in an expression.
    public struct VariableValue: Swift.Equatable {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name
        ///       instead of the hierarchy's ID.
        ///          You use a hierarchy ID instead of a model ID because you can have several hierarchies
        ///       using the same model and therefore the same propertyId. For example, you might
        ///       have separately grouped assets that come from the same asset model. For more information, see
        ///       <a href="https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html">Asset hierarchies in the IoT SiteWise User Guide.
        public var hierarchyId: Swift.String?
        /// The ID of the property to use as the variable. You can use the property name
        ///       if it's from the same asset model.
        /// This member is required.
        public var propertyId: Swift.String?

        public init (
            hierarchyId: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
        }
    }

}

extension IoTSiteWiseClientTypes.Variant: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let integerValue = integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let stringValue = stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
    }
}

extension IoTSiteWiseClientTypes.Variant: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Variant(booleanValue: \(Swift.String(describing: booleanValue)), doubleValue: \(Swift.String(describing: doubleValue)), integerValue: \(Swift.String(describing: integerValue)), stringValue: \(Swift.String(describing: stringValue)))"}
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset property value (of a single type only).
    public struct Variant: Swift.Equatable {
        /// Asset property data of type Boolean (true or false).
        public var booleanValue: Swift.Bool?
        /// Asset property data of type double (floating point number).
        public var doubleValue: Swift.Double?
        /// Asset property data of type integer (whole number).
        public var integerValue: Swift.Int?
        /// Asset property data of type string (sequence of characters).
        public var stringValue: Swift.String?

        public init (
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            integerValue: Swift.Int? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }
    }

}
