// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTSiteWiseClientTypes.AccessPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case id
        case identity
        case lastUpdateDate
        case permission
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identity = self.identity {
            try encodeContainer.encode(identity, forKey: .identity)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let identityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .identity)
        identity = identityDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an access policy that defines an identity's access to an IoT SiteWise Monitor resource.
    public struct AccessPolicySummary: Swift.Equatable {
        /// The date the access policy was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The ID of the access policy.
        /// This member is required.
        public var id: Swift.String?
        /// The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).
        /// This member is required.
        public var identity: IoTSiteWiseClientTypes.Identity?
        /// The date the access policy was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        /// This member is required.
        public var permission: IoTSiteWiseClientTypes.Permission?
        /// The IoT SiteWise Monitor resource (a portal or project).
        /// This member is required.
        public var resource: IoTSiteWiseClientTypes.Resource?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            identity: IoTSiteWiseClientTypes.Identity? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            permission: IoTSiteWiseClientTypes.Permission? = nil,
            resource: IoTSiteWiseClientTypes.Resource? = nil
        )
        {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AggregateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateType] {
            return [
                .average,
                .count,
                .maximum,
                .minimum,
                .standardDeviation,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .maximum: return "MAXIMUM"
            case .minimum: return "MINIMUM"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregateType(rawValue: rawValue) ?? AggregateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AggregatedValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = self.quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Quality.self, forKey: .quality)
        quality = qualityDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Aggregates.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains aggregated asset property values (for example, average, minimum, and maximum).
    public struct AggregatedValue: Swift.Equatable {
        /// The quality of the aggregated data.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The value of the aggregates.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Aggregates?

        public init (
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: ClientRuntime.Date? = nil,
            value: IoTSiteWiseClientTypes.Aggregates? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.Aggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let average = self.average {
            try encodeContainer.encode(average, forKey: .average)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let standardDeviation = self.standardDeviation {
            try encodeContainer.encode(standardDeviation, forKey: .standardDeviation)
        }
        if let sum = self.sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .average)
        average = averageDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .count)
        count = countDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximum)
        maximum = maximumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sum)
        sum = sumDecoded
        let standardDeviationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .standardDeviation)
        standardDeviation = standardDeviationDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the (pre-calculated) aggregate values for an asset property.
    public struct Aggregates: Swift.Equatable {
        /// The average (mean) value of the time series over a time interval window.
        public var average: Swift.Double?
        /// The count of data points in the time series over a time interval window.
        public var count: Swift.Double?
        /// The maximum value of the time series over a time interval window.
        public var maximum: Swift.Double?
        /// The minimum value of the time series over a time interval window.
        public var minimum: Swift.Double?
        /// The standard deviation of the time series over a time interval window.
        public var standardDeviation: Swift.Double?
        /// The sum of the time series over a time interval window.
        public var sum: Swift.Double?

        public init (
            average: Swift.Double? = nil,
            count: Swift.Double? = nil,
            maximum: Swift.Double? = nil,
            minimum: Swift.Double? = nil,
            standardDeviation: Swift.Double? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }
    }

}

extension IoTSiteWiseClientTypes.Alarms: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmRoleArn
        case notificationLambdaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmRoleArn = self.alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
        if let notificationLambdaArn = self.notificationLambdaArn {
            try encodeContainer.encode(notificationLambdaArn, forKey: .notificationLambdaArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
        let notificationLambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationLambdaArn)
        notificationLambdaArn = notificationLambdaArnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public struct Alarms: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.
        /// This member is required.
        public var alarmRoleArn: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Lambda function that manages alarm notifications. For more information, see [Managing alarm notifications](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html) in the IoT Events Developer Guide.
        public var notificationLambdaArn: Swift.String?

        public init (
            alarmRoleArn: Swift.String? = nil,
            notificationLambdaArn: Swift.String? = nil
        )
        {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }
    }

}

extension IoTSiteWiseClientTypes.AssetCompositeModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetproperty0 in properties {
                try propertiesContainer.encode(assetproperty0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetProperty?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model in an asset. This object contains the asset's properties that you define in the composite model.
    public struct AssetCompositeModel: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The ID of the asset composite model.
        public var id: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset properties that this composite model defines.
        /// This member is required.
        public var properties: [IoTSiteWiseClientTypes.AssetProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetErrorCode] {
            return [
                .internalFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetErrorCode(rawValue: rawValue) ?? AssetErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error details for the requested associate project asset action.
    public struct AssetErrorDetails: Swift.Equatable {
        /// The ID of the asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.AssetErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            assetId: Swift.String? = nil,
            code: IoTSiteWiseClientTypes.AssetErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.AssetHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Describes an asset hierarchy that contains a hierarchy's name and ID.
    public struct AssetHierarchy: Swift.Equatable {
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public var id: Swift.String?
        /// The hierarchy name provided in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetHierarchyInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case parentAssetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = self.childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let parentAssetId = self.parentAssetId {
            try encodeContainer.encode(parentAssetId, forKey: .parentAssetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentAssetId)
        parentAssetId = parentAssetIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a parent asset and a child asset that are related through an asset hierarchy.
    public struct AssetHierarchyInfo: Swift.Equatable {
        /// The ID of the child asset in this asset relationship.
        public var childAssetId: Swift.String?
        /// The ID of the parent asset in this asset relationship.
        public var parentAssetId: Swift.String?

        public init (
            childAssetId: Swift.String? = nil,
            parentAssetId: Swift.String? = nil
        )
        {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelCompositeModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelproperty0 in properties {
                try propertiesContainer.encode(assetmodelproperty0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model in an asset model. This object contains the asset property definitions that you define in the composite model.
    public struct AssetModelCompositeModel: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The ID of the asset model composite model.
        public var id: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelpropertydefinition0 in properties {
                try propertiesContainer.encode(assetmodelpropertydefinition0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertyDefinition?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a composite model definition in an asset model. This composite model definition is applied to all assets created from the asset model.
    public struct AssetModelCompositeModelDefinition: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init (
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetModelId
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = self.childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Describes an asset hierarchy that contains a hierarchy's name, ID, and child asset model ID that specifies the type of asset that can be in this hierarchy.
    public struct AssetModelHierarchy: Swift.Equatable {
        /// The ID of the asset model. All assets in this hierarchy must be instances of the childAssetModelId asset model.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.
        public var id: Swift.String?
        /// The name of the asset model hierarchy that you specify by using the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation.
        /// This member is required.
        public var name: Swift.String?

        public init (
            childAssetModelId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.id = id
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelHierarchyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetModelId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = self.childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset model hierarchy used in asset model creation. An asset model hierarchy determines the kind (or type) of asset that can belong to a hierarchy.
    public struct AssetModelHierarchyDefinition: Swift.Equatable {
        /// The ID of an asset model for this hierarchy.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// The name of the asset model hierarchy definition (as specified in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation).
        /// This member is required.
        public var name: Swift.String?

        public init (
            childAssetModelId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case dataTypeSpec
        case id
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an asset model property.
    public struct AssetModelProperty: Swift.Equatable {
        /// The data type of the asset model property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset model property.
        public var id: Swift.String?
        /// The name of the asset model property.
        /// This member is required.
        public var name: Swift.String?
        /// The property type (see PropertyType).
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the asset model property, such as Newtons or RPM.
        public var unit: Swift.String?

        public init (
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelPropertyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case dataTypeSpec
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset model property definition. This property definition is applied to all assets created from the asset model.
    public struct AssetModelPropertyDefinition: Swift.Equatable {
        /// The data type of the property definition. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter is required on properties that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you define this property. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public var dataTypeSpec: Swift.String?
        /// The name of the property definition.
        /// This member is required.
        public var name: Swift.String?
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the property definition, such as Newtons or RPM.
        public var unit: Swift.String?

        public init (
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelPropertySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModelId
        case dataType
        case dataTypeSpec
        case id
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModelId = self.assetModelCompositeModelId {
            try encodeContainer.encode(assetModelCompositeModelId, forKey: .assetModelCompositeModelId)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
        let assetModelCompositeModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelCompositeModelId)
        assetModelCompositeModelId = assetModelCompositeModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a property associated with a model.
    public struct AssetModelPropertySummary: Swift.Equatable {
        /// The ID of the composite model that contains the asset model property.
        public var assetModelCompositeModelId: Swift.String?
        /// The data type of the property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the property.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// Contains a property type, which can be one of attribute, measurement, metric, or transform.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit (such as Newtons or RPM) of the property.
        public var unit: Swift.String?

        public init (
            assetModelCompositeModelId: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetModelState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case propagating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetModelState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .propagating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .propagating: return "PROPAGATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetModelState(rawValue: rawValue) ?? AssetModelState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetModelStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains current status information for an asset model. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    public struct AssetModelStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current state of the asset model.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetModelState?

        public init (
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetModelState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an asset model.
    public struct AssetModelSummary: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        /// This member is required.
        public var arn: Swift.String?
        /// The date the asset model was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The asset model description.
        /// This member is required.
        public var description: Swift.String?
        /// The ID of the asset model (used with IoT SiteWise APIs).
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset model was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset model.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset model.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetModelStatus?

        public init (
            arn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetModelStatus? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.AssetProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case dataType
        case dataTypeSpec
        case id
        case name
        case notification
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property information.
    public struct AssetProperty: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The data type of the asset property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init (
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.notification = notification
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetPropertySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case assetCompositeModelId
        case id
        case notification
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let assetCompositeModelId = self.assetCompositeModelId {
            try encodeContainer.encode(assetCompositeModelId, forKey: .assetCompositeModelId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let assetCompositeModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetCompositeModelId)
        assetCompositeModelId = assetCompositeModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a property associated with an asset.
    public struct AssetPropertySummary: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The ID of the composite model that contains the asset property.
        public var assetCompositeModelId: Swift.String?
        /// The ID of the property.
        public var id: Swift.String?
        /// Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide.
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The unit of measure (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init (
            alias: Swift.String? = nil,
            assetCompositeModelId: Swift.String? = nil,
            id: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.assetCompositeModelId = assetCompositeModelId
            self.id = id
            self.notification = notification
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetPropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = self.quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Variant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Quality.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property value information.
    public struct AssetPropertyValue: Swift.Equatable {
        /// The quality of the asset property value.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The timestamp of the asset property value.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// The value of the asset property (see Variant).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init (
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.AssetRelationshipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyInfo
        case relationshipType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyInfo = self.hierarchyInfo {
            try encodeContainer.encode(hierarchyInfo, forKey: .hierarchyInfo)
        }
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetHierarchyInfo.self, forKey: .hierarchyInfo)
        hierarchyInfo = hierarchyInfoDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about assets that are related to one another.
    public struct AssetRelationshipSummary: Swift.Equatable {
        /// The assets that are related through an asset hierarchy. This object is present if the relationshipType is HIERARCHY.
        public var hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the following:
        ///
        /// * HIERARCHY – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the hierarchyInfo object.
        /// This member is required.
        public var relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType?

        public init (
            hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo? = nil,
            relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType? = nil
        )
        {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hierarchy
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetRelationshipType] {
            return [
                .hierarchy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hierarchy: return "HIERARCHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetRelationshipType(rawValue: rawValue) ?? AssetRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum AssetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetState(rawValue: rawValue) ?? AssetState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the current status of an asset. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    public struct AssetStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current status of the asset.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetState?

        public init (
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.AssetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetModelId
        case creationDate
        case description
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchy0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchy0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an asset.
    public struct AssetSummary: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create this asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A description for the asset.
        public var description: Swift.String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init (
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension AssociateAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = self.childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

extension AssociateAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/associate"
    }
}

public struct AssociateAssetsInput: Swift.Equatable {
    /// The ID of the parent asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to be associated.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct AssociateAssetsInputBody: Swift.Equatable {
    let hierarchyId: Swift.String?
    let childAssetId: Swift.String?
    let clientToken: Swift.String?
}

extension AssociateAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateAssetsOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateAssetsOutputResponse: Swift.Equatable {

    public init () { }
}

extension AssociateTimeSeriesToAssetPropertyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension AssociateTimeSeriesToAssetPropertyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let assetId = assetId else {
                let message = "Creating a URL Query Item failed. assetId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
            guard let alias = alias else {
                let message = "Creating a URL Query Item failed. alias is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
            guard let propertyId = propertyId else {
                let message = "Creating a URL Query Item failed. propertyId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
            return items
        }
    }
}

extension AssociateTimeSeriesToAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/associate"
    }
}

public struct AssociateTimeSeriesToAssetPropertyInput: Swift.Equatable {
    /// The alias that identifies the time series.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property.
    /// This member is required.
    public var propertyId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

struct AssociateTimeSeriesToAssetPropertyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension AssociateTimeSeriesToAssetPropertyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateTimeSeriesToAssetPropertyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTimeSeriesToAssetPropertyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateTimeSeriesToAssetPropertyOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTimeSeriesToAssetPropertyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AssociateTimeSeriesToAssetPropertyOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTSiteWiseClientTypes.AssociatedAssetsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetModelId
        case creationDate
        case description
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchy0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchy0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an associated asset.
    public struct AssociatedAssetsSummary: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create the asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A description for the asset.
        public var description: Swift.String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init (
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset attribute property. For more information, see [Attributes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#attributes) in the IoT SiteWise User Guide.
    public struct Attribute: Swift.Equatable {
        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see [Updating attribute values](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html) in the IoT SiteWise User Guide.
        public var defaultValue: Swift.String?

        public init (
            defaultValue: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AuthMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case sso
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMode] {
            return [
                .iam,
                .sso,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .sso: return "SSO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthMode(rawValue: rawValue) ?? AuthMode.sdkUnknown(rawValue)
        }
    }
}

extension BatchAssociateProjectAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for id0 in assetIds {
                try assetIdsContainer.encode(id0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension BatchAssociateProjectAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets/associate"
    }
}

public struct BatchAssociateProjectAssetsInput: Swift.Equatable {
    /// The IDs of the assets to be associated to the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project to which to associate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchAssociateProjectAssetsInputBody: Swift.Equatable {
    let assetIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension BatchAssociateProjectAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchAssociateProjectAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchAssociateProjectAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchAssociateProjectAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchAssociateProjectAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchAssociateProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateProjectAssetsOutputResponse: Swift.Equatable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init (
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateProjectAssetsOutputResponseBody: Swift.Equatable {
    let errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?
}

extension BatchAssociateProjectAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchDisassociateProjectAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for id0 in assetIds {
                try assetIdsContainer.encode(id0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension BatchDisassociateProjectAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets/disassociate"
    }
}

public struct BatchDisassociateProjectAssetsInput: Swift.Equatable {
    /// The IDs of the assets to be disassociated from the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project from which to disassociate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchDisassociateProjectAssetsInputBody: Swift.Equatable {
    let assetIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension BatchDisassociateProjectAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchDisassociateProjectAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDisassociateProjectAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchDisassociateProjectAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDisassociateProjectAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchDisassociateProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateProjectAssetsOutputResponse: Swift.Equatable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init (
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateProjectAssetsOutputResponseBody: Swift.Equatable {
    let errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?
}

extension BatchDisassociateProjectAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    public enum BatchEntryCompletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchEntryCompletionStatus] {
            return [
                .error,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchEntryCompletionStatus(rawValue: rawValue) ?? BatchEntryCompletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateTypes
        case assetId
        case endDate
        case entryId
        case propertyAlias
        case propertyId
        case qualities
        case resolution
        case startDate
        case timeOrdering
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateTypes = aggregateTypes {
            var aggregateTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregateTypes)
            for aggregatetype0 in aggregateTypes {
                try aggregateTypesContainer.encode(aggregatetype0.rawValue)
            }
        }
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let qualities = qualities {
            var qualitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualities)
            for quality0 in qualities {
                try qualitiesContainer.encode(quality0.rawValue)
            }
        }
        if let resolution = self.resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let timeOrdering = self.timeOrdering {
            try encodeContainer.encode(timeOrdering.rawValue, forKey: .timeOrdering)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let aggregateTypesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AggregateType?].self, forKey: .aggregateTypes)
        var aggregateTypesDecoded0:[IoTSiteWiseClientTypes.AggregateType]? = nil
        if let aggregateTypesContainer = aggregateTypesContainer {
            aggregateTypesDecoded0 = [IoTSiteWiseClientTypes.AggregateType]()
            for enum0 in aggregateTypesContainer {
                if let enum0 = enum0 {
                    aggregateTypesDecoded0?.append(enum0)
                }
            }
        }
        aggregateTypes = aggregateTypesDecoded0
        let resolutionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let qualitiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.Quality?].self, forKey: .qualities)
        var qualitiesDecoded0:[IoTSiteWiseClientTypes.Quality]? = nil
        if let qualitiesContainer = qualitiesContainer {
            qualitiesDecoded0 = [IoTSiteWiseClientTypes.Quality]()
            for enum0 in qualitiesContainer {
                if let enum0 = enum0 {
                    qualitiesDecoded0?.append(enum0)
                }
            }
        }
        qualities = qualitiesDecoded0
        let timeOrderingDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeOrdering.self, forKey: .timeOrdering)
        timeOrdering = timeOrderingDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyAggregatesEntry: Swift.Equatable {
        /// The data aggregating function.
        /// This member is required.
        public var aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]?
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        /// This member is required.
        public var endDate: ClientRuntime.Date?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The quality by which to filter asset data.
        public var qualities: [IoTSiteWiseClientTypes.Quality]?
        /// The time interval over which to aggregate data.
        /// This member is required.
        public var resolution: Swift.String?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        /// This member is required.
        public var startDate: ClientRuntime.Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

        public init (
            aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]? = nil,
            assetId: Swift.String? = nil,
            endDate: ClientRuntime.Date? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
            resolution: Swift.String? = nil,
            startDate: ClientRuntime.Date? = nil,
            timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
        )
        {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchGetAssetPropertyAggregatesErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyAggregatesErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchGetAssetPropertyAggregatesErrorCode(rawValue: rawValue) ?? BatchGetAssetPropertyAggregatesErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesErrorEntry: Swift.Equatable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init (
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorTimestamp = self.errorTimestamp {
            try encodeContainer.encodeTimestamp(errorTimestamp, format: .epochSeconds, forKey: .errorTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the error code and the timestamp for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesErrorInfo: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: ClientRuntime.Date?

        public init (
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension BatchGetAssetPropertyAggregatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchgetassetpropertyaggregatesentry0 in entries {
                try entriesContainer.encode(batchgetassetpropertyaggregatesentry0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension BatchGetAssetPropertyAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/batch/aggregates"
    }
}

public struct BatchGetAssetPropertyAggregatesInput: Swift.Equatable {
    /// The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is less than 1 MB.
    ///
    /// * The number of data points in the result set is less than the value of maxResults. The maximum value of maxResults is 4000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct BatchGetAssetPropertyAggregatesInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension BatchGetAssetPropertyAggregatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchGetAssetPropertyAggregatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetAssetPropertyAggregatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetAssetPropertyAggregatesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetAssetPropertyAggregatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetAssetPropertyAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
            self.nextToken = output.nextToken
            self.skippedEntries = output.skippedEntries
            self.successEntries = output.successEntries
        } else {
            self.errorEntries = nil
            self.nextToken = nil
            self.skippedEntries = nil
            self.successEntries = nil
        }
    }
}

public struct BatchGetAssetPropertyAggregatesOutputResponse: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]?

    public init (
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

struct BatchGetAssetPropertyAggregatesOutputResponseBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]?
    let successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]?
    let skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyAggregatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
        case nextToken
        case skippedEntries
        case successEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
        let successEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry?].self, forKey: .successEntries)
        var successEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]? = nil
        if let successEntriesContainer = successEntriesContainer {
            successEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]()
            for structure0 in successEntriesContainer {
                if let structure0 = structure0 {
                    successEntriesDecoded0?.append(structure0)
                }
            }
        }
        successEntries = successEntriesDecoded0
        let skippedEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry?].self, forKey: .skippedEntries)
        var skippedEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]? = nil
        if let skippedEntriesContainer = skippedEntriesContainer {
            skippedEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]()
            for structure0 in skippedEntriesContainer {
                if let structure0 = structure0 {
                    skippedEntriesDecoded0?.append(structure0)
                }
            }
        }
        skippedEntries = skippedEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus
        case entryId
        case errorInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = self.completionStatus {
            try encodeContainer.encode(completionStatus.rawValue, forKey: .completionStatus)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let completionStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchEntryCompletionStatus.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) request.
    public struct BatchGetAssetPropertyAggregatesSkippedEntry: Swift.Equatable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo?

        public init (
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedValues
        case entryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatedValues = aggregatedValues {
            var aggregatedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregatedValues)
            for aggregatedvalue0 in aggregatedValues {
                try aggregatedValuesContainer.encode(aggregatedvalue0)
            }
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let aggregatedValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AggregatedValue?].self, forKey: .aggregatedValues)
        var aggregatedValuesDecoded0:[IoTSiteWiseClientTypes.AggregatedValue]? = nil
        if let aggregatedValuesContainer = aggregatedValuesContainer {
            aggregatedValuesDecoded0 = [IoTSiteWiseClientTypes.AggregatedValue]()
            for structure0 in aggregatedValuesContainer {
                if let structure0 = structure0 {
                    aggregatedValuesDecoded0?.append(structure0)
                }
            }
        }
        aggregatedValues = aggregatedValuesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesSuccessEntry: Swift.Equatable {
        /// The requested aggregated asset property values (for example, average, minimum, and maximum).
        /// This member is required.
        public var aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init (
            aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.aggregatedValues = aggregatedValues
            self.entryId = entryId
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an asset property value entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyValueEntry: Swift.Equatable {
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?

        public init (
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchGetAssetPropertyValueErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyValueErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchGetAssetPropertyValueErrorCode(rawValue: rawValue) ?? BatchGetAssetPropertyValueErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information for an asset property value entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueErrorEntry: Swift.Equatable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init (
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorTimestamp = self.errorTimestamp {
            try encodeContainer.encodeTimestamp(errorTimestamp, format: .epochSeconds, forKey: .errorTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The error information, such as the error code and the timestamp.
    public struct BatchGetAssetPropertyValueErrorInfo: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: ClientRuntime.Date?

        public init (
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case endDate
        case entryId
        case propertyAlias
        case propertyId
        case qualities
        case startDate
        case timeOrdering
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let qualities = qualities {
            var qualitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualities)
            for quality0 in qualities {
                try qualitiesContainer.encode(quality0.rawValue)
            }
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let timeOrdering = self.timeOrdering {
            try encodeContainer.encode(timeOrdering.rawValue, forKey: .timeOrdering)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let qualitiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.Quality?].self, forKey: .qualities)
        var qualitiesDecoded0:[IoTSiteWiseClientTypes.Quality]? = nil
        if let qualitiesContainer = qualitiesContainer {
            qualitiesDecoded0 = [IoTSiteWiseClientTypes.Quality]()
            for enum0 in qualitiesContainer {
                if let enum0 = enum0 {
                    qualitiesDecoded0?.append(enum0)
                }
            }
        }
        qualities = qualitiesDecoded0
        let timeOrderingDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeOrdering.self, forKey: .timeOrdering)
        timeOrdering = timeOrderingDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an asset property historical value entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyValueHistoryEntry: Swift.Equatable {
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public var endDate: ClientRuntime.Date?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The quality by which to filter asset data.
        public var qualities: [IoTSiteWiseClientTypes.Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public var startDate: ClientRuntime.Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

        public init (
            assetId: Swift.String? = nil,
            endDate: ClientRuntime.Date? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
            startDate: ClientRuntime.Date? = nil,
            timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
        )
        {
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchGetAssetPropertyValueHistoryErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyValueHistoryErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchGetAssetPropertyValueHistoryErrorCode(rawValue: rawValue) ?? BatchGetAssetPropertyValueHistoryErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    public struct BatchGetAssetPropertyValueHistoryErrorEntry: Swift.Equatable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init (
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorTimestamp = self.errorTimestamp {
            try encodeContainer.encodeTimestamp(errorTimestamp, format: .epochSeconds, forKey: .errorTimestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The error information, such as the error code and the timestamp.
    public struct BatchGetAssetPropertyValueHistoryErrorInfo: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: ClientRuntime.Date?

        public init (
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension BatchGetAssetPropertyValueHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchgetassetpropertyvaluehistoryentry0 in entries {
                try entriesContainer.encode(batchgetassetpropertyvaluehistoryentry0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension BatchGetAssetPropertyValueHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/batch/history"
    }
}

public struct BatchGetAssetPropertyValueHistoryInput: Swift.Equatable {
    /// The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is less than 1 MB.
    ///
    /// * The number of data points in the result set is less than the value of maxResults. The maximum value of maxResults is 4000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct BatchGetAssetPropertyValueHistoryInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension BatchGetAssetPropertyValueHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchGetAssetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetAssetPropertyValueHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetAssetPropertyValueHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetAssetPropertyValueHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetAssetPropertyValueHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
            self.nextToken = output.nextToken
            self.skippedEntries = output.skippedEntries
            self.successEntries = output.successEntries
        } else {
            self.errorEntries = nil
            self.nextToken = nil
            self.skippedEntries = nil
            self.successEntries = nil
        }
    }
}

public struct BatchGetAssetPropertyValueHistoryOutputResponse: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]?

    public init (
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

struct BatchGetAssetPropertyValueHistoryOutputResponseBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]?
    let successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]?
    let skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyValueHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
        case nextToken
        case skippedEntries
        case successEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
        let successEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry?].self, forKey: .successEntries)
        var successEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]? = nil
        if let successEntriesContainer = successEntriesContainer {
            successEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]()
            for structure0 in successEntriesContainer {
                if let structure0 = structure0 {
                    successEntriesDecoded0?.append(structure0)
                }
            }
        }
        successEntries = successEntriesDecoded0
        let skippedEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry?].self, forKey: .skippedEntries)
        var skippedEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]? = nil
        if let skippedEntriesContainer = skippedEntriesContainer {
            skippedEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]()
            for structure0 in skippedEntriesContainer {
                if let structure0 = structure0 {
                    skippedEntriesDecoded0?.append(structure0)
                }
            }
        }
        skippedEntries = skippedEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus
        case entryId
        case errorInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = self.completionStatus {
            try encodeContainer.encode(completionStatus.rawValue, forKey: .completionStatus)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let completionStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchEntryCompletionStatus.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
    public struct BatchGetAssetPropertyValueHistorySkippedEntry: Swift.Equatable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValueHistory.html) API.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo?

        public init (
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertyValueHistory
        case entryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetPropertyValueHistory = assetPropertyValueHistory {
            var assetPropertyValueHistoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetPropertyValueHistory)
            for assetpropertyvalue0 in assetPropertyValueHistory {
                try assetPropertyValueHistoryContainer.encode(assetpropertyvalue0)
            }
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetPropertyValueHistoryContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .assetPropertyValueHistory)
        var assetPropertyValueHistoryDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let assetPropertyValueHistoryContainer = assetPropertyValueHistoryContainer {
            assetPropertyValueHistoryDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in assetPropertyValueHistoryContainer {
                if let structure0 = structure0 {
                    assetPropertyValueHistoryDecoded0?.append(structure0)
                }
            }
        }
        assetPropertyValueHistory = assetPropertyValueHistoryDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueHistorySuccessEntry: Swift.Equatable {
        /// The requested historical values for the specified asset property.
        /// This member is required.
        public var assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init (
            assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.entryId = entryId
        }
    }

}

extension BatchGetAssetPropertyValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchgetassetpropertyvalueentry0 in entries {
                try entriesContainer.encode(batchgetassetpropertyvalueentry0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension BatchGetAssetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/batch/latest"
    }
}

public struct BatchGetAssetPropertyValueInput: Swift.Equatable {
    /// The list of asset property value entries for the batch get request. You can specify up to 16 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct BatchGetAssetPropertyValueInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchGetAssetPropertyValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetAssetPropertyValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetAssetPropertyValueOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetAssetPropertyValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetAssetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
            self.nextToken = output.nextToken
            self.skippedEntries = output.skippedEntries
            self.successEntries = output.successEntries
        } else {
            self.errorEntries = nil
            self.nextToken = nil
            self.skippedEntries = nil
            self.successEntries = nil
        }
    }
}

public struct BatchGetAssetPropertyValueOutputResponse: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]?

    public init (
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

struct BatchGetAssetPropertyValueOutputResponseBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]?
    let successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]?
    let skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
        case nextToken
        case skippedEntries
        case successEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
        let successEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry?].self, forKey: .successEntries)
        var successEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]? = nil
        if let successEntriesContainer = successEntriesContainer {
            successEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]()
            for structure0 in successEntriesContainer {
                if let structure0 = structure0 {
                    successEntriesDecoded0?.append(structure0)
                }
            }
        }
        successEntries = successEntriesDecoded0
        let skippedEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry?].self, forKey: .skippedEntries)
        var skippedEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]? = nil
        if let skippedEntriesContainer = skippedEntriesContainer {
            skippedEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]()
            for structure0 in skippedEntriesContainer {
                if let structure0 = structure0 {
                    skippedEntriesDecoded0?.append(structure0)
                }
            }
        }
        skippedEntries = skippedEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus
        case entryId
        case errorInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = self.completionStatus {
            try encodeContainer.encode(completionStatus.rawValue, forKey: .completionStatus)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let completionStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchEntryCompletionStatus.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
    public struct BatchGetAssetPropertyValueSkippedEntry: Swift.Equatable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo?

        public init (
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertyValue
        case entryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetPropertyValue = self.assetPropertyValue {
            try encodeContainer.encode(assetPropertyValue, forKey: .assetPropertyValue)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetPropertyValueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetPropertyValue.self, forKey: .assetPropertyValue)
        assetPropertyValue = assetPropertyValueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueSuccessEntry: Swift.Equatable {
        /// Contains asset property value information.
        public var assetPropertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init (
            assetPropertyValue: IoTSiteWiseClientTypes.AssetPropertyValue? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.assetPropertyValue = assetPropertyValue
            self.entryId = entryId
        }
    }

}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case timestamps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let timestamps = timestamps {
            var timestampsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timestamps)
            for timeinnanos0 in timestamps {
                try timestampsContainer.encode(timeinnanos0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let timestampsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.TimeInNanos?].self, forKey: .timestamps)
        var timestampsDecoded0:[IoTSiteWiseClientTypes.TimeInNanos]? = nil
        if let timestampsContainer = timestampsContainer {
            timestampsDecoded0 = [IoTSiteWiseClientTypes.TimeInNanos]()
            for structure0 in timestampsContainer {
                if let structure0 = structure0 {
                    timestampsDecoded0?.append(structure0)
                }
            }
        }
        timestamps = timestampsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information from updating a batch of asset property values.
    public struct BatchPutAssetPropertyError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// A list of timestamps for each error, if any.
        /// This member is required.
        public var timestamps: [IoTSiteWiseClientTypes.TimeInNanos]?

        public init (
            errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            timestamps: [IoTSiteWiseClientTypes.TimeInNanos]? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }
    }

}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for batchputassetpropertyerror0 in errors {
                try errorsContainer.encode(batchputassetpropertyerror0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchPutAssetPropertyError?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.BatchPutAssetPropertyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information for asset property value entries that are associated with the [BatchPutAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html) API.
    public struct BatchPutAssetPropertyErrorEntry: Swift.Equatable {
        /// The ID of the failed entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The list of update property value errors.
        /// This member is required.
        public var errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]?

        public init (
            entryId: Swift.String? = nil,
            errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]? = nil
        )
        {
            self.entryId = entryId
            self.errors = errors
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchPutAssetPropertyValueErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case conflictingoperationexception
        case internalfailureexception
        case invalidrequestexception
        case limitexceededexception
        case resourcenotfoundexception
        case serviceunavailableexception
        case throttlingexception
        case timestampoutofrangeexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchPutAssetPropertyValueErrorCode] {
            return [
                .accessdeniedexception,
                .conflictingoperationexception,
                .internalfailureexception,
                .invalidrequestexception,
                .limitexceededexception,
                .resourcenotfoundexception,
                .serviceunavailableexception,
                .throttlingexception,
                .timestampoutofrangeexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .conflictingoperationexception: return "ConflictingOperationException"
            case .internalfailureexception: return "InternalFailureException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .limitexceededexception: return "LimitExceededException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .serviceunavailableexception: return "ServiceUnavailableException"
            case .throttlingexception: return "ThrottlingException"
            case .timestampoutofrangeexception: return "TimestampOutOfRangeException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchPutAssetPropertyValueErrorCode(rawValue: rawValue) ?? BatchPutAssetPropertyValueErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension BatchPutAssetPropertyValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for putassetpropertyvalueentry0 in entries {
                try entriesContainer.encode(putassetpropertyvalueentry0)
            }
        }
    }
}

extension BatchPutAssetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties"
    }
}

public struct BatchPutAssetPropertyValueInput: Swift.Equatable {
    /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]?

    public init (
        entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct BatchPutAssetPropertyValueInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]?
}

extension BatchPutAssetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.PutAssetPropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutAssetPropertyValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchPutAssetPropertyValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchPutAssetPropertyValueOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchPutAssetPropertyValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchPutAssetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchPutAssetPropertyValueOutputResponse: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]?

    public init (
        errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchPutAssetPropertyValueOutputResponseBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]?
}

extension BatchPutAssetPropertyValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    public enum CapabilitySyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inSync
        case outOfSync
        case syncFailed
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilitySyncStatus] {
            return [
                .inSync,
                .outOfSync,
                .syncFailed,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inSync: return "IN_SYNC"
            case .outOfSync: return "OUT_OF_SYNC"
            case .syncFailed: return "SYNC_FAILED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapabilitySyncStatus(rawValue: rawValue) ?? CapabilitySyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ColumnName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alias
        case assetId
        case dataType
        case propertyId
        case quality
        case timestampNanoOffset
        case timestampSeconds
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnName] {
            return [
                .alias,
                .assetId,
                .dataType,
                .propertyId,
                .quality,
                .timestampNanoOffset,
                .timestampSeconds,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alias: return "ALIAS"
            case .assetId: return "ASSET_ID"
            case .dataType: return "DATA_TYPE"
            case .propertyId: return "PROPERTY_ID"
            case .quality: return "QUALITY"
            case .timestampNanoOffset: return "TIMESTAMP_NANO_OFFSET"
            case .timestampSeconds: return "TIMESTAMP_SECONDS"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnName(rawValue: rawValue) ?? ColumnName.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.CompositeModelProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetProperty
        case id
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetProperty = self.assetProperty {
            try encodeContainer.encode(assetProperty, forKey: .assetProperty)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model property on an asset.
    public struct CompositeModelProperty: Swift.Equatable {
        /// Contains asset property information.
        /// This member is required.
        public var assetProperty: IoTSiteWiseClientTypes.Property?
        /// The ID of the composite model that contains the property.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the composite model that defines this property.
        /// This member is required.
        public var type: Swift.String?

        public init (
            assetProperty: IoTSiteWiseClientTypes.Property? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.assetProperty = assetProperty
            self.id = id
            self.name = name
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ComputeLocation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case edge
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeLocation] {
            return [
                .cloud,
                .edge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .edge: return "EDGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputeLocation(rawValue: rawValue) ?? ComputeLocation.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ConfigurationErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the details of an IoT SiteWise configuration error.
    public struct ConfigurationErrorDetails: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .active,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationState(rawValue: rawValue) ?? ConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ConfigurationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains current status information for the configuration.
    public struct ConfigurationStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ConfigurationErrorDetails?
        /// The current state of the configuration.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ConfigurationState?

        public init (
            error: IoTSiteWiseClientTypes.ConfigurationErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.ConfigurationState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension ConflictingOperationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictingOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictingOperationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ARN of the resource that conflicts with this operation.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource that conflicts with this operation.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ConflictingOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
}

extension ConflictingOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension CreateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = self.accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = self.accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = self.accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/access-policies"
    }
}

public struct CreateAccessPolicyInput: Swift.Equatable {
    /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the access policy. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAccessPolicyInputBody: Swift.Equatable {
    let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyId = output.accessPolicyId
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyId = nil
        }
    }
}

public struct CreateAccessPolicyOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the access policy, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init (
        accessPolicyArn: Swift.String? = nil,
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyId = accessPolicyId
    }
}

struct CreateAccessPolicyOutputResponseBody: Swift.Equatable {
    let accessPolicyId: Swift.String?
    let accessPolicyArn: Swift.String?
}

extension CreateAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyArn
        case accessPolicyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
    }
}

extension CreateAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDescription = self.assetDescription {
            try encodeContainer.encode(assetDescription, forKey: .assetDescription)
        }
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let assetName = self.assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assets"
    }
}

public struct CreateAssetInput: Swift.Equatable {
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// The ID of the asset model from which to create the asset.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assetDescription: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetDescription = assetDescription
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetInputBody: Swift.Equatable {
    let assetName: Swift.String?
    let assetModelId: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let assetDescription: Swift.String?
}

extension CreateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let assetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetDescription)
        assetDescription = assetDescriptionDecoded
    }
}

extension CreateAssetModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodeldefinition0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodeldefinition0)
            }
        }
        if let assetModelDescription = self.assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchydefinition0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchydefinition0)
            }
        }
        if let assetModelName = self.assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelpropertydefinition0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelpropertydefinition0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/asset-models"
    }
}

public struct CreateAssetModelInput: Swift.Equatable {
    /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]?
    /// A unique, friendly name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The property definitions of the asset model. For more information, see [Asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html) in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset model. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetModelInputBody: Swift.Equatable {
    let assetModelName: Swift.String?
    let assetModelDescription: Swift.String?
    let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]?
    let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssetModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertyDefinition?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchyDefinition?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssetModelOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelArn = output.assetModelArn
            self.assetModelId = output.assetModelId
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelId = nil
            self.assetModelStatus = nil
        }
    }
}

public struct CreateAssetModelOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The ID of the asset model. You can use this ID when you call other IoT SiteWise APIs.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelArn: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelId = assetModelId
        self.assetModelStatus = assetModelStatus
    }
}

struct CreateAssetModelOutputResponseBody: Swift.Equatable {
    let assetModelId: Swift.String?
    let assetModelArn: Swift.String?
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension CreateAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelArn
        case assetModelId
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension CreateAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateAssetOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetArn = output.assetArn
            self.assetId = output.assetId
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetId = nil
            self.assetStatus = nil
        }
    }
}

public struct CreateAssetOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    /// This member is required.
    public var assetArn: Swift.String?
    /// The ID of the asset. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise APIs.
    /// This member is required.
    public var assetId: Swift.String?
    /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetArn: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetId = assetId
        self.assetStatus = assetStatus
    }
}

struct CreateAssetOutputResponseBody: Swift.Equatable {
    let assetId: Swift.String?
    let assetArn: Swift.String?
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension CreateAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetArn
        case assetId
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

extension CreateBulkImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorReportLocation
        case files
        case jobConfiguration
        case jobName
        case jobRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorReportLocation = self.errorReportLocation {
            try encodeContainer.encode(errorReportLocation, forKey: .errorReportLocation)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for file0 in files {
                try filesContainer.encode(file0)
            }
        }
        if let jobConfiguration = self.jobConfiguration {
            try encodeContainer.encode(jobConfiguration, forKey: .jobConfiguration)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRoleArn = self.jobRoleArn {
            try encodeContainer.encode(jobRoleArn, forKey: .jobRoleArn)
        }
    }
}

extension CreateBulkImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct CreateBulkImportJobInput: Swift.Equatable {
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    /// This member is required.
    public var errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    /// The files in the specified Amazon S3 bucket that contain your data.
    /// This member is required.
    public var files: [IoTSiteWiseClientTypes.File]?
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    /// This member is required.
    public var jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows IoT SiteWise to read Amazon S3 data.
    /// This member is required.
    public var jobRoleArn: Swift.String?

    public init (
        errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation? = nil,
        files: [IoTSiteWiseClientTypes.File]? = nil,
        jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration? = nil,
        jobName: Swift.String? = nil,
        jobRoleArn: Swift.String? = nil
    )
    {
        self.errorReportLocation = errorReportLocation
        self.files = files
        self.jobConfiguration = jobConfiguration
        self.jobName = jobName
        self.jobRoleArn = jobRoleArn
    }
}

struct CreateBulkImportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let jobRoleArn: Swift.String?
    let files: [IoTSiteWiseClientTypes.File]?
    let errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    let jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
}

extension CreateBulkImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorReportLocation
        case files
        case jobConfiguration
        case jobName
        case jobRoleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRoleArn)
        jobRoleArn = jobRoleArnDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.File?].self, forKey: .files)
        var filesDecoded0:[IoTSiteWiseClientTypes.File]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTSiteWiseClientTypes.File]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let errorReportLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorReportLocation.self, forKey: .errorReportLocation)
        errorReportLocation = errorReportLocationDecoded
        let jobConfigurationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobConfiguration.self, forKey: .jobConfiguration)
        jobConfiguration = jobConfigurationDecoded
    }
}

extension CreateBulkImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBulkImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBulkImportJobOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBulkImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBulkImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobName = output.jobName
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobName = nil
            self.jobStatus = nil
        }
    }
}

public struct CreateBulkImportJobOutputResponse: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The status of the bulk import job can be one of following values.
    ///
    /// * PENDING – IoT SiteWise is waiting for the current bulk import job to finish.
    ///
    /// * CANCELLED – The bulk import job has been canceled.
    ///
    /// * RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.
    ///
    /// * COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.
    ///
    /// * FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    ///
    /// * COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    /// This member is required.
    public var jobStatus: IoTSiteWiseClientTypes.JobStatus?

    public init (
        jobId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: IoTSiteWiseClientTypes.JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
    }
}

struct CreateBulkImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobName: Swift.String?
    let jobStatus: IoTSiteWiseClientTypes.JobStatus?
}

extension CreateBulkImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case jobName
        case jobStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension CreateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = self.dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = self.dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = self.dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dashboards"
    }
}

public struct CreateDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The dashboard definition specified in a JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// A friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project in which to create the dashboard.
    /// This member is required.
    public var projectId: Swift.String?
    /// A list of key-value pairs that contain metadata for the dashboard. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardName = dashboardName
        self.projectId = projectId
        self.tags = tags
    }
}

struct CreateDashboardInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let dashboardName: Swift.String?
    let dashboardDescription: Swift.String?
    let dashboardDefinition: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
        }
    }
}

public struct CreateDashboardOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the dashboard, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
    }
}

struct CreateDashboardOutputResponseBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
}

extension CreateDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn
        case dashboardId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
    }
}

extension CreateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayPlatform = self.gatewayPlatform {
            try encodeContainer.encode(gatewayPlatform, forKey: .gatewayPlatform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/20200301/gateways"
    }
}

public struct CreateGatewayInput: Swift.Equatable {
    /// A unique, friendly name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform. You can only specify one platform in a gateway.
    /// This member is required.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// A list of key-value pairs that contain metadata for the gateway. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.tags = tags
    }
}

struct CreateGatewayInputBody: Swift.Equatable {
    let gatewayName: Swift.String?
    let gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
            self.gatewayId = output.gatewayId
        } else {
            self.gatewayArn = nil
            self.gatewayId = nil
        }
    }
}

public struct CreateGatewayOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the gateway, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise APIs.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        gatewayArn: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
    }
}

struct CreateGatewayOutputResponseBody: Swift.Equatable {
    let gatewayId: Swift.String?
    let gatewayArn: Swift.String?
}

extension CreateGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn
        case gatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

extension CreatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = self.alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = self.notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalAuthMode = self.portalAuthMode {
            try encodeContainer.encode(portalAuthMode.rawValue, forKey: .portalAuthMode)
        }
        if let portalContactEmail = self.portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = self.portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImageFile = self.portalLogoImageFile {
            try encodeContainer.encode(portalLogoImageFile, forKey: .portalLogoImageFile)
        }
        if let portalName = self.portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct CreatePortalInput: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications. If you use the [IoT Events managed Lambda function](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html) to manage your emails, you must [verify the sender email address in Amazon SES](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).
    public var notificationSenderEmail: Swift.String?
    /// The service to use to authenticate users to the portal. Choose from the following options:
    ///
    /// * SSO – The portal uses IAM Identity Center (successor to Single Sign-On) to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see [Enabling IAM Identity Center](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso) in the IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than the China Regions.
    ///
    /// * IAM – The portal uses Identity and Access Management to authenticate users and manage user permissions.
    ///
    ///
    /// You can't change this value after you create a portal. Default: SSO
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A description for the portal.
    public var portalDescription: Swift.String?
    /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
    public var portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile?
    /// A friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the portal. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalAuthMode = portalAuthMode
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalLogoImageFile = portalLogoImageFile
        self.portalName = portalName
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreatePortalInputBody: Swift.Equatable {
    let portalName: Swift.String?
    let portalDescription: Swift.String?
    let portalContactEmail: Swift.String?
    let clientToken: Swift.String?
    let portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    let notificationSenderEmail: Swift.String?
    let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension CreatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let portalLogoImageFileDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFile.self, forKey: .portalLogoImageFile)
        portalLogoImageFile = portalLogoImageFileDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension CreatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePortalOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.portalId = output.portalId
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.ssoApplicationId = output.ssoApplicationId
        } else {
            self.portalArn = nil
            self.portalId = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.ssoApplicationId = nil
        }
    }
}

public struct CreatePortalOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the portal, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ID of the created portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The associated IAM Identity Center application ID, if the portal uses IAM Identity Center.
    /// This member is required.
    public var ssoApplicationId: Swift.String?

    public init (
        portalArn: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        ssoApplicationId: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalId = portalId
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.ssoApplicationId = ssoApplicationId
    }
}

struct CreatePortalOutputResponseBody: Swift.Equatable {
    let portalId: Swift.String?
    let portalArn: Swift.String?
    let portalStartUrl: Swift.String?
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    let ssoApplicationId: Swift.String?
}

extension CreatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case portalId
        case portalStartUrl
        case portalStatus
        case ssoApplicationId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let ssoApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoApplicationId)
        ssoApplicationId = ssoApplicationIdDecoded
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let portalId = self.portalId {
            try encodeContainer.encode(portalId, forKey: .portalId)
        }
        if let projectDescription = self.projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal in which to create the project.
    /// This member is required.
    public var portalId: Swift.String?
    /// A description for the project.
    public var projectDescription: Swift.String?
    /// A friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?
    /// A list of key-value pairs that contain metadata for the project. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
        self.projectDescription = projectDescription
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let portalId: Swift.String?
    let projectName: Swift.String?
    let projectDescription: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
            self.projectId = output.projectId
        } else {
            self.projectArn = nil
            self.projectId = nil
        }
    }
}

public struct CreateProjectOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the project, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    /// This member is required.
    public var projectArn: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        projectArn: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectId = projectId
    }
}

struct CreateProjectOutputResponseBody: Swift.Equatable {
    let projectId: Swift.String?
    let projectArn: Swift.String?
}

extension CreateProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

extension IoTSiteWiseClientTypes.Csv: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for columnname0 in columnNames {
                try columnNamesContainer.encode(columnname0.rawValue)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNamesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ColumnName?].self, forKey: .columnNames)
        var columnNamesDecoded0:[IoTSiteWiseClientTypes.ColumnName]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [IoTSiteWiseClientTypes.ColumnName]()
            for enum0 in columnNamesContainer {
                if let enum0 = enum0 {
                    columnNamesDecoded0?.append(enum0)
                }
            }
        }
        columnNames = columnNamesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// A .csv file.
    public struct Csv: Swift.Equatable {
        /// The column names specified in the .csv file.
        public var columnNames: [IoTSiteWiseClientTypes.ColumnName]?

        public init (
            columnNames: [IoTSiteWiseClientTypes.ColumnName]? = nil
        )
        {
            self.columnNames = columnNames
        }
    }

}

extension IoTSiteWiseClientTypes.CustomerManagedS3Storage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case s3ResourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ResourceArn = self.s3ResourceArn {
            try encodeContainer.encode(s3ResourceArn, forKey: .s3ResourceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ResourceArn)
        s3ResourceArn = s3ResourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a customer managed Amazon S3 bucket.
    public struct CustomerManagedS3Storage: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see [Amazon S3 resources](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var s3ResourceArn: Swift.String?

        public init (
            roleArn: Swift.String? = nil,
            s3ResourceArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }
    }

}

extension IoTSiteWiseClientTypes.DashboardSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a dashboard summary.
    public struct DashboardSummary: Swift.Equatable {
        /// The date the dashboard was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The dashboard's description.
        public var description: Swift.String?
        /// The ID of the dashboard.
        /// This member is required.
        public var id: Swift.String?
        /// The date the dashboard was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the dashboard
        /// This member is required.
        public var name: Swift.String?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }

}

extension DeleteAccessPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPolicyId = accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

public struct DeleteAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy to be deleted.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        accessPolicyId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.clientToken = clientToken
    }
}

struct DeleteAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAssetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct DeleteAssetInput: Swift.Equatable {
    /// The ID of the asset to delete.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
    }
}

struct DeleteAssetInputBody: Swift.Equatable {
}

extension DeleteAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

public struct DeleteAssetModelInput: Swift.Equatable {
    /// The ID of the asset model to delete.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetModelId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.clientToken = clientToken
    }
}

struct DeleteAssetModelInputBody: Swift.Equatable {
}

extension DeleteAssetModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssetModelOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct DeleteAssetModelOutputResponse: Swift.Equatable {
    /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct DeleteAssetModelOutputResponseBody: Swift.Equatable {
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension DeleteAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension DeleteAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAssetOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct DeleteAssetOutputResponse: Swift.Equatable {
    /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct DeleteAssetOutputResponseBody: Swift.Equatable {
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension DeleteAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

extension DeleteDashboardInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DeleteDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the dashboard to delete.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardId = dashboardId
    }
}

struct DeleteDashboardInputBody: Swift.Equatable {
}

extension DeleteDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDashboardOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

public struct DeleteGatewayInput: Swift.Equatable {
    /// The ID of the gateway to delete.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
}

extension DeleteGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteGatewayOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePortalInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeletePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalId = portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

public struct DeletePortalInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal to delete.
    /// This member is required.
    public var portalId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
    }
}

struct DeletePortalInputBody: Swift.Equatable {
}

extension DeletePortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePortalOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeletePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct DeletePortalOutputResponse: Swift.Equatable {
    /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init (
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct DeletePortalOutputResponseBody: Swift.Equatable {
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
}

extension DeletePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

extension DeleteProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteTimeSeriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DeleteTimeSeriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let alias = alias {
                let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
                items.append(aliasQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/delete"
    }
}

public struct DeleteTimeSeriesInput: Swift.Equatable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

struct DeleteTimeSeriesInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DeleteTimeSeriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteTimeSeriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTimeSeriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteTimeSeriesOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTimeSeriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTimeSeriesOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPolicyId = accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

public struct DescribeAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init (
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
    }
}

struct DescribeAccessPolicyInputBody: Swift.Equatable {
}

extension DescribeAccessPolicyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAccessPolicyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyCreationDate = output.accessPolicyCreationDate
            self.accessPolicyId = output.accessPolicyId
            self.accessPolicyIdentity = output.accessPolicyIdentity
            self.accessPolicyLastUpdateDate = output.accessPolicyLastUpdateDate
            self.accessPolicyPermission = output.accessPolicyPermission
            self.accessPolicyResource = output.accessPolicyResource
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyCreationDate = nil
            self.accessPolicyId = nil
            self.accessPolicyIdentity = nil
            self.accessPolicyLastUpdateDate = nil
            self.accessPolicyPermission = nil
            self.accessPolicyResource = nil
        }
    }
}

public struct DescribeAccessPolicyOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the access policy, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The date the access policy was created, in Unix epoch time.
    /// This member is required.
    public var accessPolicyCreationDate: ClientRuntime.Date?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity (IAM Identity Center user, IAM Identity Center group, or IAM user) to which this access policy applies.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The date the access policy was last updated, in Unix epoch time.
    /// This member is required.
    public var accessPolicyLastUpdateDate: ClientRuntime.Date?
    /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?

    public init (
        accessPolicyArn: Swift.String? = nil,
        accessPolicyCreationDate: ClientRuntime.Date? = nil,
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyLastUpdateDate: ClientRuntime.Date? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyCreationDate = accessPolicyCreationDate
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
    }
}

struct DescribeAccessPolicyOutputResponseBody: Swift.Equatable {
    let accessPolicyId: Swift.String?
    let accessPolicyArn: Swift.String?
    let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    let accessPolicyCreationDate: ClientRuntime.Date?
    let accessPolicyLastUpdateDate: ClientRuntime.Date?
}

extension DescribeAccessPolicyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyArn
        case accessPolicyCreationDate
        case accessPolicyId
        case accessPolicyIdentity
        case accessPolicyLastUpdateDate
        case accessPolicyPermission
        case accessPolicyResource
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let accessPolicyCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .accessPolicyCreationDate)
        accessPolicyCreationDate = accessPolicyCreationDateDecoded
        let accessPolicyLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .accessPolicyLastUpdateDate)
        accessPolicyLastUpdateDate = accessPolicyLastUpdateDateDecoded
    }
}

extension DescribeAssetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if excludeProperties != false {
                let excludePropertiesQueryItem = ClientRuntime.URLQueryItem(name: "excludeProperties".urlPercentEncoding(), value: Swift.String(excludeProperties).urlPercentEncoding())
                items.append(excludePropertiesQueryItem)
            }
            return items
        }
    }
}

extension DescribeAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct DescribeAssetInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// Whether or not to exclude asset properties from the response.
    public var excludeProperties: Swift.Bool

    public init (
        assetId: Swift.String? = nil,
        excludeProperties: Swift.Bool = false
    )
    {
        self.assetId = assetId
        self.excludeProperties = excludeProperties
    }
}

struct DescribeAssetInputBody: Swift.Equatable {
}

extension DescribeAssetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if excludeProperties != false {
                let excludePropertiesQueryItem = ClientRuntime.URLQueryItem(name: "excludeProperties".urlPercentEncoding(), value: Swift.String(excludeProperties).urlPercentEncoding())
                items.append(excludePropertiesQueryItem)
            }
            return items
        }
    }
}

extension DescribeAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

public struct DescribeAssetModelInput: Swift.Equatable {
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// Whether or not to exclude asset model properties from the response.
    public var excludeProperties: Swift.Bool

    public init (
        assetModelId: Swift.String? = nil,
        excludeProperties: Swift.Bool = false
    )
    {
        self.assetModelId = assetModelId
        self.excludeProperties = excludeProperties
    }
}

struct DescribeAssetModelInputBody: Swift.Equatable {
}

extension DescribeAssetModelInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribeAssetModelOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .internalFailureException: return "InternalFailureException"
        case .invalidRequestException: return "InvalidRequestException"
        case .resourceNotFoundException: return "ResourceNotFoundException"
        case .throttlingException: return "ThrottlingException"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribeAssetModelOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelArn = output.assetModelArn
            self.assetModelCompositeModels = output.assetModelCompositeModels
            self.assetModelCreationDate = output.assetModelCreationDate
            self.assetModelDescription = output.assetModelDescription
            self.assetModelHierarchies = output.assetModelHierarchies
            self.assetModelId = output.assetModelId
            self.assetModelLastUpdateDate = output.assetModelLastUpdateDate
            self.assetModelName = output.assetModelName
            self.assetModelProperties = output.assetModelProperties
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelCompositeModels = nil
            self.assetModelCreationDate = nil
            self.assetModelDescription = nil
            self.assetModelHierarchies = nil
            self.assetModelId = nil
            self.assetModelLastUpdateDate = nil
            self.assetModelName = nil
            self.assetModelProperties = nil
            self.assetModelStatus = nil
        }
    }
}

public struct DescribeAssetModelOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The list of composite asset models for the asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// The date the asset model was created, in Unix epoch time.
    /// This member is required.
    public var assetModelCreationDate: ClientRuntime.Date?
    /// The asset model's description.
    /// This member is required.
    public var assetModelDescription: Swift.String?
    /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
    /// This member is required.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The date the asset model was last updated, in Unix epoch time.
    /// This member is required.
    public var assetModelLastUpdateDate: ClientRuntime.Date?
    /// The name of the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The list of asset properties for the asset model. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetModelCompositeModels object.
    /// This member is required.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// The current status of the asset model, which contains a state and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelArn: Swift.String? = nil,
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelCreationDate: ClientRuntime.Date? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelLastUpdateDate: ClientRuntime.Date? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelCreationDate = assetModelCreationDate
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelLastUpdateDate = assetModelLastUpdateDate
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.assetModelStatus = assetModelStatus
    }
}

struct DescribeAssetModelOutputResponseBody: Swift.Equatable {
    let assetModelId: Swift.String?
    let assetModelArn: Swift.String?
    let assetModelName: Swift.String?
    let assetModelDescription: Swift.String?
    let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    let assetModelCreationDate: ClientRuntime.Date?
    let assetModelLastUpdateDate: ClientRuntime.Date?
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension DescribeAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelArn
        case assetModelCompositeModels
        case assetModelCreationDate
        case assetModelDescription
        case assetModelHierarchies
        case assetModelId
        case assetModelLastUpdateDate
        case assetModelName
        case assetModelProperties
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let assetModelCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetModelCreationDate)
        assetModelCreationDate = assetModelCreationDateDecoded
        let assetModelLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetModelLastUpdateDate)
        assetModelLastUpdateDate = assetModelLastUpdateDateDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension DescribeAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribeAssetOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .internalFailureException: return "InternalFailureException"
        case .invalidRequestException: return "InvalidRequestException"
        case .resourceNotFoundException: return "ResourceNotFoundException"
        case .throttlingException: return "ThrottlingException"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribeAssetOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetArn = output.assetArn
            self.assetCompositeModels = output.assetCompositeModels
            self.assetCreationDate = output.assetCreationDate
            self.assetDescription = output.assetDescription
            self.assetHierarchies = output.assetHierarchies
            self.assetId = output.assetId
            self.assetLastUpdateDate = output.assetLastUpdateDate
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperties = output.assetProperties
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetCompositeModels = nil
            self.assetCreationDate = nil
            self.assetDescription = nil
            self.assetHierarchies = nil
            self.assetId = nil
            self.assetLastUpdateDate = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperties = nil
            self.assetStatus = nil
        }
    }
}

public struct DescribeAssetOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    /// This member is required.
    public var assetArn: Swift.String?
    /// The composite models for the asset.
    public var assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]?
    /// The date the asset was created, in Unix epoch time.
    /// This member is required.
    public var assetCreationDate: ClientRuntime.Date?
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
    /// This member is required.
    public var assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The date the asset was last updated, in Unix epoch time.
    /// This member is required.
    public var assetLastUpdateDate: ClientRuntime.Date?
    /// The ID of the asset model that was used to create the asset.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The list of asset properties for the asset. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetCompositeModels object.
    /// This member is required.
    public var assetProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    /// The current status of the asset, which contains a state and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetArn: Swift.String? = nil,
        assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]? = nil,
        assetCreationDate: ClientRuntime.Date? = nil,
        assetDescription: Swift.String? = nil,
        assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
        assetId: Swift.String? = nil,
        assetLastUpdateDate: ClientRuntime.Date? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetCompositeModels = assetCompositeModels
        self.assetCreationDate = assetCreationDate
        self.assetDescription = assetDescription
        self.assetHierarchies = assetHierarchies
        self.assetId = assetId
        self.assetLastUpdateDate = assetLastUpdateDate
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperties = assetProperties
        self.assetStatus = assetStatus
    }
}

struct DescribeAssetOutputResponseBody: Swift.Equatable {
    let assetId: Swift.String?
    let assetArn: Swift.String?
    let assetName: Swift.String?
    let assetModelId: Swift.String?
    let assetProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    let assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
    let assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]?
    let assetCreationDate: ClientRuntime.Date?
    let assetLastUpdateDate: ClientRuntime.Date?
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
    let assetDescription: Swift.String?
}

extension DescribeAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetArn
        case assetCompositeModels
        case assetCreationDate
        case assetDescription
        case assetHierarchies
        case assetId
        case assetLastUpdateDate
        case assetModelId
        case assetName
        case assetProperties
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetProperty?].self, forKey: .assetProperties)
        var assetPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetProperty]? = nil
        if let assetPropertiesContainer = assetPropertiesContainer {
            assetPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetProperty]()
            for structure0 in assetPropertiesContainer {
                if let structure0 = structure0 {
                    assetPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetProperties = assetPropertiesDecoded0
        let assetHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .assetHierarchies)
        var assetHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let assetHierarchiesContainer = assetHierarchiesContainer {
            assetHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in assetHierarchiesContainer {
                if let structure0 = structure0 {
                    assetHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetHierarchies = assetHierarchiesDecoded0
        let assetCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetCompositeModel?].self, forKey: .assetCompositeModels)
        var assetCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetCompositeModel]? = nil
        if let assetCompositeModelsContainer = assetCompositeModelsContainer {
            assetCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetCompositeModel]()
            for structure0 in assetCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetCompositeModels = assetCompositeModelsDecoded0
        let assetCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetCreationDate)
        assetCreationDate = assetCreationDateDecoded
        let assetLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetLastUpdateDate)
        assetLastUpdateDate = assetLastUpdateDateDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
        let assetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetDescription)
        assetDescription = assetDescriptionDecoded
    }
}

extension DescribeAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        guard let propertyId = propertyId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
    }
}

public struct DescribeAssetPropertyInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset property.
    /// This member is required.
    public var propertyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

struct DescribeAssetPropertyInputBody: Swift.Equatable {
}

extension DescribeAssetPropertyInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetPropertyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssetPropertyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAssetPropertyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssetPropertyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAssetPropertyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetId = output.assetId
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperty = output.assetProperty
            self.compositeModel = output.compositeModel
        } else {
            self.assetId = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperty = nil
            self.compositeModel = nil
        }
    }
}

public struct DescribeAssetPropertyOutputResponse: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The asset property's definition, alias, and notification state. This response includes this object for normal asset properties. If you describe an asset property in a composite model, this response includes the asset property information in compositeModel.
    public var assetProperty: IoTSiteWiseClientTypes.Property?
    /// The composite asset model that declares this asset property, if this asset property exists in a composite model.
    public var compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty?

    public init (
        assetId: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperty: IoTSiteWiseClientTypes.Property? = nil,
        compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty? = nil
    )
    {
        self.assetId = assetId
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperty = assetProperty
        self.compositeModel = compositeModel
    }
}

struct DescribeAssetPropertyOutputResponseBody: Swift.Equatable {
    let assetId: Swift.String?
    let assetName: Swift.String?
    let assetModelId: Swift.String?
    let assetProperty: IoTSiteWiseClientTypes.Property?
    let compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty?
}

extension DescribeAssetPropertyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case assetModelId
        case assetName
        case assetProperty
        case compositeModel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
        let compositeModelDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CompositeModelProperty.self, forKey: .compositeModel)
        compositeModel = compositeModelDecoded
    }
}

extension DescribeBulkImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeBulkImportJobInput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init (
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeBulkImportJobInputBody: Swift.Equatable {
}

extension DescribeBulkImportJobInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBulkImportJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBulkImportJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBulkImportJobOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBulkImportJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBulkImportJobOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errorReportLocation = output.errorReportLocation
            self.files = output.files
            self.jobConfiguration = output.jobConfiguration
            self.jobCreationDate = output.jobCreationDate
            self.jobId = output.jobId
            self.jobLastUpdateDate = output.jobLastUpdateDate
            self.jobName = output.jobName
            self.jobRoleArn = output.jobRoleArn
            self.jobStatus = output.jobStatus
        } else {
            self.errorReportLocation = nil
            self.files = nil
            self.jobConfiguration = nil
            self.jobCreationDate = nil
            self.jobId = nil
            self.jobLastUpdateDate = nil
            self.jobName = nil
            self.jobRoleArn = nil
            self.jobStatus = nil
        }
    }
}

public struct DescribeBulkImportJobOutputResponse: Swift.Equatable {
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    /// This member is required.
    public var errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    /// The files in the specified Amazon S3 bucket that contain your data.
    /// This member is required.
    public var files: [IoTSiteWiseClientTypes.File]?
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    /// This member is required.
    public var jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    /// The date the job was created, in Unix epoch TIME.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The date the job was last updated, in Unix epoch time.
    /// This member is required.
    public var jobLastUpdateDate: ClientRuntime.Date?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows IoT SiteWise to read Amazon S3 data.
    /// This member is required.
    public var jobRoleArn: Swift.String?
    /// The status of the bulk import job can be one of following values.
    ///
    /// * PENDING – IoT SiteWise is waiting for the current bulk import job to finish.
    ///
    /// * CANCELLED – The bulk import job has been canceled.
    ///
    /// * RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.
    ///
    /// * COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.
    ///
    /// * FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    ///
    /// * COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    /// This member is required.
    public var jobStatus: IoTSiteWiseClientTypes.JobStatus?

    public init (
        errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation? = nil,
        files: [IoTSiteWiseClientTypes.File]? = nil,
        jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobLastUpdateDate: ClientRuntime.Date? = nil,
        jobName: Swift.String? = nil,
        jobRoleArn: Swift.String? = nil,
        jobStatus: IoTSiteWiseClientTypes.JobStatus? = nil
    )
    {
        self.errorReportLocation = errorReportLocation
        self.files = files
        self.jobConfiguration = jobConfiguration
        self.jobCreationDate = jobCreationDate
        self.jobId = jobId
        self.jobLastUpdateDate = jobLastUpdateDate
        self.jobName = jobName
        self.jobRoleArn = jobRoleArn
        self.jobStatus = jobStatus
    }
}

struct DescribeBulkImportJobOutputResponseBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobName: Swift.String?
    let jobStatus: IoTSiteWiseClientTypes.JobStatus?
    let jobRoleArn: Swift.String?
    let files: [IoTSiteWiseClientTypes.File]?
    let errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    let jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    let jobCreationDate: ClientRuntime.Date?
    let jobLastUpdateDate: ClientRuntime.Date?
}

extension DescribeBulkImportJobOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorReportLocation
        case files
        case jobConfiguration
        case jobCreationDate
        case jobId
        case jobLastUpdateDate
        case jobName
        case jobRoleArn
        case jobStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRoleArn)
        jobRoleArn = jobRoleArnDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.File?].self, forKey: .files)
        var filesDecoded0:[IoTSiteWiseClientTypes.File]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTSiteWiseClientTypes.File]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let errorReportLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorReportLocation.self, forKey: .errorReportLocation)
        errorReportLocation = errorReportLocationDecoded
        let jobConfigurationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobConfiguration.self, forKey: .jobConfiguration)
        jobConfiguration = jobConfigurationDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        let jobLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobLastUpdateDate)
        jobLastUpdateDate = jobLastUpdateDateDecoded
    }
}

extension DescribeDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DescribeDashboardInput: Swift.Equatable {
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init (
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardId = dashboardId
    }
}

struct DescribeDashboardInputBody: Swift.Equatable {
}

extension DescribeDashboardInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDashboardOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardCreationDate = output.dashboardCreationDate
            self.dashboardDefinition = output.dashboardDefinition
            self.dashboardDescription = output.dashboardDescription
            self.dashboardId = output.dashboardId
            self.dashboardLastUpdateDate = output.dashboardLastUpdateDate
            self.dashboardName = output.dashboardName
            self.projectId = output.projectId
        } else {
            self.dashboardArn = nil
            self.dashboardCreationDate = nil
            self.dashboardDefinition = nil
            self.dashboardDescription = nil
            self.dashboardId = nil
            self.dashboardLastUpdateDate = nil
            self.dashboardName = nil
            self.projectId = nil
        }
    }
}

public struct DescribeDashboardOutputResponse: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the dashboard, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The date the dashboard was created, in Unix epoch time.
    /// This member is required.
    public var dashboardCreationDate: ClientRuntime.Date?
    /// The dashboard's definition JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// The dashboard's description.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The date the dashboard was last updated, in Unix epoch time.
    /// This member is required.
    public var dashboardLastUpdateDate: ClientRuntime.Date?
    /// The name of the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project that the dashboard is in.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        dashboardArn: Swift.String? = nil,
        dashboardCreationDate: ClientRuntime.Date? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardLastUpdateDate: ClientRuntime.Date? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardCreationDate = dashboardCreationDate
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardLastUpdateDate = dashboardLastUpdateDate
        self.dashboardName = dashboardName
        self.projectId = projectId
    }
}

struct DescribeDashboardOutputResponseBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
    let dashboardName: Swift.String?
    let projectId: Swift.String?
    let dashboardDescription: Swift.String?
    let dashboardDefinition: Swift.String?
    let dashboardCreationDate: ClientRuntime.Date?
    let dashboardLastUpdateDate: ClientRuntime.Date?
}

extension DescribeDashboardOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn
        case dashboardCreationDate
        case dashboardDefinition
        case dashboardDescription
        case dashboardId
        case dashboardLastUpdateDate
        case dashboardName
        case projectId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let dashboardCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dashboardCreationDate)
        dashboardCreationDate = dashboardCreationDateDecoded
        let dashboardLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dashboardLastUpdateDate)
        dashboardLastUpdateDate = dashboardLastUpdateDateDecoded
    }
}

extension DescribeDefaultEncryptionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/encryption"
    }
}

public struct DescribeDefaultEncryptionConfigurationInput: Swift.Equatable {

    public init () { }
}

struct DescribeDefaultEncryptionConfigurationInputBody: Swift.Equatable {
}

extension DescribeDefaultEncryptionConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDefaultEncryptionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeDefaultEncryptionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeDefaultEncryptionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeDefaultEncryptionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeDefaultEncryptionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct DescribeDefaultEncryptionConfigurationOutputResponse: Swift.Equatable {
    /// The status of the account configuration. This contains the ConfigurationState. If there's an error, it also contains the ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The key ARN of the customer managed key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct DescribeDefaultEncryptionConfigurationOutputResponseBody: Swift.Equatable {
    let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    let kmsKeyArn: Swift.String?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension DescribeDefaultEncryptionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

extension DescribeGatewayCapabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        guard let capabilityNamespace = capabilityNamespace else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability/\(capabilityNamespace.urlPercentEncoding())"
    }
}

public struct DescribeGatewayCapabilityConfigurationInput: Swift.Equatable {
    /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationInputBody: Swift.Equatable {
}

extension DescribeGatewayCapabilityConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayCapabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayCapabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGatewayCapabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayCapabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGatewayCapabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.capabilityConfiguration = output.capabilityConfiguration
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
            self.gatewayId = output.gatewayId
        } else {
            self.capabilityConfiguration = nil
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
            self.gatewayId = nil
        }
    }
}

public struct DescribeGatewayCapabilityConfigurationOutputResponse: Swift.Equatable {
    /// The JSON document that defines the gateway capability's configuration. For more information, see [Configuring data sources (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    /// * IN_SYNC – The gateway is running the capability configuration.
    ///
    /// * OUT_OF_SYNC – The gateway hasn't received the capability configuration.
    ///
    /// * SYNC_FAILED – The gateway rejected the capability configuration.
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationOutputResponseBody: Swift.Equatable {
    let gatewayId: Swift.String?
    let capabilityNamespace: Swift.String?
    let capabilityConfiguration: Swift.String?
    let capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
}

extension DescribeGatewayCapabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
        case capabilitySyncStatus
        case gatewayId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension DescribeGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

public struct DescribeGatewayInput: Swift.Equatable {
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayInputBody: Swift.Equatable {
}

extension DescribeGatewayInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeGatewayOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeGatewayOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.gatewayArn = output.gatewayArn
            self.gatewayCapabilitySummaries = output.gatewayCapabilitySummaries
            self.gatewayId = output.gatewayId
            self.gatewayName = output.gatewayName
            self.gatewayPlatform = output.gatewayPlatform
            self.lastUpdateDate = output.lastUpdateDate
        } else {
            self.creationDate = nil
            self.gatewayArn = nil
            self.gatewayCapabilitySummaries = nil
            self.gatewayId = nil
            self.gatewayName = nil
            self.gatewayPlatform = nil
            self.lastUpdateDate = nil
        }
    }
}

public struct DescribeGatewayOutputResponse: Swift.Equatable {
    /// The date the gateway was created, in Unix epoch time.
    /// This member is required.
    public var creationDate: ClientRuntime.Date?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the gateway, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use [DescribeGatewayCapabilityConfiguration](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html).
    /// This member is required.
    public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The name of the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// The date the gateway was last updated, in Unix epoch time.
    /// This member is required.
    public var lastUpdateDate: ClientRuntime.Date?

    public init (
        creationDate: ClientRuntime.Date? = nil,
        gatewayArn: Swift.String? = nil,
        gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        lastUpdateDate: ClientRuntime.Date? = nil
    )
    {
        self.creationDate = creationDate
        self.gatewayArn = gatewayArn
        self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.lastUpdateDate = lastUpdateDate
    }
}

struct DescribeGatewayOutputResponseBody: Swift.Equatable {
    let gatewayId: Swift.String?
    let gatewayName: Swift.String?
    let gatewayArn: Swift.String?
    let gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    let gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
    let creationDate: ClientRuntime.Date?
    let lastUpdateDate: ClientRuntime.Date?
}

extension DescribeGatewayOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case gatewayArn
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case gatewayPlatform
        case lastUpdateDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension DescribeLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging"
    }
}

public struct DescribeLoggingOptionsInput: Swift.Equatable {

    public init () { }
}

struct DescribeLoggingOptionsInputBody: Swift.Equatable {
}

extension DescribeLoggingOptionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeLoggingOptionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutputResponse: Swift.Equatable {
    /// The current logging options.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputResponseBody: Swift.Equatable {
    let loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?
}

extension DescribeLoggingOptionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension DescribePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalId = portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

public struct DescribePortalInput: Swift.Equatable {
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init (
        portalId: Swift.String? = nil
    )
    {
        self.portalId = portalId
    }
}

struct DescribePortalInputBody: Swift.Equatable {
}

extension DescribePortalInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

extension DescribePortalOutputError: WaiterTypedError {

    /// The Smithy identifier, without namespace, for the type of this error, or `nil` if the
    /// error has no known type.
    public var waiterErrorType: String? {
        switch self {
        case .internalFailureException: return "InternalFailureException"
        case .invalidRequestException: return "InvalidRequestException"
        case .resourceNotFoundException: return "ResourceNotFoundException"
        case .throttlingException: return "ThrottlingException"
        case .unknown(let error): return error.waiterErrorType
        }
    }
}

public enum DescribePortalOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alarms = output.alarms
            self.notificationSenderEmail = output.notificationSenderEmail
            self.portalArn = output.portalArn
            self.portalAuthMode = output.portalAuthMode
            self.portalClientId = output.portalClientId
            self.portalContactEmail = output.portalContactEmail
            self.portalCreationDate = output.portalCreationDate
            self.portalDescription = output.portalDescription
            self.portalId = output.portalId
            self.portalLastUpdateDate = output.portalLastUpdateDate
            self.portalLogoImageLocation = output.portalLogoImageLocation
            self.portalName = output.portalName
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.roleArn = output.roleArn
        } else {
            self.alarms = nil
            self.notificationSenderEmail = nil
            self.portalArn = nil
            self.portalAuthMode = nil
            self.portalClientId = nil
            self.portalContactEmail = nil
            self.portalCreationDate = nil
            self.portalDescription = nil
            self.portalId = nil
            self.portalLastUpdateDate = nil
            self.portalLogoImageLocation = nil
            self.portalName = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.roleArn = nil
        }
    }
}

public struct DescribePortalOutputResponse: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the portal, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service to use to authenticate users to the portal.
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The IAM Identity Center application generated client ID (used with IAM Identity Center APIs). IoT SiteWise includes portalClientId for only portals that use IAM Identity Center to authenticate users.
    /// This member is required.
    public var portalClientId: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// The date the portal was created, in Unix epoch time.
    /// This member is required.
    public var portalCreationDate: ClientRuntime.Date?
    /// The portal's description.
    public var portalDescription: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The date the portal was last updated, in Unix epoch time.
    /// This member is required.
    public var portalLastUpdateDate: ClientRuntime.Date?
    /// The portal's logo image, which is available at a URL.
    public var portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation?
    /// The name of the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The current status of the portal, which contains a state and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    public var roleArn: Swift.String?

    public init (
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalArn: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalClientId: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalCreationDate: ClientRuntime.Date? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLastUpdateDate: ClientRuntime.Date? = nil,
        portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation? = nil,
        portalName: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.notificationSenderEmail = notificationSenderEmail
        self.portalArn = portalArn
        self.portalAuthMode = portalAuthMode
        self.portalClientId = portalClientId
        self.portalContactEmail = portalContactEmail
        self.portalCreationDate = portalCreationDate
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLastUpdateDate = portalLastUpdateDate
        self.portalLogoImageLocation = portalLogoImageLocation
        self.portalName = portalName
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.roleArn = roleArn
    }
}

struct DescribePortalOutputResponseBody: Swift.Equatable {
    let portalId: Swift.String?
    let portalArn: Swift.String?
    let portalName: Swift.String?
    let portalDescription: Swift.String?
    let portalClientId: Swift.String?
    let portalStartUrl: Swift.String?
    let portalContactEmail: Swift.String?
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    let portalCreationDate: ClientRuntime.Date?
    let portalLastUpdateDate: ClientRuntime.Date?
    let portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation?
    let roleArn: Swift.String?
    let portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    let notificationSenderEmail: Swift.String?
    let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension DescribePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case notificationSenderEmail
        case portalArn
        case portalAuthMode
        case portalClientId
        case portalContactEmail
        case portalCreationDate
        case portalDescription
        case portalId
        case portalLastUpdateDate
        case portalLogoImageLocation
        case portalName
        case portalStartUrl
        case portalStatus
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalClientId)
        portalClientId = portalClientIdDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .portalCreationDate)
        portalCreationDate = portalCreationDateDecoded
        let portalLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .portalLastUpdateDate)
        portalLastUpdateDate = portalLastUpdateDateDecoded
        let portalLogoImageLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageLocation.self, forKey: .portalLogoImageLocation)
        portalLogoImageLocation = portalLogoImageLocationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeProjectOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalId = output.portalId
            self.projectArn = output.projectArn
            self.projectCreationDate = output.projectCreationDate
            self.projectDescription = output.projectDescription
            self.projectId = output.projectId
            self.projectLastUpdateDate = output.projectLastUpdateDate
            self.projectName = output.projectName
        } else {
            self.portalId = nil
            self.projectArn = nil
            self.projectCreationDate = nil
            self.projectDescription = nil
            self.projectId = nil
            self.projectLastUpdateDate = nil
            self.projectName = nil
        }
    }
}

public struct DescribeProjectOutputResponse: Swift.Equatable {
    /// The ID of the portal that the project is in.
    /// This member is required.
    public var portalId: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the project, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    /// This member is required.
    public var projectArn: Swift.String?
    /// The date the project was created, in Unix epoch time.
    /// This member is required.
    public var projectCreationDate: ClientRuntime.Date?
    /// The project's description.
    public var projectDescription: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The date the project was last updated, in Unix epoch time.
    /// This member is required.
    public var projectLastUpdateDate: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        portalId: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        projectCreationDate: ClientRuntime.Date? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectLastUpdateDate: ClientRuntime.Date? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.portalId = portalId
        self.projectArn = projectArn
        self.projectCreationDate = projectCreationDate
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectLastUpdateDate = projectLastUpdateDate
        self.projectName = projectName
    }
}

struct DescribeProjectOutputResponseBody: Swift.Equatable {
    let projectId: Swift.String?
    let projectArn: Swift.String?
    let projectName: Swift.String?
    let portalId: Swift.String?
    let projectDescription: Swift.String?
    let projectCreationDate: ClientRuntime.Date?
    let projectLastUpdateDate: ClientRuntime.Date?
}

extension DescribeProjectOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalId
        case projectArn
        case projectCreationDate
        case projectDescription
        case projectId
        case projectLastUpdateDate
        case projectName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let projectCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .projectCreationDate)
        projectCreationDate = projectCreationDateDecoded
        let projectLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .projectLastUpdateDate)
        projectLastUpdateDate = projectLastUpdateDateDecoded
    }
}

extension DescribeStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/storage"
    }
}

public struct DescribeStorageConfigurationInput: Swift.Equatable {

    public init () { }
}

struct DescribeStorageConfigurationInputBody: Swift.Equatable {
}

extension DescribeStorageConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeStorageConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStorageConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeStorageConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStorageConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeStorageConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.disassociatedDataStorage = output.disassociatedDataStorage
            self.lastUpdateDate = output.lastUpdateDate
            self.multiLayerStorage = output.multiLayerStorage
            self.retentionPeriod = output.retentionPeriod
            self.storageType = output.storageType
        } else {
            self.configurationStatus = nil
            self.disassociatedDataStorage = nil
            self.lastUpdateDate = nil
            self.multiLayerStorage = nil
            self.retentionPeriod = nil
            self.storageType = nil
        }
    }
}

public struct DescribeStorageConfigurationOutputResponse: Swift.Equatable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// The date the storage configuration was last updated, in Unix epoch time.
    public var lastUpdateDate: ClientRuntime.Date?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        lastUpdateDate: ClientRuntime.Date? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.disassociatedDataStorage = disassociatedDataStorage
        self.lastUpdateDate = lastUpdateDate
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
    }
}

struct DescribeStorageConfigurationOutputResponseBody: Swift.Equatable {
    let storageType: IoTSiteWiseClientTypes.StorageType?
    let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    let disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    let retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    let lastUpdateDate: ClientRuntime.Date?
}

extension DescribeStorageConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case disassociatedDataStorage
        case lastUpdateDate
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let disassociatedDataStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DisassociatedDataStorageState.self, forKey: .disassociatedDataStorage)
        disassociatedDataStorage = disassociatedDataStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension DescribeTimeSeriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let alias = alias {
                let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
                items.append(aliasQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/describe"
    }
}

public struct DescribeTimeSeriesInput: Swift.Equatable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

struct DescribeTimeSeriesInputBody: Swift.Equatable {
}

extension DescribeTimeSeriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTimeSeriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTimeSeriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeTimeSeriesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTimeSeriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeTimeSeriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.assetId = output.assetId
            self.dataType = output.dataType
            self.dataTypeSpec = output.dataTypeSpec
            self.propertyId = output.propertyId
            self.timeSeriesCreationDate = output.timeSeriesCreationDate
            self.timeSeriesId = output.timeSeriesId
            self.timeSeriesLastUpdateDate = output.timeSeriesLastUpdateDate
        } else {
            self.alias = nil
            self.assetId = nil
            self.dataType = nil
            self.dataTypeSpec = nil
            self.propertyId = nil
            self.timeSeriesCreationDate = nil
            self.timeSeriesId = nil
            self.timeSeriesLastUpdateDate = nil
        }
    }
}

public struct DescribeTimeSeriesOutputResponse: Swift.Equatable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
    /// This member is required.
    public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
    /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
    public var dataTypeSpec: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The date that the time series was created, in Unix epoch time.
    /// This member is required.
    public var timeSeriesCreationDate: ClientRuntime.Date?
    /// The ID of the time series.
    /// This member is required.
    public var timeSeriesId: Swift.String?
    /// The date that the time series was last updated, in Unix epoch time.
    /// This member is required.
    public var timeSeriesLastUpdateDate: ClientRuntime.Date?

    public init (
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
        dataTypeSpec: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        timeSeriesCreationDate: ClientRuntime.Date? = nil,
        timeSeriesId: Swift.String? = nil,
        timeSeriesLastUpdateDate: ClientRuntime.Date? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.dataType = dataType
        self.dataTypeSpec = dataTypeSpec
        self.propertyId = propertyId
        self.timeSeriesCreationDate = timeSeriesCreationDate
        self.timeSeriesId = timeSeriesId
        self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
    }
}

struct DescribeTimeSeriesOutputResponseBody: Swift.Equatable {
    let assetId: Swift.String?
    let propertyId: Swift.String?
    let alias: Swift.String?
    let timeSeriesId: Swift.String?
    let dataType: IoTSiteWiseClientTypes.PropertyDataType?
    let dataTypeSpec: Swift.String?
    let timeSeriesCreationDate: ClientRuntime.Date?
    let timeSeriesLastUpdateDate: ClientRuntime.Date?
}

extension DescribeTimeSeriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case assetId
        case dataType
        case dataTypeSpec
        case propertyId
        case timeSeriesCreationDate
        case timeSeriesId
        case timeSeriesLastUpdateDate
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let timeSeriesCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesCreationDate)
        timeSeriesCreationDate = timeSeriesCreationDateDecoded
        let timeSeriesLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesLastUpdateDate)
        timeSeriesLastUpdateDate = timeSeriesLastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes.DetailedError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DetailedErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains detailed error information.
    public struct DetailedError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.DetailedErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.DetailedErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum DetailedErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case incompatibleComputeLocation
        case incompatibleForwardingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailedErrorCode] {
            return [
                .incompatibleComputeLocation,
                .incompatibleForwardingConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .incompatibleComputeLocation: return "INCOMPATIBLE_COMPUTE_LOCATION"
            case .incompatibleForwardingConfiguration: return "INCOMPATIBLE_FORWARDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailedErrorCode(rawValue: rawValue) ?? DetailedErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = self.childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

extension DisassociateAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/disassociate"
    }
}

public struct DisassociateAssetsInput: Swift.Equatable {
    /// The ID of the parent asset from which to disassociate the child asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to disassociate.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct DisassociateAssetsInputBody: Swift.Equatable {
    let hierarchyId: Swift.String?
    let childAssetId: Swift.String?
    let clientToken: Swift.String?
}

extension DisassociateAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateAssetsOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateAssetsOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateTimeSeriesFromAssetPropertyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let assetId = assetId else {
                let message = "Creating a URL Query Item failed. assetId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
            guard let alias = alias else {
                let message = "Creating a URL Query Item failed. alias is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
            guard let propertyId = propertyId else {
                let message = "Creating a URL Query Item failed. propertyId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
            return items
        }
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/disassociate"
    }
}

public struct DisassociateTimeSeriesFromAssetPropertyInput: Swift.Equatable {
    /// The alias that identifies the time series.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property.
    /// This member is required.
    public var propertyId: Swift.String?

    public init (
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

struct DisassociateTimeSeriesFromAssetPropertyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DisassociateTimeSeriesFromAssetPropertyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateTimeSeriesFromAssetPropertyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTimeSeriesFromAssetPropertyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateTimeSeriesFromAssetPropertyOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTimeSeriesFromAssetPropertyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateTimeSeriesFromAssetPropertyOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTSiteWiseClientTypes {
    public enum DisassociatedDataStorageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DisassociatedDataStorageState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DisassociatedDataStorageState(rawValue: rawValue) ?? DisassociatedDataStorageState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kmsBasedEncryption
        case sitewiseDefaultEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kmsBasedEncryption,
                .sitewiseDefaultEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kmsBasedEncryption: return "KMS_BASED_ENCRYPTION"
            case .sitewiseDefaultEncryption: return "SITEWISE_DEFAULT_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalFailure,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case details
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .details)
            for detailederror0 in details {
                try detailsContainer.encode(detailederror0)
            }
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let detailsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.DetailedError?].self, forKey: .details)
        var detailsDecoded0:[IoTSiteWiseClientTypes.DetailedError]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [IoTSiteWiseClientTypes.DetailedError]()
            for structure0 in detailsContainer {
                if let structure0 = structure0 {
                    detailsDecoded0?.append(structure0)
                }
            }
        }
        details = detailsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the details of an IoT SiteWise error.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        /// A list of detailed errors.
        public var details: [IoTSiteWiseClientTypes.DetailedError]?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            details: [IoTSiteWiseClientTypes.DetailedError]? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.details = details
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.ErrorReportLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    public struct ErrorReportLocation: Swift.Equatable {
        /// The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.
        /// This member is required.
        public var bucket: Swift.String?
        /// Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension IoTSiteWiseClientTypes.ExpressionVariable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains expression variable information.
    public struct ExpressionVariable: Swift.Equatable {
        /// The friendly name of the variable to be used in the expression.
        /// This member is required.
        public var name: Swift.String?
        /// The variable that identifies an asset property from which to use values.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.VariableValue?

        public init (
            name: Swift.String? = nil,
            value: IoTSiteWiseClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.File: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case versionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The file in Amazon S3 where your data is saved.
    public struct File: Swift.Equatable {
        /// The name of the Amazon S3 bucket from which data is imported.
        /// This member is required.
        public var bucket: Swift.String?
        /// The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.
        /// This member is required.
        public var key: Swift.String?
        /// The version ID to identify a specific version of the Amazon S3 object that contains your data.
        public var versionId: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }
    }

}

extension IoTSiteWiseClientTypes.FileFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = self.csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Csv.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The file format of the data.
    public struct FileFormat: Swift.Equatable {
        /// The .csv file format.
        public var csv: IoTSiteWiseClientTypes.Csv?

        public init (
            csv: IoTSiteWiseClientTypes.Csv? = nil
        )
        {
            self.csv = csv
        }
    }

}

extension IoTSiteWiseClientTypes.ForwardingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfigState.self, forKey: .state)
        state = stateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The forwarding configuration for a given property.
    public struct ForwardingConfig: Swift.Equatable {
        /// The forwarding state for the given property.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ForwardingConfigState?

        public init (
            state: IoTSiteWiseClientTypes.ForwardingConfigState? = nil
        )
        {
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ForwardingConfigState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ForwardingConfigState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ForwardingConfigState(rawValue: rawValue) ?? ForwardingConfigState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.GatewayCapabilitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityNamespace = self.capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
        if let capabilitySyncStatus = self.capabilitySyncStatus {
            try encodeContainer.encode(capabilitySyncStatus.rawValue, forKey: .capabilitySyncStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a gateway capability configuration.
    public struct GatewayCapabilitySummary: Swift.Equatable {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        /// This member is required.
        public var capabilityNamespace: Swift.String?
        /// The synchronization status of the capability configuration. The sync status can be one of the following:
        ///
        /// * IN_SYNC – The gateway is running the capability configuration.
        ///
        /// * OUT_OF_SYNC – The gateway hasn't received the capability configuration.
        ///
        /// * SYNC_FAILED – The gateway rejected the capability configuration.
        /// This member is required.
        public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

        public init (
            capabilityNamespace: Swift.String? = nil,
            capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
        )
        {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }
    }

}

extension IoTSiteWiseClientTypes.GatewayPlatform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case greengrass
        case greengrassV2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let greengrass = self.greengrass {
            try encodeContainer.encode(greengrass, forKey: .greengrass)
        }
        if let greengrassV2 = self.greengrassV2 {
            try encodeContainer.encode(greengrassV2, forKey: .greengrassV2)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let greengrassDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Greengrass.self, forKey: .greengrass)
        greengrass = greengrassDecoded
        let greengrassV2Decoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GreengrassV2.self, forKey: .greengrassV2)
        greengrassV2 = greengrassV2Decoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a gateway's platform information.
    public struct GatewayPlatform: Swift.Equatable {
        /// A gateway that runs on IoT Greengrass.
        public var greengrass: IoTSiteWiseClientTypes.Greengrass?
        /// A gateway that runs on IoT Greengrass V2.
        public var greengrassV2: IoTSiteWiseClientTypes.GreengrassV2?

        public init (
            greengrass: IoTSiteWiseClientTypes.Greengrass? = nil,
            greengrassV2: IoTSiteWiseClientTypes.GreengrassV2? = nil
        )
        {
            self.greengrass = greengrass
            self.greengrassV2 = greengrassV2
        }
    }

}

extension IoTSiteWiseClientTypes.GatewaySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case gatewayPlatform
        case lastUpdateDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let gatewayCapabilitySummaries = gatewayCapabilitySummaries {
            var gatewayCapabilitySummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayCapabilitySummaries)
            for gatewaycapabilitysummary0 in gatewayCapabilitySummaries {
                try gatewayCapabilitySummariesContainer.encode(gatewaycapabilitysummary0)
            }
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayPlatform = self.gatewayPlatform {
            try encodeContainer.encode(gatewayPlatform, forKey: .gatewayPlatform)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a gateway.
    public struct GatewaySummary: Swift.Equatable {
        /// The date the gateway was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use [DescribeGatewayCapabilityConfiguration](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html).
        public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        /// This member is required.
        public var gatewayId: Swift.String?
        /// The name of the asset.
        /// This member is required.
        public var gatewayName: Swift.String?
        /// Contains a gateway's platform information.
        public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
            gatewayId: Swift.String? = nil,
            gatewayName: Swift.String? = nil,
            gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil
        )
        {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }
    }

}

extension GetAssetPropertyAggregatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let aggregateTypes = aggregateTypes else {
                let message = "Creating a URL Query Item failed. aggregateTypes is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            aggregateTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "aggregateTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let endDate = endDate else {
                let message = "Creating a URL Query Item failed. endDate is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
            items.append(endDateQueryItem)
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let qualities = qualities {
                qualities.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let timeOrdering = timeOrdering {
                let timeOrderingQueryItem = ClientRuntime.URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
                items.append(timeOrderingQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            guard let resolution = resolution else {
                let message = "Creating a URL Query Item failed. resolution is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resolutionQueryItem = ClientRuntime.URLQueryItem(name: "resolution".urlPercentEncoding(), value: Swift.String(resolution).urlPercentEncoding())
            items.append(resolutionQueryItem)
            guard let startDate = startDate else {
                let message = "Creating a URL Query Item failed. startDate is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
            items.append(startDateQueryItem)
            return items
        }
    }
}

extension GetAssetPropertyAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/aggregates"
    }
}

public struct GetAssetPropertyAggregatesInput: Swift.Equatable {
    /// The data aggregating function.
    /// This member is required.
    public var aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]?
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var endDate: ClientRuntime.Date?
    /// The maximum number of results to return for each paginated request. Default: 100
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The time interval over which to aggregate data.
    /// This member is required.
    public var resolution: Swift.String?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var startDate: ClientRuntime.Date?
    /// The chronological sorting order of the requested information. Default: ASCENDING
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init (
        aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]? = nil,
        assetId: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        resolution: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.aggregateTypes = aggregateTypes
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.resolution = resolution
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyAggregatesInputBody: Swift.Equatable {
}

extension GetAssetPropertyAggregatesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyAggregatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyAggregatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssetPropertyAggregatesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyAggregatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssetPropertyAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.aggregatedValues = output.aggregatedValues
            self.nextToken = output.nextToken
        } else {
            self.aggregatedValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyAggregatesOutputResponse: Swift.Equatable {
    /// The requested aggregated values.
    /// This member is required.
    public var aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregatedValues = aggregatedValues
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyAggregatesOutputResponseBody: Swift.Equatable {
    let aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
    let nextToken: Swift.String?
}

extension GetAssetPropertyAggregatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedValues
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatedValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AggregatedValue?].self, forKey: .aggregatedValues)
        var aggregatedValuesDecoded0:[IoTSiteWiseClientTypes.AggregatedValue]? = nil
        if let aggregatedValuesContainer = aggregatedValuesContainer {
            aggregatedValuesDecoded0 = [IoTSiteWiseClientTypes.AggregatedValue]()
            for structure0 in aggregatedValuesContainer {
                if let structure0 = structure0 {
                    aggregatedValuesDecoded0?.append(structure0)
                }
            }
        }
        aggregatedValues = aggregatedValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAssetPropertyValueHistoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let endDate = endDate {
                let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
                items.append(endDateQueryItem)
            }
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let qualities = qualities {
                qualities.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let timeOrdering = timeOrdering {
                let timeOrderingQueryItem = ClientRuntime.URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
                items.append(timeOrderingQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            if let startDate = startDate {
                let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
                items.append(startDateQueryItem)
            }
            return items
        }
    }
}

extension GetAssetPropertyValueHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/history"
    }
}

public struct GetAssetPropertyValueHistoryInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var endDate: ClientRuntime.Date?
    /// The maximum number of results to return for each paginated request. Default: 100
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var startDate: ClientRuntime.Date?
    /// The chronological sorting order of the requested information. Default: ASCENDING
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init (
        assetId: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        startDate: ClientRuntime.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyValueHistoryInputBody: Swift.Equatable {
}

extension GetAssetPropertyValueHistoryInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyValueHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssetPropertyValueHistoryOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyValueHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssetPropertyValueHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetPropertyValueHistory = output.assetPropertyValueHistory
            self.nextToken = output.nextToken
        } else {
            self.assetPropertyValueHistory = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyValueHistoryOutputResponse: Swift.Equatable {
    /// The asset property's value history.
    /// This member is required.
    public var assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetPropertyValueHistory = assetPropertyValueHistory
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyValueHistoryOutputResponseBody: Swift.Equatable {
    let assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
    let nextToken: Swift.String?
}

extension GetAssetPropertyValueHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertyValueHistory
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetPropertyValueHistoryContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .assetPropertyValueHistory)
        var assetPropertyValueHistoryDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let assetPropertyValueHistoryContainer = assetPropertyValueHistoryContainer {
            assetPropertyValueHistoryDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in assetPropertyValueHistoryContainer {
                if let structure0 = structure0 {
                    assetPropertyValueHistoryDecoded0?.append(structure0)
                }
            }
        }
        assetPropertyValueHistory = assetPropertyValueHistoryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetAssetPropertyValueInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension GetAssetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/latest"
    }
}

public struct GetAssetPropertyValueInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
    }
}

struct GetAssetPropertyValueInputBody: Swift.Equatable {
}

extension GetAssetPropertyValueInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyValueOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssetPropertyValueOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAssetPropertyValueOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssetPropertyValueOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAssetPropertyValueOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.propertyValue = output.propertyValue
        } else {
            self.propertyValue = nil
        }
    }
}

public struct GetAssetPropertyValueOutputResponse: Swift.Equatable {
    /// The current asset property value.
    public var propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?

    public init (
        propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue? = nil
    )
    {
        self.propertyValue = propertyValue
    }
}

struct GetAssetPropertyValueOutputResponseBody: Swift.Equatable {
    let propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?
}

extension GetAssetPropertyValueOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyValue
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetPropertyValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

extension GetInterpolatedAssetPropertyValuesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startTimeOffsetInNanos = startTimeOffsetInNanos {
                let startTimeOffsetInNanosQueryItem = ClientRuntime.URLQueryItem(name: "startTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(startTimeOffsetInNanos).urlPercentEncoding())
                items.append(startTimeOffsetInNanosQueryItem)
            }
            guard let endTimeInSeconds = endTimeInSeconds else {
                let message = "Creating a URL Query Item failed. endTimeInSeconds is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let endTimeInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "endTimeInSeconds".urlPercentEncoding(), value: Swift.String(endTimeInSeconds).urlPercentEncoding())
            items.append(endTimeInSecondsQueryItem)
            if let endTimeOffsetInNanos = endTimeOffsetInNanos {
                let endTimeOffsetInNanosQueryItem = ClientRuntime.URLQueryItem(name: "endTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(endTimeOffsetInNanos).urlPercentEncoding())
                items.append(endTimeOffsetInNanosQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let intervalWindowInSeconds = intervalWindowInSeconds {
                let intervalWindowInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "intervalWindowInSeconds".urlPercentEncoding(), value: Swift.String(intervalWindowInSeconds).urlPercentEncoding())
                items.append(intervalWindowInSecondsQueryItem)
            }
            guard let type = type else {
                let message = "Creating a URL Query Item failed. type is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
            guard let quality = quality else {
                let message = "Creating a URL Query Item failed. quality is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let qualityQueryItem = ClientRuntime.URLQueryItem(name: "quality".urlPercentEncoding(), value: Swift.String(quality.rawValue).urlPercentEncoding())
            items.append(qualityQueryItem)
            guard let startTimeInSeconds = startTimeInSeconds else {
                let message = "Creating a URL Query Item failed. startTimeInSeconds is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let startTimeInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "startTimeInSeconds".urlPercentEncoding(), value: Swift.String(startTimeInSeconds).urlPercentEncoding())
            items.append(startTimeInSecondsQueryItem)
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let intervalInSeconds = intervalInSeconds else {
                let message = "Creating a URL Query Item failed. intervalInSeconds is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let intervalInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "intervalInSeconds".urlPercentEncoding(), value: Swift.String(intervalInSeconds).urlPercentEncoding())
            items.append(intervalInSecondsQueryItem)
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension GetInterpolatedAssetPropertyValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/interpolated"
    }
}

public struct GetInterpolatedAssetPropertyValuesInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var endTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from endTimeInSeconds.
    public var endTimeOffsetInNanos: Swift.Int?
    /// The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.
    /// This member is required.
    public var intervalInSeconds: Swift.Int?
    /// The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.
    ///
    /// * If you specify a value for the intervalWindowInSeconds parameter, the value for the type parameter must be LINEAR_INTERPOLATION.
    ///
    /// * If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.
    ///
    ///
    /// For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.
    public var intervalWindowInSeconds: Swift.Int?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.
    /// This member is required.
    public var quality: IoTSiteWiseClientTypes.Quality?
    /// The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var startTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from startTimeInSeconds.
    public var startTimeOffsetInNanos: Swift.Int?
    /// The interpolation type. Valid values: LINEAR_INTERPOLATION | LOCF_INTERPOLATION
    ///
    /// * LINEAR_INTERPOLATION – Estimates missing data using [linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation). For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.
    ///
    /// * LOCF_INTERPOLATION – Estimates missing data using last observation carried forward interpolation If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found. For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.
    /// This member is required.
    public var type: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        endTimeInSeconds: Swift.Int? = nil,
        endTimeOffsetInNanos: Swift.Int? = nil,
        intervalInSeconds: Swift.Int? = nil,
        intervalWindowInSeconds: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        quality: IoTSiteWiseClientTypes.Quality? = nil,
        startTimeInSeconds: Swift.Int? = nil,
        startTimeOffsetInNanos: Swift.Int? = nil,
        type: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.endTimeInSeconds = endTimeInSeconds
        self.endTimeOffsetInNanos = endTimeOffsetInNanos
        self.intervalInSeconds = intervalInSeconds
        self.intervalWindowInSeconds = intervalWindowInSeconds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.quality = quality
        self.startTimeInSeconds = startTimeInSeconds
        self.startTimeOffsetInNanos = startTimeOffsetInNanos
        self.type = type
    }
}

struct GetInterpolatedAssetPropertyValuesInputBody: Swift.Equatable {
}

extension GetInterpolatedAssetPropertyValuesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInterpolatedAssetPropertyValuesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInterpolatedAssetPropertyValuesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInterpolatedAssetPropertyValuesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInterpolatedAssetPropertyValuesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInterpolatedAssetPropertyValuesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.interpolatedAssetPropertyValues = output.interpolatedAssetPropertyValues
            self.nextToken = output.nextToken
        } else {
            self.interpolatedAssetPropertyValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetInterpolatedAssetPropertyValuesOutputResponse: Swift.Equatable {
    /// The requested interpolated values.
    /// This member is required.
    public var interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
        self.nextToken = nextToken
    }
}

struct GetInterpolatedAssetPropertyValuesOutputResponseBody: Swift.Equatable {
    let interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]?
    let nextToken: Swift.String?
}

extension GetInterpolatedAssetPropertyValuesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpolatedAssetPropertyValues
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpolatedAssetPropertyValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue?].self, forKey: .interpolatedAssetPropertyValues)
        var interpolatedAssetPropertyValuesDecoded0:[IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]? = nil
        if let interpolatedAssetPropertyValuesContainer = interpolatedAssetPropertyValuesContainer {
            interpolatedAssetPropertyValuesDecoded0 = [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]()
            for structure0 in interpolatedAssetPropertyValuesContainer {
                if let structure0 = structure0 {
                    interpolatedAssetPropertyValuesDecoded0?.append(structure0)
                }
            }
        }
        interpolatedAssetPropertyValues = interpolatedAssetPropertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes.Greengrass: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupArn = self.groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains details for a gateway that runs on IoT Greengrass. To create a gateway that runs on IoT Greengrass, you must add the IoT SiteWise connector to a Greengrass group and deploy it. Your Greengrass group must also have permissions to upload data to IoT SiteWise. For more information, see [Ingesting data using a gateway](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/gateway-connector.html) in the IoT SiteWise User Guide.
    public struct Greengrass: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Greengrass group. For more information about how to find a group's ARN, see [ListGroups](https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html) and [GetGroup](https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html) in the IoT Greengrass API Reference.
        /// This member is required.
        public var groupArn: Swift.String?

        public init (
            groupArn: Swift.String? = nil
        )
        {
            self.groupArn = groupArn
        }
    }

}

extension IoTSiteWiseClientTypes.GreengrassV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDeviceThingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceThingName = self.coreDeviceThingName {
            try encodeContainer.encode(coreDeviceThingName, forKey: .coreDeviceThingName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains details for a gateway that runs on IoT Greengrass V2. To create a gateway that runs on IoT Greengrass V2, you must deploy the IoT SiteWise Edge component to your gateway device. Your [Greengrass device role](https://docs.aws.amazon.com/greengrass/v2/developerguide/device-service-role.html) must use the AWSIoTSiteWiseEdgeAccess policy. For more information, see [Using IoT SiteWise at the edge](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/sw-gateways.html) in the IoT SiteWise User Guide.
    public struct GreengrassV2: Swift.Equatable {
        /// The name of the IoT thing for your IoT Greengrass V2 core device.
        /// This member is required.
        public var coreDeviceThingName: Swift.String?

        public init (
            coreDeviceThingName: Swift.String? = nil
        )
        {
            self.coreDeviceThingName = coreDeviceThingName
        }
    }

}

extension IoTSiteWiseClientTypes.GroupIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for a group identity in an access policy.
    public struct GroupIdentity: Swift.Equatable {
        /// The IAM Identity Center ID of the group.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.IAMRoleIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an Identity and Access Management role. For more information, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the IAM User Guide.
    public struct IAMRoleIdentity: Swift.Equatable {
        /// The ARN of the IAM role. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTSiteWiseClientTypes.IAMUserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an Identity and Access Management user.
    public struct IAMUserIdentity: Swift.Equatable {
        /// The ARN of the IAM user. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide. If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists.
        /// This member is required.
        public var arn: Swift.String?

        public init (
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTSiteWiseClientTypes.Identity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group
        case iamRole
        case iamUser
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let iamUser = self.iamUser {
            try encodeContainer.encode(iamUser, forKey: .iamUser)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.UserIdentity.self, forKey: .user)
        user = userDecoded
        let groupDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GroupIdentity.self, forKey: .group)
        group = groupDecoded
        let iamUserDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.IAMUserIdentity.self, forKey: .iamUser)
        iamUser = iamUserDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.IAMRoleIdentity.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an identity that can access an IoT SiteWise Monitor resource. Currently, you can't use Amazon Web Services APIs to retrieve IAM Identity Center identity IDs. You can find the IAM Identity Center identity IDs in the URL of user and group pages in the [IAM Identity Center console](https://console.aws.amazon.com/singlesignon).
    public struct Identity: Swift.Equatable {
        /// An IAM Identity Center group identity.
        public var group: IoTSiteWiseClientTypes.GroupIdentity?
        /// An IAM role identity.
        public var iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity?
        /// An IAM user identity.
        public var iamUser: IoTSiteWiseClientTypes.IAMUserIdentity?
        /// An IAM Identity Center user identity.
        public var user: IoTSiteWiseClientTypes.UserIdentity?

        public init (
            group: IoTSiteWiseClientTypes.GroupIdentity? = nil,
            iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity? = nil,
            iamUser: IoTSiteWiseClientTypes.IAMUserIdentity? = nil,
            user: IoTSiteWiseClientTypes.UserIdentity? = nil
        )
        {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum IdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case iam
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .group,
                .iam,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .iam: return "IAM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file, forKey: .file)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fileDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFile.self, forKey: .file)
        file = fileDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an image that is one of the following:
    ///
    /// * An image file. Choose this option to upload a new image.
    ///
    /// * The ID of an existing image. Choose this option to keep an existing image.
    public struct Image: Swift.Equatable {
        /// Contains an image file.
        public var file: IoTSiteWiseClientTypes.ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public var id: Swift.String?

        public init (
            file: IoTSiteWiseClientTypes.ImageFile? = nil,
            id: Swift.String? = nil
        )
        {
            self.file = file
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.ImageFile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFileType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an image file.
    public struct ImageFile: Swift.Equatable {
        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The file type of the image.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.ImageFileType?

        public init (
            data: ClientRuntime.Data? = nil,
            type: IoTSiteWiseClientTypes.ImageFileType? = nil
        )
        {
            self.data = data
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ImageFileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case png
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFileType] {
            return [
                .png,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .png: return "PNG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFileType(rawValue: rawValue) ?? ImageFileType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ImageLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an image that is uploaded to IoT SiteWise and available at a URL.
    public struct ImageLocation: Swift.Equatable {
        /// The ID of the image.
        /// This member is required.
        public var id: Swift.String?
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        /// This member is required.
        public var url: Swift.String?

        public init (
            id: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.id = id
            self.url = url
        }
    }

}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// IoT SiteWise can't process your request right now. Try again later.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Variant.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an interpolated asset property value.
    public struct InterpolatedAssetPropertyValue: Swift.Equatable {
        /// Contains a timestamp with optional nanosecond granularity.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// Contains an asset property value (of a single type only).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init (
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension InvalidRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters. Check your request and try again.
public struct InvalidRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.JobConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat, forKey: .fileFormat)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileFormatDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    public struct JobConfiguration: Swift.Equatable {
        /// The file format of the data in Amazon S3.
        /// This member is required.
        public var fileFormat: IoTSiteWiseClientTypes.FileFormat?

        public init (
            fileFormat: IoTSiteWiseClientTypes.FileFormat? = nil
        )
        {
            self.fileFormat = fileFormat
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case completedWithFailures
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a job summary information.
    public struct JobSummary: Swift.Equatable {
        /// The ID of the job.
        /// This member is required.
        public var id: Swift.String?
        /// The unique name that helps identify the job request.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the bulk import job can be one of following values.
        ///
        /// * PENDING – IoT SiteWise is waiting for the current bulk import job to finish.
        ///
        /// * CANCELLED – The bulk import job has been canceled.
        ///
        /// * RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.
        ///
        /// * COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.
        ///
        /// * FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        ///
        /// * COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.JobStatus?

        public init (
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.JobStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've reached the limit for a resource. For example, this can occur if you're trying to associate more than the allowed number of child assets or attempting to create more than the allowed number of properties for an asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let resourceId = resourceId {
                let resourceIdQueryItem = ClientRuntime.URLQueryItem(name: "resourceId".urlPercentEncoding(), value: Swift.String(resourceId).urlPercentEncoding())
                items.append(resourceIdQueryItem)
            }
            if let identityType = identityType {
                let identityTypeQueryItem = ClientRuntime.URLQueryItem(name: "identityType".urlPercentEncoding(), value: Swift.String(identityType.rawValue).urlPercentEncoding())
                items.append(identityTypeQueryItem)
            }
            if let identityId = identityId {
                let identityIdQueryItem = ClientRuntime.URLQueryItem(name: "identityId".urlPercentEncoding(), value: Swift.String(identityId).urlPercentEncoding())
                items.append(identityIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let iamArn = iamArn {
                let iamArnQueryItem = ClientRuntime.URLQueryItem(name: "iamArn".urlPercentEncoding(), value: Swift.String(iamArn).urlPercentEncoding())
                items.append(iamArnQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListAccessPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/access-policies"
    }
}

public struct ListAccessPoliciesInput: Swift.Equatable {
    /// The ARN of the IAM user. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide. This parameter is required if you specify IAM for identityType.
    public var iamArn: Swift.String?
    /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
    public var identityId: Swift.String?
    /// The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify identityId.
    public var identityType: IoTSiteWiseClientTypes.IdentityType?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the resource. This parameter is required if you specify resourceType.
    public var resourceId: Swift.String?
    /// The type of resource (portal or project). This parameter is required if you specify resourceId.
    public var resourceType: IoTSiteWiseClientTypes.ResourceType?

    public init (
        iamArn: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityType: IoTSiteWiseClientTypes.IdentityType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IoTSiteWiseClientTypes.ResourceType? = nil
    )
    {
        self.iamArn = iamArn
        self.identityId = identityId
        self.identityType = identityType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ListAccessPoliciesInputBody: Swift.Equatable {
}

extension ListAccessPoliciesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessPoliciesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAccessPoliciesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAccessPoliciesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAccessPoliciesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAccessPoliciesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicySummaries = output.accessPolicySummaries
            self.nextToken = output.nextToken
        } else {
            self.accessPolicySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPoliciesOutputResponse: Swift.Equatable {
    /// A list that summarizes each access policy.
    /// This member is required.
    public var accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

struct ListAccessPoliciesOutputResponseBody: Swift.Equatable {
    let accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]?
    let nextToken: Swift.String?
}

extension ListAccessPoliciesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AccessPolicySummary?].self, forKey: .accessPolicySummaries)
        var accessPolicySummariesDecoded0:[IoTSiteWiseClientTypes.AccessPolicySummary]? = nil
        if let accessPolicySummariesContainer = accessPolicySummariesContainer {
            accessPolicySummariesDecoded0 = [IoTSiteWiseClientTypes.AccessPolicySummary]()
            for structure0 in accessPolicySummariesContainer {
                if let structure0 = structure0 {
                    accessPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        accessPolicySummaries = accessPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListAssetModelPropertiesFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case base
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetModelPropertiesFilter] {
            return [
                .all,
                .base,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .base: return "BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListAssetModelPropertiesFilter(rawValue: rawValue) ?? ListAssetModelPropertiesFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetModelPropertiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetModelPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/properties"
    }
}

public struct ListAssetModelPropertiesInput: Swift.Equatable {
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// Filters the requested list of asset model properties. You can choose one of the following options:
    ///
    /// * ALL – The list includes all asset model properties for a given asset model ID.
    ///
    /// * BASE – The list includes only base asset model properties for a given asset model ID.
    ///
    ///
    /// Default: BASE
    public var filter: IoTSiteWiseClientTypes.ListAssetModelPropertiesFilter?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        assetModelId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetModelPropertiesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetModelPropertiesInputBody: Swift.Equatable {
}

extension ListAssetModelPropertiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetModelPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetModelPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssetModelPropertiesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetModelPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssetModelPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelPropertySummaries = output.assetModelPropertySummaries
            self.nextToken = output.nextToken
        } else {
            self.assetModelPropertySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetModelPropertiesOutputResponse: Swift.Equatable {
    /// A list that summarizes the properties associated with the specified asset model.
    /// This member is required.
    public var assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelPropertySummaries = assetModelPropertySummaries
        self.nextToken = nextToken
    }
}

struct ListAssetModelPropertiesOutputResponseBody: Swift.Equatable {
    let assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]?
    let nextToken: Swift.String?
}

extension ListAssetModelPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelPropertySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelPropertySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertySummary?].self, forKey: .assetModelPropertySummaries)
        var assetModelPropertySummariesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertySummary]? = nil
        if let assetModelPropertySummariesContainer = assetModelPropertySummariesContainer {
            assetModelPropertySummariesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertySummary]()
            for structure0 in assetModelPropertySummariesContainer {
                if let structure0 = structure0 {
                    assetModelPropertySummariesDecoded0?.append(structure0)
                }
            }
        }
        assetModelPropertySummaries = assetModelPropertySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssetModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/asset-models"
    }
}

public struct ListAssetModelsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetModelsInputBody: Swift.Equatable {
}

extension ListAssetModelsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetModelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetModelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssetModelsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetModelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssetModelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelSummaries = output.assetModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetModelsOutputResponse: Swift.Equatable {
    /// A list that summarizes each asset model.
    /// This member is required.
    public var assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelSummaries = assetModelSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetModelsOutputResponseBody: Swift.Equatable {
    let assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]?
    let nextToken: Swift.String?
}

extension ListAssetModelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelSummary?].self, forKey: .assetModelSummaries)
        var assetModelSummariesDecoded0:[IoTSiteWiseClientTypes.AssetModelSummary]? = nil
        if let assetModelSummariesContainer = assetModelSummariesContainer {
            assetModelSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetModelSummary]()
            for structure0 in assetModelSummariesContainer {
                if let structure0 = structure0 {
                    assetModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetModelSummaries = assetModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListAssetPropertiesFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case base
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetPropertiesFilter] {
            return [
                .all,
                .base,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .base: return "BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListAssetPropertiesFilter(rawValue: rawValue) ?? ListAssetPropertiesFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetPropertiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties"
    }
}

public struct ListAssetPropertiesInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// Filters the requested list of asset properties. You can choose one of the following options:
    ///
    /// * ALL – The list includes all asset properties for a given asset model ID.
    ///
    /// * BASE – The list includes only base asset properties for a given asset model ID.
    ///
    ///
    /// Default: BASE
    public var filter: IoTSiteWiseClientTypes.ListAssetPropertiesFilter?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetPropertiesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetPropertiesInputBody: Swift.Equatable {
}

extension ListAssetPropertiesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetPropertiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetPropertiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssetPropertiesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetPropertiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssetPropertiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetPropertySummaries = output.assetPropertySummaries
            self.nextToken = output.nextToken
        } else {
            self.assetPropertySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetPropertiesOutputResponse: Swift.Equatable {
    /// A list that summarizes the properties associated with the specified asset.
    /// This member is required.
    public var assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetPropertySummaries = assetPropertySummaries
        self.nextToken = nextToken
    }
}

struct ListAssetPropertiesOutputResponseBody: Swift.Equatable {
    let assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]?
    let nextToken: Swift.String?
}

extension ListAssetPropertiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetPropertySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertySummary?].self, forKey: .assetPropertySummaries)
        var assetPropertySummariesDecoded0:[IoTSiteWiseClientTypes.AssetPropertySummary]? = nil
        if let assetPropertySummariesContainer = assetPropertySummariesContainer {
            assetPropertySummariesDecoded0 = [IoTSiteWiseClientTypes.AssetPropertySummary]()
            for structure0 in assetPropertySummariesContainer {
                if let structure0 = structure0 {
                    assetPropertySummariesDecoded0?.append(structure0)
                }
            }
        }
        assetPropertySummaries = assetPropertySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssetRelationshipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let traversalType = traversalType else {
                let message = "Creating a URL Query Item failed. traversalType is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let traversalTypeQueryItem = ClientRuntime.URLQueryItem(name: "traversalType".urlPercentEncoding(), value: Swift.String(traversalType.rawValue).urlPercentEncoding())
            items.append(traversalTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetRelationshipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/assetRelationships"
    }
}

public struct ListAssetRelationshipsInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The type of traversal to use to identify asset relationships. Choose the following option:
    ///
    /// * PATH_TO_ROOT – Identify the asset's parent assets up to the root asset. The asset that you specify in assetId is the first result in the list of assetRelationshipSummaries, and the root asset is the last result.
    /// This member is required.
    public var traversalType: IoTSiteWiseClientTypes.TraversalType?

    public init (
        assetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalType: IoTSiteWiseClientTypes.TraversalType? = nil
    )
    {
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalType = traversalType
    }
}

struct ListAssetRelationshipsInputBody: Swift.Equatable {
}

extension ListAssetRelationshipsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetRelationshipsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetRelationshipsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssetRelationshipsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetRelationshipsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssetRelationshipsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetRelationshipSummaries = output.assetRelationshipSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetRelationshipSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetRelationshipsOutputResponse: Swift.Equatable {
    /// A list that summarizes each asset relationship.
    /// This member is required.
    public var assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetRelationshipSummaries = assetRelationshipSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetRelationshipsOutputResponseBody: Swift.Equatable {
    let assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]?
    let nextToken: Swift.String?
}

extension ListAssetRelationshipsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetRelationshipSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetRelationshipSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetRelationshipSummary?].self, forKey: .assetRelationshipSummaries)
        var assetRelationshipSummariesDecoded0:[IoTSiteWiseClientTypes.AssetRelationshipSummary]? = nil
        if let assetRelationshipSummariesContainer = assetRelationshipSummariesContainer {
            assetRelationshipSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetRelationshipSummary]()
            for structure0 in assetRelationshipSummariesContainer {
                if let structure0 = structure0 {
                    assetRelationshipSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetRelationshipSummaries = assetRelationshipSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListAssetsFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case topLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetsFilter] {
            return [
                .all,
                .topLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .topLevel: return "TOP_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListAssetsFilter(rawValue: rawValue) ?? ListAssetsFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let assetModelId = assetModelId {
                let assetModelIdQueryItem = ClientRuntime.URLQueryItem(name: "assetModelId".urlPercentEncoding(), value: Swift.String(assetModelId).urlPercentEncoding())
                items.append(assetModelIdQueryItem)
            }
            return items
        }
    }
}

extension ListAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assets"
    }
}

public struct ListAssetsInput: Swift.Equatable {
    /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter.
    public var assetModelId: Swift.String?
    /// The filter for the requested list of assets. Choose one of the following options:
    ///
    /// * ALL – The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.
    ///
    /// * TOP_LEVEL – The list includes only top-level assets in the asset hierarchy tree.
    ///
    ///
    /// Default: ALL
    public var filter: IoTSiteWiseClientTypes.ListAssetsFilter?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        assetModelId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetsInputBody: Swift.Equatable {
}

extension ListAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetsOutputResponse: Swift.Equatable {
    /// A list that summarizes each asset.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetsOutputResponseBody: Swift.Equatable {
    let assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]?
    let nextToken: Swift.String?
}

extension ListAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[IoTSiteWiseClientTypes.AssetSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAssociatedAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let traversalDirection = traversalDirection {
                let traversalDirectionQueryItem = ClientRuntime.URLQueryItem(name: "traversalDirection".urlPercentEncoding(), value: Swift.String(traversalDirection.rawValue).urlPercentEncoding())
                items.append(traversalDirectionQueryItem)
            }
            if let hierarchyId = hierarchyId {
                let hierarchyIdQueryItem = ClientRuntime.URLQueryItem(name: "hierarchyId".urlPercentEncoding(), value: Swift.String(hierarchyId).urlPercentEncoding())
                items.append(hierarchyIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssociatedAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/hierarchies"
    }
}

public struct ListAssociatedAssetsInput: Swift.Equatable {
    /// The ID of the asset to query.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the [DescribeAsset](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html) or [DescribeAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html) operations. This parameter is required if you choose CHILD for traversalDirection. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    public var hierarchyId: Swift.String?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The direction to list associated assets. Choose one of the following options:
    ///
    /// * CHILD – The list includes all child assets associated to the asset. The hierarchyId parameter is required if you choose CHILD.
    ///
    /// * PARENT – The list includes the asset's parent asset.
    ///
    ///
    /// Default: CHILD
    public var traversalDirection: IoTSiteWiseClientTypes.TraversalDirection?

    public init (
        assetId: Swift.String? = nil,
        hierarchyId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalDirection: IoTSiteWiseClientTypes.TraversalDirection? = nil
    )
    {
        self.assetId = assetId
        self.hierarchyId = hierarchyId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalDirection = traversalDirection
    }
}

struct ListAssociatedAssetsInputBody: Swift.Equatable {
}

extension ListAssociatedAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListAssociatedAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssociatedAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListAssociatedAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssociatedAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListAssociatedAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedAssetsOutputResponse: Swift.Equatable {
    /// A list that summarizes the associated assets.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssociatedAssetsOutputResponseBody: Swift.Equatable {
    let assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]?
    let nextToken: Swift.String?
}

extension ListAssociatedAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssociatedAssetsSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[IoTSiteWiseClientTypes.AssociatedAssetsSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [IoTSiteWiseClientTypes.AssociatedAssetsSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListBulkImportJobsFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case cancelled
        case completed
        case completedWithFailures
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ListBulkImportJobsFilter] {
            return [
                .all,
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListBulkImportJobsFilter(rawValue: rawValue) ?? ListBulkImportJobsFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListBulkImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBulkImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct ListBulkImportJobsInput: Swift.Equatable {
    /// You can use a filter to select the bulk import jobs that you want to retrieve.
    public var filter: IoTSiteWiseClientTypes.ListBulkImportJobsFilter?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        filter: IoTSiteWiseClientTypes.ListBulkImportJobsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkImportJobsInputBody: Swift.Equatable {
}

extension ListBulkImportJobsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListBulkImportJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListBulkImportJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListBulkImportJobsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListBulkImportJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListBulkImportJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkImportJobsOutputResponse: Swift.Equatable {
    /// One or more job summaries to list.
    /// This member is required.
    public var jobSummaries: [IoTSiteWiseClientTypes.JobSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        jobSummaries: [IoTSiteWiseClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListBulkImportJobsOutputResponseBody: Swift.Equatable {
    let jobSummaries: [IoTSiteWiseClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListBulkImportJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.JobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[IoTSiteWiseClientTypes.JobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [IoTSiteWiseClientTypes.JobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDashboardsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let projectId = projectId else {
                let message = "Creating a URL Query Item failed. projectId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            items.append(projectIdQueryItem)
            return items
        }
    }
}

extension ListDashboardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dashboards"
    }
}

public struct ListDashboardsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListDashboardsInputBody: Swift.Equatable {
}

extension ListDashboardsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDashboardsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDashboardsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDashboardsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDashboardsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDashboardsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dashboardSummaries = output.dashboardSummaries
            self.nextToken = output.nextToken
        } else {
            self.dashboardSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDashboardsOutputResponse: Swift.Equatable {
    /// A list that summarizes each dashboard in the project.
    /// This member is required.
    public var dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dashboardSummaries = dashboardSummaries
        self.nextToken = nextToken
    }
}

struct ListDashboardsOutputResponseBody: Swift.Equatable {
    let dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]?
    let nextToken: Swift.String?
}

extension ListDashboardsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardSummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.DashboardSummary?].self, forKey: .dashboardSummaries)
        var dashboardSummariesDecoded0:[IoTSiteWiseClientTypes.DashboardSummary]? = nil
        if let dashboardSummariesContainer = dashboardSummariesContainer {
            dashboardSummariesDecoded0 = [IoTSiteWiseClientTypes.DashboardSummary]()
            for structure0 in dashboardSummariesContainer {
                if let structure0 = structure0 {
                    dashboardSummariesDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaries = dashboardSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListGatewaysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/20200301/gateways"
    }
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
}

extension ListGatewaysInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListGatewaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListGatewaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListGatewaysOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListGatewaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListGatewaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.gatewaySummaries = output.gatewaySummaries
            self.nextToken = output.nextToken
        } else {
            self.gatewaySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutputResponse: Swift.Equatable {
    /// A list that summarizes each gateway.
    /// This member is required.
    public var gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewaySummaries = gatewaySummaries
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputResponseBody: Swift.Equatable {
    let gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]?
    let nextToken: Swift.String?
}

extension ListGatewaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewaySummaries
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewaySummary?].self, forKey: .gatewaySummaries)
        var gatewaySummariesDecoded0:[IoTSiteWiseClientTypes.GatewaySummary]? = nil
        if let gatewaySummariesContainer = gatewaySummariesContainer {
            gatewaySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewaySummary]()
            for structure0 in gatewaySummariesContainer {
                if let structure0 = structure0 {
                    gatewaySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewaySummaries = gatewaySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPortalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPortalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct ListPortalsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Swift.Equatable {
}

extension ListPortalsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPortalsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPortalsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPortalsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPortalsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPortalsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portalSummaries = output.portalSummaries
        } else {
            self.nextToken = nil
            self.portalSummaries = nil
        }
    }
}

public struct ListPortalsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each portal.
    public var portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]?

    public init (
        nextToken: Swift.String? = nil,
        portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portalSummaries = portalSummaries
    }
}

struct ListPortalsOutputResponseBody: Swift.Equatable {
    let portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]?
    let nextToken: Swift.String?
}

extension ListPortalsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case portalSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.PortalSummary?].self, forKey: .portalSummaries)
        var portalSummariesDecoded0:[IoTSiteWiseClientTypes.PortalSummary]? = nil
        if let portalSummariesContainer = portalSummariesContainer {
            portalSummariesDecoded0 = [IoTSiteWiseClientTypes.PortalSummary]()
            for structure0 in portalSummariesContainer {
                if let structure0 = structure0 {
                    portalSummariesDecoded0?.append(structure0)
                }
            }
        }
        portalSummaries = portalSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProjectAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets"
    }
}

public struct ListProjectAssetsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListProjectAssetsInputBody: Swift.Equatable {
}

extension ListProjectAssetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectAssetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectAssetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectAssetsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectAssetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectAssetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetIds = output.assetIds
            self.nextToken = output.nextToken
        } else {
            self.assetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectAssetsOutputResponse: Swift.Equatable {
    /// A list that contains the IDs of each asset associated with the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init (
        assetIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.nextToken = nextToken
    }
}

struct ListProjectAssetsOutputResponseBody: Swift.Equatable {
    let assetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListProjectAssetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let portalId = portalId else {
                let message = "Creating a URL Query Item failed. portalId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let portalIdQueryItem = ClientRuntime.URLQueryItem(name: "portalId".urlPercentEncoding(), value: Swift.String(portalId).urlPercentEncoding())
            items.append(portalIdQueryItem)
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalId = portalId
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProjectsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListProjectsOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProjectsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListProjectsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projectSummaries = output.projectSummaries
        } else {
            self.nextToken = nil
            self.projectSummaries = nil
        }
    }
}

public struct ListProjectsOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each project in the portal.
    /// This member is required.
    public var projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]?

    public init (
        nextToken: Swift.String? = nil,
        projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projectSummaries = projectSummaries
    }
}

struct ListProjectsOutputResponseBody: Swift.Equatable {
    let projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projectSummaries
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ProjectSummary?].self, forKey: .projectSummaries)
        var projectSummariesDecoded0:[IoTSiteWiseClientTypes.ProjectSummary]? = nil
        if let projectSummariesContainer = projectSummariesContainer {
            projectSummariesDecoded0 = [IoTSiteWiseClientTypes.ProjectSummary]()
            for structure0 in projectSummariesContainer {
                if let structure0 = structure0 {
                    projectSummariesDecoded0?.append(structure0)
                }
            }
        }
        projectSummaries = projectSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The list of key-value pairs that contain metadata for the resource. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTimeSeriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let timeSeriesType = timeSeriesType {
                let timeSeriesTypeQueryItem = ClientRuntime.URLQueryItem(name: "timeSeriesType".urlPercentEncoding(), value: Swift.String(timeSeriesType.rawValue).urlPercentEncoding())
                items.append(timeSeriesTypeQueryItem)
            }
            if let aliasPrefix = aliasPrefix {
                let aliasPrefixQueryItem = ClientRuntime.URLQueryItem(name: "aliasPrefix".urlPercentEncoding(), value: Swift.String(aliasPrefix).urlPercentEncoding())
                items.append(aliasPrefixQueryItem)
            }
            return items
        }
    }
}

extension ListTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries"
    }
}

public struct ListTimeSeriesInput: Swift.Equatable {
    /// The alias prefix of the time series.
    public var aliasPrefix: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The type of the time series. The time series type can be one of the following values:
    ///
    /// * ASSOCIATED – The time series is associated with an asset property.
    ///
    /// * DISASSOCIATED – The time series isn't associated with any asset property.
    public var timeSeriesType: IoTSiteWiseClientTypes.ListTimeSeriesType?

    public init (
        aliasPrefix: Swift.String? = nil,
        assetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timeSeriesType: IoTSiteWiseClientTypes.ListTimeSeriesType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeSeriesType = timeSeriesType
    }
}

struct ListTimeSeriesInputBody: Swift.Equatable {
}

extension ListTimeSeriesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTimeSeriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTimeSeriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTimeSeriesOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTimeSeriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTimeSeriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.timeSeriesSummaries = output.timeSeriesSummaries
        } else {
            self.timeSeriesSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTimeSeriesOutputResponse: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// One or more time series summaries to list.
    /// This member is required.
    public var timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]?

    public init (
        nextToken: Swift.String? = nil,
        timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.timeSeriesSummaries = timeSeriesSummaries
    }
}

struct ListTimeSeriesOutputResponseBody: Swift.Equatable {
    let timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]?
    let nextToken: Swift.String?
}

extension ListTimeSeriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeSeriesSummaries = "TimeSeriesSummaries"
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.TimeSeriesSummary?].self, forKey: .timeSeriesSummaries)
        var timeSeriesSummariesDecoded0:[IoTSiteWiseClientTypes.TimeSeriesSummary]? = nil
        if let timeSeriesSummariesContainer = timeSeriesSummariesContainer {
            timeSeriesSummariesDecoded0 = [IoTSiteWiseClientTypes.TimeSeriesSummary]()
            for structure0 in timeSeriesSummariesContainer {
                if let structure0 = structure0 {
                    timeSeriesSummariesDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesSummaries = timeSeriesSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListTimeSeriesType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTimeSeriesType] {
            return [
                .associated,
                .disassociated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListTimeSeriesType(rawValue: rawValue) ?? ListTimeSeriesType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.LoggingOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case level
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = self.level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingLevel.self, forKey: .level)
        level = levelDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains logging options.
    public struct LoggingOptions: Swift.Equatable {
        /// The IoT SiteWise logging verbosity level.
        /// This member is required.
        public var level: IoTSiteWiseClientTypes.LoggingLevel?

        public init (
            level: IoTSiteWiseClientTypes.LoggingLevel? = nil
        )
        {
            self.level = level
        }
    }

}

extension IoTSiteWiseClientTypes.Measurement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let processingConfig = self.processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MeasurementProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset measurement property. For more information, see [Measurements](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#measurements) in the IoT SiteWise User Guide.
    public struct Measurement: Swift.Equatable {
        /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig?

        public init (
            processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig? = nil
        )
        {
            self.processingConfig = processingConfig
        }
    }

}

extension IoTSiteWiseClientTypes.MeasurementProcessingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forwardingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forwardingConfig = self.forwardingConfig {
            try encodeContainer.encode(forwardingConfig, forKey: .forwardingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfig.self, forKey: .forwardingConfig)
        forwardingConfig = forwardingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
    public struct MeasurementProcessingConfig: Swift.Equatable {
        /// The forwarding configuration for the given measurement property.
        /// This member is required.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init (
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.forwardingConfig = forwardingConfig
        }
    }

}

extension IoTSiteWiseClientTypes.Metric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case processingConfig
        case variables
        case window
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let processingConfig = self.processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariable0 in variables {
                try variablesContainer.encode(expressionvariable0)
            }
        }
        if let window = self.window {
            try encodeContainer.encode(window, forKey: .window)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTSiteWiseClientTypes.ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let windowDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MetricWindow.self, forKey: .window)
        window = windowDecoded
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MetricProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset metric property. With metrics, you can calculate aggregate functions, such as an average, maximum, or minimum, as specified through an expression. A metric maps several values to a single value (such as a sum). The maximum number of dependent/cascading variables used in any one metric calculation is 10. Therefore, a root metric can have up to 10 cascading metrics in its computational dependency tree. Additionally, a metric can only have a data type of DOUBLE and consume properties with data types of INTEGER or DOUBLE. For more information, see [Metrics](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#metrics) in the IoT SiteWise User Guide.
    public struct Metric: Swift.Equatable {
        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per window.
        /// This member is required.
        public var window: IoTSiteWiseClientTypes.MetricWindow?

        public init (
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil,
            window: IoTSiteWiseClientTypes.MetricWindow? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
            self.window = window
        }
    }

}

extension IoTSiteWiseClientTypes.MetricProcessingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeLocation = self.computeLocation {
            try encodeContainer.encode(computeLocation.rawValue, forKey: .computeLocation)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ComputeLocation.self, forKey: .computeLocation)
        computeLocation = computeLocationDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
    public struct MetricProcessingConfig: Swift.Equatable {
        /// The compute location for the given metric property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?

        public init (
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil
        )
        {
            self.computeLocation = computeLocation
        }
    }

}

extension IoTSiteWiseClientTypes.MetricWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tumbling
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tumbling = self.tumbling {
            try encodeContainer.encode(tumbling, forKey: .tumbling)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tumblingDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TumblingWindow.self, forKey: .tumbling)
        tumbling = tumblingDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a time interval window used for data aggregate computations (for example, average, sum, count, and so on).
    public struct MetricWindow: Swift.Equatable {
        /// The tumbling time interval window.
        public var tumbling: IoTSiteWiseClientTypes.TumblingWindow?

        public init (
            tumbling: IoTSiteWiseClientTypes.TumblingWindow? = nil
        )
        {
            self.tumbling = tumbling
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum MonitorErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case limitExceeded
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorErrorCode] {
            return [
                .internalFailure,
                .limitExceeded,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorErrorCode(rawValue: rawValue) ?? MonitorErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.MonitorErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MonitorErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains IoT SiteWise Monitor error details.
    public struct MonitorErrorDetails: Swift.Equatable {
        /// The error code.
        public var code: IoTSiteWiseClientTypes.MonitorErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init (
            code: IoTSiteWiseClientTypes.MonitorErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.MultiLayerStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedS3Storage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3Storage = self.customerManagedS3Storage {
            try encodeContainer.encode(customerManagedS3Storage, forKey: .customerManagedS3Storage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedS3StorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CustomerManagedS3Storage.self, forKey: .customerManagedS3Storage)
        customerManagedS3Storage = customerManagedS3StorageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the storage destination.
    public struct MultiLayerStorage: Swift.Equatable {
        /// Contains information about a customer managed Amazon S3 bucket.
        /// This member is required.
        public var customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage?

        public init (
            customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage? = nil
        )
        {
            self.customerManagedS3Storage = customerManagedS3Storage
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .administrator,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PortalResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Identifies an IoT SiteWise Monitor portal.
    public struct PortalResource: Swift.Equatable {
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PortalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortalState(rawValue: rawValue) ?? PortalState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PortalStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MonitorErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the current status of a portal.
    public struct PortalStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.MonitorErrorDetails?
        /// The current state of the portal.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PortalState?

        public init (
            error: IoTSiteWiseClientTypes.MonitorErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.PortalState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.PortalSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case roleArn
        case startUrl
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startUrl = self.startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a portal summary.
    public struct PortalSummary: Swift.Equatable {
        /// The date the portal was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The portal's description.
        public var description: Swift.String?
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?
        /// The date the portal was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the portal.
        /// This member is required.
        public var name: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
        public var roleArn: Swift.String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        /// This member is required.
        public var startUrl: Swift.String?
        /// Contains information about the current status of a portal.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.PortalStatus?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            startUrl: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.PortalStatus? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.ProjectResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Identifies a specific IoT SiteWise Monitor project.
    public struct ProjectResource: Swift.Equatable {
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains project summary information.
    public struct ProjectSummary: Swift.Equatable {
        /// The date the project was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The project's description.
        public var description: Swift.String?
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?
        /// The date the project was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?

        public init (
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.Property: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case dataType
        case id
        case name
        case notification
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property information.
    public struct Property: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The property data type.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The property type (see PropertyType). A property contains one type.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init (
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.id = id
            self.name = name
            self.notification = notification
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PropertyDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case integer
        case string
        case `struct`
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyDataType] {
            return [
                .boolean,
                .double,
                .integer,
                .string,
                .struct,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case .struct: return "STRUCT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyDataType(rawValue: rawValue) ?? PropertyDataType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PropertyNotification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case topic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotificationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide.
    public struct PropertyNotification: Swift.Equatable {
        /// The current notification state.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PropertyNotificationState?
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        /// This member is required.
        public var topic: Swift.String?

        public init (
            state: IoTSiteWiseClientTypes.PropertyNotificationState? = nil,
            topic: Swift.String? = nil
        )
        {
            self.state = state
            self.topic = topic
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PropertyNotificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyNotificationState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyNotificationState(rawValue: rawValue) ?? PropertyNotificationState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PropertyType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case measurement
        case metric
        case transform
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let measurement = self.measurement {
            try encodeContainer.encode(measurement, forKey: .measurement)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let transform = self.transform {
            try encodeContainer.encode(transform, forKey: .transform)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let measurementDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Measurement.self, forKey: .measurement)
        measurement = measurementDecoded
        let transformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Transform.self, forKey: .transform)
        transform = transformDecoded
        let metricDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a property type, which can be one of attribute, measurement, metric, or transform.
    public struct PropertyType: Swift.Equatable {
        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an [IIoT](https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications) wind turbine.
        public var attribute: IoTSiteWiseClientTypes.Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public var measurement: IoTSiteWiseClientTypes.Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public var metric: IoTSiteWiseClientTypes.Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public var transform: IoTSiteWiseClientTypes.Transform?

        public init (
            attribute: IoTSiteWiseClientTypes.Attribute? = nil,
            measurement: IoTSiteWiseClientTypes.Measurement? = nil,
            metric: IoTSiteWiseClientTypes.Metric? = nil,
            transform: IoTSiteWiseClientTypes.Transform? = nil
        )
        {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }
    }

}

extension IoTSiteWiseClientTypes.PutAssetPropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for assetpropertyvalue0 in propertyValues {
                try propertyValuesContainer.encode(assetpropertyvalue0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a list of value updates for an asset property in the list of asset entries consumed by the [BatchPutAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html) API operation.
    public struct PutAssetPropertyValueEntry: Swift.Equatable {
        /// The ID of the asset to update.
        public var assetId: Swift.String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property for this entry.
        public var propertyId: Swift.String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements.
        /// This member is required.
        public var propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]?

        public init (
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }
    }

}

extension PutDefaultEncryptionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

extension PutDefaultEncryptionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/encryption"
    }
}

public struct PutDefaultEncryptionConfigurationInput: Swift.Equatable {
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ID of the customer managed key used for KMS encryption. This is required if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyId: Swift.String?

    public init (
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

struct PutDefaultEncryptionConfigurationInputBody: Swift.Equatable {
    let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    let kmsKeyId: Swift.String?
}

extension PutDefaultEncryptionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension PutDefaultEncryptionConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutDefaultEncryptionConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutDefaultEncryptionConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutDefaultEncryptionConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutDefaultEncryptionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct PutDefaultEncryptionConfigurationOutputResponse: Swift.Equatable {
    /// The status of the account configuration. This contains the ConfigurationState. If there is an error, it also contains the ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ARN of the KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct PutDefaultEncryptionConfigurationOutputResponseBody: Swift.Equatable {
    let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    let kmsKeyArn: Swift.String?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension PutDefaultEncryptionConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

extension PutLoggingOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = self.loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

extension PutLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging"
    }
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// The logging options to set.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init (
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    let loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutLoggingOptionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutLoggingOptionsOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutLoggingOptionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutLoggingOptionsOutputResponse: Swift.Equatable {

    public init () { }
}

extension PutStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedDataStorage
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disassociatedDataStorage = self.disassociatedDataStorage {
            try encodeContainer.encode(disassociatedDataStorage.rawValue, forKey: .disassociatedDataStorage)
        }
        if let multiLayerStorage = self.multiLayerStorage {
            try encodeContainer.encode(multiLayerStorage, forKey: .multiLayerStorage)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }
}

extension PutStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/storage"
    }
}

public struct PutStorageConfigurationInput: Swift.Equatable {
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type, you must specify a MultiLayerStorage object.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init (
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.disassociatedDataStorage = disassociatedDataStorage
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
    }
}

struct PutStorageConfigurationInputBody: Swift.Equatable {
    let storageType: IoTSiteWiseClientTypes.StorageType?
    let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    let disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    let retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
}

extension PutStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedDataStorage
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let disassociatedDataStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DisassociatedDataStorageState.self, forKey: .disassociatedDataStorage)
        disassociatedDataStorage = disassociatedDataStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension PutStorageConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutStorageConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutStorageConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutStorageConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PutStorageConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.disassociatedDataStorage = output.disassociatedDataStorage
            self.multiLayerStorage = output.multiLayerStorage
            self.retentionPeriod = output.retentionPeriod
            self.storageType = output.storageType
        } else {
            self.configurationStatus = nil
            self.disassociatedDataStorage = nil
            self.multiLayerStorage = nil
            self.retentionPeriod = nil
            self.storageType = nil
        }
    }
}

public struct PutStorageConfigurationOutputResponse: Swift.Equatable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init (
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.disassociatedDataStorage = disassociatedDataStorage
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
    }
}

struct PutStorageConfigurationOutputResponseBody: Swift.Equatable {
    let storageType: IoTSiteWiseClientTypes.StorageType?
    let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    let disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    let retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension PutStorageConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case disassociatedDataStorage
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let disassociatedDataStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DisassociatedDataStorageState.self, forKey: .disassociatedDataStorage)
        disassociatedDataStorage = disassociatedDataStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum Quality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bad
        case good
        case uncertain
        case sdkUnknown(Swift.String)

        public static var allCases: [Quality] {
            return [
                .bad,
                .good,
                .uncertain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bad: return "BAD"
            case .good: return "GOOD"
            case .uncertain: return "UNCERTAIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Quality(rawValue: rawValue) ?? Quality.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
        case project
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portal = self.portal {
            try encodeContainer.encode(portal, forKey: .portal)
        }
        if let project = self.project {
            try encodeContainer.encode(project, forKey: .project)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalResource.self, forKey: .portal)
        portal = portalDecoded
        let projectDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ProjectResource.self, forKey: .project)
        project = projectDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an IoT SiteWise Monitor resource ID for a portal or project.
    public struct Resource: Swift.Equatable {
        /// A portal resource.
        public var portal: IoTSiteWiseClientTypes.PortalResource?
        /// A project resource.
        public var project: IoTSiteWiseClientTypes.ProjectResource?

        public init (
            portal: IoTSiteWiseClientTypes.PortalResource? = nil,
            project: IoTSiteWiseClientTypes.ProjectResource? = nil
        )
        {
            self.portal = portal
            self.project = project
        }
    }

}

extension ResourceAlreadyExistsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
        } else {
            self.message = nil
            self.resourceArn = nil
            self.resourceId = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// The ARN of the resource that already exists.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The ID of the resource that already exists.
    /// This member is required.
    public var resourceId: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceArn = resourceArn
        self.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case portal
        case project
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .portal,
                .project,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .portal: return "PORTAL"
            case .project: return "PROJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.RetentionPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfDays
        case unlimited
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfDays = self.numberOfDays {
            try encodeContainer.encode(numberOfDays, forKey: .numberOfDays)
        }
        if let unlimited = self.unlimited {
            try encodeContainer.encode(unlimited, forKey: .unlimited)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDays)
        numberOfDays = numberOfDaysDecoded
        let unlimitedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unlimited)
        unlimited = unlimitedDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public struct RetentionPeriod: Swift.Equatable {
        /// The number of days that your data is kept. If you specified a value for this parameter, the unlimited parameter must be false.
        public var numberOfDays: Swift.Int?
        /// If true, your data is kept indefinitely. If configured to true, you must not specify a value for the numberOfDays parameter.
        public var unlimited: Swift.Bool?

        public init (
            numberOfDays: Swift.Int? = nil,
            unlimited: Swift.Bool? = nil
        )
        {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }
    }

}

extension ServiceUnavailableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The requested service is unavailable.
public struct ServiceUnavailableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiLayerStorage
        case sitewiseDefaultStorage
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .multiLayerStorage,
                .sitewiseDefaultStorage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiLayerStorage: return "MULTI_LAYER_STORAGE"
            case .sitewiseDefaultStorage: return "SITEWISE_DEFAULT_STORAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyTagsException" : self = .tooManyTagsException(try TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case tooManyTagsException(TooManyTagsException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request exceeded a rate limit. For example, you might have exceeded the number of IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so on. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.TimeInNanos: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = self.offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = self.timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a timestamp with optional nanosecond granularity.
    public struct TimeInNanos: Swift.Equatable {
        /// The nanosecond offset from timeInSeconds.
        public var offsetInNanos: Swift.Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        /// This member is required.
        public var timeInSeconds: Swift.Int?

        public init (
            offsetInNanos: Swift.Int? = nil,
            timeInSeconds: Swift.Int? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum TimeOrdering: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeOrdering] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeOrdering(rawValue: rawValue) ?? TimeOrdering.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.TimeSeriesSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case assetId
        case dataType
        case dataTypeSpec
        case propertyId
        case timeSeriesCreationDate
        case timeSeriesId
        case timeSeriesLastUpdateDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let timeSeriesCreationDate = self.timeSeriesCreationDate {
            try encodeContainer.encodeTimestamp(timeSeriesCreationDate, format: .epochSeconds, forKey: .timeSeriesCreationDate)
        }
        if let timeSeriesId = self.timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
        if let timeSeriesLastUpdateDate = self.timeSeriesLastUpdateDate {
            try encodeContainer.encodeTimestamp(timeSeriesLastUpdateDate, format: .epochSeconds, forKey: .timeSeriesLastUpdateDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let timeSeriesCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesCreationDate)
        timeSeriesCreationDate = timeSeriesCreationDateDecoded
        let timeSeriesLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesLastUpdateDate)
        timeSeriesLastUpdateDate = timeSeriesLastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a time series (data stream).
    public struct TimeSeriesSummary: Swift.Equatable {
        /// The alias that identifies the time series.
        public var alias: Swift.String?
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The date that the time series was created, in Unix epoch time.
        /// This member is required.
        public var timeSeriesCreationDate: ClientRuntime.Date?
        /// The ID of the time series.
        /// This member is required.
        public var timeSeriesId: Swift.String?
        /// The date that the time series was last updated, in Unix epoch time.
        /// This member is required.
        public var timeSeriesLastUpdateDate: ClientRuntime.Date?

        public init (
            alias: Swift.String? = nil,
            assetId: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            timeSeriesCreationDate: ClientRuntime.Date? = nil,
            timeSeriesId: Swift.String? = nil,
            timeSeriesLastUpdateDate: ClientRuntime.Date? = nil
        )
        {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }
    }

}

extension TooManyTagsException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.resourceName = output.resourceName
        } else {
            self.message = nil
            self.resourceName = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've reached the limit for the number of tags allowed for a resource. For more information, see [Tag naming limits and requirements](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions) in the Amazon Web Services General Reference.
public struct TooManyTagsException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    /// The name of the resource with too many tags.
    public var resourceName: Swift.String?

    public init (
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.message = message
        self.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension IoTSiteWiseClientTypes.Transform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case processingConfig
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let processingConfig = self.processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariable0 in variables {
                try variablesContainer.encode(expressionvariable0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTSiteWiseClientTypes.ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TransformProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset transform property. A transform is a one-to-one mapping of a property's data points from one form to another. For example, you can use a transform to convert a Celsius data stream to Fahrenheit by applying the transformation expression to each data point of the Celsius stream. A transform can only have a data type of DOUBLE and consume properties with data types of INTEGER or DOUBLE. For more information, see [Transforms](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#transforms) in the IoT SiteWise User Guide.
    public struct Transform: Swift.Equatable {
        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?

        public init (
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
        }
    }

}

extension IoTSiteWiseClientTypes.TransformProcessingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeLocation
        case forwardingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeLocation = self.computeLocation {
            try encodeContainer.encode(computeLocation.rawValue, forKey: .computeLocation)
        }
        if let forwardingConfig = self.forwardingConfig {
            try encodeContainer.encode(forwardingConfig, forKey: .forwardingConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ComputeLocation.self, forKey: .computeLocation)
        computeLocation = computeLocationDecoded
        let forwardingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfig.self, forKey: .forwardingConfig)
        forwardingConfig = forwardingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
    public struct TransformProcessingConfig: Swift.Equatable {
        /// The compute location for the given transform property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?
        /// The forwarding configuration for a given property.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init (
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil,
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.computeLocation = computeLocation
            self.forwardingConfig = forwardingConfig
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum TraversalDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case child
        case parent
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalDirection] {
            return [
                .child,
                .parent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .parent: return "PARENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TraversalDirection(rawValue: rawValue) ?? TraversalDirection.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum TraversalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pathToRoot
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalType] {
            return [
                .pathToRoot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pathToRoot: return "PATH_TO_ROOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TraversalType(rawValue: rawValue) ?? TraversalType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.TumblingWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval
        case offset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interval)
        interval = intervalDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and contiguous time window. You can use this window in metrics to aggregate data from properties and other assets. You can use m, h, d, and w when you specify an interval or offset. Note that m represents minutes, h represents hours, d represents days, and w represents weeks. You can also use s to represent seconds in offset. The interval and offset parameters support the [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601). For example, PT5S represents 5 seconds, PT5M represents 5 minutes, and PT5H represents 5 hours.
    public struct TumblingWindow: Swift.Equatable {
        /// The time interval for the tumbling window. The interval time must be between 1 minute and 1 week. IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on. When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.
        /// This member is required.
        public var interval: Swift.String?
        /// The offset for the tumbling window. The offset parameter accepts the following:
        ///
        /// * The offset time. For example, if you specify 18h for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        /// * The ISO 8601 format. For example, if you specify PT18H for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        /// * The 24-hour clock. For example, if you specify 00:03:00 for offset, 5m for interval, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC).
        ///
        /// * The offset time zone. For example, if you specify 2021-07-23T18:00-08 for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.
        public var offset: Swift.String?

        public init (
            interval: Swift.String? = nil,
            offset: Swift.String? = nil
        )
        {
            self.interval = interval
            self.offset = offset
        }
    }

}

extension UnauthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized.
public struct UnauthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnauthorizedException" : self = .unauthorizedException(try UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unauthorizedException(UnauthorizedException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = self.accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = self.accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = self.accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPolicyId = accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

public struct UpdateAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
    }
}

struct UpdateAccessPolicyInputBody: Swift.Equatable {
    let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    let clientToken: Swift.String?
}

extension UpdateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAccessPolicyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAccessPolicyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAccessPolicyOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAccessPolicyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAccessPolicyOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetName
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDescription = self.assetDescription {
            try encodeContainer.encode(assetDescription, forKey: .assetDescription)
        }
        if let assetName = self.assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct UpdateAssetInput: Swift.Equatable {
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// The ID of the asset to update.
    /// This member is required.
    public var assetId: Swift.String?
    /// A friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetDescription: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetDescription = assetDescription
        self.assetId = assetId
        self.assetName = assetName
        self.clientToken = clientToken
    }
}

struct UpdateAssetInputBody: Swift.Equatable {
    let assetName: Swift.String?
    let clientToken: Swift.String?
    let assetDescription: Swift.String?
}

extension UpdateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetName
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let assetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetDescription)
        assetDescription = assetDescriptionDecoded
    }
}

extension UpdateAssetModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodel0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodel0)
            }
        }
        if let assetModelDescription = self.assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchy0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchy0)
            }
        }
        if let assetModelName = self.assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelproperty0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelproperty0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

public struct UpdateAssetModelInput: Swift.Equatable {
    /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model to update.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique, friendly name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The updated property definitions of the asset model. For more information, see [Asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html) in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init (
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
    }
}

struct UpdateAssetModelInputBody: Swift.Equatable {
    let assetModelName: Swift.String?
    let assetModelDescription: Swift.String?
    let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    let clientToken: Swift.String?
}

extension UpdateAssetModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAssetModelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetModelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssetModelOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetModelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssetModelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct UpdateAssetModelOutputResponse: Swift.Equatable {
    /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init (
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct UpdateAssetModelOutputResponseBody: Swift.Equatable {
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension UpdateAssetModelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

extension UpdateAssetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssetOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateAssetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct UpdateAssetOutputResponse: Swift.Equatable {
    /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init (
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct UpdateAssetOutputResponseBody: Swift.Equatable {
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension UpdateAssetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

extension UpdateAssetPropertyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
        case propertyUnit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyNotificationState = self.propertyNotificationState {
            try encodeContainer.encode(propertyNotificationState.rawValue, forKey: .propertyNotificationState)
        }
        if let propertyUnit = self.propertyUnit {
            try encodeContainer.encode(propertyUnit, forKey: .propertyUnit)
        }
    }
}

extension UpdateAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        guard let propertyId = propertyId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
    }
}

public struct UpdateAssetPropertyInput: Swift.Equatable {
    /// The ID of the asset to be updated.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property to be updated.
    /// This member is required.
    public var propertyId: Swift.String?
    /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
    public var propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState?
    /// The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
    public var propertyUnit: Swift.String?

    public init (
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState? = nil,
        propertyUnit: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyNotificationState = propertyNotificationState
        self.propertyUnit = propertyUnit
    }
}

struct UpdateAssetPropertyInputBody: Swift.Equatable {
    let propertyAlias: Swift.String?
    let propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState?
    let clientToken: Swift.String?
    let propertyUnit: Swift.String?
}

extension UpdateAssetPropertyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
        case propertyUnit
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyNotificationStateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotificationState.self, forKey: .propertyNotificationState)
        propertyNotificationState = propertyNotificationStateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let propertyUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyUnit)
        propertyUnit = propertyUnitDecoded
    }
}

extension UpdateAssetPropertyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssetPropertyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateAssetPropertyOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssetPropertyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAssetPropertyOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = self.dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = self.dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = self.dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
    }
}

extension UpdateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct UpdateDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The new dashboard definition, as specified in a JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A new description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard to update.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// A new friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardName = dashboardName
    }
}

struct UpdateDashboardInputBody: Swift.Equatable {
    let dashboardName: Swift.String?
    let dashboardDescription: Swift.String?
    let dashboardDefinition: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDashboardOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDashboardOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDashboardOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDashboardOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDashboardOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateGatewayCapabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityConfiguration = self.capabilityConfiguration {
            try encodeContainer.encode(capabilityConfiguration, forKey: .capabilityConfiguration)
        }
        if let capabilityNamespace = self.capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
    }
}

extension UpdateGatewayCapabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability"
    }
}

public struct UpdateGatewayCapabilityConfigurationInput: Swift.Equatable {
    /// The JSON document that defines the configuration for the gateway capability. For more information, see [Configuring data sources (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway to be updated.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init (
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct UpdateGatewayCapabilityConfigurationInputBody: Swift.Equatable {
    let capabilityNamespace: Swift.String?
    let capabilityConfiguration: Swift.String?
}

extension UpdateGatewayCapabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
    }
}

extension UpdateGatewayCapabilityConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayCapabilityConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGatewayCapabilityConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayCapabilityConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateGatewayCapabilityConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
        } else {
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
        }
    }
}

public struct UpdateGatewayCapabilityConfigurationOutputResponse: Swift.Equatable {
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    /// * IN_SYNC – The gateway is running the capability configuration.
    ///
    /// * OUT_OF_SYNC – The gateway hasn't received the capability configuration.
    ///
    /// * SYNC_FAILED – The gateway rejected the capability configuration.
    ///
    ///
    /// After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

    public init (
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
    }
}

struct UpdateGatewayCapabilityConfigurationOutputResponseBody: Swift.Equatable {
    let capabilityNamespace: Swift.String?
    let capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
}

extension UpdateGatewayCapabilityConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension UpdateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
    }
}

extension UpdateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

public struct UpdateGatewayInput: Swift.Equatable {
    /// The ID of the gateway to update.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// A unique, friendly name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?

    public init (
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
    }
}

struct UpdateGatewayInputBody: Swift.Equatable {
    let gatewayName: Swift.String?
}

extension UpdateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
    }
}

extension UpdateGatewayOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGatewayOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateGatewayOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGatewayOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateGatewayOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = self.alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = self.notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalContactEmail = self.portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = self.portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImage = self.portalLogoImage {
            try encodeContainer.encode(portalLogoImage, forKey: .portalLogoImage)
        }
        if let portalName = self.portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalId = portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

public struct UpdatePortalInput: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A new description for the portal.
    public var portalDescription: Swift.String?
    /// The ID of the portal to update.
    /// This member is required.
    public var portalId: Swift.String?
    /// Contains an image that is one of the following:
    ///
    /// * An image file. Choose this option to upload a new image.
    ///
    /// * The ID of an existing image. Choose this option to keep an existing image.
    public var portalLogoImage: IoTSiteWiseClientTypes.Image?
    /// A new friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?

    public init (
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLogoImage: IoTSiteWiseClientTypes.Image? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLogoImage = portalLogoImage
        self.portalName = portalName
        self.roleArn = roleArn
    }
}

struct UpdatePortalInputBody: Swift.Equatable {
    let portalName: Swift.String?
    let portalDescription: Swift.String?
    let portalContactEmail: Swift.String?
    let portalLogoImage: IoTSiteWiseClientTypes.Image?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let notificationSenderEmail: Swift.String?
    let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension UpdatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalLogoImageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Image.self, forKey: .portalLogoImage)
        portalLogoImage = portalLogoImageDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension UpdatePortalOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePortalOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictingOperationException" : self = .conflictingOperationException(try ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePortalOutputError: Swift.Error, Swift.Equatable {
    case conflictingOperationException(ConflictingOperationException)
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePortalOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePortalOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct UpdatePortalOutputResponse: Swift.Equatable {
    /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init (
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct UpdatePortalOutputResponseBody: Swift.Equatable {
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
}

extension UpdatePortalOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalStatus
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let projectDescription = self.projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A new description for the project.
    public var projectDescription: Swift.String?
    /// The ID of the project to update.
    /// This member is required.
    public var projectId: Swift.String?
    /// A new friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectName = projectName
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let projectDescription: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateProjectOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateProjectOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestException" : self = .invalidRequestException(try InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateProjectOutputError: Swift.Error, Swift.Equatable {
    case internalFailureException(InternalFailureException)
    case invalidRequestException(InvalidRequestException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateProjectOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateProjectOutputResponse: Swift.Equatable {

    public init () { }
}

extension IoTSiteWiseClientTypes.UserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for a user identity in an access policy.
    public struct UserIdentity: Swift.Equatable {
        /// The IAM Identity Center ID of the user.
        /// This member is required.
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.VariableValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyId
        case propertyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Identifies a property value used in an expression.
    public struct VariableValue: Swift.Equatable {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
        public var hierarchyId: Swift.String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model.
        /// This member is required.
        public var propertyId: Swift.String?

        public init (
            hierarchyId: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
        }
    }

}

extension IoTSiteWiseClientTypes.Variant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = self.booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = self.doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let integerValue = self.integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset property value (of a single type only).
    public struct Variant: Swift.Equatable {
        /// Asset property data of type Boolean (true or false).
        public var booleanValue: Swift.Bool?
        /// Asset property data of type double (floating point number).
        public var doubleValue: Swift.Double?
        /// Asset property data of type integer (whole number).
        public var integerValue: Swift.Int?
        /// Asset property data of type string (sequence of characters).
        public var stringValue: Swift.String?

        public init (
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            integerValue: Swift.Int? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }
    }

}
