// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             You do not have sufficient access to perform this action. Check that the workbook is owned by you and your
///             IAM policy allows access to the resource in the request.
///         </p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationExecutionException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationExecutionException(message: \(String(describing: message)))"}
}

extension AutomationExecutionException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationExecutionExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The automation execution did not end successfully.</p>
public struct AutomationExecutionException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionExceptionBody: Equatable {
    public let message: String?
}

extension AutomationExecutionExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationExecutionTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AutomationExecutionTimeoutException(message: \(String(describing: message)))"}
}

extension AutomationExecutionTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AutomationExecutionTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The automation execution timed out.</p>
public struct AutomationExecutionTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AutomationExecutionTimeoutExceptionBody: Equatable {
    public let message: String?
}

extension AutomationExecutionTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct BatchCreateTableRowsInputBodyMiddleware: Middleware {
    public let id: String = "BatchCreateTableRowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateTableRowsInput>
    public typealias MOutput = OperationOutput<BatchCreateTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateTableRowsOutputError>
}

extension BatchCreateTableRowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateTableRowsInput(clientRequestToken: \(String(describing: clientRequestToken)), rowsToCreate: \(String(describing: rowsToCreate)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension BatchCreateTableRowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowsToCreate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowsToCreate = rowsToCreate {
            var rowsToCreateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowsToCreate)
            for createrowdatalist0 in rowsToCreate {
                try rowsToCreateContainer.encode(createrowdatalist0)
            }
        }
    }
}

public struct BatchCreateTableRowsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchCreateTableRowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateTableRowsInput>
    public typealias MOutput = OperationOutput<BatchCreateTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateTableRowsOutputError>
}

public struct BatchCreateTableRowsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchCreateTableRowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchCreateTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchCreateTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchCreateTableRowsInput>
    public typealias MOutput = OperationOutput<BatchCreateTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchCreateTableRowsOutputError>
}

public struct BatchCreateTableRowsInput: Equatable {
    /// <p>
    ///             The request token for performing the batch create operation.
    ///             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
    ///             like a failed network connection, you can retry the call with the same request token. The service ensures
    ///             that if the first call using that request token is successfully performed, the second call will not perform
    ///             the operation again.
    ///         </p>
    ///         <p>
    ///             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
    ///             spanning hours or days.
    ///         </p>
    public let clientRequestToken: String?
    /// <p>
    ///             The list of rows to create at the end of the table. Each item in this list needs to have a batch item id
    ///             to uniquely identify the element in the request and the cells to create for that row.
    ///             You need to specify at least one item in this list.
    ///         </p>
    ///         <p>
    ///             Note that if one of the column ids in any of the rows in the request does not exist in the table, then the
    ///             request fails and no updates are made to the table.
    ///         </p>
    public let rowsToCreate: [CreateRowData]?
    /// <p>The ID of the table where the new rows are being added.</p>
    ///         <p>
    ///             If a table with the specified ID could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook where the new rows are being added.</p>
    ///         <p>
    ///             If a workbook with the specified ID could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        clientRequestToken: String? = nil,
        rowsToCreate: [CreateRowData]? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowsToCreate = rowsToCreate
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchCreateTableRowsInputBody: Equatable {
    public let rowsToCreate: [CreateRowData]?
    public let clientRequestToken: String?
}

extension BatchCreateTableRowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowsToCreate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsToCreateContainer = try containerValues.decodeIfPresent([CreateRowData?].self, forKey: .rowsToCreate)
        var rowsToCreateDecoded0:[CreateRowData]? = nil
        if let rowsToCreateContainer = rowsToCreateContainer {
            rowsToCreateDecoded0 = [CreateRowData]()
            for structure0 in rowsToCreateContainer {
                if let structure0 = structure0 {
                    rowsToCreateDecoded0?.append(structure0)
                }
            }
        }
        rowsToCreate = rowsToCreateDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchCreateTableRowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchCreateTableRowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchCreateTableRowsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchCreateTableRowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchCreateTableRowsOutputResponse(createdRows: \(String(describing: createdRows)), failedBatchItems: \(String(describing: failedBatchItems)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension BatchCreateTableRowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchCreateTableRowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.createdRows = output.createdRows
            self.failedBatchItems = output.failedBatchItems
            self.workbookCursor = output.workbookCursor
        } else {
            self.createdRows = nil
            self.failedBatchItems = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchCreateTableRowsOutputResponse: Equatable {
    /// <p>The map of batch item id to the row id that was created for that item.</p>
    public let createdRows: [String:String]?
    /// <p>
    ///             The list of batch items in the request that could not be added to the table. Each element in this list
    ///             contains one item from the request that could not be added to the table along with the reason why
    ///             that item could not be added.
    ///         </p>
    public let failedBatchItems: [FailedBatchItem]?
    /// <p>The updated workbook cursor after adding the new rows at the end of the table.</p>
    public let workbookCursor: Int

    public init (
        createdRows: [String:String]? = nil,
        failedBatchItems: [FailedBatchItem]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.createdRows = createdRows
        self.failedBatchItems = failedBatchItems
        self.workbookCursor = workbookCursor
    }
}

struct BatchCreateTableRowsOutputResponseBody: Equatable {
    public let workbookCursor: Int
    public let createdRows: [String:String]?
    public let failedBatchItems: [FailedBatchItem]?
}

extension BatchCreateTableRowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case createdRows
        case failedBatchItems
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
        let createdRowsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .createdRows)
        var createdRowsDecoded0: [String:String]? = nil
        if let createdRowsContainer = createdRowsContainer {
            createdRowsDecoded0 = [String:String]()
            for (key0, rowid0) in createdRowsContainer {
                if let rowid0 = rowid0 {
                    createdRowsDecoded0?[key0] = rowid0
                }
            }
        }
        createdRows = createdRowsDecoded0
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

public struct BatchDeleteTableRowsInputBodyMiddleware: Middleware {
    public let id: String = "BatchDeleteTableRowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableRowsInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableRowsOutputError>
}

extension BatchDeleteTableRowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteTableRowsInput(clientRequestToken: \(String(describing: clientRequestToken)), rowIds: \(String(describing: rowIds)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension BatchDeleteTableRowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowIds = rowIds {
            var rowIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowIds)
            for rowidlist0 in rowIds {
                try rowIdsContainer.encode(rowidlist0)
            }
        }
    }
}

public struct BatchDeleteTableRowsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchDeleteTableRowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableRowsInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableRowsOutputError>
}

public struct BatchDeleteTableRowsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchDeleteTableRowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchDeleteTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchDeleteTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchDeleteTableRowsInput>
    public typealias MOutput = OperationOutput<BatchDeleteTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchDeleteTableRowsOutputError>
}

public struct BatchDeleteTableRowsInput: Equatable {
    /// <p>
    ///             The request token for performing the delete action.
    ///             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
    ///             like a failed network connection, you can retry the call with the same request token. The service ensures
    ///             that if the first call using that request token is successfully performed, the second call will not perform
    ///             the action again.
    ///         </p>
    ///         <p>
    ///             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
    ///             spanning hours or days.
    ///         </p>
    public let clientRequestToken: String?
    /// <p>
    ///             The list of row ids to delete from the table. You need to specify at least one row id in this list.
    ///         </p>
    ///         <p>
    ///             Note that if one of the row ids provided in the request does not exist in the table, then the request fails
    ///             and no rows are deleted from the table.
    ///         </p>
    public let rowIds: [String]?
    /// <p>The ID of the table where the rows are being deleted.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook where the rows are being deleted.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        clientRequestToken: String? = nil,
        rowIds: [String]? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowIds = rowIds
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchDeleteTableRowsInputBody: Equatable {
    public let rowIds: [String]?
    public let clientRequestToken: String?
}

extension BatchDeleteTableRowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rowIds)
        var rowIdsDecoded0:[String]? = nil
        if let rowIdsContainer = rowIdsContainer {
            rowIdsDecoded0 = [String]()
            for string0 in rowIdsContainer {
                if let string0 = string0 {
                    rowIdsDecoded0?.append(string0)
                }
            }
        }
        rowIds = rowIdsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchDeleteTableRowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchDeleteTableRowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchDeleteTableRowsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchDeleteTableRowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchDeleteTableRowsOutputResponse(failedBatchItems: \(String(describing: failedBatchItems)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension BatchDeleteTableRowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchDeleteTableRowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedBatchItems = output.failedBatchItems
            self.workbookCursor = output.workbookCursor
        } else {
            self.failedBatchItems = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchDeleteTableRowsOutputResponse: Equatable {
    /// <p>
    ///             The list of row ids in the request that could not be deleted from the table. Each element in this list
    ///             contains one row id from the request that could not be deleted along with the reason why that item could not
    ///             be deleted.
    ///         </p>
    public let failedBatchItems: [FailedBatchItem]?
    /// <p>The updated workbook cursor after deleting the rows from the table.</p>
    public let workbookCursor: Int

    public init (
        failedBatchItems: [FailedBatchItem]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.failedBatchItems = failedBatchItems
        self.workbookCursor = workbookCursor
    }
}

struct BatchDeleteTableRowsOutputResponseBody: Equatable {
    public let workbookCursor: Int
    public let failedBatchItems: [FailedBatchItem]?
}

extension BatchDeleteTableRowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedBatchItems
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

public struct BatchUpdateTableRowsInputBodyMiddleware: Middleware {
    public let id: String = "BatchUpdateTableRowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateTableRowsInput>
    public typealias MOutput = OperationOutput<BatchUpdateTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateTableRowsOutputError>
}

extension BatchUpdateTableRowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateTableRowsInput(clientRequestToken: \(String(describing: clientRequestToken)), rowsToUpdate: \(String(describing: rowsToUpdate)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension BatchUpdateTableRowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowsToUpdate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowsToUpdate = rowsToUpdate {
            var rowsToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowsToUpdate)
            for updaterowdatalist0 in rowsToUpdate {
                try rowsToUpdateContainer.encode(updaterowdatalist0)
            }
        }
    }
}

public struct BatchUpdateTableRowsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchUpdateTableRowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateTableRowsInput>
    public typealias MOutput = OperationOutput<BatchUpdateTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateTableRowsOutputError>
}

public struct BatchUpdateTableRowsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchUpdateTableRowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpdateTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpdateTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpdateTableRowsInput>
    public typealias MOutput = OperationOutput<BatchUpdateTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpdateTableRowsOutputError>
}

public struct BatchUpdateTableRowsInput: Equatable {
    /// <p>
    ///             The request token for performing the update action.
    ///             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
    ///             like a failed network connection, you can retry the call with the same request token. The service ensures
    ///             that if the first call using that request token is successfully performed, the second call will not perform
    ///             the action again.
    ///         </p>
    ///         <p>
    ///             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
    ///             spanning hours or days.
    ///         </p>
    public let clientRequestToken: String?
    /// <p>
    ///             The list of rows to update in the table. Each item in this list needs to contain the row id to update
    ///             along with the map of column id to cell values for each column in that row that needs to be updated.
    ///             You need to specify at least one row in this list, and for each row, you need to specify at least one
    ///             column to update.
    ///         </p>
    ///         <p>
    ///             Note that if one of the row or column ids in the request does not exist in the table, then the request fails
    ///             and no updates are made to the table.
    ///         </p>
    public let rowsToUpdate: [UpdateRowData]?
    /// <p>The ID of the table where the rows are being updated.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook where the rows are being updated.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        clientRequestToken: String? = nil,
        rowsToUpdate: [UpdateRowData]? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowsToUpdate = rowsToUpdate
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchUpdateTableRowsInputBody: Equatable {
    public let rowsToUpdate: [UpdateRowData]?
    public let clientRequestToken: String?
}

extension BatchUpdateTableRowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowsToUpdate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsToUpdateContainer = try containerValues.decodeIfPresent([UpdateRowData?].self, forKey: .rowsToUpdate)
        var rowsToUpdateDecoded0:[UpdateRowData]? = nil
        if let rowsToUpdateContainer = rowsToUpdateContainer {
            rowsToUpdateDecoded0 = [UpdateRowData]()
            for structure0 in rowsToUpdateContainer {
                if let structure0 = structure0 {
                    rowsToUpdateDecoded0?.append(structure0)
                }
            }
        }
        rowsToUpdate = rowsToUpdateDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchUpdateTableRowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpdateTableRowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpdateTableRowsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpdateTableRowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpdateTableRowsOutputResponse(failedBatchItems: \(String(describing: failedBatchItems)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension BatchUpdateTableRowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchUpdateTableRowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedBatchItems = output.failedBatchItems
            self.workbookCursor = output.workbookCursor
        } else {
            self.failedBatchItems = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchUpdateTableRowsOutputResponse: Equatable {
    /// <p>
    ///             The list of batch items in the request that could not be updated in the table. Each element in this list
    ///             contains one item from the request that could not be updated in the table along with the reason why
    ///             that item could not be updated.
    ///         </p>
    public let failedBatchItems: [FailedBatchItem]?
    /// <p>The updated workbook cursor after adding the new rows at the end of the table.</p>
    public let workbookCursor: Int

    public init (
        failedBatchItems: [FailedBatchItem]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.failedBatchItems = failedBatchItems
        self.workbookCursor = workbookCursor
    }
}

struct BatchUpdateTableRowsOutputResponseBody: Equatable {
    public let workbookCursor: Int
    public let failedBatchItems: [FailedBatchItem]?
}

extension BatchUpdateTableRowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedBatchItems
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

public struct BatchUpsertTableRowsInputBodyMiddleware: Middleware {
    public let id: String = "BatchUpsertTableRowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpsertTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpsertTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpsertTableRowsInput>
    public typealias MOutput = OperationOutput<BatchUpsertTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpsertTableRowsOutputError>
}

extension BatchUpsertTableRowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpsertTableRowsInput(clientRequestToken: \(String(describing: clientRequestToken)), rowsToUpsert: \(String(describing: rowsToUpsert)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension BatchUpsertTableRowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowsToUpsert
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowsToUpsert = rowsToUpsert {
            var rowsToUpsertContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowsToUpsert)
            for upsertrowdatalist0 in rowsToUpsert {
                try rowsToUpsertContainer.encode(upsertrowdatalist0)
            }
        }
    }
}

public struct BatchUpsertTableRowsInputHeadersMiddleware: Middleware {
    public let id: String = "BatchUpsertTableRowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpsertTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpsertTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpsertTableRowsInput>
    public typealias MOutput = OperationOutput<BatchUpsertTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpsertTableRowsOutputError>
}

public struct BatchUpsertTableRowsInputQueryItemMiddleware: Middleware {
    public let id: String = "BatchUpsertTableRowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<BatchUpsertTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<BatchUpsertTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<BatchUpsertTableRowsInput>
    public typealias MOutput = OperationOutput<BatchUpsertTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<BatchUpsertTableRowsOutputError>
}

public struct BatchUpsertTableRowsInput: Equatable {
    /// <p>
    ///             The request token for performing the update action.
    ///             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
    ///             like a failed network connection, you can retry the call with the same request token. The service ensures
    ///             that if the first call using that request token is successfully performed, the second call will not perform
    ///             the action again.
    ///         </p>
    ///         <p>
    ///             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
    ///             spanning hours or days.
    ///         </p>
    public let clientRequestToken: String?
    /// <p>
    ///             The list of rows to upsert in the table. Each item in this list needs to have a batch item id to uniquely
    ///             identify the element in the request, a filter expression to find the rows to update for that element
    ///             and the cell values to set for each column in the upserted rows. You need to specify
    ///             at least one item in this list.
    ///         </p>
    ///         <p>
    ///             Note that if one of the filter formulas in the request fails to evaluate because of an error or one of the
    ///             column ids in any of the rows does not exist in the table, then the request fails
    ///             and no updates are made to the table.
    ///         </p>
    public let rowsToUpsert: [UpsertRowData]?
    /// <p>The ID of the table where the rows are being upserted.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook where the rows are being upserted.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        clientRequestToken: String? = nil,
        rowsToUpsert: [UpsertRowData]? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowsToUpsert = rowsToUpsert
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchUpsertTableRowsInputBody: Equatable {
    public let rowsToUpsert: [UpsertRowData]?
    public let clientRequestToken: String?
}

extension BatchUpsertTableRowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowsToUpsert
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsToUpsertContainer = try containerValues.decodeIfPresent([UpsertRowData?].self, forKey: .rowsToUpsert)
        var rowsToUpsertDecoded0:[UpsertRowData]? = nil
        if let rowsToUpsertContainer = rowsToUpsertContainer {
            rowsToUpsertDecoded0 = [UpsertRowData]()
            for structure0 in rowsToUpsertContainer {
                if let structure0 = structure0 {
                    rowsToUpsertDecoded0?.append(structure0)
                }
            }
        }
        rowsToUpsert = rowsToUpsertDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchUpsertTableRowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchUpsertTableRowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum BatchUpsertTableRowsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchUpsertTableRowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BatchUpsertTableRowsOutputResponse(failedBatchItems: \(String(describing: failedBatchItems)), rows: \(String(describing: rows)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension BatchUpsertTableRowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BatchUpsertTableRowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedBatchItems = output.failedBatchItems
            self.rows = output.rows
            self.workbookCursor = output.workbookCursor
        } else {
            self.failedBatchItems = nil
            self.rows = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchUpsertTableRowsOutputResponse: Equatable {
    /// <p>
    ///             The list of batch items in the request that could not be updated or appended in the table. Each element in
    ///             this list contains one item from the request that could not be updated in the table along with the reason
    ///             why that item could not be updated or appended.
    ///         </p>
    public let failedBatchItems: [FailedBatchItem]?
    /// <p>
    ///             A map with the batch item id as the key and the result of the upsert operation as the value. The
    ///             result of the upsert operation specifies whether existing rows were updated or a new row was appended, along
    ///             with the list of row ids that were affected.
    ///         </p>
    public let rows: [String:UpsertRowsResult]?
    /// <p>The updated workbook cursor after updating or appending rows in the table.</p>
    public let workbookCursor: Int

    public init (
        failedBatchItems: [FailedBatchItem]? = nil,
        rows: [String:UpsertRowsResult]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.failedBatchItems = failedBatchItems
        self.rows = rows
        self.workbookCursor = workbookCursor
    }
}

struct BatchUpsertTableRowsOutputResponseBody: Equatable {
    public let rows: [String:UpsertRowsResult]?
    public let workbookCursor: Int
    public let failedBatchItems: [FailedBatchItem]?
}

extension BatchUpsertTableRowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedBatchItems
        case rows
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([String: UpsertRowsResult?].self, forKey: .rows)
        var rowsDecoded0: [String:UpsertRowsResult]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [String:UpsertRowsResult]()
            for (key0, upsertrowsresult0) in rowsContainer {
                if let upsertrowsresult0 = upsertrowsresult0 {
                    rowsDecoded0?[key0] = upsertrowsresult0
                }
            }
        }
        rows = rowsDecoded0
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

extension Cell: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format
        case formattedValue
        case formula
        case rawValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formattedValue = formattedValue {
            try encodeContainer.encode(formattedValue, forKey: .formattedValue)
        }
        if let formula = formula {
            try encodeContainer.encode(formula, forKey: .formula)
        }
        if let rawValue = rawValue {
            try encodeContainer.encode(rawValue, forKey: .rawValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formulaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formula)
        formula = formulaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
        let rawValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawValue)
        rawValue = rawValueDecoded
        let formattedValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formattedValue)
        formattedValue = formattedValueDecoded
    }
}

extension Cell: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>An object that represents a single cell in a table.</p>
public struct Cell: Equatable {
    /// <p>The format of the cell. If this field is empty, then the format is either not specified in the
    ///         workbook or the format is set to AUTO.</p>
    public let format: Format?
    /// <p>
    ///             The formatted value of the cell. This is the value that you see displayed in the cell in the UI.
    ///         </p>
    ///         <p>
    ///             Note that the formatted value of a cell is always represented as a string irrespective of the data that is
    ///             stored in the cell. For example, if a cell contains a date, the formatted value of the cell is the string
    ///             representation of the formatted date being shown in the cell in the UI. See details in the rawValue field
    ///             below for how cells of different formats will have different raw and formatted values.
    ///         </p>
    public let formattedValue: String?
    /// <p>
    ///             The formula contained in the cell. This field is empty if a cell does not have a formula.
    ///         </p>
    public let formula: String?
    /// <p>
    ///             The raw value of the data contained in the cell. The raw value depends on the format of the data in the
    ///             cell. However the attribute in the API return value is always a string containing the raw value.
    ///         </p>
    ///         <p>
    ///             Cells with format DATE, DATE_TIME or TIME have the raw value as a floating point
    ///             number where the whole number represents the number of days since 1/1/1900 and the fractional part
    ///             represents the fraction of the day since midnight. For example, a cell with date 11/3/2020 has the raw value
    ///             "44138". A cell with the time 9:00 AM has the raw value "0.375" and a cell with date/time value of
    ///             11/3/2020 9:00 AM has the raw value "44138.375". Notice that even though the raw value is a number in all
    ///             three cases, it is still represented as a string.
    ///         </p>
    ///         <p>
    ///             Cells with format NUMBER, CURRENCY, PERCENTAGE and ACCOUNTING have the raw value of the data as the number
    ///             representing the data being displayed. For example, the number 1.325 with two decimal places in the format
    ///             will have it's raw value as "1.325" and formatted value as "1.33". A currency value for
    ///             $10 will have the raw value as "10" and formatted value as "$10.00". A value representing 20% with two
    ///             decimal places in the format will have its raw value as "0.2" and the formatted value as "20.00%". An
    ///             accounting value of -$25 will have "-25" as the raw value and "$  (25.00)" as the formatted value.
    ///         </p>
    ///         <p>
    ///             Cells with format TEXT will have the raw text as the raw value. For example, a cell with text "John Smith"
    ///             will have "John Smith" as both the raw value and the formatted value.
    ///         </p>
    ///         <p>
    ///             Cells with format CONTACT will have the name of the contact as a formatted value and the email address of
    ///             the contact as the raw value. For example, a contact for John Smith will have "John Smith" as the
    ///             formatted value and "john.smith@example.com" as the raw value.
    ///         </p>
    ///         <p>
    ///             Cells with format ROWLINK (aka picklist) will have the first column of the linked row as the formatted value
    ///             and the row id of the linked row as the raw value. For example, a cell containing a picklist to a table
    ///             that displays task status might have "Completed" as the formatted value and
    ///             "row:dfcefaee-5b37-4355-8f28-40c3e4ff5dd4/ca432b2f-b8eb-431d-9fb5-cbe0342f9f03" as the raw value.
    ///         </p>
    ///         <p>
    ///             Cells with format AUTO or cells without any format that are auto-detected as one of the formats above will
    ///             contain the raw and formatted values as mentioned above, based on the auto-detected formats. If there is no
    ///             auto-detected format, the raw and formatted values will be the same as the data in the cell.
    ///         </p>
    public let rawValue: String?

    public init (
        format: Format? = nil,
        formattedValue: String? = nil,
        formula: String? = nil,
        rawValue: String? = nil
    )
    {
        self.format = format
        self.formattedValue = formattedValue
        self.formula = formula
        self.rawValue = rawValue
    }
}

extension CellInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case fact
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fact = fact {
            try encodeContainer.encode(fact, forKey: .fact)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let factDecoded = try containerValues.decodeIfPresent(String.self, forKey: .fact)
        fact = factDecoded
    }
}

extension CellInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CellInput(fact: \(String(describing: fact)))"}
}

/// <p>
///             CellInput object contains the data needed to create or update cells in a table.
///         </p>
public struct CellInput: Equatable {
    /// <p>
    ///             Fact represents the data that is entered into a cell. This data can be free text or a formula. Formulas need
    ///             to start with the equals (=) sign.
    ///         </p>
    public let fact: String?

    public init (
        fact: String? = nil
    )
    {
        self.fact = fact
    }
}

extension ColumnMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
    }
}

extension ColumnMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ColumnMetadata(format: \(String(describing: format)), name: \(String(describing: name)))"}
}

/// <p>Metadata for column in the table.</p>
public struct ColumnMetadata: Equatable {
    /// <p>The format of the column.</p>
    public let format: Format?
    /// <p>The name of the column.</p>
    public let name: String?

    public init (
        format: Format? = nil,
        name: String? = nil
    )
    {
        self.format = format
        self.name = name
    }
}

extension CreateRowData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchItemId
        case cellsToCreate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchItemId = batchItemId {
            try encodeContainer.encode(batchItemId, forKey: .batchItemId)
        }
        if let cellsToCreate = cellsToCreate {
            var cellsToCreateContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .cellsToCreate)
            for (dictKey0, rowdatainput0) in cellsToCreate {
                try cellsToCreateContainer.encode(rowdatainput0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchItemId)
        batchItemId = batchItemIdDecoded
        let cellsToCreateContainer = try containerValues.decodeIfPresent([String: CellInput?].self, forKey: .cellsToCreate)
        var cellsToCreateDecoded0: [String:CellInput]? = nil
        if let cellsToCreateContainer = cellsToCreateContainer {
            cellsToCreateDecoded0 = [String:CellInput]()
            for (key0, cellinput0) in cellsToCreateContainer {
                if let cellinput0 = cellinput0 {
                    cellsToCreateDecoded0?[key0] = cellinput0
                }
            }
        }
        cellsToCreate = cellsToCreateDecoded0
    }
}

extension CreateRowData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateRowData(batchItemId: \(String(describing: batchItemId)), cellsToCreate: \(String(describing: cellsToCreate)))"}
}

/// <p>
///             Data needed to create a single row in a table as part of the BatchCreateTableRows request.
///         </p>
public struct CreateRowData: Equatable {
    /// <p>
    ///             An external identifier that represents the single row that is being created as part of the
    ///             BatchCreateTableRows request. This can be any string that you can use to identify the row in the request.
    ///             The BatchCreateTableRows API puts the batch item id in the results to allow you to link data in the
    ///             request to data in the results.
    ///         </p>
    public let batchItemId: String?
    /// <p>
    ///             A map representing the cells to create in the new row. The key is the column id of the
    ///             cell and the value is the CellInput object that represents the data to set in that cell.
    ///         </p>
    public let cellsToCreate: [String:CellInput]?

    public init (
        batchItemId: String? = nil,
        cellsToCreate: [String:CellInput]? = nil
    )
    {
        self.batchItemId = batchItemId
        self.cellsToCreate = cellsToCreate
    }
}

extension DataItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case formattedValue
        case overrideFormat
        case rawValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formattedValue = formattedValue {
            try encodeContainer.encode(formattedValue, forKey: .formattedValue)
        }
        if let overrideFormat = overrideFormat {
            try encodeContainer.encode(overrideFormat.rawValue, forKey: .overrideFormat)
        }
        if let rawValue = rawValue {
            try encodeContainer.encode(rawValue, forKey: .rawValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideFormatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .overrideFormat)
        overrideFormat = overrideFormatDecoded
        let rawValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawValue)
        rawValue = rawValueDecoded
        let formattedValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formattedValue)
        formattedValue = formattedValueDecoded
    }
}

extension DataItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>The data in a particular data cell defined on the screen.</p>
public struct DataItem: Equatable {
    /// <p>The formatted value of the data. e.g. John Smith.</p>
    public let formattedValue: String?
    /// <p>
    ///             The overrideFormat is optional and is specified only if a particular row of data has a different format for
    ///             the data than the default format defined on the screen or the table.
    ///         </p>
    public let overrideFormat: Format?
    /// <p>The raw value of the data. e.g. jsmith@example.com</p>
    public let rawValue: String?

    public init (
        formattedValue: String? = nil,
        overrideFormat: Format? = nil,
        rawValue: String? = nil
    )
    {
        self.formattedValue = formattedValue
        self.overrideFormat = overrideFormat
        self.rawValue = rawValue
    }
}

extension DelimitedTextImportOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataCharacterEncoding
        case delimiter
        case hasHeaderRow
        case ignoreEmptyRows
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataCharacterEncoding = dataCharacterEncoding {
            try encodeContainer.encode(dataCharacterEncoding.rawValue, forKey: .dataCharacterEncoding)
        }
        if let delimiter = delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if hasHeaderRow != false {
            try encodeContainer.encode(hasHeaderRow, forKey: .hasHeaderRow)
        }
        if ignoreEmptyRows != false {
            try encodeContainer.encode(ignoreEmptyRows, forKey: .ignoreEmptyRows)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let hasHeaderRowDecoded = try containerValues.decode(Bool.self, forKey: .hasHeaderRow)
        hasHeaderRow = hasHeaderRowDecoded
        let ignoreEmptyRowsDecoded = try containerValues.decode(Bool.self, forKey: .ignoreEmptyRows)
        ignoreEmptyRows = ignoreEmptyRowsDecoded
        let dataCharacterEncodingDecoded = try containerValues.decodeIfPresent(ImportDataCharacterEncoding.self, forKey: .dataCharacterEncoding)
        dataCharacterEncoding = dataCharacterEncodingDecoded
    }
}

extension DelimitedTextImportOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DelimitedTextImportOptions(dataCharacterEncoding: \(String(describing: dataCharacterEncoding)), delimiter: \(String(describing: delimiter)), hasHeaderRow: \(String(describing: hasHeaderRow)), ignoreEmptyRows: \(String(describing: ignoreEmptyRows)))"}
}

/// <p>
///             An object that contains the options relating to parsing delimited text as part of an import request.
///         </p>
public struct DelimitedTextImportOptions: Equatable {
    /// <p>The encoding of the data in the input file.</p>
    public let dataCharacterEncoding: ImportDataCharacterEncoding?
    /// <p>The delimiter to use for separating columns in a single row of the input.</p>
    public let delimiter: String?
    /// <p>Indicates whether the input file has a header row at the top containing the column names.</p>
    public let hasHeaderRow: Bool
    /// <p>A parameter to indicate whether empty rows should be ignored or be included in the import.</p>
    public let ignoreEmptyRows: Bool

    public init (
        dataCharacterEncoding: ImportDataCharacterEncoding? = nil,
        delimiter: String? = nil,
        hasHeaderRow: Bool = false,
        ignoreEmptyRows: Bool = false
    )
    {
        self.dataCharacterEncoding = dataCharacterEncoding
        self.delimiter = delimiter
        self.hasHeaderRow = hasHeaderRow
        self.ignoreEmptyRows = ignoreEmptyRows
    }
}

extension DescribeTableDataImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableDataImportJobInput(jobId: \(String(describing: jobId)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension DescribeTableDataImportJobInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeTableDataImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeTableDataImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableDataImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableDataImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableDataImportJobInput>
    public typealias MOutput = OperationOutput<DescribeTableDataImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableDataImportJobOutputError>
}

public struct DescribeTableDataImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeTableDataImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeTableDataImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeTableDataImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeTableDataImportJobInput>
    public typealias MOutput = OperationOutput<DescribeTableDataImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeTableDataImportJobOutputError>
}

public struct DescribeTableDataImportJobInput: Equatable {
    /// <p>The ID of the job that was returned by the StartTableDataImportJob request.</p>
    ///         <p>
    ///             If a job with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let jobId: String?
    /// <p>The ID of the table into which data was imported.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook into which data was imported.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        jobId: String? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.jobId = jobId
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct DescribeTableDataImportJobInputBody: Equatable {
}

extension DescribeTableDataImportJobInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeTableDataImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeTableDataImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeTableDataImportJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeTableDataImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeTableDataImportJobOutputResponse(jobMetadata: \(String(describing: jobMetadata)), jobStatus: \(String(describing: jobStatus)), message: \(String(describing: message)))"}
}

extension DescribeTableDataImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeTableDataImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobMetadata = output.jobMetadata
            self.jobStatus = output.jobStatus
            self.message = output.message
        } else {
            self.jobMetadata = nil
            self.jobStatus = nil
            self.message = nil
        }
    }
}

public struct DescribeTableDataImportJobOutputResponse: Equatable {
    /// <p>
    ///             The metadata about the job that was submitted for import.
    ///         </p>
    public let jobMetadata: TableDataImportJobMetadata?
    /// <p>
    ///             The current status of the import job.
    ///         </p>
    public let jobStatus: TableDataImportJobStatus?
    /// <p>
    ///             A message providing more details about the current status of the import job.
    ///         </p>
    public let message: String?

    public init (
        jobMetadata: TableDataImportJobMetadata? = nil,
        jobStatus: TableDataImportJobStatus? = nil,
        message: String? = nil
    )
    {
        self.jobMetadata = jobMetadata
        self.jobStatus = jobStatus
        self.message = message
    }
}

struct DescribeTableDataImportJobOutputResponseBody: Equatable {
    public let jobStatus: TableDataImportJobStatus?
    public let message: String?
    public let jobMetadata: TableDataImportJobMetadata?
}

extension DescribeTableDataImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobMetadata
        case jobStatus
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobStatusDecoded = try containerValues.decodeIfPresent(TableDataImportJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let jobMetadataDecoded = try containerValues.decodeIfPresent(TableDataImportJobMetadata.self, forKey: .jobMetadata)
        jobMetadata = jobMetadataDecoded
    }
}

extension DestinationOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnMap
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnMap = columnMap {
            var columnMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .columnMap)
            for (dictKey0, importcolumnmap0) in columnMap {
                try columnMapContainer.encode(importcolumnmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnMapContainer = try containerValues.decodeIfPresent([String: SourceDataColumnProperties?].self, forKey: .columnMap)
        var columnMapDecoded0: [String:SourceDataColumnProperties]? = nil
        if let columnMapContainer = columnMapContainer {
            columnMapDecoded0 = [String:SourceDataColumnProperties]()
            for (key0, sourcedatacolumnproperties0) in columnMapContainer {
                if let sourcedatacolumnproperties0 = sourcedatacolumnproperties0 {
                    columnMapDecoded0?[key0] = sourcedatacolumnproperties0
                }
            }
        }
        columnMap = columnMapDecoded0
    }
}

extension DestinationOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationOptions(columnMap: \(String(describing: columnMap)))"}
}

/// <p>An object that contains the options relating to the destination of the import request.</p>
public struct DestinationOptions: Equatable {
    /// <p>A map of the column id to the import properties for each column.</p>
    public let columnMap: [String:SourceDataColumnProperties]?

    public init (
        columnMap: [String:SourceDataColumnProperties]? = nil
    )
    {
        self.columnMap = columnMap
    }
}

extension FailedBatchItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorMessage
        case id
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension FailedBatchItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedBatchItem(errorMessage: \(String(describing: errorMessage)), id: \(String(describing: id)))"}
}

/// <p>
///             A single item in a batch that failed to perform the intended action because of an error preventing it from
///             succeeding.
///         </p>
public struct FailedBatchItem: Equatable {
    /// <p>
    ///             The error message that indicates why the batch item failed.
    ///         </p>
    public let errorMessage: String?
    /// <p>
    ///             The id of the batch item that failed. This is the batch item id for the BatchCreateTableRows and
    ///             BatchUpsertTableRows operations and the row id for the BatchUpdateTableRows and BatchDeleteTableRows
    ///             operations.
    ///         </p>
    public let id: String?

    public init (
        errorMessage: String? = nil,
        id: String? = nil
    )
    {
        self.errorMessage = errorMessage
        self.id = id
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case contextRowId
        case formula
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextRowId = contextRowId {
            try encodeContainer.encode(contextRowId, forKey: .contextRowId)
        }
        if let formula = formula {
            try encodeContainer.encode(formula, forKey: .formula)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formulaDecoded = try containerValues.decodeIfPresent(String.self, forKey: .formula)
        formula = formulaDecoded
        let contextRowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .contextRowId)
        contextRowId = contextRowIdDecoded
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(contextRowId: \(String(describing: contextRowId)), formula: \(String(describing: formula)))"}
}

/// <p>
///             An object that represents a filter formula along with the id of the context row under which the filter
///             function needs to evaluate.
///         </p>
public struct Filter: Equatable {
    /// <p>
    ///             The optional contextRowId attribute can be used to specify the row id of the context row if the filter
    ///             formula contains unqualified references to table columns and needs a context row to evaluate them
    ///             successfully.
    ///         </p>
    public let contextRowId: String?
    /// <p>
    ///             A formula representing a filter function that returns zero or more matching rows from a table. Valid
    ///             formulas in this field return a list of rows from a table. The most common ways of writing a formula to
    ///             return a list of rows are to use the FindRow() or Filter() functions. Any other formula that returns zero or
    ///             more rows is also acceptable. For example, you can use a formula that points to a cell that contains a
    ///             filter function.
    ///         </p>
    public let formula: String?

    public init (
        contextRowId: String? = nil,
        formula: String? = nil
    )
    {
        self.contextRowId = contextRowId
        self.formula = formula
    }
}

public enum Format {
    case accounting
    case auto
    case contact
    case currency
    case date
    case datetime
    case number
    case percentage
    case rowlink
    case text
    case time
    case sdkUnknown(String)
}

extension Format : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Format] {
        return [
            .accounting,
            .auto,
            .contact,
            .currency,
            .date,
            .datetime,
            .number,
            .percentage,
            .rowlink,
            .text,
            .time,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accounting: return "ACCOUNTING"
        case .auto: return "AUTO"
        case .contact: return "CONTACT"
        case .currency: return "CURRENCY"
        case .date: return "DATE"
        case .datetime: return "DATE_TIME"
        case .number: return "NUMBER"
        case .percentage: return "PERCENTAGE"
        case .rowlink: return "ROWLINK"
        case .text: return "TEXT"
        case .time: return "TIME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
    }
}

public struct GetScreenDataInputBodyMiddleware: Middleware {
    public let id: String = "GetScreenDataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetScreenDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetScreenDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetScreenDataInput>
    public typealias MOutput = OperationOutput<GetScreenDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetScreenDataOutputError>
}

extension GetScreenDataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetScreenDataInput(appId: \(String(describing: appId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), screenId: \(String(describing: screenId)), variables: \(String(describing: variables)), workbookId: \(String(describing: workbookId)))"}
}

extension GetScreenDataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case appId
        case maxResults
        case nextToken
        case screenId
        case variables
        case workbookId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let screenId = screenId {
            try encodeContainer.encode(screenId, forKey: .screenId)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, variablevaluemap0) in variables {
                try variablesContainer.encode(variablevaluemap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let workbookId = workbookId {
            try encodeContainer.encode(workbookId, forKey: .workbookId)
        }
    }
}

public struct GetScreenDataInputHeadersMiddleware: Middleware {
    public let id: String = "GetScreenDataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetScreenDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetScreenDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetScreenDataInput>
    public typealias MOutput = OperationOutput<GetScreenDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetScreenDataOutputError>
}

public struct GetScreenDataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetScreenDataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetScreenDataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetScreenDataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetScreenDataInput>
    public typealias MOutput = OperationOutput<GetScreenDataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetScreenDataOutputError>
}

public struct GetScreenDataInput: Equatable {
    /// <p>The ID of the app that contains the screem.</p>
    public let appId: String?
    /// <p>
    ///             The number of results to be returned on a single page.
    ///             Specify a number between 1 and 100. The maximum value is 100.
    ///         </p>
    ///         <p>
    ///             This parameter is optional. If you don't specify this parameter, the default page size is 100.
    ///         </p>
    public let maxResults: Int?
    /// <p>
    ///             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
    ///         </p>
    ///         <p>
    ///             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
    ///             will throw ValidationException.
    ///         </p>
    public let nextToken: String?
    /// <p>The ID of the screen.</p>
    public let screenId: String?
    /// <p>
    ///             Variables are optional and are needed only if the screen requires them to render correctly. Variables are
    ///             specified as a map where the key is the name of the variable as defined on the screen. The value is an
    ///             object which currently has only one property, rawValue, which holds the value of the variable to be passed
    ///             to the screen.
    ///         </p>
    public let variables: [String:VariableValue]?
    /// <p>The ID of the workbook that contains the screen.</p>
    public let workbookId: String?

    public init (
        appId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        screenId: String? = nil,
        variables: [String:VariableValue]? = nil,
        workbookId: String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.screenId = screenId
        self.variables = variables
        self.workbookId = workbookId
    }
}

struct GetScreenDataInputBody: Equatable {
    public let workbookId: String?
    public let appId: String?
    public let screenId: String?
    public let variables: [String:VariableValue]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetScreenDataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case appId
        case maxResults
        case nextToken
        case screenId
        case variables
        case workbookId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workbookId)
        workbookId = workbookIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .appId)
        appId = appIdDecoded
        let screenIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .screenId)
        screenId = screenIdDecoded
        let variablesContainer = try containerValues.decodeIfPresent([String: VariableValue?].self, forKey: .variables)
        var variablesDecoded0: [String:VariableValue]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:VariableValue]()
            for (key0, variablevalue0) in variablesContainer {
                if let variablevalue0 = variablevalue0 {
                    variablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetScreenDataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetScreenDataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetScreenDataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetScreenDataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetScreenDataOutputResponse(nextToken: \(String(describing: nextToken)), results: \(String(describing: results)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension GetScreenDataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetScreenDataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.results = output.results
            self.workbookCursor = output.workbookCursor
        } else {
            self.nextToken = nil
            self.results = nil
            self.workbookCursor = 0
        }
    }
}

public struct GetScreenDataOutputResponse: Equatable {
    /// <p>
    ///             Provides the pagination token to load the next page if there are more results matching the request. If a
    ///             pagination token is not present in the response, it means that all data matching the query has been loaded.
    ///         </p>
    public let nextToken: String?
    /// <p>A map of all the rows on the screen keyed by block name.</p>
    public let results: [String:ResultSet]?
    /// <p>
    ///             Indicates the cursor of the workbook at which the data returned by this workbook is read. Workbook cursor
    ///             keeps increasing with every update and the increments are not sequential.
    ///         </p>
    public let workbookCursor: Int

    public init (
        nextToken: String? = nil,
        results: [String:ResultSet]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.nextToken = nextToken
        self.results = results
        self.workbookCursor = workbookCursor
    }
}

struct GetScreenDataOutputResponseBody: Equatable {
    public let results: [String:ResultSet]?
    public let workbookCursor: Int
    public let nextToken: String?
}

extension GetScreenDataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case results
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([String: ResultSet?].self, forKey: .results)
        var resultsDecoded0: [String:ResultSet]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [String:ResultSet]()
            for (key0, resultset0) in resultsContainer {
                if let resultset0 = resultset0 {
                    resultsDecoded0?[key0] = resultset0
                }
            }
        }
        results = resultsDecoded0
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum ImportDataCharacterEncoding {
    case iso88591
    case usAscii
    case utf16
    case utf16be
    case utf16le
    case utf8
    case sdkUnknown(String)
}

extension ImportDataCharacterEncoding : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportDataCharacterEncoding] {
        return [
            .iso88591,
            .usAscii,
            .utf16,
            .utf16be,
            .utf16le,
            .utf8,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .iso88591: return "ISO-8859-1"
        case .usAscii: return "US-ASCII"
        case .utf16: return "UTF-16"
        case .utf16be: return "UTF-16BE"
        case .utf16le: return "UTF-16LE"
        case .utf8: return "UTF-8"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportDataCharacterEncoding(rawValue: rawValue) ?? ImportDataCharacterEncoding.sdkUnknown(rawValue)
    }
}

extension ImportDataSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceConfig
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfig = dataSourceConfig {
            try encodeContainer.encode(dataSourceConfig, forKey: .dataSourceConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceConfigDecoded = try containerValues.decodeIfPresent(ImportDataSourceConfig.self, forKey: .dataSourceConfig)
        dataSourceConfig = dataSourceConfigDecoded
    }
}

extension ImportDataSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportDataSource(dataSourceConfig: \(String(describing: dataSourceConfig)))"}
}

/// <p>An object that has details about the source of the data that was submitted for import.</p>
public struct ImportDataSource: Equatable {
    /// <p>The configuration parameters for the data source of the import</p>
    public let dataSourceConfig: ImportDataSourceConfig?

    public init (
        dataSourceConfig: ImportDataSourceConfig? = nil
    )
    {
        self.dataSourceConfig = dataSourceConfig
    }
}

extension ImportDataSourceConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSourceUrl
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceUrl = dataSourceUrl {
            try encodeContainer.encode(dataSourceUrl, forKey: .dataSourceUrl)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dataSourceUrl)
        dataSourceUrl = dataSourceUrlDecoded
    }
}

extension ImportDataSourceConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportDataSourceConfig(dataSourceUrl: \(String(describing: dataSourceUrl)))"}
}

/// <p>
///             An object that contains the configuration parameters for the data source of an import request.
///         </p>
public struct ImportDataSourceConfig: Equatable {
    /// <p>
    ///             The URL from which source data will be downloaded for the import request.
    ///         </p>
    public let dataSourceUrl: String?

    public init (
        dataSourceUrl: String? = nil
    )
    {
        self.dataSourceUrl = dataSourceUrl
    }
}

extension ImportJobSubmitter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case email
        case userArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailDecoded = try containerValues.decodeIfPresent(String.self, forKey: .email)
        email = emailDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension ImportJobSubmitter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportJobSubmitter(email: \(String(describing: email)), userArn: \(String(describing: userArn)))"}
}

/// <p>An object that contains the attributes of the submitter of the import job.</p>
public struct ImportJobSubmitter: Equatable {
    /// <p>The email id of the submitter of the import job, if available.</p>
    public let email: String?
    /// <p>The AWS user ARN of the submitter of the import job, if available.</p>
    public let userArn: String?

    public init (
        email: String? = nil,
        userArn: String? = nil
    )
    {
        self.email = email
        self.userArn = userArn
    }
}

extension ImportOptions: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case delimitedTextOptions
        case destinationOptions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimitedTextOptions = delimitedTextOptions {
            try encodeContainer.encode(delimitedTextOptions, forKey: .delimitedTextOptions)
        }
        if let destinationOptions = destinationOptions {
            try encodeContainer.encode(destinationOptions, forKey: .destinationOptions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationOptionsDecoded = try containerValues.decodeIfPresent(DestinationOptions.self, forKey: .destinationOptions)
        destinationOptions = destinationOptionsDecoded
        let delimitedTextOptionsDecoded = try containerValues.decodeIfPresent(DelimitedTextImportOptions.self, forKey: .delimitedTextOptions)
        delimitedTextOptions = delimitedTextOptionsDecoded
    }
}

extension ImportOptions: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImportOptions(delimitedTextOptions: \(String(describing: delimitedTextOptions)), destinationOptions: \(String(describing: destinationOptions)))"}
}

/// <p>An object that contains the options specified by the sumitter of the import request.</p>
public struct ImportOptions: Equatable {
    /// <p>Options relating to parsing delimited text. Required if dataFormat is DELIMITED_TEXT.</p>
    public let delimitedTextOptions: DelimitedTextImportOptions?
    /// <p>Options relating to the destination of the import request.</p>
    public let destinationOptions: DestinationOptions?

    public init (
        delimitedTextOptions: DelimitedTextImportOptions? = nil,
        destinationOptions: DestinationOptions? = nil
    )
    {
        self.delimitedTextOptions = delimitedTextOptions
        self.destinationOptions = destinationOptions
    }
}

public enum ImportSourceDataFormat {
    case delimitedtext
    case sdkUnknown(String)
}

extension ImportSourceDataFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ImportSourceDataFormat] {
        return [
            .delimitedtext,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .delimitedtext: return "DELIMITED_TEXT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ImportSourceDataFormat(rawValue: rawValue) ?? ImportSourceDataFormat.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There were unexpected errors from the server.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct InvokeScreenAutomationInputBodyMiddleware: Middleware {
    public let id: String = "InvokeScreenAutomationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeScreenAutomationInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeScreenAutomationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeScreenAutomationInput>
    public typealias MOutput = OperationOutput<InvokeScreenAutomationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeScreenAutomationOutputError>
}

extension InvokeScreenAutomationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvokeScreenAutomationInput(appId: \(String(describing: appId)), clientRequestToken: \(String(describing: clientRequestToken)), rowId: \(String(describing: rowId)), screenAutomationId: \(String(describing: screenAutomationId)), screenId: \(String(describing: screenId)), variables: \(String(describing: variables)), workbookId: \(String(describing: workbookId)))"}
}

extension InvokeScreenAutomationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowId
        case variables
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowId = rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, variablevaluemap0) in variables {
                try variablesContainer.encode(variablevaluemap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct InvokeScreenAutomationInputHeadersMiddleware: Middleware {
    public let id: String = "InvokeScreenAutomationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeScreenAutomationInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeScreenAutomationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeScreenAutomationInput>
    public typealias MOutput = OperationOutput<InvokeScreenAutomationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeScreenAutomationOutputError>
}

public struct InvokeScreenAutomationInputQueryItemMiddleware: Middleware {
    public let id: String = "InvokeScreenAutomationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeScreenAutomationInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeScreenAutomationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeScreenAutomationInput>
    public typealias MOutput = OperationOutput<InvokeScreenAutomationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeScreenAutomationOutputError>
}

public struct InvokeScreenAutomationInput: Equatable {
    /// <p>The ID of the app that contains the screen automation.</p>
    public let appId: String?
    /// <p>
    ///             The request token for performing the automation action.
    ///             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
    ///             like a failed network connection, you can retry the call with the same request token. The service ensures
    ///             that if the first call using that request token is successfully performed, the second call will return the
    ///             response of the previous call rather than performing the action again.
    ///         </p>
    ///         <p>
    ///             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
    ///             spanning hours or days.
    ///         </p>
    public let clientRequestToken: String?
    /// <p>
    ///             The row ID for the automation if the automation is defined inside a block with source or list.
    ///         </p>
    public let rowId: String?
    /// <p>The ID of the automation action to be performed.</p>
    public let screenAutomationId: String?
    /// <p>The ID of the screen that contains the screen automation.</p>
    public let screenId: String?
    /// <p>
    ///             Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an
    ///             object which currently has only one property, rawValue, which holds the value of the variable to be passed
    ///             to the screen. Any variables defined in a screen are required to be passed in the call.
    ///         </p>
    public let variables: [String:VariableValue]?
    /// <p>The ID of the workbook that contains the screen automation.</p>
    public let workbookId: String?

    public init (
        appId: String? = nil,
        clientRequestToken: String? = nil,
        rowId: String? = nil,
        screenAutomationId: String? = nil,
        screenId: String? = nil,
        variables: [String:VariableValue]? = nil,
        workbookId: String? = nil
    )
    {
        self.appId = appId
        self.clientRequestToken = clientRequestToken
        self.rowId = rowId
        self.screenAutomationId = screenAutomationId
        self.screenId = screenId
        self.variables = variables
        self.workbookId = workbookId
    }
}

struct InvokeScreenAutomationInputBody: Equatable {
    public let variables: [String:VariableValue]?
    public let rowId: String?
    public let clientRequestToken: String?
}

extension InvokeScreenAutomationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case rowId
        case variables
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([String: VariableValue?].self, forKey: .variables)
        var variablesDecoded0: [String:VariableValue]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:VariableValue]()
            for (key0, variablevalue0) in variablesContainer {
                if let variablevalue0 = variablevalue0 {
                    variablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let rowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension InvokeScreenAutomationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeScreenAutomationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionException" : self = .automationExecutionException(try AutomationExecutionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AutomationExecutionTimeoutException" : self = .automationExecutionTimeoutException(try AutomationExecutionTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeScreenAutomationOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case automationExecutionException(AutomationExecutionException)
    case automationExecutionTimeoutException(AutomationExecutionTimeoutException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeScreenAutomationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvokeScreenAutomationOutputResponse(workbookCursor: \(String(describing: workbookCursor)))"}
}

extension InvokeScreenAutomationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvokeScreenAutomationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.workbookCursor = output.workbookCursor
        } else {
            self.workbookCursor = 0
        }
    }
}

public struct InvokeScreenAutomationOutputResponse: Equatable {
    /// <p>The updated workbook cursor after performing the automation action.</p>
    public let workbookCursor: Int

    public init (
        workbookCursor: Int = 0
    )
    {
        self.workbookCursor = workbookCursor
    }
}

struct InvokeScreenAutomationOutputResponseBody: Equatable {
    public let workbookCursor: Int
}

extension InvokeScreenAutomationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
    }
}

extension ListTableColumnsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTableColumnsInput(nextToken: \(String(describing: nextToken)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension ListTableColumnsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTableColumnsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTableColumnsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableColumnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableColumnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableColumnsInput>
    public typealias MOutput = OperationOutput<ListTableColumnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableColumnsOutputError>
}

public struct ListTableColumnsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTableColumnsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableColumnsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableColumnsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableColumnsInput>
    public typealias MOutput = OperationOutput<ListTableColumnsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableColumnsOutputError>
}

public struct ListTableColumnsInput: Equatable {
    /// <p>
    ///             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
    ///         </p>
    ///         <p>
    ///             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
    ///             will throw ValidationException.
    ///         </p>
    public let nextToken: String?
    /// <p>The ID of the table whose columns are being retrieved.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook that contains the table whose columns are being retrieved.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        nextToken: String? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.nextToken = nextToken
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct ListTableColumnsInputBody: Equatable {
}

extension ListTableColumnsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTableColumnsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTableColumnsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTableColumnsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTableColumnsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTableColumnsOutputResponse(nextToken: \(String(describing: nextToken)), tableColumns: \(String(describing: tableColumns)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension ListTableColumnsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTableColumnsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tableColumns = output.tableColumns
            self.workbookCursor = output.workbookCursor
        } else {
            self.nextToken = nil
            self.tableColumns = nil
            self.workbookCursor = 0
        }
    }
}

public struct ListTableColumnsOutputResponse: Equatable {
    /// <p>
    ///             Provides the pagination token to load the next page if there are more results matching the request. If a
    ///             pagination token is not present in the response, it means that all data matching the request has been
    ///             loaded.
    ///         </p>
    public let nextToken: String?
    /// <p>
    ///             The list of columns in the table.
    ///         </p>
    public let tableColumns: [TableColumn]?
    /// <p>
    ///             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
    ///             keeps increasing with every update and the increments are not sequential.
    ///         </p>
    public let workbookCursor: Int

    public init (
        nextToken: String? = nil,
        tableColumns: [TableColumn]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.nextToken = nextToken
        self.tableColumns = tableColumns
        self.workbookCursor = workbookCursor
    }
}

struct ListTableColumnsOutputResponseBody: Equatable {
    public let tableColumns: [TableColumn]?
    public let nextToken: String?
    public let workbookCursor: Int
}

extension ListTableColumnsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tableColumns
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableColumnsContainer = try containerValues.decodeIfPresent([TableColumn?].self, forKey: .tableColumns)
        var tableColumnsDecoded0:[TableColumn]? = nil
        if let tableColumnsContainer = tableColumnsContainer {
            tableColumnsDecoded0 = [TableColumn]()
            for structure0 in tableColumnsContainer {
                if let structure0 = structure0 {
                    tableColumnsDecoded0?.append(structure0)
                }
            }
        }
        tableColumns = tableColumnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
    }
}

public struct ListTableRowsInputBodyMiddleware: Middleware {
    public let id: String = "ListTableRowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableRowsInput>
    public typealias MOutput = OperationOutput<ListTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableRowsOutputError>
}

extension ListTableRowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTableRowsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), rowIds: \(String(describing: rowIds)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension ListTableRowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case rowIds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rowIds = rowIds {
            var rowIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowIds)
            for rowidlist0 in rowIds {
                try rowIdsContainer.encode(rowidlist0)
            }
        }
    }
}

public struct ListTableRowsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTableRowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableRowsInput>
    public typealias MOutput = OperationOutput<ListTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableRowsOutputError>
}

public struct ListTableRowsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTableRowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTableRowsInput>
    public typealias MOutput = OperationOutput<ListTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTableRowsOutputError>
}

public struct ListTableRowsInput: Equatable {
    /// <p>The maximum number of rows to return in each page of the results.</p>
    public let maxResults: Int?
    /// <p>
    ///             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
    ///         </p>
    ///         <p>
    ///             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
    ///             will throw ValidationException.
    ///         </p>
    public let nextToken: String?
    /// <p>
    ///             This parameter is optional. If one or more row ids are specified in this list, then only the specified
    ///             row ids are returned in the result. If no row ids are specified here, then all the rows in the table are
    ///             returned.
    ///         </p>
    public let rowIds: [String]?
    /// <p>The ID of the table whose rows are being retrieved.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook that contains the table whose rows are being retrieved.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        rowIds: [String]? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rowIds = rowIds
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct ListTableRowsInputBody: Equatable {
    public let rowIds: [String]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListTableRowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case rowIds
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rowIds)
        var rowIdsDecoded0:[String]? = nil
        if let rowIdsContainer = rowIdsContainer {
            rowIdsDecoded0 = [String]()
            for string0 in rowIdsContainer {
                if let string0 = string0 {
                    rowIdsDecoded0?.append(string0)
                }
            }
        }
        rowIds = rowIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTableRowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTableRowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTableRowsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTableRowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTableRowsOutputResponse(columnIds: \(String(describing: columnIds)), nextToken: \(String(describing: nextToken)), rowIdsNotFound: \(String(describing: rowIdsNotFound)), rows: \(String(describing: rows)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension ListTableRowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTableRowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnIds = output.columnIds
            self.nextToken = output.nextToken
            self.rowIdsNotFound = output.rowIdsNotFound
            self.rows = output.rows
            self.workbookCursor = output.workbookCursor
        } else {
            self.columnIds = nil
            self.nextToken = nil
            self.rowIdsNotFound = nil
            self.rows = nil
            self.workbookCursor = 0
        }
    }
}

public struct ListTableRowsOutputResponse: Equatable {
    /// <p>
    ///             The list of columns in the table whose row data is returned in the result.
    ///         </p>
    public let columnIds: [String]?
    /// <p>
    ///             Provides the pagination token to load the next page if there are more results matching the request. If a
    ///             pagination token is not present in the response, it means that all data matching the request has been
    ///             loaded.
    ///         </p>
    public let nextToken: String?
    /// <p>
    ///             The list of row ids included in the request that were not found in the table.
    ///         </p>
    public let rowIdsNotFound: [String]?
    /// <p>
    ///             The list of rows in the table. Note that this result is paginated, so this list contains a maximum of 100
    ///             rows.
    ///         </p>
    public let rows: [TableRow]?
    /// <p>
    ///             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
    ///             keeps increasing with every update and the increments are not sequential.
    ///         </p>
    public let workbookCursor: Int

    public init (
        columnIds: [String]? = nil,
        nextToken: String? = nil,
        rowIdsNotFound: [String]? = nil,
        rows: [TableRow]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.columnIds = columnIds
        self.nextToken = nextToken
        self.rowIdsNotFound = rowIdsNotFound
        self.rows = rows
        self.workbookCursor = workbookCursor
    }
}

struct ListTableRowsOutputResponseBody: Equatable {
    public let columnIds: [String]?
    public let rows: [TableRow]?
    public let rowIdsNotFound: [String]?
    public let nextToken: String?
    public let workbookCursor: Int
}

extension ListTableRowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnIds
        case nextToken
        case rowIdsNotFound
        case rows
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columnIds)
        var columnIdsDecoded0:[String]? = nil
        if let columnIdsContainer = columnIdsContainer {
            columnIdsDecoded0 = [String]()
            for string0 in columnIdsContainer {
                if let string0 = string0 {
                    columnIdsDecoded0?.append(string0)
                }
            }
        }
        columnIds = columnIdsDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([TableRow?].self, forKey: .rows)
        var rowsDecoded0:[TableRow]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [TableRow]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let rowIdsNotFoundContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rowIdsNotFound)
        var rowIdsNotFoundDecoded0:[String]? = nil
        if let rowIdsNotFoundContainer = rowIdsNotFoundContainer {
            rowIdsNotFoundDecoded0 = [String]()
            for string0 in rowIdsNotFoundContainer {
                if let string0 = string0 {
                    rowIdsNotFoundDecoded0?.append(string0)
                }
            }
        }
        rowIdsNotFound = rowIdsNotFoundDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
    }
}

extension ListTablesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTablesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), workbookId: \(String(describing: workbookId)))"}
}

extension ListTablesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTablesInputHeadersMiddleware: Middleware {
    public let id: String = "ListTablesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

public struct ListTablesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTablesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTablesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTablesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTablesInput>
    public typealias MOutput = OperationOutput<ListTablesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTablesOutputError>
}

public struct ListTablesInput: Equatable {
    /// <p>The maximum number of tables to return in each page of the results.</p>
    public let maxResults: Int?
    /// <p>
    ///             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
    ///         </p>
    ///         <p>
    ///             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
    ///             will throw ValidationException.
    ///         </p>
    public let nextToken: String?
    /// <p>The ID of the workbook whose tables are being retrieved.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        workbookId: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workbookId = workbookId
    }
}

struct ListTablesInputBody: Equatable {
}

extension ListTablesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTablesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTablesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTablesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTablesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTablesOutputResponse(nextToken: \(String(describing: nextToken)), tables: \(String(describing: tables)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension ListTablesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTablesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tables = output.tables
            self.workbookCursor = output.workbookCursor
        } else {
            self.nextToken = nil
            self.tables = nil
            self.workbookCursor = 0
        }
    }
}

public struct ListTablesOutputResponse: Equatable {
    /// <p>
    ///             Provides the pagination token to load the next page if there are more results matching the request. If a
    ///             pagination token is not present in the response, it means that all data matching the request has been
    ///             loaded.
    ///         </p>
    public let nextToken: String?
    /// <p>
    ///             The list of tables in the workbook.
    ///         </p>
    public let tables: [Table]?
    /// <p>
    ///             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
    ///             keeps increasing with every update and the increments are not sequential.
    ///         </p>
    public let workbookCursor: Int

    public init (
        nextToken: String? = nil,
        tables: [Table]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.nextToken = nextToken
        self.tables = tables
        self.workbookCursor = workbookCursor
    }
}

struct ListTablesOutputResponseBody: Equatable {
    public let tables: [Table]?
    public let nextToken: String?
    public let workbookCursor: Int
}

extension ListTablesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case tables
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([Table?].self, forKey: .tables)
        var tablesDecoded0:[Table]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [Table]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
    }
}

public struct QueryTableRowsInputBodyMiddleware: Middleware {
    public let id: String = "QueryTableRowsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryTableRowsInput>
    public typealias MOutput = OperationOutput<QueryTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryTableRowsOutputError>
}

extension QueryTableRowsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryTableRowsInput(filterFormula: \(String(describing: filterFormula)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), tableId: \(String(describing: tableId)), workbookId: \(String(describing: workbookId)))"}
}

extension QueryTableRowsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filterFormula
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterFormula = filterFormula {
            try encodeContainer.encode(filterFormula, forKey: .filterFormula)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct QueryTableRowsInputHeadersMiddleware: Middleware {
    public let id: String = "QueryTableRowsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryTableRowsInput>
    public typealias MOutput = OperationOutput<QueryTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryTableRowsOutputError>
}

public struct QueryTableRowsInputQueryItemMiddleware: Middleware {
    public let id: String = "QueryTableRowsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<QueryTableRowsInput>,
                  next: H) -> Swift.Result<OperationOutput<QueryTableRowsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<QueryTableRowsInput>
    public typealias MOutput = OperationOutput<QueryTableRowsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<QueryTableRowsOutputError>
}

public struct QueryTableRowsInput: Equatable {
    /// <p>An object that represents a filter formula along with the id of the context row under which the filter
    ///             function needs to evaluate.</p>
    public let filterFormula: Filter?
    /// <p>The maximum number of rows to return in each page of the results.</p>
    public let maxResults: Int?
    /// <p>
    ///             This parameter is optional. If a nextToken is not specified, the API returns the first page of data.
    ///         </p>
    ///         <p>
    ///             Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API
    ///             will throw ValidationException.
    ///         </p>
    public let nextToken: String?
    /// <p>The ID of the table whose rows are being queried.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let tableId: String?
    /// <p>The ID of the workbook whose table rows are being queried.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        filterFormula: Filter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        tableId: String? = nil,
        workbookId: String? = nil
    )
    {
        self.filterFormula = filterFormula
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct QueryTableRowsInputBody: Equatable {
    public let filterFormula: Filter?
    public let maxResults: Int?
    public let nextToken: String?
}

extension QueryTableRowsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filterFormula
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterFormulaDecoded = try containerValues.decodeIfPresent(Filter.self, forKey: .filterFormula)
        filterFormula = filterFormulaDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension QueryTableRowsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension QueryTableRowsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum QueryTableRowsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case requestTimeoutException(RequestTimeoutException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension QueryTableRowsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "QueryTableRowsOutputResponse(columnIds: \(String(describing: columnIds)), nextToken: \(String(describing: nextToken)), rows: \(String(describing: rows)), workbookCursor: \(String(describing: workbookCursor)))"}
}

extension QueryTableRowsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: QueryTableRowsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.columnIds = output.columnIds
            self.nextToken = output.nextToken
            self.rows = output.rows
            self.workbookCursor = output.workbookCursor
        } else {
            self.columnIds = nil
            self.nextToken = nil
            self.rows = nil
            self.workbookCursor = 0
        }
    }
}

public struct QueryTableRowsOutputResponse: Equatable {
    /// <p>
    ///             The list of columns in the table whose row data is returned in the result.
    ///         </p>
    public let columnIds: [String]?
    /// <p>
    ///             Provides the pagination token to load the next page if there are more results matching the request. If a
    ///             pagination token is not present in the response, it means that all data matching the request has been
    ///             loaded.
    ///         </p>
    public let nextToken: String?
    /// <p>
    ///             The list of rows in the table that match the query filter.
    ///         </p>
    public let rows: [TableRow]?
    /// <p>
    ///             Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor
    ///             keeps increasing with every update and the increments are not sequential.
    ///         </p>
    public let workbookCursor: Int

    public init (
        columnIds: [String]? = nil,
        nextToken: String? = nil,
        rows: [TableRow]? = nil,
        workbookCursor: Int = 0
    )
    {
        self.columnIds = columnIds
        self.nextToken = nextToken
        self.rows = rows
        self.workbookCursor = workbookCursor
    }
}

struct QueryTableRowsOutputResponseBody: Equatable {
    public let columnIds: [String]?
    public let rows: [TableRow]?
    public let nextToken: String?
    public let workbookCursor: Int
}

extension QueryTableRowsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case columnIds
        case nextToken
        case rows
        case workbookCursor
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .columnIds)
        var columnIdsDecoded0:[String]? = nil
        if let columnIdsContainer = columnIdsContainer {
            columnIdsDecoded0 = [String]()
            for string0 in columnIdsContainer {
                if let string0 = string0 {
                    columnIdsDecoded0?.append(string0)
                }
            }
        }
        columnIds = columnIdsDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([TableRow?].self, forKey: .rows)
        var rowsDecoded0:[TableRow]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [TableRow]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decode(Int.self, forKey: .workbookCursor)
        workbookCursor = workbookCursorDecoded
    }
}

extension RequestTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestTimeoutException(message: \(String(describing: message)))"}
}

extension RequestTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request timed out.</p>
public struct RequestTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct RequestTimeoutExceptionBody: Equatable {
    public let message: String?
}

extension RequestTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A Workbook, Table, App, Screen or Screen Automation was not found with the given ID.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResultRow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataItems
        case rowId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataItems = dataItems {
            var dataItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataItems)
            for dataitems0 in dataItems {
                try dataItemsContainer.encode(dataitems0)
            }
        }
        if let rowId = rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let dataItemsContainer = try containerValues.decodeIfPresent([DataItem?].self, forKey: .dataItems)
        var dataItemsDecoded0:[DataItem]? = nil
        if let dataItemsContainer = dataItemsContainer {
            dataItemsDecoded0 = [DataItem]()
            for structure0 in dataItemsContainer {
                if let structure0 = structure0 {
                    dataItemsDecoded0?.append(structure0)
                }
            }
        }
        dataItems = dataItemsDecoded0
    }
}

extension ResultRow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultRow(dataItems: \(String(describing: dataItems)), rowId: \(String(describing: rowId)))"}
}

/// <p>A single row in the ResultSet.</p>
public struct ResultRow: Equatable {
    /// <p>List of all the data cells in a row.</p>
    public let dataItems: [DataItem]?
    /// <p>The ID for a particular row.</p>
    public let rowId: String?

    public init (
        dataItems: [DataItem]? = nil,
        rowId: String? = nil
    )
    {
        self.dataItems = dataItems
        self.rowId = rowId
    }
}

extension ResultSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case headers
        case rows
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for resultheader0 in headers {
                try headersContainer.encode(resultheader0)
            }
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for resultrows0 in rows {
                try rowsContainer.encode(resultrows0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headersContainer = try containerValues.decodeIfPresent([ColumnMetadata?].self, forKey: .headers)
        var headersDecoded0:[ColumnMetadata]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [ColumnMetadata]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([ResultRow?].self, forKey: .rows)
        var rowsDecoded0:[ResultRow]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [ResultRow]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
    }
}

extension ResultSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResultSet(headers: \(String(describing: headers)), rows: \(String(describing: rows)))"}
}

/// <p>
///             ResultSet contains the results of the request for a single block or list defined on the screen.
///         </p>
public struct ResultSet: Equatable {
    /// <p>
    ///             List of headers for all the data cells in the block. The header identifies the name and default format of
    ///             the data cell. Data cells appear in the same order in all rows as defined in the header. The names and
    ///             formats are not repeated in the rows. If a particular row does not have a value for a data cell, a blank
    ///             value is used.
    ///         </p>
    ///         <p>
    ///             For example, a task list that displays the task name, due date and assigned person might have headers
    ///             [ { "name": "Task Name"}, {"name": "Due Date", "format": "DATE"}, {"name": "Assigned", "format": "CONTACT"} ].
    ///             Every row in the result will have the task name as the first item, due date as the second item and assigned
    ///             person as the third item. If a particular task does not have a due date, that row will still have a blank
    ///             value in the second element and the assigned person will still be in the third element.
    ///         </p>
    public let headers: [ColumnMetadata]?
    /// <p>
    ///             List of rows returned by the request. Each row has a row Id and a list of data cells in that row. The data
    ///             cells will be present in the same order as they are defined in the header.
    ///         </p>
    public let rows: [ResultRow]?

    public init (
        headers: [ColumnMetadata]? = nil,
        rows: [ResultRow]? = nil
    )
    {
        self.headers = headers
        self.rows = rows
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             The request caused service quota to be breached.
///         </p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceUnavailableException(message: \(String(describing: message)))"}
}

extension ServiceUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Remote service is unreachable.</p>
public struct ServiceUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceUnavailableExceptionBody: Equatable {
    public let message: String?
}

extension ServiceUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceDataColumnProperties: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case columnIndex
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if columnIndex != 0 {
            try encodeContainer.encode(columnIndex, forKey: .columnIndex)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnIndexDecoded = try containerValues.decode(Int.self, forKey: .columnIndex)
        columnIndex = columnIndexDecoded
    }
}

extension SourceDataColumnProperties: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceDataColumnProperties(columnIndex: \(String(describing: columnIndex)))"}
}

/// <p>An object that contains the properties for importing data to a specific column in a table.</p>
public struct SourceDataColumnProperties: Equatable {
    /// <p>The index of the column in the input file.</p>
    public let columnIndex: Int

    public init (
        columnIndex: Int = 0
    )
    {
        self.columnIndex = columnIndex
    }
}

public struct StartTableDataImportJobInputBodyMiddleware: Middleware {
    public let id: String = "StartTableDataImportJobInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTableDataImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTableDataImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTableDataImportJobInput>
    public typealias MOutput = OperationOutput<StartTableDataImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTableDataImportJobOutputError>
}

extension StartTableDataImportJobInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTableDataImportJobInput(clientRequestToken: \(String(describing: clientRequestToken)), dataFormat: \(String(describing: dataFormat)), dataSource: \(String(describing: dataSource)), destinationTableId: \(String(describing: destinationTableId)), importOptions: \(String(describing: importOptions)), workbookId: \(String(describing: workbookId)))"}
}

extension StartTableDataImportJobInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case dataFormat
        case dataSource
        case importOptions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataFormat = dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let importOptions = importOptions {
            try encodeContainer.encode(importOptions, forKey: .importOptions)
        }
    }
}

public struct StartTableDataImportJobInputHeadersMiddleware: Middleware {
    public let id: String = "StartTableDataImportJobInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTableDataImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTableDataImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTableDataImportJobInput>
    public typealias MOutput = OperationOutput<StartTableDataImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTableDataImportJobOutputError>
}

public struct StartTableDataImportJobInputQueryItemMiddleware: Middleware {
    public let id: String = "StartTableDataImportJobInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartTableDataImportJobInput>,
                  next: H) -> Swift.Result<OperationOutput<StartTableDataImportJobOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartTableDataImportJobInput>
    public typealias MOutput = OperationOutput<StartTableDataImportJobOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartTableDataImportJobOutputError>
}

public struct StartTableDataImportJobInput: Equatable {
    /// <p>
    ///             The request token for performing the update action.
    ///             Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error
    ///             like a failed network connection, you can retry the call with the same request token. The service ensures
    ///             that if the first call using that request token is successfully performed, the second call will not perform
    ///             the action again.
    ///         </p>
    ///         <p>
    ///             Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests
    ///             spanning hours or days.
    ///         </p>
    public let clientRequestToken: String?
    /// <p>
    ///             The format of the data that is being imported. Currently the only option supported is "DELIMITED_TEXT".
    ///         </p>
    public let dataFormat: ImportSourceDataFormat?
    /// <p>
    ///             The source of the data that is being imported. The size of source must be no larger than 100 MB.
    ///             Source must have no more than 100,000 cells and no more than 1,000 rows.
    ///         </p>
    public let dataSource: ImportDataSource?
    /// <p>The ID of the table where the rows are being imported.</p>
    ///         <p>
    ///             If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let destinationTableId: String?
    /// <p>
    ///             The options for customizing this import request.
    ///         </p>
    public let importOptions: ImportOptions?
    /// <p>The ID of the workbook where the rows are being imported.</p>
    ///         <p>
    ///             If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    ///         </p>
    public let workbookId: String?

    public init (
        clientRequestToken: String? = nil,
        dataFormat: ImportSourceDataFormat? = nil,
        dataSource: ImportDataSource? = nil,
        destinationTableId: String? = nil,
        importOptions: ImportOptions? = nil,
        workbookId: String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataFormat = dataFormat
        self.dataSource = dataSource
        self.destinationTableId = destinationTableId
        self.importOptions = importOptions
        self.workbookId = workbookId
    }
}

struct StartTableDataImportJobInputBody: Equatable {
    public let dataSource: ImportDataSource?
    public let dataFormat: ImportSourceDataFormat?
    public let importOptions: ImportOptions?
    public let clientRequestToken: String?
}

extension StartTableDataImportJobInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientRequestToken
        case dataFormat
        case dataSource
        case importOptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(ImportDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(ImportSourceDataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartTableDataImportJobOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartTableDataImportJobOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceUnavailableException" : self = .serviceUnavailableException(try ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartTableDataImportJobOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceUnavailableException(ServiceUnavailableException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartTableDataImportJobOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartTableDataImportJobOutputResponse(jobId: \(String(describing: jobId)), jobStatus: \(String(describing: jobStatus)))"}
}

extension StartTableDataImportJobOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartTableDataImportJobOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartTableDataImportJobOutputResponse: Equatable {
    /// <p>
    ///             The id that is assigned to this import job. Future requests to find out the status of this import job
    ///             need to send this id in the appropriate parameter in the request.
    ///         </p>
    public let jobId: String?
    /// <p>
    ///             The status of the import job immediately after submitting the request.
    ///         </p>
    public let jobStatus: TableDataImportJobStatus?

    public init (
        jobId: String? = nil,
        jobStatus: TableDataImportJobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartTableDataImportJobOutputResponseBody: Equatable {
    public let jobId: String?
    public let jobStatus: TableDataImportJobStatus?
}

extension StartTableDataImportJobOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case jobId
        case jobStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(TableDataImportJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

extension Table: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tableId
        case tableName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableId = tableId {
            try encodeContainer.encode(tableId, forKey: .tableId)
        }
        if let tableName = tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableId)
        tableId = tableIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension Table: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Table(tableId: \(String(describing: tableId)), tableName: \(String(describing: tableName)))"}
}

/// <p>An object representing the properties of a table in a workbook.</p>
public struct Table: Equatable {
    /// <p>The id of the table.</p>
    public let tableId: String?
    /// <p>The name of the table.</p>
    public let tableName: String?

    public init (
        tableId: String? = nil,
        tableName: String? = nil
    )
    {
        self.tableId = tableId
        self.tableName = tableName
    }
}

extension TableColumn: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case format
        case tableColumnId
        case tableColumnName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let tableColumnId = tableColumnId {
            try encodeContainer.encode(tableColumnId, forKey: .tableColumnId)
        }
        if let tableColumnName = tableColumnName {
            try encodeContainer.encode(tableColumnName, forKey: .tableColumnName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableColumnIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableColumnId)
        tableColumnId = tableColumnIdDecoded
        let tableColumnNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .tableColumnName)
        tableColumnName = tableColumnNameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(Format.self, forKey: .format)
        format = formatDecoded
    }
}

extension TableColumn: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableColumn(format: \(String(describing: format)), tableColumnId: \(String(describing: tableColumnId)), tableColumnName: \(String(describing: tableColumnName)))"}
}

/// <p>An object that contains attributes about a single column in a table</p>
public struct TableColumn: Equatable {
    /// <p>
    ///             The column level format that is applied in the table. An empty value in this field means that the
    ///             column format is the default value 'AUTO'.
    ///         </p>
    public let format: Format?
    /// <p>The id of the column in the table.</p>
    public let tableColumnId: String?
    /// <p>The name of the column in the table.</p>
    public let tableColumnName: String?

    public init (
        format: Format? = nil,
        tableColumnId: String? = nil,
        tableColumnName: String? = nil
    )
    {
        self.format = format
        self.tableColumnId = tableColumnId
        self.tableColumnName = tableColumnName
    }
}

extension TableDataImportJobMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dataSource
        case importOptions
        case submitTime
        case submitter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let importOptions = importOptions {
            try encodeContainer.encode(importOptions, forKey: .importOptions)
        }
        if let submitTime = submitTime {
            try encodeContainer.encode(submitTime.timeIntervalSince1970, forKey: .submitTime)
        }
        if let submitter = submitter {
            try encodeContainer.encode(submitter, forKey: .submitter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submitterDecoded = try containerValues.decodeIfPresent(ImportJobSubmitter.self, forKey: .submitter)
        submitter = submitterDecoded
        let submitTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(ImportDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension TableDataImportJobMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableDataImportJobMetadata(dataSource: \(String(describing: dataSource)), importOptions: \(String(describing: importOptions)), submitTime: \(String(describing: submitTime)), submitter: \(String(describing: submitter)))"}
}

/// <p>The metadata associated with the table data import job that was submitted.</p>
public struct TableDataImportJobMetadata: Equatable {
    /// <p>The source of the data that was submitted for import.</p>
    public let dataSource: ImportDataSource?
    /// <p>The options that was specified at the time of submitting the import request.</p>
    public let importOptions: ImportOptions?
    /// <p>The timestamp when the job was submitted for import.</p>
    public let submitTime: Date?
    /// <p>Details about the submitter of the import request.</p>
    public let submitter: ImportJobSubmitter?

    public init (
        dataSource: ImportDataSource? = nil,
        importOptions: ImportOptions? = nil,
        submitTime: Date? = nil,
        submitter: ImportJobSubmitter? = nil
    )
    {
        self.dataSource = dataSource
        self.importOptions = importOptions
        self.submitTime = submitTime
        self.submitter = submitter
    }
}

public enum TableDataImportJobStatus {
    case completed
    case failed
    case inprogress
    case submitted
    case sdkUnknown(String)
}

extension TableDataImportJobStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TableDataImportJobStatus] {
        return [
            .completed,
            .failed,
            .inprogress,
            .submitted,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .inprogress: return "IN_PROGRESS"
        case .submitted: return "SUBMITTED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TableDataImportJobStatus(rawValue: rawValue) ?? TableDataImportJobStatus.sdkUnknown(rawValue)
    }
}

extension TableRow: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cells
        case rowId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for cells0 in cells {
                try cellsContainer.encode(cells0)
            }
        }
        if let rowId = rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let cellsContainer = try containerValues.decodeIfPresent([Cell?].self, forKey: .cells)
        var cellsDecoded0:[Cell]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [Cell]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension TableRow: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TableRow(cells: \(String(describing: cells)), rowId: \(String(describing: rowId)))"}
}

/// <p>An object that contains attributes about a single row in a table</p>
public struct TableRow: Equatable {
    /// <p>A list of cells in the table row. The cells appear in the same order as the columns of the table.
    ///         </p>
    public let cells: [Cell]?
    /// <p>The id of the row in the table.</p>
    public let rowId: String?

    public init (
        cells: [Cell]? = nil,
        rowId: String? = nil
    )
    {
        self.cells = cells
        self.rowId = rowId
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Tps(transactions per second) rate reached.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateRowData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cellsToUpdate
        case rowId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellsToUpdate = cellsToUpdate {
            var cellsToUpdateContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .cellsToUpdate)
            for (dictKey0, rowdatainput0) in cellsToUpdate {
                try cellsToUpdateContainer.encode(rowdatainput0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let rowId = rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let cellsToUpdateContainer = try containerValues.decodeIfPresent([String: CellInput?].self, forKey: .cellsToUpdate)
        var cellsToUpdateDecoded0: [String:CellInput]? = nil
        if let cellsToUpdateContainer = cellsToUpdateContainer {
            cellsToUpdateDecoded0 = [String:CellInput]()
            for (key0, cellinput0) in cellsToUpdateContainer {
                if let cellinput0 = cellinput0 {
                    cellsToUpdateDecoded0?[key0] = cellinput0
                }
            }
        }
        cellsToUpdate = cellsToUpdateDecoded0
    }
}

extension UpdateRowData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRowData(cellsToUpdate: \(String(describing: cellsToUpdate)), rowId: \(String(describing: rowId)))"}
}

/// <p>
///             Data needed to create a single row in a table as part of the BatchCreateTableRows request.
///         </p>
public struct UpdateRowData: Equatable {
    /// <p>
    ///             A map representing the cells to update in the given row. The key is the column id of the
    ///             cell and the value is the CellInput object that represents the data to set in that cell.
    ///         </p>
    public let cellsToUpdate: [String:CellInput]?
    /// <p>
    ///             The id of the row that needs to be updated.
    ///         </p>
    public let rowId: String?

    public init (
        cellsToUpdate: [String:CellInput]? = nil,
        rowId: String? = nil
    )
    {
        self.cellsToUpdate = cellsToUpdate
        self.rowId = rowId
    }
}

public enum UpsertAction {
    case appended
    case updated
    case sdkUnknown(String)
}

extension UpsertAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [UpsertAction] {
        return [
            .appended,
            .updated,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .appended: return "APPENDED"
        case .updated: return "UPDATED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = UpsertAction(rawValue: rawValue) ?? UpsertAction.sdkUnknown(rawValue)
    }
}

extension UpsertRowData: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchItemId
        case cellsToUpdate
        case filter
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchItemId = batchItemId {
            try encodeContainer.encode(batchItemId, forKey: .batchItemId)
        }
        if let cellsToUpdate = cellsToUpdate {
            var cellsToUpdateContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .cellsToUpdate)
            for (dictKey0, rowdatainput0) in cellsToUpdate {
                try cellsToUpdateContainer.encode(rowdatainput0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchItemIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .batchItemId)
        batchItemId = batchItemIdDecoded
        let filterDecoded = try containerValues.decodeIfPresent(Filter.self, forKey: .filter)
        filter = filterDecoded
        let cellsToUpdateContainer = try containerValues.decodeIfPresent([String: CellInput?].self, forKey: .cellsToUpdate)
        var cellsToUpdateDecoded0: [String:CellInput]? = nil
        if let cellsToUpdateContainer = cellsToUpdateContainer {
            cellsToUpdateDecoded0 = [String:CellInput]()
            for (key0, cellinput0) in cellsToUpdateContainer {
                if let cellinput0 = cellinput0 {
                    cellsToUpdateDecoded0?[key0] = cellinput0
                }
            }
        }
        cellsToUpdate = cellsToUpdateDecoded0
    }
}

extension UpsertRowData: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpsertRowData(batchItemId: \(String(describing: batchItemId)), cellsToUpdate: \(String(describing: cellsToUpdate)), filter: \(String(describing: filter)))"}
}

/// <p>
///             Data needed to upsert rows in a table as part of a single item in the BatchUpsertTableRows request.
///         </p>
public struct UpsertRowData: Equatable {
    /// <p>
    ///             An external identifier that represents a single item in the request that is being upserted as part of the
    ///             BatchUpsertTableRows request. This can be any string that you can use to identify the item in the request.
    ///             The BatchUpsertTableRows API puts the batch item id in the results to allow you to link data in the
    ///             request to data in the results.
    ///         </p>
    public let batchItemId: String?
    /// <p>
    ///             A map representing the cells to update for the matching rows or an appended row. The key is the column id
    ///             of the cell and the value is the CellInput object that represents the data to set in that cell.
    ///         </p>
    public let cellsToUpdate: [String:CellInput]?
    /// <p>
    ///             The filter formula to use to find existing matching rows to update. The formula needs to return zero or more
    ///             rows. If the formula returns 0 rows, then a new row will be appended in the target table. If the formula
    ///             returns one or more rows, then the returned rows will be updated.
    ///         </p>
    ///         <p>
    ///             Note that the filter formula needs to return rows from the target table for the upsert operation to succeed.
    ///             If the filter formula has a syntax error or it doesn't evaluate to zero or more rows in the target table
    ///             for any one item in the input list, then the entire BatchUpsertTableRows request fails and no updates are
    ///             made to the table.
    ///         </p>
    public let filter: Filter?

    public init (
        batchItemId: String? = nil,
        cellsToUpdate: [String:CellInput]? = nil,
        filter: Filter? = nil
    )
    {
        self.batchItemId = batchItemId
        self.cellsToUpdate = cellsToUpdate
        self.filter = filter
    }
}

extension UpsertRowsResult: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rowIds
        case upsertAction
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rowIds = rowIds {
            var rowIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowIds)
            for rowidlist0 in rowIds {
                try rowIdsContainer.encode(rowidlist0)
            }
        }
        if let upsertAction = upsertAction {
            try encodeContainer.encode(upsertAction.rawValue, forKey: .upsertAction)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rowIds)
        var rowIdsDecoded0:[String]? = nil
        if let rowIdsContainer = rowIdsContainer {
            rowIdsDecoded0 = [String]()
            for string0 in rowIdsContainer {
                if let string0 = string0 {
                    rowIdsDecoded0?.append(string0)
                }
            }
        }
        rowIds = rowIdsDecoded0
        let upsertActionDecoded = try containerValues.decodeIfPresent(UpsertAction.self, forKey: .upsertAction)
        upsertAction = upsertActionDecoded
    }
}

extension UpsertRowsResult: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpsertRowsResult(rowIds: \(String(describing: rowIds)), upsertAction: \(String(describing: upsertAction)))"}
}

/// <p>
///             An object that represents the result of a single upsert row request.
///         </p>
public struct UpsertRowsResult: Equatable {
    /// <p>
    ///             The list of row ids that were changed as part of an upsert row operation. If the upsert resulted in an
    ///             update, this list could potentially contain multiple rows that matched the filter and hence got updated.
    ///             If the upsert resulted in an append, this list would only have the single row that was appended.
    ///         </p>
    public let rowIds: [String]?
    /// <p>
    ///             The result of the upsert action.
    ///         </p>
    public let upsertAction: UpsertAction?

    public init (
        rowIds: [String]? = nil,
        upsertAction: UpsertAction? = nil
    )
    {
        self.rowIds = rowIds
        self.upsertAction = upsertAction
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>
///             Request is invalid. The message in the response contains details on why the request is invalid.
///         </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension VariableValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rawValue
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rawValue = rawValue {
            try encodeContainer.encode(rawValue, forKey: .rawValue)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rawValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawValue)
        rawValue = rawValueDecoded
    }
}

extension VariableValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>The input variables to the app to be used by the InvokeScreenAutomation action request.</p>
public struct VariableValue: Equatable {
    /// <p>Raw value of the variable.</p>
    public let rawValue: String?

    public init (
        rawValue: String? = nil
    )
    {
        self.rawValue = rawValue
    }
}
