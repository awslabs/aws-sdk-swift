// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension OpsWorksCmClientTypes.AccountAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maximum = "Maximum"
        case name = "Name"
        case used = "Used"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let used = used {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maximum)
        maximum = maximumDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .used)
        used = usedDecoded
    }
}

extension OpsWorksCmClientTypes.AccountAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountAttribute(maximum: \(Swift.String(describing: maximum)), name: \(Swift.String(describing: name)), used: \(Swift.String(describing: used)))"}
}

extension OpsWorksCmClientTypes {
    /// <p>Stores account attributes.
    ///     </p>
    public struct AccountAttribute: Swift.Equatable {
        /// <p>
        ///       The maximum allowed value.
        ///     </p>
        public let maximum: Swift.Int?
        /// <p>
        ///       The attribute name. The following are supported attribute names.
        ///     </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <i>ServerLimit:</i> The number of current servers/maximum number of servers allowed. By default, you can have a maximum of 10 servers.
        ///       </p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <i>ManualBackupLimit:</i> The number of current manual backups/maximum number of backups allowed. By default, you can have a maximum
        ///         of 50 manual backups saved.
        ///       </p>
        ///             </li>
        ///          </ul>
        public let name: Swift.String?
        /// <p>
        ///       The current usage, such as the current number of servers that are associated with the account.
        ///     </p>
        public let used: Swift.Int?

        public init (
            maximum: Swift.Int? = nil,
            name: Swift.String? = nil,
            used: Swift.Int? = nil
        )
        {
            self.maximum = maximum
            self.name = name
            self.used = used
        }
    }

}

public struct AssociateNodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateNodeOutputError>
}

extension AssociateNodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateNodeInput(engineAttributes: \(Swift.String(describing: engineAttributes)), nodeName: \(Swift.String(describing: nodeName)), serverName: \(Swift.String(describing: serverName)))"}
}

extension AssociateNodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let nodeName = nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct AssociateNodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateNodeOutputError>
}

public struct AssociateNodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "AssociateNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<AssociateNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<AssociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<AssociateNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<AssociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<AssociateNodeOutputError>
}

public struct AssociateNodeInput: Swift.Equatable {
    /// <p>Engine attributes used for associating the node.
    ///     </p>
    ///          <p class="title">
    ///             <b>Attributes accepted in a AssociateNode request for Chef</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_ORGANIZATION</code>: The Chef organization
    ///           with which the node is associated. By default only one organization
    ///           named <code>default</code> can exist.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_NODE_PUBLIC_KEY</code>: A PEM-formatted public key. This key is required for the <code>chef-client</code> agent to access the Chef API.
    ///     </p>
    ///             </li>
    ///          </ul>
    ///          <p class="title">
    ///             <b>Attributes accepted in a AssociateNode request for Puppet</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_NODE_CSR</code>: A PEM-formatted certificate-signing request (CSR) that is created by the node.
    ///     </p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
    /// <p>The name of the node.
    ///     </p>
    public let nodeName: Swift.String?
    /// <p>The name of the server with which to associate the node.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]? = nil,
        nodeName: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

struct AssociateNodeInputBody: Swift.Equatable {
    public let serverName: Swift.String?
    public let nodeName: Swift.String?
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
}

extension AssociateNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCmClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCmClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension AssociateNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateNodeOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateNodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateNodeOutputResponse(nodeAssociationStatusToken: \(Swift.String(describing: nodeAssociationStatusToken)))"}
}

extension AssociateNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AssociateNodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nodeAssociationStatusToken = output.nodeAssociationStatusToken
        } else {
            self.nodeAssociationStatusToken = nil
        }
    }
}

public struct AssociateNodeOutputResponse: Swift.Equatable {
    /// <p>Contains a token which can be passed to the <code>DescribeNodeAssociationStatus</code> API call to get the status of the association request.
    ///     </p>
    public let nodeAssociationStatusToken: Swift.String?

    public init (
        nodeAssociationStatusToken: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

struct AssociateNodeOutputResponseBody: Swift.Equatable {
    public let nodeAssociationStatusToken: Swift.String?
}

extension AssociateNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
    }
}

extension OpsWorksCmClientTypes.Backup: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupArn = "BackupArn"
        case backupId = "BackupId"
        case backupType = "BackupType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case engine = "Engine"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case s3DataSize = "S3DataSize"
        case s3DataUrl = "S3DataUrl"
        case s3LogUrl = "S3LogUrl"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case subnetIds = "SubnetIds"
        case toolsVersion = "ToolsVersion"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupArn = backupArn {
            try encodeContainer.encode(backupArn, forKey: .backupArn)
        }
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupType = backupType {
            try encodeContainer.encode(backupType.rawValue, forKey: .backupType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineModel = engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let s3DataSize = s3DataSize {
            try encodeContainer.encode(s3DataSize, forKey: .s3DataSize)
        }
        if let s3DataUrl = s3DataUrl {
            try encodeContainer.encode(s3DataUrl, forKey: .s3DataUrl)
        }
        if let s3LogUrl = s3LogUrl {
            try encodeContainer.encode(s3LogUrl, forKey: .s3LogUrl)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDescription = statusDescription {
            try encodeContainer.encode(statusDescription, forKey: .statusDescription)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
        if let toolsVersion = toolsVersion {
            try encodeContainer.encode(toolsVersion, forKey: .toolsVersion)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupArn)
        backupArn = backupArnDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let backupTypeDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.BackupType.self, forKey: .backupType)
        backupType = backupTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let s3DataSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .s3DataSize)
        s3DataSize = s3DataSizeDecoded
        let s3DataUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3DataUrl)
        s3DataUrl = s3DataUrlDecoded
        let s3LogUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3LogUrl)
        s3LogUrl = s3LogUrlDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.BackupStatus.self, forKey: .status)
        status = statusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let toolsVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toolsVersion)
        toolsVersion = toolsVersionDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension OpsWorksCmClientTypes.Backup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Backup(backupArn: \(Swift.String(describing: backupArn)), backupId: \(Swift.String(describing: backupId)), backupType: \(Swift.String(describing: backupType)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), engine: \(Swift.String(describing: engine)), engineModel: \(Swift.String(describing: engineModel)), engineVersion: \(Swift.String(describing: engineVersion)), instanceProfileArn: \(Swift.String(describing: instanceProfileArn)), instanceType: \(Swift.String(describing: instanceType)), keyPair: \(Swift.String(describing: keyPair)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), s3DataSize: \(Swift.String(describing: s3DataSize)), s3DataUrl: \(Swift.String(describing: s3DataUrl)), s3LogUrl: \(Swift.String(describing: s3LogUrl)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), serverName: \(Swift.String(describing: serverName)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), status: \(Swift.String(describing: status)), statusDescription: \(Swift.String(describing: statusDescription)), subnetIds: \(Swift.String(describing: subnetIds)), toolsVersion: \(Swift.String(describing: toolsVersion)), userArn: \(Swift.String(describing: userArn)))"}
}

extension OpsWorksCmClientTypes {
    /// <p>Describes a single backup.
    ///     </p>
    public struct Backup: Swift.Equatable {
        /// <p>The ARN of the backup.
        ///     </p>
        public let backupArn: Swift.String?
        /// <p>
        ///       The generated ID of the backup. Example: <code>myServerName-yyyyMMddHHmmssSSS</code>
        ///          </p>
        public let backupId: Swift.String?
        /// <p>
        ///       The backup type. Valid values are <code>automated</code> or <code>manual</code>.
        ///     </p>
        public let backupType: OpsWorksCmClientTypes.BackupType?
        /// <p>
        ///       The time stamp when the backup was created in the database. Example: <code>2016-07-29T13:38:47.520Z</code>
        ///          </p>
        public let createdAt: ClientRuntime.Date?
        /// <p>
        ///       A user-provided description for a manual backup. This field is empty for automated backups.
        ///     </p>
        public let description: Swift.String?
        /// <p>
        ///       The engine type that is obtained from the server when the backup is created.
        ///     </p>
        public let engine: Swift.String?
        /// <p>
        ///       The engine model that is obtained from the server when the backup is created.
        ///     </p>
        public let engineModel: Swift.String?
        /// <p>
        ///       The engine version that is obtained from the server when the backup is created.
        ///     </p>
        public let engineVersion: Swift.String?
        /// <p>
        ///       The EC2 instance profile ARN that is obtained from the server when the backup is created. Because this value is stored,
        ///       you are not required to provide the InstanceProfileArn again if you restore a backup.
        ///     </p>
        public let instanceProfileArn: Swift.String?
        /// <p>
        ///       The instance type that is obtained from the server when the backup is created.
        ///     </p>
        public let instanceType: Swift.String?
        /// <p>
        ///       The key pair that is obtained from the server when the backup is created.
        ///     </p>
        public let keyPair: Swift.String?
        /// <p>
        ///       The preferred backup period that is obtained from the server when the backup is created.
        ///     </p>
        public let preferredBackupWindow: Swift.String?
        /// <p>
        ///       The preferred maintenance period that is obtained from the server when the backup is created.
        ///     </p>
        public let preferredMaintenanceWindow: Swift.String?
        /// <p>
        ///       This field is deprecated and is no longer used.
        ///     </p>
        @available(*, deprecated)
        public let s3DataSize: Swift.Int?
        /// <p>
        ///       This field is deprecated and is no longer used.
        ///     </p>
        @available(*, deprecated)
        public let s3DataUrl: Swift.String?
        /// <p>
        ///       The Amazon S3 URL of the backup's log file.
        ///     </p>
        public let s3LogUrl: Swift.String?
        /// <p>
        ///       The security group IDs that are obtained from the server when the backup is created.
        ///     </p>
        public let securityGroupIds: [Swift.String]?
        /// <p>
        ///       The name of the server from which the backup was made.
        ///     </p>
        public let serverName: Swift.String?
        /// <p>
        ///       The service role ARN that is obtained from the server when the backup is created.
        ///     </p>
        public let serviceRoleArn: Swift.String?
        /// <p>The status of a backup while in progress.
        ///     </p>
        public let status: OpsWorksCmClientTypes.BackupStatus?
        /// <p>
        ///       An informational message about backup status.
        ///     </p>
        public let statusDescription: Swift.String?
        /// <p>
        ///       The subnet IDs that are obtained from the server when the backup is created.
        ///     </p>
        public let subnetIds: [Swift.String]?
        /// <p>
        ///       The version of AWS OpsWorks CM-specific tools that is obtained from the server when the backup is created.
        ///     </p>
        public let toolsVersion: Swift.String?
        /// <p>
        ///       The IAM user ARN of the requester for manual backups. This field is empty for automated backups.
        ///     </p>
        public let userArn: Swift.String?

        public init (
            backupArn: Swift.String? = nil,
            backupId: Swift.String? = nil,
            backupType: OpsWorksCmClientTypes.BackupType? = nil,
            createdAt: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineModel: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            keyPair: Swift.String? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            s3DataSize: Swift.Int? = nil,
            s3DataUrl: Swift.String? = nil,
            s3LogUrl: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            serverName: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            status: OpsWorksCmClientTypes.BackupStatus? = nil,
            statusDescription: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil,
            toolsVersion: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.backupArn = backupArn
            self.backupId = backupId
            self.backupType = backupType
            self.createdAt = createdAt
            self.description = description
            self.engine = engine
            self.engineModel = engineModel
            self.engineVersion = engineVersion
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.keyPair = keyPair
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.s3DataSize = s3DataSize
            self.s3DataUrl = s3DataUrl
            self.s3LogUrl = s3LogUrl
            self.securityGroupIds = securityGroupIds
            self.serverName = serverName
            self.serviceRoleArn = serviceRoleArn
            self.status = status
            self.statusDescription = statusDescription
            self.subnetIds = subnetIds
            self.toolsVersion = toolsVersion
            self.userArn = userArn
        }
    }

}

extension OpsWorksCmClientTypes {
    public enum BackupStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleting
        case failed
        case inProgress
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupStatus] {
            return [
                .deleting,
                .failed,
                .inProgress,
                .ok,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupStatus(rawValue: rawValue) ?? BackupStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksCmClientTypes {
    public enum BackupType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automated
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [BackupType] {
            return [
                .automated,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automated: return "AUTOMATED"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BackupType(rawValue: rawValue) ?? BackupType.sdkUnknown(rawValue)
        }
    }
}

public struct CreateBackupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupOutputError>
}

extension CreateBackupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupInput(description: \(Swift.String(describing: description)), serverName: \(Swift.String(describing: serverName)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateBackupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case serverName = "ServerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateBackupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupOutputError>
}

public struct CreateBackupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateBackupOutputError>
}

public struct CreateBackupInput: Swift.Equatable {
    /// <p>
    ///       A user-defined description of the backup.
    ///     </p>
    public let description: Swift.String?
    /// <p>The name of the server that you want to back up.
    ///     </p>
    public let serverName: Swift.String?
    /// <p>A map that contains tag keys and tag values to attach to an AWS OpsWorks-CM server backup.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The key cannot be empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Leading and trailing white spaces are trimmed from both the key and value.</p>
    ///             </li>
    ///             <li>
    ///                <p>A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.</p>
    ///             </li>
    ///          </ul>
    public let tags: [OpsWorksCmClientTypes.Tag]?

    public init (
        description: Swift.String? = nil,
        serverName: Swift.String? = nil,
        tags: [OpsWorksCmClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.serverName = serverName
        self.tags = tags
    }
}

struct CreateBackupInputBody: Swift.Equatable {
    public let serverName: Swift.String?
    public let description: Swift.String?
    public let tags: [OpsWorksCmClientTypes.Tag]?
}

extension CreateBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case serverName = "ServerName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateBackupOutputResponse(backup: \(Swift.String(describing: backup)))"}
}

extension CreateBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateBackupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct CreateBackupOutputResponse: Swift.Equatable {
    /// <p>Backup created by request.</p>
    public let backup: OpsWorksCmClientTypes.Backup?

    public init (
        backup: OpsWorksCmClientTypes.Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct CreateBackupOutputResponseBody: Swift.Equatable {
    public let backup: OpsWorksCmClientTypes.Backup?
}

extension CreateBackupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct CreateServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServerOutputError>
}

extension CreateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerInput(associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), backupId: \(Swift.String(describing: backupId)), backupRetentionCount: \(Swift.String(describing: backupRetentionCount)), customCertificate: \(Swift.String(describing: customCertificate)), customDomain: \(Swift.String(describing: customDomain)), customPrivateKey: \(Swift.String(describing: customPrivateKey)), disableAutomatedBackup: \(Swift.String(describing: disableAutomatedBackup)), engine: \(Swift.String(describing: engine)), engineAttributes: \(Swift.String(describing: engineAttributes)), engineModel: \(Swift.String(describing: engineModel)), engineVersion: \(Swift.String(describing: engineVersion)), instanceProfileArn: \(Swift.String(describing: instanceProfileArn)), instanceType: \(Swift.String(describing: instanceType)), keyPair: \(Swift.String(describing: keyPair)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), serverName: \(Swift.String(describing: serverName)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), subnetIds: \(Swift.String(describing: subnetIds)), tags: \(Swift.String(describing: tags)))"}
}

extension CreateServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupId = "BackupId"
        case backupRetentionCount = "BackupRetentionCount"
        case customCertificate = "CustomCertificate"
        case customDomain = "CustomDomain"
        case customPrivateKey = "CustomPrivateKey"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupRetentionCount = backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let customCertificate = customCertificate {
            try encodeContainer.encode(customCertificate, forKey: .customCertificate)
        }
        if let customDomain = customDomain {
            try encodeContainer.encode(customDomain, forKey: .customDomain)
        }
        if let customPrivateKey = customPrivateKey {
            try encodeContainer.encode(customPrivateKey, forKey: .customPrivateKey)
        }
        if let disableAutomatedBackup = disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let engineModel = engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServerOutputError>
}

public struct CreateServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "CreateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<CreateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<CreateServerOutputError>
}

public struct CreateServerInput: Swift.Equatable {
    /// <p>
    ///         Associate a public IP address with a server that you are launching. Valid values are <code>true</code> or <code>false</code>. The default value is <code>true</code>.
    ///       </p>
    public let associatePublicIpAddress: Swift.Bool?
    /// <p>
    ///       If you specify this field, AWS OpsWorks CM creates the server by using the backup represented by BackupId.
    ///     </p>
    public let backupId: Swift.String?
    /// <p>
    ///         The number of automated backups that you want to keep. Whenever a new backup is created, AWS OpsWorks CM deletes the oldest backups if this number is exceeded.
    ///         The default value is <code>1</code>.
    ///       </p>
    public let backupRetentionCount: Swift.Int?
    /// <p>A PEM-formatted HTTPS certificate. The value can be be a single, self-signed certificate, or a certificate chain. If you specify a
    ///       custom certificate, you must also specify values for <code>CustomDomain</code> and <code>CustomPrivateKey</code>. The following are requirements for the <code>CustomCertificate</code> value:</p>
    ///          <ul>
    ///             <li>
    ///                <p>You can provide either a self-signed, custom certificate, or the full certificate chain.</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificate must be a valid X509 certificate, or a certificate chain in PEM format.</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificate must be valid at the time of upload. A certificate can't be used before its validity period begins (the certificate's <code>NotBefore</code> date), or after it expires
    ///         (the certificate's <code>NotAfter</code> date).</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificates common name or subject alternative names (SANs), if present, must match the value of <code>CustomDomain</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificate must match the value of <code>CustomPrivateKey</code>.</p>
    ///             </li>
    ///          </ul>
    public let customCertificate: Swift.String?
    /// <p>An optional public endpoint of a server, such as <code>https://aws.my-company.com</code>. To access the server, create a CNAME DNS record in your preferred DNS service that points the custom
    ///       domain to the endpoint that is generated when the server is created (the value of the CreateServer Endpoint attribute). You cannot access the server by using the
    ///       generated <code>Endpoint</code> value if the server is using a custom domain. If you specify a custom domain, you must also specify values for <code>CustomCertificate</code>
    ///       and <code>CustomPrivateKey</code>.</p>
    public let customDomain: Swift.String?
    /// <p>A private key in PEM format for connecting to the server by using HTTPS. The private key must not be encrypted; it cannot be protected by a password or passphrase.
    ///       If you specify a custom private key, you must also specify values for <code>CustomDomain</code> and <code>CustomCertificate</code>.</p>
    public let customPrivateKey: Swift.String?
    /// <p>
    ///         Enable or disable scheduled backups. Valid values are <code>true</code> or <code>false</code>. The default value is <code>true</code>.
    ///       </p>
    public let disableAutomatedBackup: Swift.Bool?
    /// <p>
    ///         The configuration management engine to use. Valid values include <code>ChefAutomate</code> and <code>Puppet</code>.
    ///       </p>
    public let engine: Swift.String?
    /// <p>Optional engine attributes on a specified server.
    ///     </p>
    ///          <p class="title">
    ///             <b>Attributes accepted in a Chef createServer request:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_AUTOMATE_PIVOTAL_KEY</code>: A
    ///       base64-encoded RSA public key. The corresponding private key is required to
    ///       access the Chef API. When no CHEF_AUTOMATE_PIVOTAL_KEY is set, a private key is
    ///       generated and returned in the response.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_AUTOMATE_ADMIN_PASSWORD</code>:
    ///       The password for the administrative user in the Chef Automate web-based dashboard. The
    ///       password length is a minimum of eight characters, and a maximum of 32. The
    ///       password can contain letters, numbers, and special characters
    ///       (!/@#$%^&+=_). The password must contain at least one lower case letter, one upper
    ///       case letter, one number, and one special character. When no CHEF_AUTOMATE_ADMIN_PASSWORD is set, one is
    ///       generated and returned in the response.</p>
    ///             </li>
    ///          </ul>
    ///          <p class="title">
    ///             <b>Attributes accepted in a Puppet createServer request:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_ADMIN_PASSWORD</code>: To work with the Puppet Enterprise console, a password must use ASCII characters.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_R10K_REMOTE</code>: The r10k remote is the URL of your control repository
    ///         (for example, ssh://git@your.git-repo.com:user/control-repo.git). Specifying an r10k remote opens TCP port 8170.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_R10K_PRIVATE_KEY</code>: If you are using a private Git repository, add
    ///         PUPPET_R10K_PRIVATE_KEY to specify a PEM-encoded private SSH key.</p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
    /// <p>
    ///         The engine model of the server. Valid values in this release include <code>Monolithic</code> for Puppet and <code>Single</code> for Chef.
    ///       </p>
    public let engineModel: Swift.String?
    /// <p>
    ///         The major release version of the engine that you want to use. For a Chef server, the valid value for EngineVersion
    ///         is currently <code>2</code>. For a Puppet server, valid values are <code>2019</code> or <code>2017</code>.
    ///       </p>
    public let engineVersion: Swift.String?
    /// <p>
    ///         The ARN of the instance profile that your Amazon EC2
    ///         instances use. Although the AWS OpsWorks console typically creates
    ///         the instance profile for you, if you are using API commands instead, run the service-role-creation.yaml
    ///         AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml.
    ///         This template creates a CloudFormation stack that includes the instance profile you need.
    ///
    ///       </p>
    public let instanceProfileArn: Swift.String?
    /// <p>
    ///         The Amazon EC2 instance type to use. For example, <code>m5.large</code>.
    ///       </p>
    public let instanceType: Swift.String?
    /// <p>
    ///         The Amazon EC2 key pair to set for the instance. This parameter is optional; if desired, you may specify this parameter to connect to your instances by using SSH.
    ///       </p>
    public let keyPair: Swift.String?
    /// <p>
    ///       The start time for a one-hour period during which AWS OpsWorks CM backs up application-level data on your server
    ///       if automated backups are enabled. Valid values must be specified in one of the following formats:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HH:MM</code> for daily backups</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DDD:HH:MM</code> for weekly backups</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>MM</code> must be specified as <code>00</code>. The specified time is in coordinated universal time (UTC). The default value is a random, daily start time.</p>
    ///          <p>
    ///             <b>Example:</b>
    ///             <code>08:00</code>, which represents a daily start time of 08:00 UTC.</p>
    ///          <p>
    ///             <b>Example:</b>
    ///             <code>Mon:08:00</code>, which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)</p>
    public let preferredBackupWindow: Swift.String?
    /// <p>
    ///       The start time for a one-hour period each week during which AWS OpsWorks CM performs maintenance on the instance.
    ///       Valid values must be specified in the following format: <code>DDD:HH:MM</code>. <code>MM</code> must be specified as <code>00</code>. The specified time is in coordinated universal time (UTC).
    ///       The default value is a random one-hour period on Tuesday, Wednesday, or Friday. See <code>TimeWindowDefinition</code> for more information.
    ///     </p>
    ///          <p>
    ///             <b>Example:</b>
    ///             <code>Mon:08:00</code>,
    ///       which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)
    ///     </p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>
    ///       A list of security group IDs to attach to the Amazon EC2 instance. If you add this parameter, the specified security groups
    ///       must be within the VPC that is specified by <code>SubnetIds</code>.
    ///     </p>
    ///          <p>
    ///       If you do not specify this parameter, AWS OpsWorks CM creates one new security group that uses TCP ports 22 and 443, open to
    ///       0.0.0.0/0 (everyone).
    ///     </p>
    public let securityGroupIds: [Swift.String]?
    /// <p>
    ///         The name of the server. The server name must be unique within your AWS account, within each region.
    ///         Server names must start with a letter; then letters, numbers, or hyphens (-) are allowed, up to a maximum of 40 characters.
    ///       </p>
    public let serverName: Swift.String?
    /// <p>
    ///       The service role that the AWS OpsWorks CM service backend uses to work with your account. Although the AWS OpsWorks management console typically creates
    ///       the service role for you, if you are using the AWS CLI or API commands,
    ///       run the service-role-creation.yaml AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml.
    ///       This template creates a CloudFormation stack that includes the service role and instance profile that you need.
    ///     </p>
    public let serviceRoleArn: Swift.String?
    /// <p>
    ///       The IDs of subnets in which to launch the server EC2 instance.
    ///     </p>
    ///          <p>
    ///       Amazon EC2-Classic customers: This field is required. All servers must run within a VPC. The VPC must have "Auto Assign Public IP" enabled.
    ///     </p>
    ///          <p>
    ///       EC2-VPC customers: This field is optional. If you do not specify subnet IDs, your EC2 instances are created in a default subnet that is selected by Amazon EC2. If you specify subnet IDs, the VPC must have "Auto Assign Public IP" enabled.
    ///     </p>
    ///          <p>For more information about supported Amazon EC2 platforms, see
    ///       <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported Platforms</a>.</p>
    public let subnetIds: [Swift.String]?
    /// <p>A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The key cannot be empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : / @</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : / @</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Leading and trailing white spaces are trimmed from both the key and value.</p>
    ///             </li>
    ///             <li>
    ///                <p>A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server.</p>
    ///             </li>
    ///          </ul>
    public let tags: [OpsWorksCmClientTypes.Tag]?

    public init (
        associatePublicIpAddress: Swift.Bool? = nil,
        backupId: Swift.String? = nil,
        backupRetentionCount: Swift.Int? = nil,
        customCertificate: Swift.String? = nil,
        customDomain: Swift.String? = nil,
        customPrivateKey: Swift.String? = nil,
        disableAutomatedBackup: Swift.Bool? = nil,
        engine: Swift.String? = nil,
        engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]? = nil,
        engineModel: Swift.String? = nil,
        engineVersion: Swift.String? = nil,
        instanceProfileArn: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        keyPair: Swift.String? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        securityGroupIds: [Swift.String]? = nil,
        serverName: Swift.String? = nil,
        serviceRoleArn: Swift.String? = nil,
        subnetIds: [Swift.String]? = nil,
        tags: [OpsWorksCmClientTypes.Tag]? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.backupId = backupId
        self.backupRetentionCount = backupRetentionCount
        self.customCertificate = customCertificate
        self.customDomain = customDomain
        self.customPrivateKey = customPrivateKey
        self.disableAutomatedBackup = disableAutomatedBackup
        self.engine = engine
        self.engineAttributes = engineAttributes
        self.engineModel = engineModel
        self.engineVersion = engineVersion
        self.instanceProfileArn = instanceProfileArn
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
        self.serverName = serverName
        self.serviceRoleArn = serviceRoleArn
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateServerInputBody: Swift.Equatable {
    public let associatePublicIpAddress: Swift.Bool?
    public let customDomain: Swift.String?
    public let customCertificate: Swift.String?
    public let customPrivateKey: Swift.String?
    public let disableAutomatedBackup: Swift.Bool?
    public let engine: Swift.String?
    public let engineModel: Swift.String?
    public let engineVersion: Swift.String?
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
    public let backupRetentionCount: Swift.Int?
    public let serverName: Swift.String?
    public let instanceProfileArn: Swift.String?
    public let instanceType: Swift.String?
    public let keyPair: Swift.String?
    public let preferredMaintenanceWindow: Swift.String?
    public let preferredBackupWindow: Swift.String?
    public let securityGroupIds: [Swift.String]?
    public let serviceRoleArn: Swift.String?
    public let subnetIds: [Swift.String]?
    public let tags: [OpsWorksCmClientTypes.Tag]?
    public let backupId: Swift.String?
}

extension CreateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupId = "BackupId"
        case backupRetentionCount = "BackupRetentionCount"
        case customCertificate = "CustomCertificate"
        case customDomain = "CustomDomain"
        case customPrivateKey = "CustomPrivateKey"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let customCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customCertificate)
        customCertificate = customCertificateDecoded
        let customPrivateKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customPrivateKey)
        customPrivateKey = customPrivateKeyDecoded
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCmClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCmClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension CreateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServerOutputError: Swift.Error, Swift.Equatable {
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateServerOutputResponse(server: \(Swift.String(describing: server)))"}
}

extension CreateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct CreateServerOutputResponse: Swift.Equatable {
    /// <p>The server that is created by the request.
    ///     </p>
    public let server: OpsWorksCmClientTypes.Server?

    public init (
        server: OpsWorksCmClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct CreateServerOutputResponseBody: Swift.Equatable {
    public let server: OpsWorksCmClientTypes.Server?
}

extension CreateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

public struct DeleteBackupInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupOutputError>
}

extension DeleteBackupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupInput(backupId: \(Swift.String(describing: backupId)))"}
}

extension DeleteBackupInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

public struct DeleteBackupInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInput: Swift.Equatable {
    /// <p>The ID of the backup to delete. Run the DescribeBackups command to get a list of backup IDs.
    ///       Backup IDs are in the format <code>ServerName-yyyyMMddHHmmssSSS</code>.
    ///     </p>
    public let backupId: Swift.String?

    public init (
        backupId: Swift.String? = nil
    )
    {
        self.backupId = backupId
    }
}

struct DeleteBackupInputBody: Swift.Equatable {
    public let backupId: Swift.String?
}

extension DeleteBackupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension DeleteBackupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteBackupOutputResponse()"}
}

extension DeleteBackupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteBackupOutputResponseBody: Swift.Equatable {
}

extension DeleteBackupOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct DeleteServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServerOutputError>
}

extension DeleteServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServerInput(serverName: \(Swift.String(describing: serverName)))"}
}

extension DeleteServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DeleteServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServerOutputError>
}

public struct DeleteServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DeleteServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DeleteServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DeleteServerOutputError>
}

public struct DeleteServerInput: Swift.Equatable {
    /// <p>The ID of the server to delete.</p>
    public let serverName: Swift.String?

    public init (
        serverName: Swift.String? = nil
    )
    {
        self.serverName = serverName
    }
}

struct DeleteServerInputBody: Swift.Equatable {
    public let serverName: Swift.String?
}

extension DeleteServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DeleteServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServerOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeleteServerOutputResponse()"}
}

extension DeleteServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerOutputResponse: Swift.Equatable {

    public init() {}
}

struct DeleteServerOutputResponseBody: Swift.Equatable {
}

extension DeleteServerOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesInput()"}
}

extension DescribeAccountAttributesInput: Swift.Encodable, ClientRuntime.Reflection {

    public func encode(to encoder: Swift.Encoder) throws {
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInput: Swift.Equatable {

    public init() {}
}

struct DescribeAccountAttributesInputBody: Swift.Equatable {
}

extension DescribeAccountAttributesInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccountAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeAccountAttributesOutputResponse(attributes: \(Swift.String(describing: attributes)))"}
}

extension DescribeAccountAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct DescribeAccountAttributesOutputResponse: Swift.Equatable {
    /// <p>
    ///       The attributes that are currently set for the account.
    ///     </p>
    public let attributes: [OpsWorksCmClientTypes.AccountAttribute]?

    public init (
        attributes: [OpsWorksCmClientTypes.AccountAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct DescribeAccountAttributesOutputResponseBody: Swift.Equatable {
    public let attributes: [OpsWorksCmClientTypes.AccountAttribute]?
}

extension DescribeAccountAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.AccountAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[OpsWorksCmClientTypes.AccountAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [OpsWorksCmClientTypes.AccountAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

public struct DescribeBackupsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupsOutputError>
}

extension DescribeBackupsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupsInput(backupId: \(Swift.String(describing: backupId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serverName: \(Swift.String(describing: serverName)))"}
}

extension DescribeBackupsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeBackupsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeBackupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInput: Swift.Equatable {
    /// <p>Describes a single backup.
    ///     </p>
    public let backupId: Swift.String?
    /// <p>This is not currently implemented for <code>DescribeBackups</code> requests.</p>
    public let maxResults: Swift.Int?
    /// <p>This is not currently implemented for <code>DescribeBackups</code> requests.</p>
    public let nextToken: Swift.String?
    /// <p>Returns backups for the server with the specified ServerName.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        backupId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeBackupsInputBody: Swift.Equatable {
    public let backupId: Swift.String?
    public let serverName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeBackupsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeBackupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeBackupsOutputResponse(backups: \(Swift.String(describing: backups)), nextToken: \(Swift.String(describing: nextToken)))"}
}

extension DescribeBackupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeBackupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.backups = output.backups
            self.nextToken = output.nextToken
        } else {
            self.backups = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBackupsOutputResponse: Swift.Equatable {
    /// <p>Contains the response to a <code>DescribeBackups</code> request.
    ///     </p>
    public let backups: [OpsWorksCmClientTypes.Backup]?
    /// <p>This is not currently implemented for <code>DescribeBackups</code> requests.</p>
    public let nextToken: Swift.String?

    public init (
        backups: [OpsWorksCmClientTypes.Backup]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

struct DescribeBackupsOutputResponseBody: Swift.Equatable {
    public let backups: [OpsWorksCmClientTypes.Backup]?
    public let nextToken: Swift.String?
}

extension DescribeBackupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backups = "Backups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupsContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.Backup?].self, forKey: .backups)
        var backupsDecoded0:[OpsWorksCmClientTypes.Backup]? = nil
        if let backupsContainer = backupsContainer {
            backupsDecoded0 = [OpsWorksCmClientTypes.Backup]()
            for structure0 in backupsContainer {
                if let structure0 = structure0 {
                    backupsDecoded0?.append(structure0)
                }
            }
        }
        backups = backupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEventsInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serverName: \(Swift.String(describing: serverName)))"}
}

extension DescribeEventsInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Swift.Equatable {
    /// <p>To receive a paginated response, use this parameter to specify the maximum number
    ///       of results to be returned with a single call. If the number of available results exceeds
    ///       this maximum, the response includes a <code>NextToken</code> value that you can assign to the <code>NextToken</code>
    ///       request parameter to get the next set of results.
    ///     </p>
    public let maxResults: Swift.Int?
    /// <p>NextToken is a string that is returned in some command responses. It indicates that
    ///       not all entries have been returned, and that you must run at least one more request to get remaining
    ///       items. To get remaining results, call <code>DescribeEvents</code> again, and assign the token from the previous
    ///       results as the value of the <code>nextToken</code> parameter. If there are no more results,
    ///       the response object's <code>nextToken</code> parameter value is <code>null</code>.
    ///       Setting a <code>nextToken</code> value that was not returned in
    ///       your previous results causes an <code>InvalidNextTokenException</code> to occur.
    ///     </p>
    public let nextToken: Swift.String?
    /// <p>The name of the server for which you want to view events.</p>
    public let serverName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    public let serverName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeEventsOutputResponse(nextToken: \(Swift.String(describing: nextToken)), serverEvents: \(Swift.String(describing: serverEvents)))"}
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverEvents = output.serverEvents
        } else {
            self.nextToken = nil
            self.serverEvents = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// <p>NextToken is a string that is returned in some command responses. It indicates that
    ///       not all entries have been returned, and that you must run at least one more request to get remaining
    ///       items. To get remaining results, call <code>DescribeEvents</code> again, and assign the token from the previous
    ///       results as the value of the <code>nextToken</code> parameter. If there are no more results,
    ///       the response object's <code>nextToken</code> parameter value is <code>null</code>.
    ///       Setting a <code>nextToken</code> value that was not returned in
    ///       your previous results causes an <code>InvalidNextTokenException</code> to occur.
    ///     </p>
    public let nextToken: Swift.String?
    /// <p>Contains the response to a <code>DescribeEvents</code> request.
    ///     </p>
    public let serverEvents: [OpsWorksCmClientTypes.ServerEvent]?

    public init (
        nextToken: Swift.String? = nil,
        serverEvents: [OpsWorksCmClientTypes.ServerEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverEvents = serverEvents
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    public let serverEvents: [OpsWorksCmClientTypes.ServerEvent]?
    public let nextToken: Swift.String?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case serverEvents = "ServerEvents"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverEventsContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.ServerEvent?].self, forKey: .serverEvents)
        var serverEventsDecoded0:[OpsWorksCmClientTypes.ServerEvent]? = nil
        if let serverEventsContainer = serverEventsContainer {
            serverEventsDecoded0 = [OpsWorksCmClientTypes.ServerEvent]()
            for structure0 in serverEventsContainer {
                if let structure0 = structure0 {
                    serverEventsDecoded0?.append(structure0)
                }
            }
        }
        serverEvents = serverEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeNodeAssociationStatusInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNodeAssociationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNodeAssociationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNodeAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNodeAssociationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNodeAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNodeAssociationStatusOutputError>
}

extension DescribeNodeAssociationStatusInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNodeAssociationStatusInput(nodeAssociationStatusToken: \(Swift.String(describing: nodeAssociationStatusToken)), serverName: \(Swift.String(describing: serverName)))"}
}

extension DescribeNodeAssociationStatusInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeAssociationStatusToken = nodeAssociationStatusToken {
            try encodeContainer.encode(nodeAssociationStatusToken, forKey: .nodeAssociationStatusToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeNodeAssociationStatusInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNodeAssociationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNodeAssociationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNodeAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNodeAssociationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNodeAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNodeAssociationStatusOutputError>
}

public struct DescribeNodeAssociationStatusInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeNodeAssociationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeNodeAssociationStatusInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeNodeAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeNodeAssociationStatusInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeNodeAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeNodeAssociationStatusOutputError>
}

public struct DescribeNodeAssociationStatusInput: Swift.Equatable {
    /// <p>The token returned in either the AssociateNodeResponse or the DisassociateNodeResponse.
    ///     </p>
    public let nodeAssociationStatusToken: Swift.String?
    /// <p>The name of the server from which to disassociate the node.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        nodeAssociationStatusToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
        self.serverName = serverName
    }
}

struct DescribeNodeAssociationStatusInputBody: Swift.Equatable {
    public let nodeAssociationStatusToken: Swift.String?
    public let serverName: Swift.String?
}

extension DescribeNodeAssociationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DescribeNodeAssociationStatusOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNodeAssociationStatusOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNodeAssociationStatusOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNodeAssociationStatusOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeNodeAssociationStatusOutputResponse(engineAttributes: \(Swift.String(describing: engineAttributes)), nodeAssociationStatus: \(Swift.String(describing: nodeAssociationStatus)))"}
}

extension DescribeNodeAssociationStatusOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeNodeAssociationStatusOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineAttributes = output.engineAttributes
            self.nodeAssociationStatus = output.nodeAssociationStatus
        } else {
            self.engineAttributes = nil
            self.nodeAssociationStatus = nil
        }
    }
}

public struct DescribeNodeAssociationStatusOutputResponse: Swift.Equatable {
    /// <p>Attributes specific to the node association.
    ///       In Puppet, the attibute PUPPET_NODE_CERT contains the signed certificate (the result of the CSR).
    ///     </p>
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
    /// <p>The status of the association or disassociation request.
    ///     </p>
    ///          <p class="title">
    ///             <b>Possible values:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCESS</code>: The association or disassociation succeeded.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The association or disassociation failed.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code>: The association or disassociation is still in progress.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let nodeAssociationStatus: OpsWorksCmClientTypes.NodeAssociationStatus?

    public init (
        engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]? = nil,
        nodeAssociationStatus: OpsWorksCmClientTypes.NodeAssociationStatus? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeAssociationStatus = nodeAssociationStatus
    }
}

struct DescribeNodeAssociationStatusOutputResponseBody: Swift.Equatable {
    public let nodeAssociationStatus: OpsWorksCmClientTypes.NodeAssociationStatus?
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
}

extension DescribeNodeAssociationStatusOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeAssociationStatus = "NodeAssociationStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.NodeAssociationStatus.self, forKey: .nodeAssociationStatus)
        nodeAssociationStatus = nodeAssociationStatusDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCmClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCmClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

public struct DescribeServersInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServersOutputError>
}

extension DescribeServersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServersInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), serverName: \(Swift.String(describing: serverName)))"}
}

extension DescribeServersInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeServersInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServersOutputError>
}

public struct DescribeServersInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DescribeServersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DescribeServersInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DescribeServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DescribeServersInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DescribeServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DescribeServersOutputError>
}

public struct DescribeServersInput: Swift.Equatable {
    /// <p>This is not currently implemented for <code>DescribeServers</code> requests.
    ///     </p>
    public let maxResults: Swift.Int?
    /// <p>This is not currently implemented for <code>DescribeServers</code> requests.
    ///     </p>
    public let nextToken: Swift.String?
    /// <p>Describes the server with the specified ServerName.</p>
    public let serverName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeServersInputBody: Swift.Equatable {
    public let serverName: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension DescribeServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServersOutputError: Swift.Error, Swift.Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServersOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DescribeServersOutputResponse(nextToken: \(Swift.String(describing: nextToken)), servers: \(Swift.String(describing: servers)))"}
}

extension DescribeServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct DescribeServersOutputResponse: Swift.Equatable {
    /// <p>This is not currently implemented for <code>DescribeServers</code> requests.
    ///     </p>
    public let nextToken: Swift.String?
    /// <p>Contains the response to a <code>DescribeServers</code> request.</p>
    ///          <p>
    ///             <i>For Chef Automate servers:</i>  If <code>DescribeServersResponse$Servers$EngineAttributes</code> includes
    ///       CHEF_MAJOR_UPGRADE_AVAILABLE, you can upgrade the Chef Automate server to Chef Automate 2. To be eligible for upgrade, a server running
    ///       Chef Automate 1 must have had at least one successful maintenance run after November 1, 2019.</p>
    ///          <p>
    ///             <i>For Puppet servers:</i>
    ///             <code>DescribeServersResponse$Servers$EngineAttributes</code> contains
    ///       the following two responses:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_API_CA_CERT</code>, the PEM-encoded CA certificate that is used by the Puppet API over TCP port number 8140.
    ///         The CA certificate is also used to sign node certificates.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_API_CRL</code>, a certificate revocation list. The certificate revocation list is for internal
    ///         maintenance purposes only. For more information about the Puppet certificate revocation list, see
    ///         <a href="https://puppet.com/docs/puppet/5.5/man/certificate_revocation_list.html">Man Page: puppet certificate_revocation_list</a> in the Puppet documentation.</p>
    ///             </li>
    ///          </ul>
    public let servers: [OpsWorksCmClientTypes.Server]?

    public init (
        nextToken: Swift.String? = nil,
        servers: [OpsWorksCmClientTypes.Server]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct DescribeServersOutputResponseBody: Swift.Equatable {
    public let servers: [OpsWorksCmClientTypes.Server]?
    public let nextToken: Swift.String?
}

extension DescribeServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serversContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.Server?].self, forKey: .servers)
        var serversDecoded0:[OpsWorksCmClientTypes.Server]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [OpsWorksCmClientTypes.Server]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateNodeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateNodeOutputError>
}

extension DisassociateNodeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateNodeInput(engineAttributes: \(Swift.String(describing: engineAttributes)), nodeName: \(Swift.String(describing: nodeName)), serverName: \(Swift.String(describing: serverName)))"}
}

extension DisassociateNodeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let nodeName = nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DisassociateNodeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateNodeOutputError>
}

public struct DisassociateNodeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "DisassociateNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<DisassociateNodeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<DisassociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<DisassociateNodeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<DisassociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<DisassociateNodeOutputError>
}

public struct DisassociateNodeInput: Swift.Equatable {
    /// <p>Engine attributes that are used for disassociating the node. No attributes are required for Puppet.
    ///     </p>
    ///          <p class="title">
    ///             <b>Attributes required in a DisassociateNode request for Chef</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_ORGANIZATION</code>: The Chef organization
    ///           with which the node was associated. By default only one organization
    ///           named <code>default</code> can exist.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
    /// <p>The name of the client node.
    ///     </p>
    public let nodeName: Swift.String?
    /// <p>The name of the server from which to disassociate the node.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]? = nil,
        nodeName: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

struct DisassociateNodeInputBody: Swift.Equatable {
    public let serverName: Swift.String?
    public let nodeName: Swift.String?
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
}

extension DisassociateNodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCmClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCmClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension DisassociateNodeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateNodeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateNodeOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateNodeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisassociateNodeOutputResponse(nodeAssociationStatusToken: \(Swift.String(describing: nodeAssociationStatusToken)))"}
}

extension DisassociateNodeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisassociateNodeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nodeAssociationStatusToken = output.nodeAssociationStatusToken
        } else {
            self.nodeAssociationStatusToken = nil
        }
    }
}

public struct DisassociateNodeOutputResponse: Swift.Equatable {
    /// <p>Contains a token which can be passed to the
    ///       <code>DescribeNodeAssociationStatus</code> API call to get the status of
    ///       the disassociation request.
    ///     </p>
    public let nodeAssociationStatusToken: Swift.String?

    public init (
        nodeAssociationStatusToken: Swift.String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

struct DisassociateNodeOutputResponseBody: Swift.Equatable {
    public let nodeAssociationStatusToken: Swift.String?
}

extension DisassociateNodeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
    }
}

extension OpsWorksCmClientTypes.EngineAttribute: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OpsWorksCmClientTypes.EngineAttribute: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngineAttribute(name: \(Swift.String(describing: name)), value: \(Swift.String(describing: value)))"}
}

extension OpsWorksCmClientTypes {
    /// <p>A name and value pair that is specific to the engine of the server.
    ///     </p>
    public struct EngineAttribute: Swift.Equatable {
        /// <p>The name of the engine attribute.
        ///     </p>
        public let name: Swift.String?
        /// <p>The value of the engine attribute.
        ///     </p>
        public let value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

public struct ExportServerEngineAttributeInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportServerEngineAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportServerEngineAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportServerEngineAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportServerEngineAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportServerEngineAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportServerEngineAttributeOutputError>
}

extension ExportServerEngineAttributeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportServerEngineAttributeInput(exportAttributeName: \(Swift.String(describing: exportAttributeName)), inputAttributes: \(Swift.String(describing: inputAttributes)), serverName: \(Swift.String(describing: serverName)))"}
}

extension ExportServerEngineAttributeInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportAttributeName = "ExportAttributeName"
        case inputAttributes = "InputAttributes"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportAttributeName = exportAttributeName {
            try encodeContainer.encode(exportAttributeName, forKey: .exportAttributeName)
        }
        if let inputAttributes = inputAttributes {
            var inputAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputAttributes)
            for engineattributes0 in inputAttributes {
                try inputAttributesContainer.encode(engineattributes0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct ExportServerEngineAttributeInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportServerEngineAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportServerEngineAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportServerEngineAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportServerEngineAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportServerEngineAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportServerEngineAttributeOutputError>
}

public struct ExportServerEngineAttributeInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ExportServerEngineAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ExportServerEngineAttributeInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ExportServerEngineAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ExportServerEngineAttributeInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ExportServerEngineAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ExportServerEngineAttributeOutputError>
}

public struct ExportServerEngineAttributeInput: Swift.Equatable {
    /// <p>The name of the export attribute. Currently, the supported export attribute is <code>Userdata</code>.
    ///       This exports a user data script that includes parameters and values provided in the <code>InputAttributes</code> list.</p>
    public let exportAttributeName: Swift.String?
    /// <p>The list of engine attributes. The list type is <code>EngineAttribute</code>. An <code>EngineAttribute</code> list item
    ///       is a pair that includes an attribute name and its value. For the <code>Userdata</code> ExportAttributeName, the following are
    ///       supported engine attribute names.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>RunList</b> In Chef, a list of roles or recipes that are run in the specified order.
    ///         In Puppet, this parameter is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>OrganizationName</b> In Chef, an organization name. AWS OpsWorks for Chef Automate
    ///         always creates the organization <code>default</code>. In Puppet, this parameter is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>NodeEnvironment</b> In Chef, a node environment (for example, development, staging, or one-box).
    ///         In Puppet, this parameter is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>NodeClientVersion</b> In Chef, the version of the Chef engine (three numbers separated
    ///         by dots, such as 13.8.5). If this attribute is empty, OpsWorks for Chef Automate uses the most current version. In Puppet,
    ///         this parameter is ignored.</p>
    ///             </li>
    ///          </ul>
    public let inputAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
    /// <p>The name of the server from which you are exporting the attribute.</p>
    public let serverName: Swift.String?

    public init (
        exportAttributeName: Swift.String? = nil,
        inputAttributes: [OpsWorksCmClientTypes.EngineAttribute]? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.exportAttributeName = exportAttributeName
        self.inputAttributes = inputAttributes
        self.serverName = serverName
    }
}

struct ExportServerEngineAttributeInputBody: Swift.Equatable {
    public let exportAttributeName: Swift.String?
    public let serverName: Swift.String?
    public let inputAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
}

extension ExportServerEngineAttributeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportAttributeName = "ExportAttributeName"
        case inputAttributes = "InputAttributes"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAttributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportAttributeName)
        exportAttributeName = exportAttributeNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let inputAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.EngineAttribute?].self, forKey: .inputAttributes)
        var inputAttributesDecoded0:[OpsWorksCmClientTypes.EngineAttribute]? = nil
        if let inputAttributesContainer = inputAttributesContainer {
            inputAttributesDecoded0 = [OpsWorksCmClientTypes.EngineAttribute]()
            for structure0 in inputAttributesContainer {
                if let structure0 = structure0 {
                    inputAttributesDecoded0?.append(structure0)
                }
            }
        }
        inputAttributes = inputAttributesDecoded0
    }
}

extension ExportServerEngineAttributeOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportServerEngineAttributeOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportServerEngineAttributeOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportServerEngineAttributeOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExportServerEngineAttributeOutputResponse(engineAttribute: \(Swift.String(describing: engineAttribute)), serverName: \(Swift.String(describing: serverName)))"}
}

extension ExportServerEngineAttributeOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ExportServerEngineAttributeOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.engineAttribute = output.engineAttribute
            self.serverName = output.serverName
        } else {
            self.engineAttribute = nil
            self.serverName = nil
        }
    }
}

public struct ExportServerEngineAttributeOutputResponse: Swift.Equatable {
    /// <p>The requested engine attribute pair with attribute name and value.</p>
    public let engineAttribute: OpsWorksCmClientTypes.EngineAttribute?
    /// <p>The server name used in the request.</p>
    public let serverName: Swift.String?

    public init (
        engineAttribute: OpsWorksCmClientTypes.EngineAttribute? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttribute = engineAttribute
        self.serverName = serverName
    }
}

struct ExportServerEngineAttributeOutputResponseBody: Swift.Equatable {
    public let engineAttribute: OpsWorksCmClientTypes.EngineAttribute?
    public let serverName: Swift.String?
}

extension ExportServerEngineAttributeOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttribute = "EngineAttribute"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineAttributeDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.EngineAttribute.self, forKey: .engineAttribute)
        engineAttribute = engineAttributeDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension InvalidNextTokenException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidNextTokenException(message: \(Swift.String(describing: message)))"}
}

extension InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This occurs when the provided nextToken is not valid.
///     </p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Error or informational message that can contain more detail about a nextToken failure.
    ///     </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvalidStateException(message: \(Swift.String(describing: message)))"}
}

extension InvalidStateException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is in a state that does not allow you to perform a specified action.
///     </p>
public struct InvalidStateException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Error or informational message that provides more detail if a resource is
    ///       in a state that is not valid for performing a specified action.
    ///     </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension InvalidStateExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LimitExceededException(message: \(Swift.String(describing: message)))"}
}

extension LimitExceededException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit of servers or backups has been reached.
///     </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Error or informational message that the maximum allowed number of servers or backups has been exceeded.
    ///     </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceArn: \(Swift.String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// <p>To receive a paginated response, use this parameter to specify the maximum number
    ///         of results to be returned with a single call. If the number of available results exceeds
    ///         this maximum, the response includes a <code>NextToken</code> value that you can assign to the <code>NextToken</code>
    ///         request parameter to get the next set of results.</p>
    public let maxResults: Swift.Int?
    /// <p>NextToken is a string that is returned in some command responses. It indicates that
    ///         not all entries have been returned, and that you must run at least one more request to get remaining
    ///         items. To get remaining results, call <code>ListTagsForResource</code> again, and assign the token from the previous
    ///         results as the value of the <code>nextToken</code> parameter. If there are no more results,
    ///         the response object's <code>nextToken</code> parameter value is <code>null</code>.
    ///         Setting a <code>nextToken</code> value that was not returned in
    ///         your previous results causes an <code>InvalidNextTokenException</code> to occur.</p>
    public let nextToken: Swift.String?
    /// <p>The Amazon Resource Number (ARN) of an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server for which you want to show applied tags. For example,
    ///         <code>arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE</code>.</p>
    public let resourceArn: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let nextToken: Swift.String?
    public let maxResults: Swift.Int?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutputResponse(nextToken: \(Swift.String(describing: nextToken)), tags: \(Swift.String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// <p>A token that you can use as the value of <code>NextToken</code> in subsequent calls to the API to show more results.</p>
    public let nextToken: Swift.String?
    /// <p>Tags that have been applied to the resource.</p>
    public let tags: [OpsWorksCmClientTypes.Tag]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [OpsWorksCmClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    public let tags: [OpsWorksCmClientTypes.Tag]?
    public let nextToken: Swift.String?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension OpsWorksCmClientTypes {
    public enum MaintenanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceStatus] {
            return [
                .failed,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceStatus(rawValue: rawValue) ?? MaintenanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension OpsWorksCmClientTypes {
    /// <p>The status of the association or disassociation request.
    ///     </p>
    ///          <p class="title">
    ///             <b>Possible values:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCESS</code>: The association or disassociation succeeded.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The association or disassociation failed.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code>: The association or disassociation is still in progress.
    ///       </p>
    ///             </li>
    ///          </ul>
    public enum NodeAssociationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [NodeAssociationStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NodeAssociationStatus(rawValue: rawValue) ?? NodeAssociationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceAlreadyExistsException(message: \(Swift.String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource cannot be created because it already exists.
///     </p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Error or informational message in response to a CreateServer request that a resource cannot be created because it already exists.
    ///     </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceNotFoundException(message: \(Swift.String(describing: message)))"}
}

extension ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource does not exist, or access was denied.
///     </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Error or informational message that can contain more detail about problems locating or accessing a resource.
    ///     </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreServerOutputError>
}

extension RestoreServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreServerInput(backupId: \(Swift.String(describing: backupId)), instanceType: \(Swift.String(describing: instanceType)), keyPair: \(Swift.String(describing: keyPair)), serverName: \(Swift.String(describing: serverName)))"}
}

extension RestoreServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct RestoreServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreServerOutputError>
}

public struct RestoreServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "RestoreServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<RestoreServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<RestoreServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<RestoreServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<RestoreServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<RestoreServerOutputError>
}

public struct RestoreServerInput: Swift.Equatable {
    /// <p> The ID of the backup that you want to use to restore a server.
    ///     </p>
    public let backupId: Swift.String?
    /// <p> The type of instance to restore. Valid values must be specified in the following format: <code>^([cm][34]|t2).*</code>
    ///       For example, <code>m5.large</code>. Valid values are <code>m5.large</code>, <code>r5.xlarge</code>, and <code>r5.2xlarge</code>. If you do not specify this parameter,
    ///       RestoreServer uses the instance type from the specified backup.
    ///     </p>
    public let instanceType: Swift.String?
    /// <p> The name of the key pair to set on the new EC2 instance. This can be helpful
    ///       if the administrator no longer has the SSH key.
    ///     </p>
    public let keyPair: Swift.String?
    /// <p> The name of the server that you want to restore.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        backupId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        keyPair: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupId = backupId
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.serverName = serverName
    }
}

struct RestoreServerInputBody: Swift.Equatable {
    public let backupId: Swift.String?
    public let serverName: Swift.String?
    public let instanceType: Swift.String?
    public let keyPair: Swift.String?
}

extension RestoreServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupId = "BackupId"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

extension RestoreServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreServerOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RestoreServerOutputResponse(server: \(Swift.String(describing: server)))"}
}

extension RestoreServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RestoreServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct RestoreServerOutputResponse: Swift.Equatable {
    /// <p>Describes a configuration management server.
    ///     </p>
    public let server: OpsWorksCmClientTypes.Server?

    public init (
        server: OpsWorksCmClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct RestoreServerOutputResponseBody: Swift.Equatable {
    public let server: OpsWorksCmClientTypes.Server?
}

extension RestoreServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension OpsWorksCmClientTypes.Server: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupRetentionCount = "BackupRetentionCount"
        case cloudFormationStackArn = "CloudFormationStackArn"
        case createdAt = "CreatedAt"
        case customDomain = "CustomDomain"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case maintenanceStatus = "MaintenanceStatus"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverArn = "ServerArn"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case status = "Status"
        case statusReason = "StatusReason"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let backupRetentionCount = backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let cloudFormationStackArn = cloudFormationStackArn {
            try encodeContainer.encode(cloudFormationStackArn, forKey: .cloudFormationStackArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let customDomain = customDomain {
            try encodeContainer.encode(customDomain, forKey: .customDomain)
        }
        if let disableAutomatedBackup = disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let engineModel = engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let maintenanceStatus = maintenanceStatus {
            try encodeContainer.encode(maintenanceStatus.rawValue, forKey: .maintenanceStatus)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let serverArn = serverArn {
            try encodeContainer.encode(serverArn, forKey: .serverArn)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let cloudFormationStackArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cloudFormationStackArn)
        cloudFormationStackArn = cloudFormationStackArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCmClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCmClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let maintenanceStatusDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.MaintenanceStatus.self, forKey: .maintenanceStatus)
        maintenanceStatus = maintenanceStatusDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[Swift.String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [Swift.String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.ServerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let serverArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverArn)
        serverArn = serverArnDecoded
    }
}

extension OpsWorksCmClientTypes.Server: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Server(associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), backupRetentionCount: \(Swift.String(describing: backupRetentionCount)), cloudFormationStackArn: \(Swift.String(describing: cloudFormationStackArn)), createdAt: \(Swift.String(describing: createdAt)), customDomain: \(Swift.String(describing: customDomain)), disableAutomatedBackup: \(Swift.String(describing: disableAutomatedBackup)), endpoint: \(Swift.String(describing: endpoint)), engine: \(Swift.String(describing: engine)), engineAttributes: \(Swift.String(describing: engineAttributes)), engineModel: \(Swift.String(describing: engineModel)), engineVersion: \(Swift.String(describing: engineVersion)), instanceProfileArn: \(Swift.String(describing: instanceProfileArn)), instanceType: \(Swift.String(describing: instanceType)), keyPair: \(Swift.String(describing: keyPair)), maintenanceStatus: \(Swift.String(describing: maintenanceStatus)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), serverArn: \(Swift.String(describing: serverArn)), serverName: \(Swift.String(describing: serverName)), serviceRoleArn: \(Swift.String(describing: serviceRoleArn)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), subnetIds: \(Swift.String(describing: subnetIds)))"}
}

extension OpsWorksCmClientTypes {
    /// <p>Describes a configuration management server.
    ///     </p>
    public struct Server: Swift.Equatable {
        /// <p>Associate a public IP address with a server that you are launching.
        ///     </p>
        public let associatePublicIpAddress: Swift.Bool?
        /// <p>The number of automated backups to keep.
        ///     </p>
        public let backupRetentionCount: Swift.Int?
        /// <p>The ARN of the CloudFormation stack that was used to create the server.
        ///     </p>
        public let cloudFormationStackArn: Swift.String?
        /// <p>Time stamp of server creation. Example <code>2016-07-29T13:38:47.520Z</code>
        ///          </p>
        public let createdAt: ClientRuntime.Date?
        /// <p>An optional public endpoint of a server, such as <code>https://aws.my-company.com</code>.
        ///       You cannot access the server by using the <code>Endpoint</code> value if the server has a <code>CustomDomain</code> specified.</p>
        public let customDomain: Swift.String?
        /// <p>Disables automated backups. The number of stored backups is dependent on the value of PreferredBackupCount.
        ///     </p>
        public let disableAutomatedBackup: Swift.Bool?
        /// <p>
        ///       A DNS name that can be used to access the engine. Example: <code>myserver-asdfghjkl.us-east-1.opsworks.io</code>.
        ///       You cannot access the server by using the <code>Endpoint</code> value if the server has a <code>CustomDomain</code> specified.
        ///     </p>
        public let endpoint: Swift.String?
        /// <p>The engine type of the server. Valid values in this release include <code>ChefAutomate</code> and <code>Puppet</code>.
        ///     </p>
        public let engine: Swift.String?
        /// <p>The response of a createServer() request returns the master
        ///     credential to access the server in EngineAttributes. These
        ///     credentials are not stored by AWS OpsWorks CM; they are returned only as part of the result of createServer().
        ///     </p>
        ///          <p class="title">
        ///             <b>Attributes returned in a createServer response for Chef</b>
        ///          </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>CHEF_AUTOMATE_PIVOTAL_KEY</code>: A base64-encoded RSA private key that is
        ///       generated by AWS OpsWorks for Chef Automate. This private key is required to access
        ///       the Chef API.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>CHEF_STARTER_KIT</code>: A base64-encoded ZIP file.
        ///       The ZIP file contains a Chef starter kit, which includes a README, a
        ///       configuration file, and the required RSA private key. Save this file, unzip it,
        ///       and then change to the directory where you've unzipped the file contents.
        ///       From this directory, you can run Knife commands.</p>
        ///             </li>
        ///          </ul>
        ///          <p class="title">
        ///             <b>Attributes returned in a createServer response for Puppet</b>
        ///          </p>
        ///          <ul>
        ///             <li>
        ///                <p>
        ///                   <code>PUPPET_STARTER_KIT</code>: A base64-encoded ZIP file.
        ///         The ZIP file contains a Puppet starter kit, including a README and a
        ///         required private key. Save this file, unzip it,
        ///         and then change to the directory where you've unzipped the file contents.</p>
        ///             </li>
        ///             <li>
        ///                <p>
        ///                   <code>PUPPET_ADMIN_PASSWORD</code>: An administrator password that you can use to sign in to the Puppet Enterprise console after the server is online.</p>
        ///             </li>
        ///          </ul>
        public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
        /// <p>The engine model of the server. Valid values in this release include <code>Monolithic</code> for Puppet and <code>Single</code> for Chef.
        ///     </p>
        public let engineModel: Swift.String?
        /// <p>The engine version of the server. For a Chef server, the valid value for EngineVersion is
        ///       currently <code>2</code>. For a Puppet server, specify either <code>2019</code> or <code>2017</code>.
        ///     </p>
        public let engineVersion: Swift.String?
        /// <p>The instance profile ARN of the server.
        ///     </p>
        public let instanceProfileArn: Swift.String?
        /// <p>
        ///       The instance type for the server, as specified in the CloudFormation stack. This might not be the same instance type that is shown in the EC2 console.
        ///     </p>
        public let instanceType: Swift.String?
        /// <p>The key pair associated with the server.
        ///     </p>
        public let keyPair: Swift.String?
        /// <p>The status of the most recent server maintenance run. Shows <code>SUCCESS</code> or <code>FAILED</code>.
        ///     </p>
        public let maintenanceStatus: OpsWorksCmClientTypes.MaintenanceStatus?
        /// <p>The preferred backup period specified for the server.
        ///     </p>
        public let preferredBackupWindow: Swift.String?
        /// <p>The preferred maintenance period specified for the server.
        ///     </p>
        public let preferredMaintenanceWindow: Swift.String?
        /// <p>
        ///       The security group IDs for the server, as specified in the CloudFormation stack.
        ///       These might not be the same security groups that are shown in the EC2 console.
        ///     </p>
        public let securityGroupIds: [Swift.String]?
        /// <p>The ARN of the server.
        ///     </p>
        public let serverArn: Swift.String?
        /// <p>The name of the server.
        ///     </p>
        public let serverName: Swift.String?
        /// <p>The service role ARN used to create the server.
        ///     </p>
        public let serviceRoleArn: Swift.String?
        /// <p>
        ///       The server's status. This field displays the states of actions in progress, such as creating, running, or backing up the server,
        ///       as well as the server's health state.
        ///     </p>
        public let status: OpsWorksCmClientTypes.ServerStatus?
        /// <p>
        ///       Depending on the server status, this field has either a human-readable
        ///       message (such as a create or backup error), or an escaped block of JSON (used for health check results).
        ///     </p>
        public let statusReason: Swift.String?
        /// <p>
        ///       The subnet IDs specified in a CreateServer request.
        ///     </p>
        public let subnetIds: [Swift.String]?

        public init (
            associatePublicIpAddress: Swift.Bool? = nil,
            backupRetentionCount: Swift.Int? = nil,
            cloudFormationStackArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            customDomain: Swift.String? = nil,
            disableAutomatedBackup: Swift.Bool? = nil,
            endpoint: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]? = nil,
            engineModel: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            instanceProfileArn: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            keyPair: Swift.String? = nil,
            maintenanceStatus: OpsWorksCmClientTypes.MaintenanceStatus? = nil,
            preferredBackupWindow: Swift.String? = nil,
            preferredMaintenanceWindow: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            serverArn: Swift.String? = nil,
            serverName: Swift.String? = nil,
            serviceRoleArn: Swift.String? = nil,
            status: OpsWorksCmClientTypes.ServerStatus? = nil,
            statusReason: Swift.String? = nil,
            subnetIds: [Swift.String]? = nil
        )
        {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.backupRetentionCount = backupRetentionCount
            self.cloudFormationStackArn = cloudFormationStackArn
            self.createdAt = createdAt
            self.customDomain = customDomain
            self.disableAutomatedBackup = disableAutomatedBackup
            self.endpoint = endpoint
            self.engine = engine
            self.engineAttributes = engineAttributes
            self.engineModel = engineModel
            self.engineVersion = engineVersion
            self.instanceProfileArn = instanceProfileArn
            self.instanceType = instanceType
            self.keyPair = keyPair
            self.maintenanceStatus = maintenanceStatus
            self.preferredBackupWindow = preferredBackupWindow
            self.preferredMaintenanceWindow = preferredMaintenanceWindow
            self.securityGroupIds = securityGroupIds
            self.serverArn = serverArn
            self.serverName = serverName
            self.serviceRoleArn = serviceRoleArn
            self.status = status
            self.statusReason = statusReason
            self.subnetIds = subnetIds
        }
    }

}

extension OpsWorksCmClientTypes.ServerEvent: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case logUrl = "LogUrl"
        case message = "Message"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(ClientRuntime.Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
    }
}

extension OpsWorksCmClientTypes.ServerEvent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ServerEvent(createdAt: \(Swift.String(describing: createdAt)), logUrl: \(Swift.String(describing: logUrl)), message: \(Swift.String(describing: message)), serverName: \(Swift.String(describing: serverName)))"}
}

extension OpsWorksCmClientTypes {
    /// <p>An event that is related to the server, such as the start of maintenance or backup.
    ///     </p>
    public struct ServerEvent: Swift.Equatable {
        /// <p>The time when the event occurred.
        ///     </p>
        public let createdAt: ClientRuntime.Date?
        /// <p>The Amazon S3 URL of the event's log file.</p>
        public let logUrl: Swift.String?
        /// <p>A human-readable informational or status message.</p>
        public let message: Swift.String?
        /// <p>The name of the server on or for which the event occurred.
        ///     </p>
        public let serverName: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            logUrl: Swift.String? = nil,
            message: Swift.String? = nil,
            serverName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.logUrl = logUrl
            self.message = message
            self.serverName = serverName
        }
    }

}

extension OpsWorksCmClientTypes {
    public enum ServerStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backingUp
        case connectionLost
        case creating
        case deleting
        case failed
        case healthy
        case modifying
        case restoring
        case running
        case setup
        case terminated
        case underMaintenance
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerStatus] {
            return [
                .backingUp,
                .connectionLost,
                .creating,
                .deleting,
                .failed,
                .healthy,
                .modifying,
                .restoring,
                .running,
                .setup,
                .terminated,
                .underMaintenance,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backingUp: return "BACKING_UP"
            case .connectionLost: return "CONNECTION_LOST"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .healthy: return "HEALTHY"
            case .modifying: return "MODIFYING"
            case .restoring: return "RESTORING"
            case .running: return "RUNNING"
            case .setup: return "SETUP"
            case .terminated: return "TERMINATED"
            case .underMaintenance: return "UNDER_MAINTENANCE"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerStatus(rawValue: rawValue) ?? ServerStatus.sdkUnknown(rawValue)
        }
    }
}

public struct StartMaintenanceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMaintenanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMaintenanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMaintenanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMaintenanceOutputError>
}

extension StartMaintenanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMaintenanceInput(engineAttributes: \(Swift.String(describing: engineAttributes)), serverName: \(Swift.String(describing: serverName)))"}
}

extension StartMaintenanceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct StartMaintenanceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMaintenanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMaintenanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMaintenanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMaintenanceOutputError>
}

public struct StartMaintenanceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "StartMaintenanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<StartMaintenanceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<StartMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<StartMaintenanceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<StartMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<StartMaintenanceOutputError>
}

public struct StartMaintenanceInput: Swift.Equatable {
    /// <p>Engine attributes that are specific to the server on which you want to run maintenance.</p>
    ///          <p class="title">
    ///             <b>Attributes accepted in a StartMaintenance request for Chef</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_MAJOR_UPGRADE</code>: If a Chef Automate server is eligible for upgrade to Chef Automate 2,
    ///         add this engine attribute to a <code>StartMaintenance</code> request and set the value to <code>true</code> to upgrade the server to Chef Automate 2. For more information, see
    ///         <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opscm-a2upgrade.html">Upgrade an AWS OpsWorks for Chef Automate Server to Chef Automate 2</a>.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
    /// <p>The name of the server on which to run maintenance.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.serverName = serverName
    }
}

struct StartMaintenanceInputBody: Swift.Equatable {
    public let serverName: Swift.String?
    public let engineAttributes: [OpsWorksCmClientTypes.EngineAttribute]?
}

extension StartMaintenanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engineAttributes = "EngineAttributes"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[OpsWorksCmClientTypes.EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [OpsWorksCmClientTypes.EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension StartMaintenanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMaintenanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMaintenanceOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMaintenanceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartMaintenanceOutputResponse(server: \(Swift.String(describing: server)))"}
}

extension StartMaintenanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartMaintenanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct StartMaintenanceOutputResponse: Swift.Equatable {
    /// <p>Contains the response to a <code>StartMaintenance</code> request.
    ///     </p>
    public let server: OpsWorksCmClientTypes.Server?

    public init (
        server: OpsWorksCmClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct StartMaintenanceOutputResponseBody: Swift.Equatable {
    public let server: OpsWorksCmClientTypes.Server?
}

extension StartMaintenanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension OpsWorksCmClientTypes.Tag: Swift.Codable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension OpsWorksCmClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \(Swift.String(describing: key)), value: \(Swift.String(describing: value)))"}
}

extension OpsWorksCmClientTypes {
    /// <p>A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate
    ///       or AWS OpsWorks for Puppet Enterprise server. Leading and trailing white spaces are trimmed from both the key and value.
    ///       A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.</p>
    public struct Tag: Swift.Equatable {
        /// <p>A tag key, such as <code>Stage</code> or <code>Name</code>. A tag key cannot be empty. The key can be a maximum of 127 characters,
        ///       and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
        ///          </p>
        public let key: Swift.String?
        /// <p>An optional tag value, such as <code>Production</code> or <code>test-owcm-server</code>. The value can be a maximum of 255 characters,
        ///       and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
        ///          </p>
        public let value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct TagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \(Swift.String(describing: tags)))"}
}

extension TagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<TagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Number (ARN) of a resource to which you want to apply tags. For example,
    ///       <code>arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE</code>.</p>
    public let resourceArn: Swift.String?
    /// <p>A map that contains tag keys and tag values to attach to AWS OpsWorks-CM servers or backups.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The key cannot be empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Leading and trailing white spaces are trimmed from both the key and value.</p>
    ///             </li>
    ///             <li>
    ///                <p>A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server or backup.</p>
    ///             </li>
    ///          </ul>
    public let tags: [OpsWorksCmClientTypes.Tag]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [OpsWorksCmClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tags: [OpsWorksCmClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([OpsWorksCmClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[OpsWorksCmClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [OpsWorksCmClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Swift.Equatable {
}

extension TagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \(Swift.String(describing: tagKeys)))"}
}

extension UntagResourceInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UntagResourceInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Swift.Equatable {
    /// <p>The Amazon Resource Number (ARN) of a resource from which you want to remove tags. For example,
    ///       <code>arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE</code>.</p>
    public let resourceArn: Swift.String?
    /// <p>The keys of tags that you want to remove.</p>
    public let tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    public let resourceArn: Swift.String?
    public let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Swift.Equatable {
}

extension UntagResourceOutputResponseBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

public struct UpdateServerEngineAttributesInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerEngineAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerEngineAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerEngineAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerEngineAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerEngineAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerEngineAttributesOutputError>
}

extension UpdateServerEngineAttributesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerEngineAttributesInput(attributeName: \(Swift.String(describing: attributeName)), attributeValue: \(Swift.String(describing: attributeValue)), serverName: \(Swift.String(describing: serverName)))"}
}

extension UpdateServerEngineAttributesInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeValue = attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct UpdateServerEngineAttributesInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerEngineAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerEngineAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerEngineAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerEngineAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerEngineAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerEngineAttributesOutputError>
}

public struct UpdateServerEngineAttributesInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerEngineAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerEngineAttributesInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerEngineAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerEngineAttributesInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerEngineAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerEngineAttributesOutputError>
}

public struct UpdateServerEngineAttributesInput: Swift.Equatable {
    /// <p>The name of the engine attribute to update.
    ///     </p>
    public let attributeName: Swift.String?
    /// <p>The value to set for the attribute.
    ///     </p>
    public let attributeValue: Swift.String?
    /// <p>The name of the server to update.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        attributeName: Swift.String? = nil,
        attributeValue: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.serverName = serverName
    }
}

struct UpdateServerEngineAttributesInputBody: Swift.Equatable {
    public let serverName: Swift.String?
    public let attributeName: Swift.String?
    public let attributeValue: Swift.String?
}

extension UpdateServerEngineAttributesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension UpdateServerEngineAttributesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerEngineAttributesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerEngineAttributesOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerEngineAttributesOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerEngineAttributesOutputResponse(server: \(Swift.String(describing: server)))"}
}

extension UpdateServerEngineAttributesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServerEngineAttributesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct UpdateServerEngineAttributesOutputResponse: Swift.Equatable {
    /// <p>Contains the response to an <code>UpdateServerEngineAttributes</code> request.
    ///     </p>
    public let server: OpsWorksCmClientTypes.Server?

    public init (
        server: OpsWorksCmClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct UpdateServerEngineAttributesOutputResponseBody: Swift.Equatable {
    public let server: OpsWorksCmClientTypes.Server?
}

extension UpdateServerEngineAttributesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

public struct UpdateServerInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = ClientRuntime.HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientRuntime.ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerOutputError>
}

extension UpdateServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerInput(backupRetentionCount: \(Swift.String(describing: backupRetentionCount)), disableAutomatedBackup: \(Swift.String(describing: disableAutomatedBackup)), preferredBackupWindow: \(Swift.String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(Swift.String(describing: preferredMaintenanceWindow)), serverName: \(Swift.String(describing: serverName)))"}
}

extension UpdateServerInput: Swift.Encodable, ClientRuntime.Reflection {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionCount = "BackupRetentionCount"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupRetentionCount = backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let disableAutomatedBackup = disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct UpdateServerInputHeadersMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerOutputError>
}

public struct UpdateServerInputQueryItemMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "UpdateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<ClientRuntime.OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<UpdateServerInput>
    public typealias MOutput = ClientRuntime.OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = ClientRuntime.SdkError<UpdateServerOutputError>
}

public struct UpdateServerInput: Swift.Equatable {
    /// <p>Sets the number of automated backups that you want to keep.
    ///       </p>
    public let backupRetentionCount: Swift.Int?
    /// <p>Setting DisableAutomatedBackup to <code>true</code> disables automated or scheduled backups. Automated backups are enabled by default.
    ///     </p>
    public let disableAutomatedBackup: Swift.Bool?
    /// <p>
    ///             <code>DDD:HH:MM</code> (weekly start time) or
    ///     <code>HH:MM</code> (daily start time).
    ///     </p>
    ///          <p>
    ///       Time windows always use coordinated universal time (UTC). Valid strings for day of week (<code>DDD</code>) are: <code>Mon</code>, <code>Tue</code>, <code>Wed</code>,
    ///       <code>Thr</code>, <code>Fri</code>, <code>Sat</code>, or <code>Sun</code>.</p>
    public let preferredBackupWindow: Swift.String?
    /// <p>
    ///             <code>DDD:HH:MM</code> (weekly start time) or
    ///     <code>HH:MM</code> (daily start time).
    ///     </p>
    ///          <p>
    ///       Time windows always use coordinated universal time (UTC). Valid strings for day of week (<code>DDD</code>) are: <code>Mon</code>, <code>Tue</code>, <code>Wed</code>,
    ///       <code>Thr</code>, <code>Fri</code>, <code>Sat</code>, or <code>Sun</code>.</p>
    public let preferredMaintenanceWindow: Swift.String?
    /// <p>The name of the server to update.
    ///     </p>
    public let serverName: Swift.String?

    public init (
        backupRetentionCount: Swift.Int? = nil,
        disableAutomatedBackup: Swift.Bool? = nil,
        preferredBackupWindow: Swift.String? = nil,
        preferredMaintenanceWindow: Swift.String? = nil,
        serverName: Swift.String? = nil
    )
    {
        self.backupRetentionCount = backupRetentionCount
        self.disableAutomatedBackup = disableAutomatedBackup
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.serverName = serverName
    }
}

struct UpdateServerInputBody: Swift.Equatable {
    public let disableAutomatedBackup: Swift.Bool?
    public let backupRetentionCount: Swift.Int?
    public let serverName: Swift.String?
    public let preferredMaintenanceWindow: Swift.String?
    public let preferredBackupWindow: Swift.String?
}

extension UpdateServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backupRetentionCount = "BackupRetentionCount"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case serverName = "ServerName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
    }
}

extension UpdateServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerOutputError: Swift.Error, Swift.Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateServerOutputResponse(server: \(Swift.String(describing: server)))"}
}

extension UpdateServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct UpdateServerOutputResponse: Swift.Equatable {
    /// <p>Contains the response to a <code>UpdateServer</code> request.
    ///     </p>
    public let server: OpsWorksCmClientTypes.Server?

    public init (
        server: OpsWorksCmClientTypes.Server? = nil
    )
    {
        self.server = server
    }
}

struct UpdateServerOutputResponseBody: Swift.Equatable {
    public let server: OpsWorksCmClientTypes.Server?
}

extension UpdateServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server = "Server"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(OpsWorksCmClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension ValidationException: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ValidationException(message: \(Swift.String(describing: message)))"}
}

extension ValidationException: AWSClientRuntime.AWSHttpServiceError {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the provided request parameters are not valid.
///     </p>
public struct ValidationException: ClientRuntime.ServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// <p>Error or informational message that can contain more detail about a validation failure.
    ///     </p>
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    public let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
