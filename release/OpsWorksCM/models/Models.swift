// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maximum = "Maximum"
        case name = "Name"
        case used = "Used"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maximum = maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let used = used {
            try encodeContainer.encode(used, forKey: .used)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximum)
        maximum = maximumDecoded
        let usedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .used)
        used = usedDecoded
    }
}

extension AccountAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountAttribute(maximum: \(String(describing: maximum)), name: \(String(describing: name)), used: \(String(describing: used)))"}
}

/// <p>Stores account attributes.
///     </p>
public struct AccountAttribute: Equatable {
    /// <p>
    ///       The maximum allowed value.
    ///     </p>
    public let maximum: Int?
    /// <p>
    ///       The attribute name. The following are supported attribute names.
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <i>ServerLimit:</i> The number of current servers/maximum number of servers allowed. By default, you can have a maximum of 10 servers.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <i>ManualBackupLimit:</i> The number of current manual backups/maximum number of backups allowed. By default, you can have a maximum
    ///         of 50 manual backups saved.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let name: String?
    /// <p>
    ///       The current usage, such as the current number of servers that are associated with the account.
    ///     </p>
    public let used: Int?

    public init (
        maximum: Int? = nil,
        name: String? = nil,
        used: Int? = nil
    )
    {
        self.maximum = maximum
        self.name = name
        self.used = used
    }
}

public struct AssociateNodeInputBodyMiddleware: Middleware {
    public let id: String = "AssociateNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateNodeInput>
    public typealias MOutput = OperationOutput<AssociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateNodeOutputError>
}

extension AssociateNodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateNodeInput(engineAttributes: \(String(describing: engineAttributes)), nodeName: \(String(describing: nodeName)), serverName: \(String(describing: serverName)))"}
}

extension AssociateNodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let nodeName = nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct AssociateNodeInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateNodeInput>
    public typealias MOutput = OperationOutput<AssociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateNodeOutputError>
}

public struct AssociateNodeInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateNodeInput>
    public typealias MOutput = OperationOutput<AssociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateNodeOutputError>
}

public struct AssociateNodeInput: Equatable {
    /// <p>Engine attributes used for associating the node.
    ///     </p>
    ///          <p class="title">
    ///             <b>Attributes accepted in a AssociateNode request for Chef</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_ORGANIZATION</code>: The Chef organization
    ///           with which the node is associated. By default only one organization
    ///           named <code>default</code> can exist.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_NODE_PUBLIC_KEY</code>: A PEM-formatted public key. This key is required for the <code>chef-client</code> agent to access the Chef API.
    ///     </p>
    ///             </li>
    ///          </ul>
    ///          <p class="title">
    ///             <b>Attributes accepted in a AssociateNode request for Puppet</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_NODE_CSR</code>: A PEM-formatted certificate-signing request (CSR) that is created by the node.
    ///     </p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [EngineAttribute]?
    /// <p>The name of the node.
    ///     </p>
    public let nodeName: String?
    /// <p>The name of the server with which to associate the node.
    ///     </p>
    public let serverName: String?

    public init (
        engineAttributes: [EngineAttribute]? = nil,
        nodeName: String? = nil,
        serverName: String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

struct AssociateNodeInputBody: Equatable {
    public let serverName: String?
    public let nodeName: String?
    public let engineAttributes: [EngineAttribute]?
}

extension AssociateNodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension AssociateNodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateNodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateNodeOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateNodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateNodeOutputResponse(nodeAssociationStatusToken: \(String(describing: nodeAssociationStatusToken)))"}
}

extension AssociateNodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateNodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nodeAssociationStatusToken = output.nodeAssociationStatusToken
        } else {
            self.nodeAssociationStatusToken = nil
        }
    }
}

public struct AssociateNodeOutputResponse: Equatable {
    /// <p>Contains a token which can be passed to the <code>DescribeNodeAssociationStatus</code> API call to get the status of the association request.
    ///     </p>
    public let nodeAssociationStatusToken: String?

    public init (
        nodeAssociationStatusToken: String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

struct AssociateNodeOutputResponseBody: Equatable {
    public let nodeAssociationStatusToken: String?
}

extension AssociateNodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
    }
}

extension Backup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupArn = "BackupArn"
        case backupId = "BackupId"
        case backupType = "BackupType"
        case createdAt = "CreatedAt"
        case description = "Description"
        case engine = "Engine"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case s3DataSize = "S3DataSize"
        case s3DataUrl = "S3DataUrl"
        case s3LogUrl = "S3LogUrl"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case status = "Status"
        case statusDescription = "StatusDescription"
        case subnetIds = "SubnetIds"
        case toolsVersion = "ToolsVersion"
        case userArn = "UserArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupArn = backupArn {
            try encodeContainer.encode(backupArn, forKey: .backupArn)
        }
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupType = backupType {
            try encodeContainer.encode(backupType.rawValue, forKey: .backupType)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineModel = engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let s3DataSize = s3DataSize {
            try encodeContainer.encode(s3DataSize, forKey: .s3DataSize)
        }
        if let s3DataUrl = s3DataUrl {
            try encodeContainer.encode(s3DataUrl, forKey: .s3DataUrl)
        }
        if let s3LogUrl = s3LogUrl {
            try encodeContainer.encode(s3LogUrl, forKey: .s3LogUrl)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusDescription = statusDescription {
            try encodeContainer.encode(statusDescription, forKey: .statusDescription)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
        if let toolsVersion = toolsVersion {
            try encodeContainer.encode(toolsVersion, forKey: .toolsVersion)
        }
        if let userArn = userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupArn)
        backupArn = backupArnDecoded
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let backupTypeDecoded = try containerValues.decodeIfPresent(BackupType.self, forKey: .backupType)
        backupType = backupTypeDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let s3DataSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .s3DataSize)
        s3DataSize = s3DataSizeDecoded
        let s3DataUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3DataUrl)
        s3DataUrl = s3DataUrlDecoded
        let s3LogUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3LogUrl)
        s3LogUrl = s3LogUrlDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BackupStatus.self, forKey: .status)
        status = statusDecoded
        let statusDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusDescription)
        statusDescription = statusDescriptionDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let toolsVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .toolsVersion)
        toolsVersion = toolsVersionDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension Backup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Backup(backupArn: \(String(describing: backupArn)), backupId: \(String(describing: backupId)), backupType: \(String(describing: backupType)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), engine: \(String(describing: engine)), engineModel: \(String(describing: engineModel)), engineVersion: \(String(describing: engineVersion)), instanceProfileArn: \(String(describing: instanceProfileArn)), instanceType: \(String(describing: instanceType)), keyPair: \(String(describing: keyPair)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), s3DataSize: \(String(describing: s3DataSize)), s3DataUrl: \(String(describing: s3DataUrl)), s3LogUrl: \(String(describing: s3LogUrl)), securityGroupIds: \(String(describing: securityGroupIds)), serverName: \(String(describing: serverName)), serviceRoleArn: \(String(describing: serviceRoleArn)), status: \(String(describing: status)), statusDescription: \(String(describing: statusDescription)), subnetIds: \(String(describing: subnetIds)), toolsVersion: \(String(describing: toolsVersion)), userArn: \(String(describing: userArn)))"}
}

/// <p>Describes a single backup.
///     </p>
public struct Backup: Equatable {
    /// <p>The ARN of the backup.
    ///     </p>
    public let backupArn: String?
    /// <p>
    ///       The generated ID of the backup. Example: <code>myServerName-yyyyMMddHHmmssSSS</code>
    ///          </p>
    public let backupId: String?
    /// <p>
    ///       The backup type. Valid values are <code>automated</code> or <code>manual</code>.
    ///     </p>
    public let backupType: BackupType?
    /// <p>
    ///       The time stamp when the backup was created in the database. Example: <code>2016-07-29T13:38:47.520Z</code>
    ///          </p>
    public let createdAt: Date?
    /// <p>
    ///       A user-provided description for a manual backup. This field is empty for automated backups.
    ///     </p>
    public let description: String?
    /// <p>
    ///       The engine type that is obtained from the server when the backup is created.
    ///     </p>
    public let engine: String?
    /// <p>
    ///       The engine model that is obtained from the server when the backup is created.
    ///     </p>
    public let engineModel: String?
    /// <p>
    ///       The engine version that is obtained from the server when the backup is created.
    ///     </p>
    public let engineVersion: String?
    /// <p>
    ///       The EC2 instance profile ARN that is obtained from the server when the backup is created. Because this value is stored,
    ///       you are not required to provide the InstanceProfileArn again if you restore a backup.
    ///     </p>
    public let instanceProfileArn: String?
    /// <p>
    ///       The instance type that is obtained from the server when the backup is created.
    ///     </p>
    public let instanceType: String?
    /// <p>
    ///       The key pair that is obtained from the server when the backup is created.
    ///     </p>
    public let keyPair: String?
    /// <p>
    ///       The preferred backup period that is obtained from the server when the backup is created.
    ///     </p>
    public let preferredBackupWindow: String?
    /// <p>
    ///       The preferred maintenance period that is obtained from the server when the backup is created.
    ///     </p>
    public let preferredMaintenanceWindow: String?
    /// <p>
    ///       This field is deprecated and is no longer used.
    ///     </p>
    @available(*, deprecated)
    public let s3DataSize: Int?
    /// <p>
    ///       This field is deprecated and is no longer used.
    ///     </p>
    @available(*, deprecated)
    public let s3DataUrl: String?
    /// <p>
    ///       The Amazon S3 URL of the backup's log file.
    ///     </p>
    public let s3LogUrl: String?
    /// <p>
    ///       The security group IDs that are obtained from the server when the backup is created.
    ///     </p>
    public let securityGroupIds: [String]?
    /// <p>
    ///       The name of the server from which the backup was made.
    ///     </p>
    public let serverName: String?
    /// <p>
    ///       The service role ARN that is obtained from the server when the backup is created.
    ///     </p>
    public let serviceRoleArn: String?
    /// <p>The status of a backup while in progress.
    ///     </p>
    public let status: BackupStatus?
    /// <p>
    ///       An informational message about backup status.
    ///     </p>
    public let statusDescription: String?
    /// <p>
    ///       The subnet IDs that are obtained from the server when the backup is created.
    ///     </p>
    public let subnetIds: [String]?
    /// <p>
    ///       The version of AWS OpsWorks CM-specific tools that is obtained from the server when the backup is created.
    ///     </p>
    public let toolsVersion: String?
    /// <p>
    ///       The IAM user ARN of the requester for manual backups. This field is empty for automated backups.
    ///     </p>
    public let userArn: String?

    public init (
        backupArn: String? = nil,
        backupId: String? = nil,
        backupType: BackupType? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        engine: String? = nil,
        engineModel: String? = nil,
        engineVersion: String? = nil,
        instanceProfileArn: String? = nil,
        instanceType: String? = nil,
        keyPair: String? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        s3DataSize: Int? = nil,
        s3DataUrl: String? = nil,
        s3LogUrl: String? = nil,
        securityGroupIds: [String]? = nil,
        serverName: String? = nil,
        serviceRoleArn: String? = nil,
        status: BackupStatus? = nil,
        statusDescription: String? = nil,
        subnetIds: [String]? = nil,
        toolsVersion: String? = nil,
        userArn: String? = nil
    )
    {
        self.backupArn = backupArn
        self.backupId = backupId
        self.backupType = backupType
        self.createdAt = createdAt
        self.description = description
        self.engine = engine
        self.engineModel = engineModel
        self.engineVersion = engineVersion
        self.instanceProfileArn = instanceProfileArn
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.s3DataSize = s3DataSize
        self.s3DataUrl = s3DataUrl
        self.s3LogUrl = s3LogUrl
        self.securityGroupIds = securityGroupIds
        self.serverName = serverName
        self.serviceRoleArn = serviceRoleArn
        self.status = status
        self.statusDescription = statusDescription
        self.subnetIds = subnetIds
        self.toolsVersion = toolsVersion
        self.userArn = userArn
    }
}

public enum BackupStatus {
    case deleting
    case failed
    case inProgress
    case ok
    case sdkUnknown(String)
}

extension BackupStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupStatus] {
        return [
            .deleting,
            .failed,
            .inProgress,
            .ok,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .ok: return "OK"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupStatus(rawValue: rawValue) ?? BackupStatus.sdkUnknown(rawValue)
    }
}

public enum BackupType {
    case automated
    case manual
    case sdkUnknown(String)
}

extension BackupType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [BackupType] {
        return [
            .automated,
            .manual,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .automated: return "AUTOMATED"
        case .manual: return "MANUAL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = BackupType(rawValue: rawValue) ?? BackupType.sdkUnknown(rawValue)
    }
}

public struct CreateBackupInputBodyMiddleware: Middleware {
    public let id: String = "CreateBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupInput>
    public typealias MOutput = OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupOutputError>
}

extension CreateBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupInput(description: \(String(describing: description)), serverName: \(String(describing: serverName)), tags: \(String(describing: tags)))"}
}

extension CreateBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case serverName = "ServerName"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateBackupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupInput>
    public typealias MOutput = OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupOutputError>
}

public struct CreateBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateBackupInput>
    public typealias MOutput = OperationOutput<CreateBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateBackupOutputError>
}

public struct CreateBackupInput: Equatable {
    /// <p>
    ///       A user-defined description of the backup.
    ///     </p>
    public let description: String?
    /// <p>The name of the server that you want to back up.
    ///     </p>
    public let serverName: String?
    /// <p>A map that contains tag keys and tag values to attach to an AWS OpsWorks-CM server backup.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The key cannot be empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Leading and trailing white spaces are trimmed from both the key and value.</p>
    ///             </li>
    ///             <li>
    ///                <p>A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        serverName: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.serverName = serverName
        self.tags = tags
    }
}

struct CreateBackupInputBody: Equatable {
    public let serverName: String?
    public let description: String?
    public let tags: [Tag]?
}

extension CreateBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case serverName = "ServerName"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateBackupOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateBackupOutputResponse(backup: \(String(describing: backup)))"}
}

extension CreateBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateBackupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backup = output.backup
        } else {
            self.backup = nil
        }
    }
}

public struct CreateBackupOutputResponse: Equatable {
    /// <p>Backup created by request.</p>
    public let backup: Backup?

    public init (
        backup: Backup? = nil
    )
    {
        self.backup = backup
    }
}

struct CreateBackupOutputResponseBody: Equatable {
    public let backup: Backup?
}

extension CreateBackupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backup = "Backup"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupDecoded = try containerValues.decodeIfPresent(Backup.self, forKey: .backup)
        backup = backupDecoded
    }
}

public struct CreateServerInputBodyMiddleware: Middleware {
    public let id: String = "CreateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServerInput>
    public typealias MOutput = OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServerOutputError>
}

extension CreateServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServerInput(associatePublicIpAddress: \(String(describing: associatePublicIpAddress)), backupId: \(String(describing: backupId)), backupRetentionCount: \(String(describing: backupRetentionCount)), customCertificate: \(String(describing: customCertificate)), customDomain: \(String(describing: customDomain)), customPrivateKey: \(String(describing: customPrivateKey)), disableAutomatedBackup: \(String(describing: disableAutomatedBackup)), engine: \(String(describing: engine)), engineAttributes: \(String(describing: engineAttributes)), engineModel: \(String(describing: engineModel)), engineVersion: \(String(describing: engineVersion)), instanceProfileArn: \(String(describing: instanceProfileArn)), instanceType: \(String(describing: instanceType)), keyPair: \(String(describing: keyPair)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), securityGroupIds: \(String(describing: securityGroupIds)), serverName: \(String(describing: serverName)), serviceRoleArn: \(String(describing: serviceRoleArn)), subnetIds: \(String(describing: subnetIds)), tags: \(String(describing: tags)))"}
}

extension CreateServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupId = "BackupId"
        case backupRetentionCount = "BackupRetentionCount"
        case customCertificate = "CustomCertificate"
        case customDomain = "CustomDomain"
        case customPrivateKey = "CustomPrivateKey"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let backupRetentionCount = backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let customCertificate = customCertificate {
            try encodeContainer.encode(customCertificate, forKey: .customCertificate)
        }
        if let customDomain = customDomain {
            try encodeContainer.encode(customDomain, forKey: .customDomain)
        }
        if let customPrivateKey = customPrivateKey {
            try encodeContainer.encode(customPrivateKey, forKey: .customPrivateKey)
        }
        if let disableAutomatedBackup = disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let engineModel = engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateServerInputHeadersMiddleware: Middleware {
    public let id: String = "CreateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServerInput>
    public typealias MOutput = OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServerOutputError>
}

public struct CreateServerInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateServerInput>
    public typealias MOutput = OperationOutput<CreateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateServerOutputError>
}

public struct CreateServerInput: Equatable {
    /// <p>
    ///         Associate a public IP address with a server that you are launching. Valid values are <code>true</code> or <code>false</code>. The default value is <code>true</code>.
    ///       </p>
    public let associatePublicIpAddress: Bool?
    /// <p>
    ///       If you specify this field, AWS OpsWorks CM creates the server by using the backup represented by BackupId.
    ///     </p>
    public let backupId: String?
    /// <p>
    ///         The number of automated backups that you want to keep. Whenever a new backup is created, AWS OpsWorks CM deletes the oldest backups if this number is exceeded.
    ///         The default value is <code>1</code>.
    ///       </p>
    public let backupRetentionCount: Int?
    /// <p>A PEM-formatted HTTPS certificate. The value can be be a single, self-signed certificate, or a certificate chain. If you specify a
    ///       custom certificate, you must also specify values for <code>CustomDomain</code> and <code>CustomPrivateKey</code>. The following are requirements for the <code>CustomCertificate</code> value:</p>
    ///          <ul>
    ///             <li>
    ///                <p>You can provide either a self-signed, custom certificate, or the full certificate chain.</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificate must be a valid X509 certificate, or a certificate chain in PEM format.</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificate must be valid at the time of upload. A certificate can't be used before its validity period begins (the certificate's <code>NotBefore</code> date), or after it expires
    ///         (the certificate's <code>NotAfter</code> date).</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificate’s common name or subject alternative names (SANs), if present, must match the value of <code>CustomDomain</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>The certificate must match the value of <code>CustomPrivateKey</code>.</p>
    ///             </li>
    ///          </ul>
    public let customCertificate: String?
    /// <p>An optional public endpoint of a server, such as <code>https://aws.my-company.com</code>. To access the server, create a CNAME DNS record in your preferred DNS service that points the custom
    ///       domain to the endpoint that is generated when the server is created (the value of the CreateServer Endpoint attribute). You cannot access the server by using the
    ///       generated <code>Endpoint</code> value if the server is using a custom domain. If you specify a custom domain, you must also specify values for <code>CustomCertificate</code>
    ///       and <code>CustomPrivateKey</code>.</p>
    public let customDomain: String?
    /// <p>A private key in PEM format for connecting to the server by using HTTPS. The private key must not be encrypted; it cannot be protected by a password or passphrase.
    ///       If you specify a custom private key, you must also specify values for <code>CustomDomain</code> and <code>CustomCertificate</code>.</p>
    public let customPrivateKey: String?
    /// <p>
    ///         Enable or disable scheduled backups. Valid values are <code>true</code> or <code>false</code>. The default value is <code>true</code>.
    ///       </p>
    public let disableAutomatedBackup: Bool?
    /// <p>
    ///         The configuration management engine to use. Valid values include <code>ChefAutomate</code> and <code>Puppet</code>.
    ///       </p>
    public let engine: String?
    /// <p>Optional engine attributes on a specified server.
    ///     </p>
    ///          <p class="title">
    ///             <b>Attributes accepted in a Chef createServer request:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_AUTOMATE_PIVOTAL_KEY</code>: A
    ///       base64-encoded RSA public key. The corresponding private key is required to
    ///       access the Chef API. When no CHEF_AUTOMATE_PIVOTAL_KEY is set, a private key is
    ///       generated and returned in the response.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_AUTOMATE_ADMIN_PASSWORD</code>:
    ///       The password for the administrative user in the Chef Automate web-based dashboard. The
    ///       password length is a minimum of eight characters, and a maximum of 32. The
    ///       password can contain letters, numbers, and special characters
    ///       (!/@#$%^&+=_). The password must contain at least one lower case letter, one upper
    ///       case letter, one number, and one special character. When no CHEF_AUTOMATE_ADMIN_PASSWORD is set, one is
    ///       generated and returned in the response.</p>
    ///             </li>
    ///          </ul>
    ///          <p class="title">
    ///             <b>Attributes accepted in a Puppet createServer request:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_ADMIN_PASSWORD</code>: To work with the Puppet Enterprise console, a password must use ASCII characters.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_R10K_REMOTE</code>: The r10k remote is the URL of your control repository
    ///         (for example, ssh://git@your.git-repo.com:user/control-repo.git). Specifying an r10k remote opens TCP port 8170.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_R10K_PRIVATE_KEY</code>: If you are using a private Git repository, add
    ///         PUPPET_R10K_PRIVATE_KEY to specify a PEM-encoded private SSH key.</p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [EngineAttribute]?
    /// <p>
    ///         The engine model of the server. Valid values in this release include <code>Monolithic</code> for Puppet and <code>Single</code> for Chef.
    ///       </p>
    public let engineModel: String?
    /// <p>
    ///         The major release version of the engine that you want to use. For a Chef server, the valid value for EngineVersion
    ///         is currently <code>2</code>. For a Puppet server, valid values are <code>2019</code> or <code>2017</code>.
    ///       </p>
    public let engineVersion: String?
    /// <p>
    ///         The ARN of the instance profile that your Amazon EC2
    ///         instances use. Although the AWS OpsWorks console typically creates
    ///         the instance profile for you, if you are using API commands instead, run the service-role-creation.yaml
    ///         AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml.
    ///         This template creates a CloudFormation stack that includes the instance profile you need.
    ///
    ///       </p>
    public let instanceProfileArn: String?
    /// <p>
    ///         The Amazon EC2 instance type to use. For example, <code>m5.large</code>.
    ///       </p>
    public let instanceType: String?
    /// <p>
    ///         The Amazon EC2 key pair to set for the instance. This parameter is optional; if desired, you may specify this parameter to connect to your instances by using SSH.
    ///       </p>
    public let keyPair: String?
    /// <p>
    ///       The start time for a one-hour period during which AWS OpsWorks CM backs up application-level data on your server
    ///       if automated backups are enabled. Valid values must be specified in one of the following formats:
    ///     </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>HH:MM</code> for daily backups</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DDD:HH:MM</code> for weekly backups</p>
    ///             </li>
    ///          </ul>
    ///          <p>
    ///             <code>MM</code> must be specified as <code>00</code>. The specified time is in coordinated universal time (UTC). The default value is a random, daily start time.</p>
    ///          <p>
    ///             <b>Example:</b>
    ///             <code>08:00</code>, which represents a daily start time of 08:00 UTC.</p>
    ///          <p>
    ///             <b>Example:</b>
    ///             <code>Mon:08:00</code>, which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)</p>
    public let preferredBackupWindow: String?
    /// <p>
    ///       The start time for a one-hour period each week during which AWS OpsWorks CM performs maintenance on the instance.
    ///       Valid values must be specified in the following format: <code>DDD:HH:MM</code>. <code>MM</code> must be specified as <code>00</code>. The specified time is in coordinated universal time (UTC).
    ///       The default value is a random one-hour period on Tuesday, Wednesday, or Friday. See <code>TimeWindowDefinition</code> for more information.
    ///     </p>
    ///          <p>
    ///             <b>Example:</b>
    ///             <code>Mon:08:00</code>,
    ///       which represents a start time of every Monday at 08:00 UTC. (8:00 a.m.)
    ///     </p>
    public let preferredMaintenanceWindow: String?
    /// <p>
    ///       A list of security group IDs to attach to the Amazon EC2 instance. If you add this parameter, the specified security groups
    ///       must be within the VPC that is specified by <code>SubnetIds</code>.
    ///     </p>
    ///          <p>
    ///       If you do not specify this parameter, AWS OpsWorks CM creates one new security group that uses TCP ports 22 and 443, open to
    ///       0.0.0.0/0 (everyone).
    ///     </p>
    public let securityGroupIds: [String]?
    /// <p>
    ///         The name of the server. The server name must be unique within your AWS account, within each region.
    ///         Server names must start with a letter; then letters, numbers, or hyphens (-) are allowed, up to a maximum of 40 characters.
    ///       </p>
    public let serverName: String?
    /// <p>
    ///       The service role that the AWS OpsWorks CM service backend uses to work with your account. Although the AWS OpsWorks management console typically creates
    ///       the service role for you, if you are using the AWS CLI or API commands,
    ///       run the service-role-creation.yaml AWS CloudFormation template, located at https://s3.amazonaws.com/opsworks-cm-us-east-1-prod-default-assets/misc/opsworks-cm-roles.yaml.
    ///       This template creates a CloudFormation stack that includes the service role and instance profile that you need.
    ///     </p>
    public let serviceRoleArn: String?
    /// <p>
    ///       The IDs of subnets in which to launch the server EC2 instance.
    ///     </p>
    ///          <p>
    ///       Amazon EC2-Classic customers: This field is required. All servers must run within a VPC. The VPC must have "Auto Assign Public IP" enabled.
    ///     </p>
    ///          <p>
    ///       EC2-VPC customers: This field is optional. If you do not specify subnet IDs, your EC2 instances are created in a default subnet that is selected by Amazon EC2. If you specify subnet IDs, the VPC must have "Auto Assign Public IP" enabled.
    ///     </p>
    ///          <p>For more information about supported Amazon EC2 platforms, see
    ///       <a href="https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-supported-platforms.html">Supported Platforms</a>.</p>
    public let subnetIds: [String]?
    /// <p>A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The key cannot be empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : / @</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : / @</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Leading and trailing white spaces are trimmed from both the key and value.</p>
    ///             </li>
    ///             <li>
    ///                <p>A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        associatePublicIpAddress: Bool? = nil,
        backupId: String? = nil,
        backupRetentionCount: Int? = nil,
        customCertificate: String? = nil,
        customDomain: String? = nil,
        customPrivateKey: String? = nil,
        disableAutomatedBackup: Bool? = nil,
        engine: String? = nil,
        engineAttributes: [EngineAttribute]? = nil,
        engineModel: String? = nil,
        engineVersion: String? = nil,
        instanceProfileArn: String? = nil,
        instanceType: String? = nil,
        keyPair: String? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        securityGroupIds: [String]? = nil,
        serverName: String? = nil,
        serviceRoleArn: String? = nil,
        subnetIds: [String]? = nil,
        tags: [Tag]? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.backupId = backupId
        self.backupRetentionCount = backupRetentionCount
        self.customCertificate = customCertificate
        self.customDomain = customDomain
        self.customPrivateKey = customPrivateKey
        self.disableAutomatedBackup = disableAutomatedBackup
        self.engine = engine
        self.engineAttributes = engineAttributes
        self.engineModel = engineModel
        self.engineVersion = engineVersion
        self.instanceProfileArn = instanceProfileArn
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
        self.serverName = serverName
        self.serviceRoleArn = serviceRoleArn
        self.subnetIds = subnetIds
        self.tags = tags
    }
}

struct CreateServerInputBody: Equatable {
    public let associatePublicIpAddress: Bool?
    public let customDomain: String?
    public let customCertificate: String?
    public let customPrivateKey: String?
    public let disableAutomatedBackup: Bool?
    public let engine: String?
    public let engineModel: String?
    public let engineVersion: String?
    public let engineAttributes: [EngineAttribute]?
    public let backupRetentionCount: Int?
    public let serverName: String?
    public let instanceProfileArn: String?
    public let instanceType: String?
    public let keyPair: String?
    public let preferredMaintenanceWindow: String?
    public let preferredBackupWindow: String?
    public let securityGroupIds: [String]?
    public let serviceRoleArn: String?
    public let subnetIds: [String]?
    public let tags: [Tag]?
    public let backupId: String?
}

extension CreateServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupId = "BackupId"
        case backupRetentionCount = "BackupRetentionCount"
        case customCertificate = "CustomCertificate"
        case customDomain = "CustomDomain"
        case customPrivateKey = "CustomPrivateKey"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case subnetIds = "SubnetIds"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let customCertificateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customCertificate)
        customCertificate = customCertificateDecoded
        let customPrivateKeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customPrivateKey)
        customPrivateKey = customPrivateKeyDecoded
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension CreateServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceAlreadyExistsException" : self = .resourceAlreadyExistsException(try ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateServerOutputError: Equatable {
    case limitExceededException(LimitExceededException)
    case resourceAlreadyExistsException(ResourceAlreadyExistsException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateServerOutputResponse(server: \(String(describing: server)))"}
}

extension CreateServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct CreateServerOutputResponse: Equatable {
    /// <p>The server that is created by the request.
    ///     </p>
    public let server: Server?

    public init (
        server: Server? = nil
    )
    {
        self.server = server
    }
}

struct CreateServerOutputResponseBody: Equatable {
    public let server: Server?
}

extension CreateServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case server = "Server"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
    }
}

public struct DeleteBackupInputBodyMiddleware: Middleware {
    public let id: String = "DeleteBackupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

extension DeleteBackupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupInput(backupId: \(String(describing: backupId)))"}
}

extension DeleteBackupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
    }
}

public struct DeleteBackupInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteBackupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteBackupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteBackupInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteBackupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteBackupInput>
    public typealias MOutput = OperationOutput<DeleteBackupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteBackupOutputError>
}

public struct DeleteBackupInput: Equatable {
    /// <p>The ID of the backup to delete. Run the DescribeBackups command to get a list of backup IDs.
    ///       Backup IDs are in the format <code>ServerName-yyyyMMddHHmmssSSS</code>.
    ///     </p>
    public let backupId: String?

    public init (
        backupId: String? = nil
    )
    {
        self.backupId = backupId
    }
}

struct DeleteBackupInputBody: Equatable {
    public let backupId: String?
}

extension DeleteBackupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
    }
}

extension DeleteBackupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBackupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteBackupOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBackupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteBackupOutputResponse()"}
}

extension DeleteBackupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteBackupOutputResponse: Equatable {

    public init() {}
}

struct DeleteBackupOutputResponseBody: Equatable {
}

extension DeleteBackupOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteServerInputBodyMiddleware: Middleware {
    public let id: String = "DeleteServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerInput>
    public typealias MOutput = OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerOutputError>
}

extension DeleteServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerInput(serverName: \(String(describing: serverName)))"}
}

extension DeleteServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DeleteServerInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerInput>
    public typealias MOutput = OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerOutputError>
}

public struct DeleteServerInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteServerInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteServerInput>
    public typealias MOutput = OperationOutput<DeleteServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteServerOutputError>
}

public struct DeleteServerInput: Equatable {
    /// <p>The ID of the server to delete.</p>
    public let serverName: String?

    public init (
        serverName: String? = nil
    )
    {
        self.serverName = serverName
    }
}

struct DeleteServerInputBody: Equatable {
    public let serverName: String?
}

extension DeleteServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DeleteServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteServerOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteServerOutputResponse()"}
}

extension DeleteServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteServerOutputResponse: Equatable {

    public init() {}
}

struct DeleteServerOutputResponseBody: Equatable {
}

extension DeleteServerOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesInput()"}
}

extension DescribeAccountAttributesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeAccountAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAccountAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAccountAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAccountAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAccountAttributesInput>
    public typealias MOutput = OperationOutput<DescribeAccountAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAccountAttributesOutputError>
}

public struct DescribeAccountAttributesInput: Equatable {

    public init() {}
}

struct DescribeAccountAttributesInputBody: Equatable {
}

extension DescribeAccountAttributesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeAccountAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAccountAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAccountAttributesOutputError: Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAccountAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAccountAttributesOutputResponse(attributes: \(String(describing: attributes)))"}
}

extension DescribeAccountAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAccountAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.attributes = output.attributes
        } else {
            self.attributes = nil
        }
    }
}

public struct DescribeAccountAttributesOutputResponse: Equatable {
    /// <p>
    ///       The attributes that are currently set for the account.
    ///     </p>
    public let attributes: [AccountAttribute]?

    public init (
        attributes: [AccountAttribute]? = nil
    )
    {
        self.attributes = attributes
    }
}

struct DescribeAccountAttributesOutputResponseBody: Equatable {
    public let attributes: [AccountAttribute]?
}

extension DescribeAccountAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes = "Attributes"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributesContainer = try containerValues.decodeIfPresent([AccountAttribute?].self, forKey: .attributes)
        var attributesDecoded0:[AccountAttribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [AccountAttribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

public struct DescribeBackupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

extension DescribeBackupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupsInput(backupId: \(String(describing: backupId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serverName: \(String(describing: serverName)))"}
}

extension DescribeBackupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeBackupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeBackupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeBackupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeBackupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeBackupsInput>
    public typealias MOutput = OperationOutput<DescribeBackupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeBackupsOutputError>
}

public struct DescribeBackupsInput: Equatable {
    /// <p>Describes a single backup.
    ///     </p>
    public let backupId: String?
    /// <p>This is not currently implemented for <code>DescribeBackups</code> requests.</p>
    public let maxResults: Int?
    /// <p>This is not currently implemented for <code>DescribeBackups</code> requests.</p>
    public let nextToken: String?
    /// <p>Returns backups for the server with the specified ServerName.
    ///     </p>
    public let serverName: String?

    public init (
        backupId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serverName: String? = nil
    )
    {
        self.backupId = backupId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeBackupsInputBody: Equatable {
    public let backupId: String?
    public let serverName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeBackupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeBackupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBackupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeBackupsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBackupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeBackupsOutputResponse(backups: \(String(describing: backups)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeBackupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeBackupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.backups = output.backups
            self.nextToken = output.nextToken
        } else {
            self.backups = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBackupsOutputResponse: Equatable {
    /// <p>Contains the response to a <code>DescribeBackups</code> request.
    ///     </p>
    public let backups: [Backup]?
    /// <p>This is not currently implemented for <code>DescribeBackups</code> requests.</p>
    public let nextToken: String?

    public init (
        backups: [Backup]? = nil,
        nextToken: String? = nil
    )
    {
        self.backups = backups
        self.nextToken = nextToken
    }
}

struct DescribeBackupsOutputResponseBody: Equatable {
    public let backups: [Backup]?
    public let nextToken: String?
}

extension DescribeBackupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backups = "Backups"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupsContainer = try containerValues.decodeIfPresent([Backup?].self, forKey: .backups)
        var backupsDecoded0:[Backup]? = nil
        if let backupsContainer = backupsContainer {
            backupsDecoded0 = [Backup]()
            for structure0 in backupsContainer {
                if let structure0 = structure0 {
                    backupsDecoded0?.append(structure0)
                }
            }
        }
        backups = backupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeEventsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

extension DescribeEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serverName: \(String(describing: serverName)))"}
}

extension DescribeEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeEventsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeEventsInput>
    public typealias MOutput = OperationOutput<DescribeEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeEventsOutputError>
}

public struct DescribeEventsInput: Equatable {
    /// <p>To receive a paginated response, use this parameter to specify the maximum number
    ///       of results to be returned with a single call. If the number of available results exceeds
    ///       this maximum, the response includes a <code>NextToken</code> value that you can assign to the <code>NextToken</code>
    ///       request parameter to get the next set of results.
    ///     </p>
    public let maxResults: Int?
    /// <p>NextToken is a string that is returned in some command responses. It indicates that
    ///       not all entries have been returned, and that you must run at least one more request to get remaining
    ///       items. To get remaining results, call <code>DescribeEvents</code> again, and assign the token from the previous
    ///       results as the value of the <code>nextToken</code> parameter. If there are no more results,
    ///       the response object's <code>nextToken</code> parameter value is <code>null</code>.
    ///       Setting a <code>nextToken</code> value that was not returned in
    ///       your previous results causes an <code>InvalidNextTokenException</code> to occur.
    ///     </p>
    public let nextToken: String?
    /// <p>The name of the server for which you want to view events.</p>
    public let serverName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serverName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeEventsInputBody: Equatable {
    public let serverName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeEventsOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeEventsOutputResponse(nextToken: \(String(describing: nextToken)), serverEvents: \(String(describing: serverEvents)))"}
}

extension DescribeEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.serverEvents = output.serverEvents
        } else {
            self.nextToken = nil
            self.serverEvents = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Equatable {
    /// <p>NextToken is a string that is returned in some command responses. It indicates that
    ///       not all entries have been returned, and that you must run at least one more request to get remaining
    ///       items. To get remaining results, call <code>DescribeEvents</code> again, and assign the token from the previous
    ///       results as the value of the <code>nextToken</code> parameter. If there are no more results,
    ///       the response object's <code>nextToken</code> parameter value is <code>null</code>.
    ///       Setting a <code>nextToken</code> value that was not returned in
    ///       your previous results causes an <code>InvalidNextTokenException</code> to occur.
    ///     </p>
    public let nextToken: String?
    /// <p>Contains the response to a <code>DescribeEvents</code> request.
    ///     </p>
    public let serverEvents: [ServerEvent]?

    public init (
        nextToken: String? = nil,
        serverEvents: [ServerEvent]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverEvents = serverEvents
    }
}

struct DescribeEventsOutputResponseBody: Equatable {
    public let serverEvents: [ServerEvent]?
    public let nextToken: String?
}

extension DescribeEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case serverEvents = "ServerEvents"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverEventsContainer = try containerValues.decodeIfPresent([ServerEvent?].self, forKey: .serverEvents)
        var serverEventsDecoded0:[ServerEvent]? = nil
        if let serverEventsContainer = serverEventsContainer {
            serverEventsDecoded0 = [ServerEvent]()
            for structure0 in serverEventsContainer {
                if let structure0 = structure0 {
                    serverEventsDecoded0?.append(structure0)
                }
            }
        }
        serverEvents = serverEventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DescribeNodeAssociationStatusInputBodyMiddleware: Middleware {
    public let id: String = "DescribeNodeAssociationStatusInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNodeAssociationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNodeAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNodeAssociationStatusInput>
    public typealias MOutput = OperationOutput<DescribeNodeAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNodeAssociationStatusOutputError>
}

extension DescribeNodeAssociationStatusInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNodeAssociationStatusInput(nodeAssociationStatusToken: \(String(describing: nodeAssociationStatusToken)), serverName: \(String(describing: serverName)))"}
}

extension DescribeNodeAssociationStatusInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nodeAssociationStatusToken = nodeAssociationStatusToken {
            try encodeContainer.encode(nodeAssociationStatusToken, forKey: .nodeAssociationStatusToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeNodeAssociationStatusInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeNodeAssociationStatusInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNodeAssociationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNodeAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNodeAssociationStatusInput>
    public typealias MOutput = OperationOutput<DescribeNodeAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNodeAssociationStatusOutputError>
}

public struct DescribeNodeAssociationStatusInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeNodeAssociationStatusInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeNodeAssociationStatusInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeNodeAssociationStatusOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeNodeAssociationStatusInput>
    public typealias MOutput = OperationOutput<DescribeNodeAssociationStatusOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeNodeAssociationStatusOutputError>
}

public struct DescribeNodeAssociationStatusInput: Equatable {
    /// <p>The token returned in either the AssociateNodeResponse or the DisassociateNodeResponse.
    ///     </p>
    public let nodeAssociationStatusToken: String?
    /// <p>The name of the server from which to disassociate the node.
    ///     </p>
    public let serverName: String?

    public init (
        nodeAssociationStatusToken: String? = nil,
        serverName: String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
        self.serverName = serverName
    }
}

struct DescribeNodeAssociationStatusInputBody: Equatable {
    public let nodeAssociationStatusToken: String?
    public let serverName: String?
}

extension DescribeNodeAssociationStatusInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension DescribeNodeAssociationStatusOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNodeAssociationStatusOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeNodeAssociationStatusOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNodeAssociationStatusOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeNodeAssociationStatusOutputResponse(engineAttributes: \(String(describing: engineAttributes)), nodeAssociationStatus: \(String(describing: nodeAssociationStatus)))"}
}

extension DescribeNodeAssociationStatusOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeNodeAssociationStatusOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.engineAttributes = output.engineAttributes
            self.nodeAssociationStatus = output.nodeAssociationStatus
        } else {
            self.engineAttributes = nil
            self.nodeAssociationStatus = nil
        }
    }
}

public struct DescribeNodeAssociationStatusOutputResponse: Equatable {
    /// <p>Attributes specific to the node association.
    ///       In Puppet, the attibute PUPPET_NODE_CERT contains the signed certificate (the result of the CSR).
    ///     </p>
    public let engineAttributes: [EngineAttribute]?
    /// <p>The status of the association or disassociation request.
    ///     </p>
    ///          <p class="title">
    ///             <b>Possible values:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>SUCCESS</code>: The association or disassociation succeeded.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>FAILED</code>: The association or disassociation failed.
    ///       </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>IN_PROGRESS</code>: The association or disassociation is still in progress.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let nodeAssociationStatus: NodeAssociationStatus?

    public init (
        engineAttributes: [EngineAttribute]? = nil,
        nodeAssociationStatus: NodeAssociationStatus? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeAssociationStatus = nodeAssociationStatus
    }
}

struct DescribeNodeAssociationStatusOutputResponseBody: Equatable {
    public let nodeAssociationStatus: NodeAssociationStatus?
    public let engineAttributes: [EngineAttribute]?
}

extension DescribeNodeAssociationStatusOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeAssociationStatus = "NodeAssociationStatus"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusDecoded = try containerValues.decodeIfPresent(NodeAssociationStatus.self, forKey: .nodeAssociationStatus)
        nodeAssociationStatus = nodeAssociationStatusDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

public struct DescribeServersInputBodyMiddleware: Middleware {
    public let id: String = "DescribeServersInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServersInput>
    public typealias MOutput = OperationOutput<DescribeServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServersOutputError>
}

extension DescribeServersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServersInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), serverName: \(String(describing: serverName)))"}
}

extension DescribeServersInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DescribeServersInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeServersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServersInput>
    public typealias MOutput = OperationOutput<DescribeServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServersOutputError>
}

public struct DescribeServersInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeServersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeServersInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeServersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeServersInput>
    public typealias MOutput = OperationOutput<DescribeServersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeServersOutputError>
}

public struct DescribeServersInput: Equatable {
    /// <p>This is not currently implemented for <code>DescribeServers</code> requests.
    ///     </p>
    public let maxResults: Int?
    /// <p>This is not currently implemented for <code>DescribeServers</code> requests.
    ///     </p>
    public let nextToken: String?
    /// <p>Describes the server with the specified ServerName.</p>
    public let serverName: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        serverName: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverName = serverName
    }
}

struct DescribeServersInputBody: Equatable {
    public let serverName: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension DescribeServersInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeServersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeServersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeServersOutputError: Equatable {
    case invalidNextTokenException(InvalidNextTokenException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeServersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeServersOutputResponse(nextToken: \(String(describing: nextToken)), servers: \(String(describing: servers)))"}
}

extension DescribeServersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeServersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.servers = output.servers
        } else {
            self.nextToken = nil
            self.servers = nil
        }
    }
}

public struct DescribeServersOutputResponse: Equatable {
    /// <p>This is not currently implemented for <code>DescribeServers</code> requests.
    ///     </p>
    public let nextToken: String?
    /// <p>Contains the response to a <code>DescribeServers</code> request.</p>
    ///          <p>
    ///             <i>For Chef Automate servers:</i>  If <code>DescribeServersResponse$Servers$EngineAttributes</code> includes
    ///       CHEF_MAJOR_UPGRADE_AVAILABLE, you can upgrade the Chef Automate server to Chef Automate 2. To be eligible for upgrade, a server running
    ///       Chef Automate 1 must have had at least one successful maintenance run after November 1, 2019.</p>
    ///          <p>
    ///             <i>For Puppet servers:</i>
    ///             <code>DescribeServersResponse$Servers$EngineAttributes</code> contains
    ///       the following two responses:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_API_CA_CERT</code>, the PEM-encoded CA certificate that is used by the Puppet API over TCP port number 8140.
    ///         The CA certificate is also used to sign node certificates.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_API_CRL</code>, a certificate revocation list. The certificate revocation list is for internal
    ///         maintenance purposes only. For more information about the Puppet certificate revocation list, see
    ///         <a href="https://puppet.com/docs/puppet/5.5/man/certificate_revocation_list.html">Man Page: puppet certificate_revocation_list</a> in the Puppet documentation.</p>
    ///             </li>
    ///          </ul>
    public let servers: [Server]?

    public init (
        nextToken: String? = nil,
        servers: [Server]? = nil
    )
    {
        self.nextToken = nextToken
        self.servers = servers
    }
}

struct DescribeServersOutputResponseBody: Equatable {
    public let servers: [Server]?
    public let nextToken: String?
}

extension DescribeServersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case servers = "Servers"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serversContainer = try containerValues.decodeIfPresent([Server?].self, forKey: .servers)
        var serversDecoded0:[Server]? = nil
        if let serversContainer = serversContainer {
            serversDecoded0 = [Server]()
            for structure0 in serversContainer {
                if let structure0 = structure0 {
                    serversDecoded0?.append(structure0)
                }
            }
        }
        servers = serversDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct DisassociateNodeInputBodyMiddleware: Middleware {
    public let id: String = "DisassociateNodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateNodeInput>
    public typealias MOutput = OperationOutput<DisassociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateNodeOutputError>
}

extension DisassociateNodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateNodeInput(engineAttributes: \(String(describing: engineAttributes)), nodeName: \(String(describing: nodeName)), serverName: \(String(describing: serverName)))"}
}

extension DisassociateNodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let nodeName = nodeName {
            try encodeContainer.encode(nodeName, forKey: .nodeName)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct DisassociateNodeInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateNodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateNodeInput>
    public typealias MOutput = OperationOutput<DisassociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateNodeOutputError>
}

public struct DisassociateNodeInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateNodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateNodeInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateNodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateNodeInput>
    public typealias MOutput = OperationOutput<DisassociateNodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateNodeOutputError>
}

public struct DisassociateNodeInput: Equatable {
    /// <p>Engine attributes that are used for disassociating the node. No attributes are required for Puppet.
    ///     </p>
    ///          <p class="title">
    ///             <b>Attributes required in a DisassociateNode request for Chef</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_ORGANIZATION</code>: The Chef organization
    ///           with which the node was associated. By default only one organization
    ///           named <code>default</code> can exist.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [EngineAttribute]?
    /// <p>The name of the client node.
    ///     </p>
    public let nodeName: String?
    /// <p>The name of the server from which to disassociate the node.
    ///     </p>
    public let serverName: String?

    public init (
        engineAttributes: [EngineAttribute]? = nil,
        nodeName: String? = nil,
        serverName: String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.nodeName = nodeName
        self.serverName = serverName
    }
}

struct DisassociateNodeInputBody: Equatable {
    public let serverName: String?
    public let nodeName: String?
    public let engineAttributes: [EngineAttribute]?
}

extension DisassociateNodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineAttributes = "EngineAttributes"
        case nodeName = "NodeName"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let nodeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeName)
        nodeName = nodeNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension DisassociateNodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateNodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateNodeOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateNodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateNodeOutputResponse(nodeAssociationStatusToken: \(String(describing: nodeAssociationStatusToken)))"}
}

extension DisassociateNodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateNodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nodeAssociationStatusToken = output.nodeAssociationStatusToken
        } else {
            self.nodeAssociationStatusToken = nil
        }
    }
}

public struct DisassociateNodeOutputResponse: Equatable {
    /// <p>Contains a token which can be passed to the
    ///       <code>DescribeNodeAssociationStatus</code> API call to get the status of
    ///       the disassociation request.
    ///     </p>
    public let nodeAssociationStatusToken: String?

    public init (
        nodeAssociationStatusToken: String? = nil
    )
    {
        self.nodeAssociationStatusToken = nodeAssociationStatusToken
    }
}

struct DisassociateNodeOutputResponseBody: Equatable {
    public let nodeAssociationStatusToken: String?
}

extension DisassociateNodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nodeAssociationStatusToken = "NodeAssociationStatusToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nodeAssociationStatusTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nodeAssociationStatusToken)
        nodeAssociationStatusToken = nodeAssociationStatusTokenDecoded
    }
}

extension EngineAttribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension EngineAttribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EngineAttribute(name: \(String(describing: name)), value: \(String(describing: value)))"}
}

/// <p>A name and value pair that is specific to the engine of the server.
///     </p>
public struct EngineAttribute: Equatable {
    /// <p>The name of the engine attribute.
    ///     </p>
    public let name: String?
    /// <p>The value of the engine attribute.
    ///     </p>
    public let value: String?

    public init (
        name: String? = nil,
        value: String? = nil
    )
    {
        self.name = name
        self.value = value
    }
}

public struct ExportServerEngineAttributeInputBodyMiddleware: Middleware {
    public let id: String = "ExportServerEngineAttributeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportServerEngineAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportServerEngineAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportServerEngineAttributeInput>
    public typealias MOutput = OperationOutput<ExportServerEngineAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportServerEngineAttributeOutputError>
}

extension ExportServerEngineAttributeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportServerEngineAttributeInput(exportAttributeName: \(String(describing: exportAttributeName)), inputAttributes: \(String(describing: inputAttributes)), serverName: \(String(describing: serverName)))"}
}

extension ExportServerEngineAttributeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exportAttributeName = "ExportAttributeName"
        case inputAttributes = "InputAttributes"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exportAttributeName = exportAttributeName {
            try encodeContainer.encode(exportAttributeName, forKey: .exportAttributeName)
        }
        if let inputAttributes = inputAttributes {
            var inputAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputAttributes)
            for engineattributes0 in inputAttributes {
                try inputAttributesContainer.encode(engineattributes0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct ExportServerEngineAttributeInputHeadersMiddleware: Middleware {
    public let id: String = "ExportServerEngineAttributeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportServerEngineAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportServerEngineAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportServerEngineAttributeInput>
    public typealias MOutput = OperationOutput<ExportServerEngineAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportServerEngineAttributeOutputError>
}

public struct ExportServerEngineAttributeInputQueryItemMiddleware: Middleware {
    public let id: String = "ExportServerEngineAttributeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ExportServerEngineAttributeInput>,
                  next: H) -> Swift.Result<OperationOutput<ExportServerEngineAttributeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ExportServerEngineAttributeInput>
    public typealias MOutput = OperationOutput<ExportServerEngineAttributeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ExportServerEngineAttributeOutputError>
}

public struct ExportServerEngineAttributeInput: Equatable {
    /// <p>The name of the export attribute. Currently, the supported export attribute is <code>Userdata</code>.
    ///       This exports a user data script that includes parameters and values provided in the <code>InputAttributes</code> list.</p>
    public let exportAttributeName: String?
    /// <p>The list of engine attributes. The list type is <code>EngineAttribute</code>. An <code>EngineAttribute</code> list item
    ///       is a pair that includes an attribute name and its value. For the <code>Userdata</code> ExportAttributeName, the following are
    ///       supported engine attribute names.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>RunList</b> In Chef, a list of roles or recipes that are run in the specified order.
    ///         In Puppet, this parameter is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>OrganizationName</b> In Chef, an organization name. AWS OpsWorks for Chef Automate
    ///         always creates the organization <code>default</code>. In Puppet, this parameter is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>NodeEnvironment</b> In Chef, a node environment (for example, development, staging, or one-box).
    ///         In Puppet, this parameter is ignored.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>NodeClientVersion</b> In Chef, the version of the Chef engine (three numbers separated
    ///         by dots, such as 13.8.5). If this attribute is empty, OpsWorks for Chef Automate uses the most current version. In Puppet,
    ///         this parameter is ignored.</p>
    ///             </li>
    ///          </ul>
    public let inputAttributes: [EngineAttribute]?
    /// <p>The name of the server from which you are exporting the attribute.</p>
    public let serverName: String?

    public init (
        exportAttributeName: String? = nil,
        inputAttributes: [EngineAttribute]? = nil,
        serverName: String? = nil
    )
    {
        self.exportAttributeName = exportAttributeName
        self.inputAttributes = inputAttributes
        self.serverName = serverName
    }
}

struct ExportServerEngineAttributeInputBody: Equatable {
    public let exportAttributeName: String?
    public let serverName: String?
    public let inputAttributes: [EngineAttribute]?
}

extension ExportServerEngineAttributeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exportAttributeName = "ExportAttributeName"
        case inputAttributes = "InputAttributes"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportAttributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .exportAttributeName)
        exportAttributeName = exportAttributeNameDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let inputAttributesContainer = try containerValues.decodeIfPresent([EngineAttribute?].self, forKey: .inputAttributes)
        var inputAttributesDecoded0:[EngineAttribute]? = nil
        if let inputAttributesContainer = inputAttributesContainer {
            inputAttributesDecoded0 = [EngineAttribute]()
            for structure0 in inputAttributesContainer {
                if let structure0 = structure0 {
                    inputAttributesDecoded0?.append(structure0)
                }
            }
        }
        inputAttributes = inputAttributesDecoded0
    }
}

extension ExportServerEngineAttributeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExportServerEngineAttributeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ExportServerEngineAttributeOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExportServerEngineAttributeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExportServerEngineAttributeOutputResponse(engineAttribute: \(String(describing: engineAttribute)), serverName: \(String(describing: serverName)))"}
}

extension ExportServerEngineAttributeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ExportServerEngineAttributeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.engineAttribute = output.engineAttribute
            self.serverName = output.serverName
        } else {
            self.engineAttribute = nil
            self.serverName = nil
        }
    }
}

public struct ExportServerEngineAttributeOutputResponse: Equatable {
    /// <p>The requested engine attribute pair with attribute name and value.</p>
    public let engineAttribute: EngineAttribute?
    /// <p>The server name used in the request.</p>
    public let serverName: String?

    public init (
        engineAttribute: EngineAttribute? = nil,
        serverName: String? = nil
    )
    {
        self.engineAttribute = engineAttribute
        self.serverName = serverName
    }
}

struct ExportServerEngineAttributeOutputResponseBody: Equatable {
    public let engineAttribute: EngineAttribute?
    public let serverName: String?
}

extension ExportServerEngineAttributeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineAttribute = "EngineAttribute"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engineAttributeDecoded = try containerValues.decodeIfPresent(EngineAttribute.self, forKey: .engineAttribute)
        engineAttribute = engineAttributeDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
    }
}

extension InvalidNextTokenException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidNextTokenException(message: \(String(describing: message)))"}
}

extension InvalidNextTokenException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>This occurs when the provided nextToken is not valid.
///     </p>
public struct InvalidNextTokenException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error or informational message that can contain more detail about a nextToken failure.
    ///     </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Equatable {
    public let message: String?
}

extension InvalidNextTokenExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidStateException(message: \(String(describing: message)))"}
}

extension InvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource is in a state that does not allow you to perform a specified action.
///     </p>
public struct InvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error or informational message that provides more detail if a resource is
    ///       in a state that is not valid for performing a specified action.
    ///     </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidStateExceptionBody: Equatable {
    public let message: String?
}

extension InvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The limit of servers or backups has been reached.
///     </p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error or informational message that the maximum allowed number of servers or backups has been exceeded.
    ///     </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>To receive a paginated response, use this parameter to specify the maximum number
    ///         of results to be returned with a single call. If the number of available results exceeds
    ///         this maximum, the response includes a <code>NextToken</code> value that you can assign to the <code>NextToken</code>
    ///         request parameter to get the next set of results.</p>
    public let maxResults: Int?
    /// <p>NextToken is a string that is returned in some command responses. It indicates that
    ///         not all entries have been returned, and that you must run at least one more request to get remaining
    ///         items. To get remaining results, call <code>ListTagsForResource</code> again, and assign the token from the previous
    ///         results as the value of the <code>nextToken</code> parameter. If there are no more results,
    ///         the response object's <code>nextToken</code> parameter value is <code>null</code>.
    ///         Setting a <code>nextToken</code> value that was not returned in
    ///         your previous results causes an <code>InvalidNextTokenException</code> to occur.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Number (ARN) of an AWS OpsWorks for Chef Automate or AWS OpsWorks for Puppet Enterprise server for which you want to show applied tags. For example,
    ///         <code>arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE</code>.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(nextToken: \(String(describing: nextToken)), tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A token that you can use as the value of <code>NextToken</code> in subsequent calls to the API to show more results.</p>
    public let nextToken: String?
    /// <p>Tags that have been applied to the resource.</p>
    public let tags: [Tag]?

    public init (
        nextToken: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
    public let nextToken: String?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public enum MaintenanceStatus {
    case failed
    case success
    case sdkUnknown(String)
}

extension MaintenanceStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [MaintenanceStatus] {
        return [
            .failed,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = MaintenanceStatus(rawValue: rawValue) ?? MaintenanceStatus.sdkUnknown(rawValue)
    }
}

/// <p>The status of the association or disassociation request.
///     </p>
///          <p class="title">
///             <b>Possible values:</b>
///          </p>
///          <ul>
///             <li>
///                <p>
///                   <code>SUCCESS</code>: The association or disassociation succeeded.
///       </p>
///             </li>
///             <li>
///                <p>
///                   <code>FAILED</code>: The association or disassociation failed.
///       </p>
///             </li>
///             <li>
///                <p>
///                   <code>IN_PROGRESS</code>: The association or disassociation is still in progress.
///       </p>
///             </li>
///          </ul>
public enum NodeAssociationStatus {
    case failed
    case inProgress
    case success
    case sdkUnknown(String)
}

extension NodeAssociationStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NodeAssociationStatus] {
        return [
            .failed,
            .inProgress,
            .success,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .success: return "SUCCESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NodeAssociationStatus(rawValue: rawValue) ?? NodeAssociationStatus.sdkUnknown(rawValue)
    }
}

extension ResourceAlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceAlreadyExistsException(message: \(String(describing: message)))"}
}

extension ResourceAlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource cannot be created because it already exists.
///     </p>
public struct ResourceAlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error or informational message in response to a CreateServer request that a resource cannot be created because it already exists.
    ///     </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceAlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension ResourceAlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The requested resource does not exist, or access was denied.
///     </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error or informational message that can contain more detail about problems locating or accessing a resource.
    ///     </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct RestoreServerInputBodyMiddleware: Middleware {
    public let id: String = "RestoreServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreServerInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreServerInput>
    public typealias MOutput = OperationOutput<RestoreServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreServerOutputError>
}

extension RestoreServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreServerInput(backupId: \(String(describing: backupId)), instanceType: \(String(describing: instanceType)), keyPair: \(String(describing: keyPair)), serverName: \(String(describing: serverName)))"}
}

extension RestoreServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupId = backupId {
            try encodeContainer.encode(backupId, forKey: .backupId)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct RestoreServerInputHeadersMiddleware: Middleware {
    public let id: String = "RestoreServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreServerInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreServerInput>
    public typealias MOutput = OperationOutput<RestoreServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreServerOutputError>
}

public struct RestoreServerInputQueryItemMiddleware: Middleware {
    public let id: String = "RestoreServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RestoreServerInput>,
                  next: H) -> Swift.Result<OperationOutput<RestoreServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RestoreServerInput>
    public typealias MOutput = OperationOutput<RestoreServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RestoreServerOutputError>
}

public struct RestoreServerInput: Equatable {
    /// <p> The ID of the backup that you want to use to restore a server.
    ///     </p>
    public let backupId: String?
    /// <p> The type of instance to restore. Valid values must be specified in the following format: <code>^([cm][34]|t2).*</code>
    ///       For example, <code>m5.large</code>. Valid values are <code>m5.large</code>, <code>r5.xlarge</code>, and <code>r5.2xlarge</code>. If you do not specify this parameter,
    ///       RestoreServer uses the instance type from the specified backup.
    ///     </p>
    public let instanceType: String?
    /// <p> The name of the key pair to set on the new EC2 instance. This can be helpful
    ///       if the administrator no longer has the SSH key.
    ///     </p>
    public let keyPair: String?
    /// <p> The name of the server that you want to restore.
    ///     </p>
    public let serverName: String?

    public init (
        backupId: String? = nil,
        instanceType: String? = nil,
        keyPair: String? = nil,
        serverName: String? = nil
    )
    {
        self.backupId = backupId
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.serverName = serverName
    }
}

struct RestoreServerInputBody: Equatable {
    public let backupId: String?
    public let serverName: String?
    public let instanceType: String?
    public let keyPair: String?
}

extension RestoreServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupId = "BackupId"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let backupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .backupId)
        backupId = backupIdDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

extension RestoreServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RestoreServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RestoreServerOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RestoreServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RestoreServerOutputResponse(server: \(String(describing: server)))"}
}

extension RestoreServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RestoreServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct RestoreServerOutputResponse: Equatable {
    /// <p>Describes a configuration management server.
    ///     </p>
    public let server: Server?

    public init (
        server: Server? = nil
    )
    {
        self.server = server
    }
}

struct RestoreServerOutputResponseBody: Equatable {
    public let server: Server?
}

extension RestoreServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case server = "Server"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension Server: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case associatePublicIpAddress = "AssociatePublicIpAddress"
        case backupRetentionCount = "BackupRetentionCount"
        case cloudFormationStackArn = "CloudFormationStackArn"
        case createdAt = "CreatedAt"
        case customDomain = "CustomDomain"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case endpoint = "Endpoint"
        case engine = "Engine"
        case engineAttributes = "EngineAttributes"
        case engineModel = "EngineModel"
        case engineVersion = "EngineVersion"
        case instanceProfileArn = "InstanceProfileArn"
        case instanceType = "InstanceType"
        case keyPair = "KeyPair"
        case maintenanceStatus = "MaintenanceStatus"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case securityGroupIds = "SecurityGroupIds"
        case serverArn = "ServerArn"
        case serverName = "ServerName"
        case serviceRoleArn = "ServiceRoleArn"
        case status = "Status"
        case statusReason = "StatusReason"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let backupRetentionCount = backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let cloudFormationStackArn = cloudFormationStackArn {
            try encodeContainer.encode(cloudFormationStackArn, forKey: .cloudFormationStackArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let customDomain = customDomain {
            try encodeContainer.encode(customDomain, forKey: .customDomain)
        }
        if let disableAutomatedBackup = disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let endpoint = endpoint {
            try encodeContainer.encode(endpoint, forKey: .endpoint)
        }
        if let engine = engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let engineModel = engineModel {
            try encodeContainer.encode(engineModel, forKey: .engineModel)
        }
        if let engineVersion = engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let instanceProfileArn = instanceProfileArn {
            try encodeContainer.encode(instanceProfileArn, forKey: .instanceProfileArn)
        }
        if let instanceType = instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let keyPair = keyPair {
            try encodeContainer.encode(keyPair, forKey: .keyPair)
        }
        if let maintenanceStatus = maintenanceStatus {
            try encodeContainer.encode(maintenanceStatus.rawValue, forKey: .maintenanceStatus)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for strings0 in securityGroupIds {
                try securityGroupIdsContainer.encode(strings0)
            }
        }
        if let serverArn = serverArn {
            try encodeContainer.encode(serverArn, forKey: .serverArn)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
        if let serviceRoleArn = serviceRoleArn {
            try encodeContainer.encode(serviceRoleArn, forKey: .serviceRoleArn)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for strings0 in subnetIds {
                try subnetIdsContainer.encode(strings0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let cloudFormationStackArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .cloudFormationStackArn)
        cloudFormationStackArn = cloudFormationStackArnDecoded
        let customDomainDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customDomain)
        customDomain = customDomainDecoded
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpoint)
        endpoint = endpointDecoded
        let engineDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engine)
        engine = engineDecoded
        let engineModelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineModel)
        engineModel = engineModelDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
        let engineVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let instanceProfileArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceProfileArn)
        instanceProfileArn = instanceProfileArnDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let keyPairDecoded = try containerValues.decodeIfPresent(String.self, forKey: .keyPair)
        keyPair = keyPairDecoded
        let maintenanceStatusDecoded = try containerValues.decodeIfPresent(MaintenanceStatus.self, forKey: .maintenanceStatus)
        maintenanceStatus = maintenanceStatusDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let serviceRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceRoleArn)
        serviceRoleArn = serviceRoleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ServerStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let serverArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverArn)
        serverArn = serverArnDecoded
    }
}

extension Server: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Server(associatePublicIpAddress: \(String(describing: associatePublicIpAddress)), backupRetentionCount: \(String(describing: backupRetentionCount)), cloudFormationStackArn: \(String(describing: cloudFormationStackArn)), createdAt: \(String(describing: createdAt)), customDomain: \(String(describing: customDomain)), disableAutomatedBackup: \(String(describing: disableAutomatedBackup)), endpoint: \(String(describing: endpoint)), engine: \(String(describing: engine)), engineAttributes: \(String(describing: engineAttributes)), engineModel: \(String(describing: engineModel)), engineVersion: \(String(describing: engineVersion)), instanceProfileArn: \(String(describing: instanceProfileArn)), instanceType: \(String(describing: instanceType)), keyPair: \(String(describing: keyPair)), maintenanceStatus: \(String(describing: maintenanceStatus)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), securityGroupIds: \(String(describing: securityGroupIds)), serverArn: \(String(describing: serverArn)), serverName: \(String(describing: serverName)), serviceRoleArn: \(String(describing: serviceRoleArn)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>Describes a configuration management server.
///     </p>
public struct Server: Equatable {
    /// <p>Associate a public IP address with a server that you are launching.
    ///     </p>
    public let associatePublicIpAddress: Bool?
    /// <p>The number of automated backups to keep.
    ///     </p>
    public let backupRetentionCount: Int?
    /// <p>The ARN of the CloudFormation stack that was used to create the server.
    ///     </p>
    public let cloudFormationStackArn: String?
    /// <p>Time stamp of server creation. Example <code>2016-07-29T13:38:47.520Z</code>
    ///          </p>
    public let createdAt: Date?
    /// <p>An optional public endpoint of a server, such as <code>https://aws.my-company.com</code>.
    ///       You cannot access the server by using the <code>Endpoint</code> value if the server has a <code>CustomDomain</code> specified.</p>
    public let customDomain: String?
    /// <p>Disables automated backups. The number of stored backups is dependent on the value of PreferredBackupCount.
    ///     </p>
    public let disableAutomatedBackup: Bool?
    /// <p>
    ///       A DNS name that can be used to access the engine. Example: <code>myserver-asdfghjkl.us-east-1.opsworks.io</code>.
    ///       You cannot access the server by using the <code>Endpoint</code> value if the server has a <code>CustomDomain</code> specified.
    ///     </p>
    public let endpoint: String?
    /// <p>The engine type of the server. Valid values in this release include <code>ChefAutomate</code> and <code>Puppet</code>.
    ///     </p>
    public let engine: String?
    /// <p>The response of a createServer() request returns the master
    ///     credential to access the server in EngineAttributes. These
    ///     credentials are not stored by AWS OpsWorks CM; they are returned only as part of the result of createServer().
    ///     </p>
    ///          <p class="title">
    ///             <b>Attributes returned in a createServer response for Chef</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_AUTOMATE_PIVOTAL_KEY</code>: A base64-encoded RSA private key that is
    ///       generated by AWS OpsWorks for Chef Automate. This private key is required to access
    ///       the Chef API.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_STARTER_KIT</code>: A base64-encoded ZIP file.
    ///       The ZIP file contains a Chef starter kit, which includes a README, a
    ///       configuration file, and the required RSA private key. Save this file, unzip it,
    ///       and then change to the directory where you've unzipped the file contents.
    ///       From this directory, you can run Knife commands.</p>
    ///             </li>
    ///          </ul>
    ///          <p class="title">
    ///             <b>Attributes returned in a createServer response for Puppet</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_STARTER_KIT</code>: A base64-encoded ZIP file.
    ///         The ZIP file contains a Puppet starter kit, including a README and a
    ///         required private key. Save this file, unzip it,
    ///         and then change to the directory where you've unzipped the file contents.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PUPPET_ADMIN_PASSWORD</code>: An administrator password that you can use to sign in to the Puppet Enterprise console after the server is online.</p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [EngineAttribute]?
    /// <p>The engine model of the server. Valid values in this release include <code>Monolithic</code> for Puppet and <code>Single</code> for Chef.
    ///     </p>
    public let engineModel: String?
    /// <p>The engine version of the server. For a Chef server, the valid value for EngineVersion is
    ///       currently <code>2</code>. For a Puppet server, specify either <code>2019</code> or <code>2017</code>.
    ///     </p>
    public let engineVersion: String?
    /// <p>The instance profile ARN of the server.
    ///     </p>
    public let instanceProfileArn: String?
    /// <p>
    ///       The instance type for the server, as specified in the CloudFormation stack. This might not be the same instance type that is shown in the EC2 console.
    ///     </p>
    public let instanceType: String?
    /// <p>The key pair associated with the server.
    ///     </p>
    public let keyPair: String?
    /// <p>The status of the most recent server maintenance run. Shows <code>SUCCESS</code> or <code>FAILED</code>.
    ///     </p>
    public let maintenanceStatus: MaintenanceStatus?
    /// <p>The preferred backup period specified for the server.
    ///     </p>
    public let preferredBackupWindow: String?
    /// <p>The preferred maintenance period specified for the server.
    ///     </p>
    public let preferredMaintenanceWindow: String?
    /// <p>
    ///       The security group IDs for the server, as specified in the CloudFormation stack.
    ///       These might not be the same security groups that are shown in the EC2 console.
    ///     </p>
    public let securityGroupIds: [String]?
    /// <p>The ARN of the server.
    ///     </p>
    public let serverArn: String?
    /// <p>The name of the server.
    ///     </p>
    public let serverName: String?
    /// <p>The service role ARN used to create the server.
    ///     </p>
    public let serviceRoleArn: String?
    /// <p>
    ///       The server's status. This field displays the states of actions in progress, such as creating, running, or backing up the server,
    ///       as well as the server's health state.
    ///     </p>
    public let status: ServerStatus?
    /// <p>
    ///       Depending on the server status, this field has either a human-readable
    ///       message (such as a create or backup error), or an escaped block of JSON (used for health check results).
    ///     </p>
    public let statusReason: String?
    /// <p>
    ///       The subnet IDs specified in a CreateServer request.
    ///     </p>
    public let subnetIds: [String]?

    public init (
        associatePublicIpAddress: Bool? = nil,
        backupRetentionCount: Int? = nil,
        cloudFormationStackArn: String? = nil,
        createdAt: Date? = nil,
        customDomain: String? = nil,
        disableAutomatedBackup: Bool? = nil,
        endpoint: String? = nil,
        engine: String? = nil,
        engineAttributes: [EngineAttribute]? = nil,
        engineModel: String? = nil,
        engineVersion: String? = nil,
        instanceProfileArn: String? = nil,
        instanceType: String? = nil,
        keyPair: String? = nil,
        maintenanceStatus: MaintenanceStatus? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        securityGroupIds: [String]? = nil,
        serverArn: String? = nil,
        serverName: String? = nil,
        serviceRoleArn: String? = nil,
        status: ServerStatus? = nil,
        statusReason: String? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.associatePublicIpAddress = associatePublicIpAddress
        self.backupRetentionCount = backupRetentionCount
        self.cloudFormationStackArn = cloudFormationStackArn
        self.createdAt = createdAt
        self.customDomain = customDomain
        self.disableAutomatedBackup = disableAutomatedBackup
        self.endpoint = endpoint
        self.engine = engine
        self.engineAttributes = engineAttributes
        self.engineModel = engineModel
        self.engineVersion = engineVersion
        self.instanceProfileArn = instanceProfileArn
        self.instanceType = instanceType
        self.keyPair = keyPair
        self.maintenanceStatus = maintenanceStatus
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.securityGroupIds = securityGroupIds
        self.serverArn = serverArn
        self.serverName = serverName
        self.serviceRoleArn = serviceRoleArn
        self.status = status
        self.statusReason = statusReason
        self.subnetIds = subnetIds
    }
}

extension ServerEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case logUrl = "LogUrl"
        case message = "Message"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let logUrl = logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
    }
}

extension ServerEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServerEvent(createdAt: \(String(describing: createdAt)), logUrl: \(String(describing: logUrl)), message: \(String(describing: message)), serverName: \(String(describing: serverName)))"}
}

/// <p>An event that is related to the server, such as the start of maintenance or backup.
///     </p>
public struct ServerEvent: Equatable {
    /// <p>The time when the event occurred.
    ///     </p>
    public let createdAt: Date?
    /// <p>The Amazon S3 URL of the event's log file.</p>
    public let logUrl: String?
    /// <p>A human-readable informational or status message.</p>
    public let message: String?
    /// <p>The name of the server on or for which the event occurred.
    ///     </p>
    public let serverName: String?

    public init (
        createdAt: Date? = nil,
        logUrl: String? = nil,
        message: String? = nil,
        serverName: String? = nil
    )
    {
        self.createdAt = createdAt
        self.logUrl = logUrl
        self.message = message
        self.serverName = serverName
    }
}

public enum ServerStatus {
    case backingUp
    case connectionLost
    case creating
    case deleting
    case failed
    case healthy
    case modifying
    case restoring
    case running
    case setup
    case terminated
    case underMaintenance
    case unhealthy
    case sdkUnknown(String)
}

extension ServerStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServerStatus] {
        return [
            .backingUp,
            .connectionLost,
            .creating,
            .deleting,
            .failed,
            .healthy,
            .modifying,
            .restoring,
            .running,
            .setup,
            .terminated,
            .underMaintenance,
            .unhealthy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .backingUp: return "BACKING_UP"
        case .connectionLost: return "CONNECTION_LOST"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .healthy: return "HEALTHY"
        case .modifying: return "MODIFYING"
        case .restoring: return "RESTORING"
        case .running: return "RUNNING"
        case .setup: return "SETUP"
        case .terminated: return "TERMINATED"
        case .underMaintenance: return "UNDER_MAINTENANCE"
        case .unhealthy: return "UNHEALTHY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServerStatus(rawValue: rawValue) ?? ServerStatus.sdkUnknown(rawValue)
    }
}

public struct StartMaintenanceInputBodyMiddleware: Middleware {
    public let id: String = "StartMaintenanceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMaintenanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMaintenanceInput>
    public typealias MOutput = OperationOutput<StartMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMaintenanceOutputError>
}

extension StartMaintenanceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMaintenanceInput(engineAttributes: \(String(describing: engineAttributes)), serverName: \(String(describing: serverName)))"}
}

extension StartMaintenanceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case engineAttributes = "EngineAttributes"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engineAttributes = engineAttributes {
            var engineAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engineAttributes)
            for engineattributes0 in engineAttributes {
                try engineAttributesContainer.encode(engineattributes0)
            }
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct StartMaintenanceInputHeadersMiddleware: Middleware {
    public let id: String = "StartMaintenanceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMaintenanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMaintenanceInput>
    public typealias MOutput = OperationOutput<StartMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMaintenanceOutputError>
}

public struct StartMaintenanceInputQueryItemMiddleware: Middleware {
    public let id: String = "StartMaintenanceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartMaintenanceInput>,
                  next: H) -> Swift.Result<OperationOutput<StartMaintenanceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartMaintenanceInput>
    public typealias MOutput = OperationOutput<StartMaintenanceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartMaintenanceOutputError>
}

public struct StartMaintenanceInput: Equatable {
    /// <p>Engine attributes that are specific to the server on which you want to run maintenance.</p>
    ///          <p class="title">
    ///             <b>Attributes accepted in a StartMaintenance request for Chef</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>CHEF_MAJOR_UPGRADE</code>: If a Chef Automate server is eligible for upgrade to Chef Automate 2,
    ///         add this engine attribute to a <code>StartMaintenance</code> request and set the value to <code>true</code> to upgrade the server to Chef Automate 2. For more information, see
    ///         <a href="https://docs.aws.amazon.com/opsworks/latest/userguide/opscm-a2upgrade.html">Upgrade an AWS OpsWorks for Chef Automate Server to Chef Automate 2</a>.
    ///       </p>
    ///             </li>
    ///          </ul>
    public let engineAttributes: [EngineAttribute]?
    /// <p>The name of the server on which to run maintenance.
    ///     </p>
    public let serverName: String?

    public init (
        engineAttributes: [EngineAttribute]? = nil,
        serverName: String? = nil
    )
    {
        self.engineAttributes = engineAttributes
        self.serverName = serverName
    }
}

struct StartMaintenanceInputBody: Equatable {
    public let serverName: String?
    public let engineAttributes: [EngineAttribute]?
}

extension StartMaintenanceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case engineAttributes = "EngineAttributes"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let engineAttributesContainer = try containerValues.decodeIfPresent([EngineAttribute?].self, forKey: .engineAttributes)
        var engineAttributesDecoded0:[EngineAttribute]? = nil
        if let engineAttributesContainer = engineAttributesContainer {
            engineAttributesDecoded0 = [EngineAttribute]()
            for structure0 in engineAttributesContainer {
                if let structure0 = structure0 {
                    engineAttributesDecoded0?.append(structure0)
                }
            }
        }
        engineAttributes = engineAttributesDecoded0
    }
}

extension StartMaintenanceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMaintenanceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartMaintenanceOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMaintenanceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartMaintenanceOutputResponse(server: \(String(describing: server)))"}
}

extension StartMaintenanceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartMaintenanceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct StartMaintenanceOutputResponse: Equatable {
    /// <p>Contains the response to a <code>StartMaintenance</code> request.
    ///     </p>
    public let server: Server?

    public init (
        server: Server? = nil
    )
    {
        self.server = server
    }
}

struct StartMaintenanceOutputResponseBody: Equatable {
    public let server: Server?
}

extension StartMaintenanceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case server = "Server"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A map that contains tag keys and tag values to attach to an AWS OpsWorks for Chef Automate
///       or AWS OpsWorks for Puppet Enterprise server. Leading and trailing white spaces are trimmed from both the key and value.
///       A maximum of 50 user-applied tags is allowed for tag-supported AWS OpsWorks-CM resources.</p>
public struct Tag: Equatable {
    /// <p>A tag key, such as <code>Stage</code> or <code>Name</code>. A tag key cannot be empty. The key can be a maximum of 127 characters,
    ///       and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///          </p>
    public let key: String?
    /// <p>An optional tag value, such as <code>Production</code> or <code>test-owcm-server</code>. The value can be a maximum of 255 characters,
    ///       and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///          </p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of a resource to which you want to apply tags. For example,
    ///       <code>arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE</code>.</p>
    public let resourceArn: String?
    /// <p>A map that contains tag keys and tag values to attach to AWS OpsWorks-CM servers or backups.</p>
    ///          <ul>
    ///             <li>
    ///                <p>The key cannot be empty.</p>
    ///             </li>
    ///             <li>
    ///                <p>The key can be a maximum of 127 characters, and can contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>The value can be a maximum 255 characters, and contain only Unicode letters, numbers, or separators, or the following special characters: <code>+ - = . _ : /</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>Leading and trailing white spaces are trimmed from both the key and value.</p>
    ///             </li>
    ///             <li>
    ///                <p>A maximum of 50 user-applied tags is allowed for any AWS OpsWorks-CM server or backup.</p>
    ///             </li>
    ///          </ul>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UntagResourceInputBodyMiddleware: Middleware {
    public let id: String = "UntagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkeylist0 in tagKeys {
                try tagKeysContainer.encode(tagkeylist0)
            }
        }
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Number (ARN) of a resource from which you want to remove tags. For example,
    ///       <code>arn:aws:opsworks-cm:us-west-2:123456789012:server/test-owcm-server/EXAMPLE-66b0-4196-8274-d1a2bEXAMPLE</code>.</p>
    public let resourceArn: String?
    /// <p>The keys of tags that you want to remove.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tagKeys: [String]?
}

extension UntagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateServerEngineAttributesInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServerEngineAttributesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerEngineAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerEngineAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerEngineAttributesInput>
    public typealias MOutput = OperationOutput<UpdateServerEngineAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerEngineAttributesOutputError>
}

extension UpdateServerEngineAttributesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerEngineAttributesInput(attributeName: \(String(describing: attributeName)), attributeValue: \(String(describing: attributeValue)), serverName: \(String(describing: serverName)))"}
}

extension UpdateServerEngineAttributesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let attributeValue = attributeValue {
            try encodeContainer.encode(attributeValue, forKey: .attributeValue)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct UpdateServerEngineAttributesInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServerEngineAttributesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerEngineAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerEngineAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerEngineAttributesInput>
    public typealias MOutput = OperationOutput<UpdateServerEngineAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerEngineAttributesOutputError>
}

public struct UpdateServerEngineAttributesInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServerEngineAttributesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerEngineAttributesInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerEngineAttributesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerEngineAttributesInput>
    public typealias MOutput = OperationOutput<UpdateServerEngineAttributesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerEngineAttributesOutputError>
}

public struct UpdateServerEngineAttributesInput: Equatable {
    /// <p>The name of the engine attribute to update.
    ///     </p>
    public let attributeName: String?
    /// <p>The value to set for the attribute.
    ///     </p>
    public let attributeValue: String?
    /// <p>The name of the server to update.
    ///     </p>
    public let serverName: String?

    public init (
        attributeName: String? = nil,
        attributeValue: String? = nil,
        serverName: String? = nil
    )
    {
        self.attributeName = attributeName
        self.attributeValue = attributeValue
        self.serverName = serverName
    }
}

struct UpdateServerEngineAttributesInputBody: Equatable {
    public let serverName: String?
    public let attributeName: String?
    public let attributeValue: String?
}

extension UpdateServerEngineAttributesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeName = "AttributeName"
        case attributeValue = "AttributeValue"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let attributeNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let attributeValueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .attributeValue)
        attributeValue = attributeValueDecoded
    }
}

extension UpdateServerEngineAttributesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerEngineAttributesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerEngineAttributesOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerEngineAttributesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerEngineAttributesOutputResponse(server: \(String(describing: server)))"}
}

extension UpdateServerEngineAttributesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateServerEngineAttributesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct UpdateServerEngineAttributesOutputResponse: Equatable {
    /// <p>Contains the response to an <code>UpdateServerEngineAttributes</code> request.
    ///     </p>
    public let server: Server?

    public init (
        server: Server? = nil
    )
    {
        self.server = server
    }
}

struct UpdateServerEngineAttributesOutputResponseBody: Equatable {
    public let server: Server?
}

extension UpdateServerEngineAttributesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case server = "Server"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
    }
}

public struct UpdateServerInputBodyMiddleware: Middleware {
    public let id: String = "UpdateServerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerInput>
    public typealias MOutput = OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerOutputError>
}

extension UpdateServerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerInput(backupRetentionCount: \(String(describing: backupRetentionCount)), disableAutomatedBackup: \(String(describing: disableAutomatedBackup)), preferredBackupWindow: \(String(describing: preferredBackupWindow)), preferredMaintenanceWindow: \(String(describing: preferredMaintenanceWindow)), serverName: \(String(describing: serverName)))"}
}

extension UpdateServerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case backupRetentionCount = "BackupRetentionCount"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case serverName = "ServerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let backupRetentionCount = backupRetentionCount {
            try encodeContainer.encode(backupRetentionCount, forKey: .backupRetentionCount)
        }
        if let disableAutomatedBackup = disableAutomatedBackup {
            try encodeContainer.encode(disableAutomatedBackup, forKey: .disableAutomatedBackup)
        }
        if let preferredBackupWindow = preferredBackupWindow {
            try encodeContainer.encode(preferredBackupWindow, forKey: .preferredBackupWindow)
        }
        if let preferredMaintenanceWindow = preferredMaintenanceWindow {
            try encodeContainer.encode(preferredMaintenanceWindow, forKey: .preferredMaintenanceWindow)
        }
        if let serverName = serverName {
            try encodeContainer.encode(serverName, forKey: .serverName)
        }
    }
}

public struct UpdateServerInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateServerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerInput>
    public typealias MOutput = OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerOutputError>
}

public struct UpdateServerInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateServerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateServerInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateServerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateServerInput>
    public typealias MOutput = OperationOutput<UpdateServerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateServerOutputError>
}

public struct UpdateServerInput: Equatable {
    /// <p>Sets the number of automated backups that you want to keep.
    ///       </p>
    public let backupRetentionCount: Int?
    /// <p>Setting DisableAutomatedBackup to <code>true</code> disables automated or scheduled backups. Automated backups are enabled by default.
    ///     </p>
    public let disableAutomatedBackup: Bool?
    /// <p>
    ///             <code>DDD:HH:MM</code> (weekly start time) or
    ///     <code>HH:MM</code> (daily start time).
    ///     </p>
    ///          <p>
    ///       Time windows always use coordinated universal time (UTC). Valid strings for day of week (<code>DDD</code>) are: <code>Mon</code>, <code>Tue</code>, <code>Wed</code>,
    ///       <code>Thr</code>, <code>Fri</code>, <code>Sat</code>, or <code>Sun</code>.</p>
    public let preferredBackupWindow: String?
    /// <p>
    ///             <code>DDD:HH:MM</code> (weekly start time) or
    ///     <code>HH:MM</code> (daily start time).
    ///     </p>
    ///          <p>
    ///       Time windows always use coordinated universal time (UTC). Valid strings for day of week (<code>DDD</code>) are: <code>Mon</code>, <code>Tue</code>, <code>Wed</code>,
    ///       <code>Thr</code>, <code>Fri</code>, <code>Sat</code>, or <code>Sun</code>.</p>
    public let preferredMaintenanceWindow: String?
    /// <p>The name of the server to update.
    ///     </p>
    public let serverName: String?

    public init (
        backupRetentionCount: Int? = nil,
        disableAutomatedBackup: Bool? = nil,
        preferredBackupWindow: String? = nil,
        preferredMaintenanceWindow: String? = nil,
        serverName: String? = nil
    )
    {
        self.backupRetentionCount = backupRetentionCount
        self.disableAutomatedBackup = disableAutomatedBackup
        self.preferredBackupWindow = preferredBackupWindow
        self.preferredMaintenanceWindow = preferredMaintenanceWindow
        self.serverName = serverName
    }
}

struct UpdateServerInputBody: Equatable {
    public let disableAutomatedBackup: Bool?
    public let backupRetentionCount: Int?
    public let serverName: String?
    public let preferredMaintenanceWindow: String?
    public let preferredBackupWindow: String?
}

extension UpdateServerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case backupRetentionCount = "BackupRetentionCount"
        case disableAutomatedBackup = "DisableAutomatedBackup"
        case preferredBackupWindow = "PreferredBackupWindow"
        case preferredMaintenanceWindow = "PreferredMaintenanceWindow"
        case serverName = "ServerName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disableAutomatedBackupDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .disableAutomatedBackup)
        disableAutomatedBackup = disableAutomatedBackupDecoded
        let backupRetentionCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .backupRetentionCount)
        backupRetentionCount = backupRetentionCountDecoded
        let serverNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serverName)
        serverName = serverNameDecoded
        let preferredMaintenanceWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredMaintenanceWindow)
        preferredMaintenanceWindow = preferredMaintenanceWindowDecoded
        let preferredBackupWindowDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preferredBackupWindow)
        preferredBackupWindow = preferredBackupWindowDecoded
    }
}

extension UpdateServerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateServerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidStateException" : self = .invalidStateException(try InvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateServerOutputError: Equatable {
    case invalidStateException(InvalidStateException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateServerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateServerOutputResponse(server: \(String(describing: server)))"}
}

extension UpdateServerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateServerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.server = output.server
        } else {
            self.server = nil
        }
    }
}

public struct UpdateServerOutputResponse: Equatable {
    /// <p>Contains the response to a <code>UpdateServer</code> request.
    ///     </p>
    public let server: Server?

    public init (
        server: Server? = nil
    )
    {
        self.server = server
    }
}

struct UpdateServerOutputResponseBody: Equatable {
    public let server: Server?
}

extension UpdateServerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case server = "Server"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One or more of the provided request parameters are not valid.
///     </p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>Error or informational message that can contain more detail about a validation failure.
    ///     </p>
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
