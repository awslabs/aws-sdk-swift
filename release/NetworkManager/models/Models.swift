// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AWSLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case subnetArn = "SubnetArn"
        case zone = "Zone"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subnetArn = subnetArn {
            try encodeContainer.encode(subnetArn, forKey: .subnetArn)
        }
        if let zone = zone {
            try encodeContainer.encode(zone, forKey: .zone)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zoneDecoded = try containerValues.decodeIfPresent(String.self, forKey: .zone)
        zone = zoneDecoded
        let subnetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetArn)
        subnetArn = subnetArnDecoded
    }
}

extension AWSLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AWSLocation(subnetArn: \(String(describing: subnetArn)), zone: \(String(describing: zone)))"}
}

/// <p>Specifies a location in AWS.</p>
public struct AWSLocation: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the subnet the device is located in.</p>
    public let subnetArn: String?
    /// <p>The Zone the device is located in. This can be the ID of an Availability Zone, Local Zone, Wavelength Zone, or an Outpost.</p>
    public let zone: String?

    public init (
        subnetArn: String? = nil,
        zone: String? = nil
    )
    {
        self.subnetArn = subnetArn
        self.zone = zone
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct AssociateCustomerGatewayInputBodyMiddleware: Middleware {
    public let id: String = "AssociateCustomerGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCustomerGatewayOutputError>
}

extension AssociateCustomerGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateCustomerGatewayInput(customerGatewayArn: \(String(describing: customerGatewayArn)), deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)))"}
}

extension AssociateCustomerGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct AssociateCustomerGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateCustomerGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateCustomerGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateCustomerGatewayInput>
    public typealias MOutput = OperationOutput<AssociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateCustomerGatewayOutputError>
}

public struct AssociateCustomerGatewayInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies">Resources Defined by Amazon EC2</a>.</p>
    public let customerGatewayArn: String?
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?

    public init (
        customerGatewayArn: String? = nil,
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateCustomerGatewayInputBody: Equatable {
    public let customerGatewayArn: String?
    public let deviceId: String?
    public let linkId: String?
}

extension AssociateCustomerGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateCustomerGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateCustomerGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateCustomerGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateCustomerGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateCustomerGatewayOutputResponse(customerGatewayAssociation: \(String(describing: customerGatewayAssociation)))"}
}

extension AssociateCustomerGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct AssociateCustomerGatewayOutputResponse: Equatable {
    /// <p>The customer gateway association.</p>
    public let customerGatewayAssociation: CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct AssociateCustomerGatewayOutputResponseBody: Equatable {
    public let customerGatewayAssociation: CustomerGatewayAssociation?
}

extension AssociateCustomerGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

public struct AssociateLinkInputBodyMiddleware: Middleware {
    public let id: String = "AssociateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLinkOutputError>
}

extension AssociateLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLinkInput(deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)))"}
}

extension AssociateLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct AssociateLinkInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateLinkInput>
    public typealias MOutput = OperationOutput<AssociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateLinkOutputError>
}

public struct AssociateLinkInput: Equatable {
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?

    public init (
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct AssociateLinkInputBody: Equatable {
    public let deviceId: String?
    public let linkId: String?
}

extension AssociateLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateLinkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateLinkOutputResponse(linkAssociation: \(String(describing: linkAssociation)))"}
}

extension AssociateLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct AssociateLinkOutputResponse: Equatable {
    /// <p>The link association.</p>
    public let linkAssociation: LinkAssociation?

    public init (
        linkAssociation: LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct AssociateLinkOutputResponseBody: Equatable {
    public let linkAssociation: LinkAssociation?
}

extension AssociateLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

public struct AssociateTransitGatewayConnectPeerInputBodyMiddleware: Middleware {
    public let id: String = "AssociateTransitGatewayConnectPeerInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

extension AssociateTransitGatewayConnectPeerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTransitGatewayConnectPeerInput(deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)), transitGatewayConnectPeerArn: \(String(describing: transitGatewayConnectPeerArn)))"}
}

extension AssociateTransitGatewayConnectPeerInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let transitGatewayConnectPeerArn = transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }
}

public struct AssociateTransitGatewayConnectPeerInputHeadersMiddleware: Middleware {
    public let id: String = "AssociateTransitGatewayConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInputQueryItemMiddleware: Middleware {
    public let id: String = "AssociateTransitGatewayConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AssociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AssociateTransitGatewayConnectPeerInput>
    public typealias MOutput = OperationOutput<AssociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AssociateTransitGatewayConnectPeerOutputError>
}

public struct AssociateTransitGatewayConnectPeerInput: Equatable {
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?
    /// <p>The Amazon Resource Name (ARN) of the Connect peer.</p>
    public let transitGatewayConnectPeerArn: String?

    public init (
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil,
        transitGatewayConnectPeerArn: String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct AssociateTransitGatewayConnectPeerInputBody: Equatable {
    public let transitGatewayConnectPeerArn: String?
    public let deviceId: String?
    public let linkId: String?
}

extension AssociateTransitGatewayConnectPeerInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
    }
}

extension AssociateTransitGatewayConnectPeerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateTransitGatewayConnectPeerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AssociateTransitGatewayConnectPeerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateTransitGatewayConnectPeerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssociateTransitGatewayConnectPeerOutputResponse(transitGatewayConnectPeerAssociation: \(String(describing: transitGatewayConnectPeerAssociation)))"}
}

extension AssociateTransitGatewayConnectPeerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct AssociateTransitGatewayConnectPeerOutputResponse: Equatable {
    /// <p>The transit gateway Connect peer association.</p>
    public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct AssociateTransitGatewayConnectPeerOutputResponseBody: Equatable {
    public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?
}

extension AssociateTransitGatewayConnectPeerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension Bandwidth: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case downloadSpeed = "DownloadSpeed"
        case uploadSpeed = "UploadSpeed"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let downloadSpeed = downloadSpeed {
            try encodeContainer.encode(downloadSpeed, forKey: .downloadSpeed)
        }
        if let uploadSpeed = uploadSpeed {
            try encodeContainer.encode(uploadSpeed, forKey: .uploadSpeed)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadSpeedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .uploadSpeed)
        uploadSpeed = uploadSpeedDecoded
        let downloadSpeedDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .downloadSpeed)
        downloadSpeed = downloadSpeedDecoded
    }
}

extension Bandwidth: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Bandwidth(downloadSpeed: \(String(describing: downloadSpeed)), uploadSpeed: \(String(describing: uploadSpeed)))"}
}

/// <p>Describes bandwidth information.</p>
public struct Bandwidth: Equatable {
    /// <p>Download speed in Mbps.</p>
    public let downloadSpeed: Int?
    /// <p>Upload speed in Mbps.</p>
    public let uploadSpeed: Int?

    public init (
        downloadSpeed: Int? = nil,
        uploadSpeed: Int? = nil
    )
    {
        self.downloadSpeed = downloadSpeed
        self.uploadSpeed = uploadSpeed
    }
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>There was a conflict processing the request. Updating or deleting the resource can
///             cause an inconsistent state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The resource type.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension Connection: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case connectionArn = "ConnectionArn"
        case connectionId = "ConnectionId"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let connectionArn = connectionArn {
            try encodeContainer.encode(connectionArn, forKey: .connectionArn)
        }
        if let connectionId = connectionId {
            try encodeContainer.encode(connectionId, forKey: .connectionId)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionId)
        connectionId = connectionIdDecoded
        let connectionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectionArn)
        connectionArn = connectionArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(ConnectionState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Connection: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Connection(connectedDeviceId: \(String(describing: connectedDeviceId)), connectedLinkId: \(String(describing: connectedLinkId)), connectionArn: \(String(describing: connectionArn)), connectionId: \(String(describing: connectionId)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>Describes a connection.</p>
public struct Connection: Equatable {
    /// <p>The ID of the second device in the connection.</p>
    public let connectedDeviceId: String?
    /// <p>The ID of the link for the second device in the connection.</p>
    public let connectedLinkId: String?
    /// <p>The Amazon Resource Name (ARN) of the connection.</p>
    public let connectionArn: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The date and time that the connection was created.</p>
    public let createdAt: Date?
    /// <p>The description of the connection.</p>
    public let description: String?
    /// <p>The ID of the first device in the connection.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link for the first device in the connection.</p>
    public let linkId: String?
    /// <p>The state of the connection.</p>
    public let state: ConnectionState?
    /// <p>The tags for the connection.</p>
    public let tags: [Tag]?

    public init (
        connectedDeviceId: String? = nil,
        connectedLinkId: String? = nil,
        connectionArn: String? = nil,
        connectionId: String? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil,
        state: ConnectionState? = nil,
        tags: [Tag]? = nil
    )
    {
        self.connectedDeviceId = connectedDeviceId
        self.connectedLinkId = connectedLinkId
        self.connectionArn = connectionArn
        self.connectionId = connectionId
        self.createdAt = createdAt
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.state = state
        self.tags = tags
    }
}

public enum ConnectionState {
    case available
    case deleting
    case pending
    case updating
    case sdkUnknown(String)
}

extension ConnectionState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ConnectionState] {
        return [
            .available,
            .deleting,
            .pending,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ConnectionState(rawValue: rawValue) ?? ConnectionState.sdkUnknown(rawValue)
    }
}

public struct CreateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "CreateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

extension CreateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionInput(connectedDeviceId: \(String(describing: connectedDeviceId)), connectedLinkId: \(String(describing: connectedLinkId)), description: \(String(describing: description)), deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)), tags: \(String(describing: tags)))"}
}

extension CreateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedDeviceId = connectedDeviceId {
            try encodeContainer.encode(connectedDeviceId, forKey: .connectedDeviceId)
        }
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConnectionInput>
    public typealias MOutput = OperationOutput<CreateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConnectionOutputError>
}

public struct CreateConnectionInput: Equatable {
    /// <p>The ID of the second device in the connection.</p>
    public let connectedDeviceId: String?
    /// <p>The ID of the link for the second device.</p>
    public let connectedLinkId: String?
    /// <p>A description of the connection.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the first device in the connection.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link for the first device.</p>
    public let linkId: String?
    /// <p>The tags to apply to the resource during creation.</p>
    public let tags: [Tag]?

    public init (
        connectedDeviceId: String? = nil,
        connectedLinkId: String? = nil,
        description: String? = nil,
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.connectedDeviceId = connectedDeviceId
        self.connectedLinkId = connectedLinkId
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.tags = tags
    }
}

struct CreateConnectionInputBody: Equatable {
    public let deviceId: String?
    public let connectedDeviceId: String?
    public let linkId: String?
    public let connectedLinkId: String?
    public let description: String?
    public let tags: [Tag]?
}

extension CreateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectedDeviceId = "ConnectedDeviceId"
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case deviceId = "DeviceId"
        case linkId = "LinkId"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let connectedDeviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedDeviceId)
        connectedDeviceId = connectedDeviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConnectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension CreateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct CreateConnectionOutputResponse: Equatable {
    /// <p>Information about the connection.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct CreateConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension CreateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct CreateDeviceInputBodyMiddleware: Middleware {
    public let id: String = "CreateDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceOutputError>
}

extension CreateDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceInput(aWSLocation: \(String(describing: aWSLocation)), description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), location: \(String(describing: location)), model: \(String(describing: model)), serialNumber: \(String(describing: serialNumber)), siteId: \(String(describing: siteId)), tags: \(String(describing: tags)), type: \(String(describing: type)), vendor: \(String(describing: vendor)))"}
}

extension CreateDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

public struct CreateDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "CreateDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateDeviceInput>
    public typealias MOutput = OperationOutput<CreateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateDeviceOutputError>
}

public struct CreateDeviceInput: Equatable {
    /// <p>The AWS location of the device.</p>
    public let aWSLocation: AWSLocation?
    /// <p>A description of the device.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The location of the device.</p>
    public let location: Location?
    /// <p>The model of the device.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let model: String?
    /// <p>The serial number of the device.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let serialNumber: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?
    /// <p>The tags to apply to the resource during creation.</p>
    public let tags: [Tag]?
    /// <p>The type of the device.</p>
    public let type: String?
    /// <p>The vendor of the device.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let vendor: String?

    public init (
        aWSLocation: AWSLocation? = nil,
        description: String? = nil,
        globalNetworkId: String? = nil,
        location: Location? = nil,
        model: String? = nil,
        serialNumber: String? = nil,
        siteId: String? = nil,
        tags: [Tag]? = nil,
        type: String? = nil,
        vendor: String? = nil
    )
    {
        self.aWSLocation = aWSLocation
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.tags = tags
        self.type = type
        self.vendor = vendor
    }
}

struct CreateDeviceInputBody: Equatable {
    public let aWSLocation: AWSLocation?
    public let description: String?
    public let type: String?
    public let vendor: String?
    public let model: String?
    public let serialNumber: String?
    public let location: Location?
    public let siteId: String?
    public let tags: [Tag]?
}

extension CreateDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSLocationDecoded = try containerValues.decodeIfPresent(AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateDeviceOutputResponse(device: \(String(describing: device)))"}
}

extension CreateDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct CreateDeviceOutputResponse: Equatable {
    /// <p>Information about the device.</p>
    public let device: Device?

    public init (
        device: Device? = nil
    )
    {
        self.device = device
    }
}

struct CreateDeviceOutputResponseBody: Equatable {
    public let device: Device?
}

extension CreateDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case device = "Device"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct CreateGlobalNetworkInputBodyMiddleware: Middleware {
    public let id: String = "CreateGlobalNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGlobalNetworkOutputError>
}

extension CreateGlobalNetworkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGlobalNetworkInput(description: \(String(describing: description)), tags: \(String(describing: tags)))"}
}

extension CreateGlobalNetworkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateGlobalNetworkInputHeadersMiddleware: Middleware {
    public let id: String = "CreateGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateGlobalNetworkInput>
    public typealias MOutput = OperationOutput<CreateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateGlobalNetworkOutputError>
}

public struct CreateGlobalNetworkInput: Equatable {
    /// <p>A description of the global network.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The tags to apply to the resource during creation.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.tags = tags
    }
}

struct CreateGlobalNetworkInputBody: Equatable {
    public let description: String?
    public let tags: [Tag]?
}

extension CreateGlobalNetworkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGlobalNetworkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateGlobalNetworkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateGlobalNetworkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateGlobalNetworkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateGlobalNetworkOutputResponse(globalNetwork: \(String(describing: globalNetwork)))"}
}

extension CreateGlobalNetworkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct CreateGlobalNetworkOutputResponse: Equatable {
    /// <p>Information about the global network object.</p>
    public let globalNetwork: GlobalNetwork?

    public init (
        globalNetwork: GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct CreateGlobalNetworkOutputResponseBody: Equatable {
    public let globalNetwork: GlobalNetwork?
}

extension CreateGlobalNetworkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

public struct CreateLinkInputBodyMiddleware: Middleware {
    public let id: String = "CreateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLinkInput>
    public typealias MOutput = OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLinkOutputError>
}

extension CreateLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLinkInput(bandwidth: \(String(describing: bandwidth)), description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), provider: \(String(describing: provider)), siteId: \(String(describing: siteId)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

extension CreateLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct CreateLinkInputHeadersMiddleware: Middleware {
    public let id: String = "CreateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLinkInput>
    public typealias MOutput = OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLinkOutputError>
}

public struct CreateLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateLinkInput>
    public typealias MOutput = OperationOutput<CreateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateLinkOutputError>
}

public struct CreateLinkInput: Equatable {
    /// <p> The upload speed and download speed in Mbps. </p>
    public let bandwidth: Bandwidth?
    /// <p>A description of the link.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The provider of the link.</p>
    ///         <p>Constraints: Cannot include the following characters: | \ ^</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let provider: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?
    /// <p>The tags to apply to the resource during creation.</p>
    public let tags: [Tag]?
    /// <p>The type of the link.</p>
    ///         <p>Constraints: Cannot include the following characters: | \ ^</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let type: String?

    public init (
        bandwidth: Bandwidth? = nil,
        description: String? = nil,
        globalNetworkId: String? = nil,
        provider: String? = nil,
        siteId: String? = nil,
        tags: [Tag]? = nil,
        type: String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.provider = provider
        self.siteId = siteId
        self.tags = tags
        self.type = type
    }
}

struct CreateLinkInputBody: Equatable {
    public let description: String?
    public let type: String?
    public let bandwidth: Bandwidth?
    public let provider: String?
    public let siteId: String?
    public let tags: [Tag]?
}

extension CreateLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case siteId = "SiteId"
        case tags = "Tags"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateLinkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateLinkOutputResponse(link: \(String(describing: link)))"}
}

extension CreateLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct CreateLinkOutputResponse: Equatable {
    /// <p>Information about the link.</p>
    public let link: Link?

    public init (
        link: Link? = nil
    )
    {
        self.link = link
    }
}

struct CreateLinkOutputResponseBody: Equatable {
    public let link: Link?
}

extension CreateLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case link = "Link"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(Link.self, forKey: .link)
        link = linkDecoded
    }
}

public struct CreateSiteInputBodyMiddleware: Middleware {
    public let id: String = "CreateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSiteInput>
    public typealias MOutput = OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSiteOutputError>
}

extension CreateSiteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSiteInput(description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), location: \(String(describing: location)), tags: \(String(describing: tags)))"}
}

extension CreateSiteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct CreateSiteInputHeadersMiddleware: Middleware {
    public let id: String = "CreateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSiteInput>
    public typealias MOutput = OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSiteOutputError>
}

public struct CreateSiteInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateSiteInput>
    public typealias MOutput = OperationOutput<CreateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateSiteOutputError>
}

public struct CreateSiteInput: Equatable {
    /// <p>A description of your site.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The site location. This information is used for visualization in the Network Manager console. If you specify the address, the latitude and longitude are automatically calculated.</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Address</code>: The physical address of the site.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Latitude</code>: The latitude of the site. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Longitude</code>: The longitude of the site.</p>
    ///             </li>
    ///          </ul>
    public let location: Location?
    /// <p>The tags to apply to the resource during creation.</p>
    public let tags: [Tag]?

    public init (
        description: String? = nil,
        globalNetworkId: String? = nil,
        location: Location? = nil,
        tags: [Tag]? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.tags = tags
    }
}

struct CreateSiteInputBody: Equatable {
    public let description: String?
    public let location: Location?
    public let tags: [Tag]?
}

extension CreateSiteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case location = "Location"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSiteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSiteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateSiteOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSiteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateSiteOutputResponse(site: \(String(describing: site)))"}
}

extension CreateSiteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateSiteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct CreateSiteOutputResponse: Equatable {
    /// <p>Information about the site.</p>
    public let site: Site?

    public init (
        site: Site? = nil
    )
    {
        self.site = site
    }
}

struct CreateSiteOutputResponseBody: Equatable {
    public let site: Site?
}

extension CreateSiteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case site = "Site"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension CustomerGatewayAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case customerGatewayArn = "CustomerGatewayArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerGatewayArn = customerGatewayArn {
            try encodeContainer.encode(customerGatewayArn, forKey: .customerGatewayArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .customerGatewayArn)
        customerGatewayArn = customerGatewayArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(CustomerGatewayAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension CustomerGatewayAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CustomerGatewayAssociation(customerGatewayArn: \(String(describing: customerGatewayArn)), deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)), state: \(String(describing: state)))"}
}

/// <p>Describes the association between a customer gateway, a device, and a link.</p>
public struct CustomerGatewayAssociation: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway.</p>
    public let customerGatewayArn: String?
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?
    /// <p>The association state.</p>
    public let state: CustomerGatewayAssociationState?

    public init (
        customerGatewayArn: String? = nil,
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil,
        state: CustomerGatewayAssociationState? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.state = state
    }
}

public enum CustomerGatewayAssociationState {
    case available
    case deleted
    case deleting
    case pending
    case sdkUnknown(String)
}

extension CustomerGatewayAssociationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CustomerGatewayAssociationState] {
        return [
            .available,
            .deleted,
            .deleting,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CustomerGatewayAssociationState(rawValue: rawValue) ?? CustomerGatewayAssociationState.sdkUnknown(rawValue)
    }
}

extension DeleteConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionInput(connectionId: \(String(describing: connectionId)), globalNetworkId: \(String(describing: globalNetworkId)))"}
}

extension DeleteConnectionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConnectionInput>
    public typealias MOutput = OperationOutput<DeleteConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConnectionOutputError>
}

public struct DeleteConnectionInput: Equatable {
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?

    public init (
        connectionId: String? = nil,
        globalNetworkId: String? = nil
    )
    {
        self.connectionId = connectionId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteConnectionInputBody: Equatable {
}

extension DeleteConnectionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConnectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension DeleteConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct DeleteConnectionOutputResponse: Equatable {
    /// <p>Information about the connection.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct DeleteConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension DeleteConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

extension DeleteDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceInput(deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)))"}
}

extension DeleteDeviceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteDeviceInput>
    public typealias MOutput = OperationOutput<DeleteDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteDeviceOutputError>
}

public struct DeleteDeviceInput: Equatable {
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?

    public init (
        deviceId: String? = nil,
        globalNetworkId: String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteDeviceInputBody: Equatable {
}

extension DeleteDeviceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteDeviceOutputResponse(device: \(String(describing: device)))"}
}

extension DeleteDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct DeleteDeviceOutputResponse: Equatable {
    /// <p>Information about the device.</p>
    public let device: Device?

    public init (
        device: Device? = nil
    )
    {
        self.device = device
    }
}

struct DeleteDeviceOutputResponseBody: Equatable {
    public let device: Device?
}

extension DeleteDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case device = "Device"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
    }
}

extension DeleteGlobalNetworkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGlobalNetworkInput(globalNetworkId: \(String(describing: globalNetworkId)))"}
}

extension DeleteGlobalNetworkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteGlobalNetworkInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGlobalNetworkInput>
    public typealias MOutput = OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteGlobalNetworkInput>
    public typealias MOutput = OperationOutput<DeleteGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteGlobalNetworkOutputError>
}

public struct DeleteGlobalNetworkInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?

    public init (
        globalNetworkId: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
    }
}

struct DeleteGlobalNetworkInputBody: Equatable {
}

extension DeleteGlobalNetworkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteGlobalNetworkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteGlobalNetworkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteGlobalNetworkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteGlobalNetworkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteGlobalNetworkOutputResponse(globalNetwork: \(String(describing: globalNetwork)))"}
}

extension DeleteGlobalNetworkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct DeleteGlobalNetworkOutputResponse: Equatable {
    /// <p>Information about the global network.</p>
    public let globalNetwork: GlobalNetwork?

    public init (
        globalNetwork: GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct DeleteGlobalNetworkOutputResponseBody: Equatable {
    public let globalNetwork: GlobalNetwork?
}

extension DeleteGlobalNetworkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

extension DeleteLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLinkInput(globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)))"}
}

extension DeleteLinkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLinkInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLinkInput>
    public typealias MOutput = OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLinkInput>
    public typealias MOutput = OperationOutput<DeleteLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLinkOutputError>
}

public struct DeleteLinkInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?

    public init (
        globalNetworkId: String? = nil,
        linkId: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DeleteLinkInputBody: Equatable {
}

extension DeleteLinkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLinkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLinkOutputResponse(link: \(String(describing: link)))"}
}

extension DeleteLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct DeleteLinkOutputResponse: Equatable {
    /// <p>Information about the link.</p>
    public let link: Link?

    public init (
        link: Link? = nil
    )
    {
        self.link = link
    }
}

struct DeleteLinkOutputResponseBody: Equatable {
    public let link: Link?
}

extension DeleteLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case link = "Link"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(Link.self, forKey: .link)
        link = linkDecoded
    }
}

extension DeleteSiteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSiteInput(globalNetworkId: \(String(describing: globalNetworkId)), siteId: \(String(describing: siteId)))"}
}

extension DeleteSiteInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteSiteInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteSiteInput>
    public typealias MOutput = OperationOutput<DeleteSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteSiteOutputError>
}

public struct DeleteSiteInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?

    public init (
        globalNetworkId: String? = nil,
        siteId: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.siteId = siteId
    }
}

struct DeleteSiteInputBody: Equatable {
}

extension DeleteSiteInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteSiteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSiteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSiteOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSiteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteSiteOutputResponse(site: \(String(describing: site)))"}
}

extension DeleteSiteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteSiteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct DeleteSiteOutputResponse: Equatable {
    /// <p>Information about the site.</p>
    public let site: Site?

    public init (
        site: Site? = nil
    )
    {
        self.site = site
    }
}

struct DeleteSiteOutputResponseBody: Equatable {
    public let site: Site?
}

extension DeleteSiteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case site = "Site"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension DeregisterTransitGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTransitGatewayInput(globalNetworkId: \(String(describing: globalNetworkId)), transitGatewayArn: \(String(describing: transitGatewayArn)))"}
}

extension DeregisterTransitGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeregisterTransitGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DeregisterTransitGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTransitGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTransitGatewayInput>
    public typealias MOutput = OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DeregisterTransitGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeregisterTransitGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DeregisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeregisterTransitGatewayInput>
    public typealias MOutput = OperationOutput<DeregisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeregisterTransitGatewayOutputError>
}

public struct DeregisterTransitGatewayInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    public let transitGatewayArn: String?

    public init (
        globalNetworkId: String? = nil,
        transitGatewayArn: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct DeregisterTransitGatewayInputBody: Equatable {
}

extension DeregisterTransitGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeregisterTransitGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeregisterTransitGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeregisterTransitGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeregisterTransitGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeregisterTransitGatewayOutputResponse(transitGatewayRegistration: \(String(describing: transitGatewayRegistration)))"}
}

extension DeregisterTransitGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeregisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct DeregisterTransitGatewayOutputResponse: Equatable {
    /// <p>The transit gateway registration information.</p>
    public let transitGatewayRegistration: TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct DeregisterTransitGatewayOutputResponseBody: Equatable {
    public let transitGatewayRegistration: TransitGatewayRegistration?
}

extension DeregisterTransitGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension DescribeGlobalNetworksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGlobalNetworksInput(globalNetworkIds: \(String(describing: globalNetworkIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeGlobalNetworksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeGlobalNetworksInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeGlobalNetworksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGlobalNetworksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGlobalNetworksInput>
    public typealias MOutput = OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeGlobalNetworksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeGlobalNetworksInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeGlobalNetworksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let globalNetworkIds = input.operationInput.globalNetworkIds {
            globalNetworkIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "globalNetworkIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeGlobalNetworksInput>
    public typealias MOutput = OperationOutput<DescribeGlobalNetworksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeGlobalNetworksOutputError>
}

public struct DescribeGlobalNetworksInput: Equatable {
    /// <p>The IDs of one or more global networks. The maximum is 10.</p>
    public let globalNetworkIds: [String]?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        globalNetworkIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.globalNetworkIds = globalNetworkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksInputBody: Equatable {
}

extension DescribeGlobalNetworksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeGlobalNetworksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeGlobalNetworksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeGlobalNetworksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeGlobalNetworksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeGlobalNetworksOutputResponse(globalNetworks: \(String(describing: globalNetworks)), nextToken: \(String(describing: nextToken)))"}
}

extension DescribeGlobalNetworksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeGlobalNetworksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalNetworks = output.globalNetworks
            self.nextToken = output.nextToken
        } else {
            self.globalNetworks = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeGlobalNetworksOutputResponse: Equatable {
    /// <p>Information about the global networks.</p>
    public let globalNetworks: [GlobalNetwork]?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        globalNetworks: [GlobalNetwork]? = nil,
        nextToken: String? = nil
    )
    {
        self.globalNetworks = globalNetworks
        self.nextToken = nextToken
    }
}

struct DescribeGlobalNetworksOutputResponseBody: Equatable {
    public let globalNetworks: [GlobalNetwork]?
    public let nextToken: String?
}

extension DescribeGlobalNetworksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalNetworks = "GlobalNetworks"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworksContainer = try containerValues.decodeIfPresent([GlobalNetwork?].self, forKey: .globalNetworks)
        var globalNetworksDecoded0:[GlobalNetwork]? = nil
        if let globalNetworksContainer = globalNetworksContainer {
            globalNetworksDecoded0 = [GlobalNetwork]()
            for structure0 in globalNetworksContainer {
                if let structure0 = structure0 {
                    globalNetworksDecoded0?.append(structure0)
                }
            }
        }
        globalNetworks = globalNetworksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension Device: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aWSLocation = "AWSLocation"
        case createdAt = "CreatedAt"
        case description = "Description"
        case deviceArn = "DeviceArn"
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let deviceArn = deviceArn {
            try encodeContainer.encode(deviceArn, forKey: .deviceArn)
        }
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let deviceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceArn)
        deviceArn = deviceArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let aWSLocationDecoded = try containerValues.decodeIfPresent(AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DeviceState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Device: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Device(aWSLocation: \(String(describing: aWSLocation)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), deviceArn: \(String(describing: deviceArn)), deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), location: \(String(describing: location)), model: \(String(describing: model)), serialNumber: \(String(describing: serialNumber)), siteId: \(String(describing: siteId)), state: \(String(describing: state)), tags: \(String(describing: tags)), type: \(String(describing: type)), vendor: \(String(describing: vendor)))"}
}

/// <p>Describes a device.</p>
public struct Device: Equatable {
    /// <p>The AWS location of the device.</p>
    public let aWSLocation: AWSLocation?
    /// <p>The date and time that the site was created.</p>
    public let createdAt: Date?
    /// <p>The description of the device.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the device.</p>
    public let deviceArn: String?
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The site location.</p>
    public let location: Location?
    /// <p>The device model.</p>
    public let model: String?
    /// <p>The device serial number.</p>
    public let serialNumber: String?
    /// <p>The site ID.</p>
    public let siteId: String?
    /// <p>The device state.</p>
    public let state: DeviceState?
    /// <p>The tags for the device.</p>
    public let tags: [Tag]?
    /// <p>The device type.</p>
    public let type: String?
    /// <p>The device vendor.</p>
    public let vendor: String?

    public init (
        aWSLocation: AWSLocation? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        deviceArn: String? = nil,
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        location: Location? = nil,
        model: String? = nil,
        serialNumber: String? = nil,
        siteId: String? = nil,
        state: DeviceState? = nil,
        tags: [Tag]? = nil,
        type: String? = nil,
        vendor: String? = nil
    )
    {
        self.aWSLocation = aWSLocation
        self.createdAt = createdAt
        self.description = description
        self.deviceArn = deviceArn
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.state = state
        self.tags = tags
        self.type = type
        self.vendor = vendor
    }
}

public enum DeviceState {
    case available
    case deleting
    case pending
    case updating
    case sdkUnknown(String)
}

extension DeviceState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [DeviceState] {
        return [
            .available,
            .deleting,
            .pending,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = DeviceState(rawValue: rawValue) ?? DeviceState.sdkUnknown(rawValue)
    }
}

extension DisassociateCustomerGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateCustomerGatewayInput(customerGatewayArn: \(String(describing: customerGatewayArn)), globalNetworkId: \(String(describing: globalNetworkId)))"}
}

extension DisassociateCustomerGatewayInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateCustomerGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateCustomerGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCustomerGatewayInput>
    public typealias MOutput = OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateCustomerGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateCustomerGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateCustomerGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateCustomerGatewayInput>
    public typealias MOutput = OperationOutput<DisassociateCustomerGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateCustomerGatewayOutputError>
}

public struct DisassociateCustomerGatewayInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the customer gateway. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies">Resources Defined by Amazon EC2</a>.</p>
    public let customerGatewayArn: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?

    public init (
        customerGatewayArn: String? = nil,
        globalNetworkId: String? = nil
    )
    {
        self.customerGatewayArn = customerGatewayArn
        self.globalNetworkId = globalNetworkId
    }
}

struct DisassociateCustomerGatewayInputBody: Equatable {
}

extension DisassociateCustomerGatewayInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateCustomerGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateCustomerGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateCustomerGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateCustomerGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateCustomerGatewayOutputResponse(customerGatewayAssociation: \(String(describing: customerGatewayAssociation)))"}
}

extension DisassociateCustomerGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateCustomerGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customerGatewayAssociation = output.customerGatewayAssociation
        } else {
            self.customerGatewayAssociation = nil
        }
    }
}

public struct DisassociateCustomerGatewayOutputResponse: Equatable {
    /// <p>Information about the customer gateway association.</p>
    public let customerGatewayAssociation: CustomerGatewayAssociation?

    public init (
        customerGatewayAssociation: CustomerGatewayAssociation? = nil
    )
    {
        self.customerGatewayAssociation = customerGatewayAssociation
    }
}

struct DisassociateCustomerGatewayOutputResponseBody: Equatable {
    public let customerGatewayAssociation: CustomerGatewayAssociation?
}

extension DisassociateCustomerGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerGatewayAssociation = "CustomerGatewayAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationDecoded = try containerValues.decodeIfPresent(CustomerGatewayAssociation.self, forKey: .customerGatewayAssociation)
        customerGatewayAssociation = customerGatewayAssociationDecoded
    }
}

extension DisassociateLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLinkInput(deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)))"}
}

extension DisassociateLinkInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateLinkInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLinkInput>
    public typealias MOutput = OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = URLQueryItem(name: "deviceId".urlPercentEncoding(), value: String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let linkId = input.operationInput.linkId {
            let linkIdQueryItem = URLQueryItem(name: "linkId".urlPercentEncoding(), value: String(linkId).urlPercentEncoding())
            input.builder.withQueryItem(linkIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateLinkInput>
    public typealias MOutput = OperationOutput<DisassociateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateLinkOutputError>
}

public struct DisassociateLinkInput: Equatable {
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?

    public init (
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct DisassociateLinkInputBody: Equatable {
}

extension DisassociateLinkInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateLinkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateLinkOutputResponse(linkAssociation: \(String(describing: linkAssociation)))"}
}

extension DisassociateLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.linkAssociation = output.linkAssociation
        } else {
            self.linkAssociation = nil
        }
    }
}

public struct DisassociateLinkOutputResponse: Equatable {
    /// <p>Information about the link association.</p>
    public let linkAssociation: LinkAssociation?

    public init (
        linkAssociation: LinkAssociation? = nil
    )
    {
        self.linkAssociation = linkAssociation
    }
}

struct DisassociateLinkOutputResponseBody: Equatable {
    public let linkAssociation: LinkAssociation?
}

extension DisassociateLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case linkAssociation = "LinkAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationDecoded = try containerValues.decodeIfPresent(LinkAssociation.self, forKey: .linkAssociation)
        linkAssociation = linkAssociationDecoded
    }
}

extension DisassociateTransitGatewayConnectPeerInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateTransitGatewayConnectPeerInput(globalNetworkId: \(String(describing: globalNetworkId)), transitGatewayConnectPeerArn: \(String(describing: transitGatewayConnectPeerArn)))"}
}

extension DisassociateTransitGatewayConnectPeerInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DisassociateTransitGatewayConnectPeerInputHeadersMiddleware: Middleware {
    public let id: String = "DisassociateTransitGatewayConnectPeerInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>
    public typealias MOutput = OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInputQueryItemMiddleware: Middleware {
    public let id: String = "DisassociateTransitGatewayConnectPeerInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>,
                  next: H) -> Swift.Result<OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DisassociateTransitGatewayConnectPeerInput>
    public typealias MOutput = OperationOutput<DisassociateTransitGatewayConnectPeerOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DisassociateTransitGatewayConnectPeerOutputError>
}

public struct DisassociateTransitGatewayConnectPeerInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    public let transitGatewayConnectPeerArn: String?

    public init (
        globalNetworkId: String? = nil,
        transitGatewayConnectPeerArn: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

struct DisassociateTransitGatewayConnectPeerInputBody: Equatable {
}

extension DisassociateTransitGatewayConnectPeerInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateTransitGatewayConnectPeerOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisassociateTransitGatewayConnectPeerOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateTransitGatewayConnectPeerOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DisassociateTransitGatewayConnectPeerOutputResponse(transitGatewayConnectPeerAssociation: \(String(describing: transitGatewayConnectPeerAssociation)))"}
}

extension DisassociateTransitGatewayConnectPeerOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DisassociateTransitGatewayConnectPeerOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transitGatewayConnectPeerAssociation = output.transitGatewayConnectPeerAssociation
        } else {
            self.transitGatewayConnectPeerAssociation = nil
        }
    }
}

public struct DisassociateTransitGatewayConnectPeerOutputResponse: Equatable {
    /// <p>The transit gateway Connect peer association.</p>
    public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?

    public init (
        transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation? = nil
    )
    {
        self.transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociation
    }
}

struct DisassociateTransitGatewayConnectPeerOutputResponseBody: Equatable {
    public let transitGatewayConnectPeerAssociation: TransitGatewayConnectPeerAssociation?
}

extension DisassociateTransitGatewayConnectPeerOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transitGatewayConnectPeerAssociation = "TransitGatewayConnectPeerAssociation"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationDecoded = try containerValues.decodeIfPresent(TransitGatewayConnectPeerAssociation.self, forKey: .transitGatewayConnectPeerAssociation)
        transitGatewayConnectPeerAssociation = transitGatewayConnectPeerAssociationDecoded
    }
}

extension GetConnectionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionsInput(connectionIds: \(String(describing: connectionIds)), deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConnectionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConnectionsInputHeadersMiddleware: Middleware {
    public let id: String = "GetConnectionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConnectionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConnectionsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConnectionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = URLQueryItem(name: "deviceId".urlPercentEncoding(), value: String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let connectionIds = input.operationInput.connectionIds {
            connectionIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "connectionIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConnectionsInput>
    public typealias MOutput = OperationOutput<GetConnectionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConnectionsOutputError>
}

public struct GetConnectionsInput: Equatable {
    /// <p>One or more connection IDs.</p>
    public let connectionIds: [String]?
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        connectionIds: [String]? = nil,
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.connectionIds = connectionIds
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectionsInputBody: Equatable {
}

extension GetConnectionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConnectionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConnectionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConnectionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConnectionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConnectionsOutputResponse(connections: \(String(describing: connections)), nextToken: \(String(describing: nextToken)))"}
}

extension GetConnectionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConnectionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connections = output.connections
            self.nextToken = output.nextToken
        } else {
            self.connections = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectionsOutputResponse: Equatable {
    /// <p>Information about the connections.</p>
    public let connections: [Connection]?
    /// <p>The token to use for the next page of results.</p>
    public let nextToken: String?

    public init (
        connections: [Connection]? = nil,
        nextToken: String? = nil
    )
    {
        self.connections = connections
        self.nextToken = nextToken
    }
}

struct GetConnectionsOutputResponseBody: Equatable {
    public let connections: [Connection]?
    public let nextToken: String?
}

extension GetConnectionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connections = "Connections"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionsContainer = try containerValues.decodeIfPresent([Connection?].self, forKey: .connections)
        var connectionsDecoded0:[Connection]? = nil
        if let connectionsContainer = connectionsContainer {
            connectionsDecoded0 = [Connection]()
            for structure0 in connectionsContainer {
                if let structure0 = structure0 {
                    connectionsDecoded0?.append(structure0)
                }
            }
        }
        connections = connectionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetCustomerGatewayAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomerGatewayAssociationsInput(customerGatewayArns: \(String(describing: customerGatewayArns)), globalNetworkId: \(String(describing: globalNetworkId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCustomerGatewayAssociationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCustomerGatewayAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetCustomerGatewayAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomerGatewayAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomerGatewayAssociationsInput>
    public typealias MOutput = OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCustomerGatewayAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCustomerGatewayAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCustomerGatewayAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let customerGatewayArns = input.operationInput.customerGatewayArns {
            customerGatewayArns.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "customerGatewayArns".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCustomerGatewayAssociationsInput>
    public typealias MOutput = OperationOutput<GetCustomerGatewayAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCustomerGatewayAssociationsOutputError>
}

public struct GetCustomerGatewayAssociationsInput: Equatable {
    /// <p>One or more customer gateway Amazon Resource Names (ARNs). For more information, see
    ///                 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies">Resources Defined by Amazon EC2</a>. The maximum is 10.</p>
    public let customerGatewayArns: [String]?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        customerGatewayArns: [String]? = nil,
        globalNetworkId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.customerGatewayArns = customerGatewayArns
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsInputBody: Equatable {
}

extension GetCustomerGatewayAssociationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCustomerGatewayAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCustomerGatewayAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCustomerGatewayAssociationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCustomerGatewayAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCustomerGatewayAssociationsOutputResponse(customerGatewayAssociations: \(String(describing: customerGatewayAssociations)), nextToken: \(String(describing: nextToken)))"}
}

extension GetCustomerGatewayAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCustomerGatewayAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.customerGatewayAssociations = output.customerGatewayAssociations
            self.nextToken = output.nextToken
        } else {
            self.customerGatewayAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetCustomerGatewayAssociationsOutputResponse: Equatable {
    /// <p>The customer gateway associations.</p>
    public let customerGatewayAssociations: [CustomerGatewayAssociation]?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        customerGatewayAssociations: [CustomerGatewayAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.customerGatewayAssociations = customerGatewayAssociations
        self.nextToken = nextToken
    }
}

struct GetCustomerGatewayAssociationsOutputResponseBody: Equatable {
    public let customerGatewayAssociations: [CustomerGatewayAssociation]?
    public let nextToken: String?
}

extension GetCustomerGatewayAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case customerGatewayAssociations = "CustomerGatewayAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerGatewayAssociationsContainer = try containerValues.decodeIfPresent([CustomerGatewayAssociation?].self, forKey: .customerGatewayAssociations)
        var customerGatewayAssociationsDecoded0:[CustomerGatewayAssociation]? = nil
        if let customerGatewayAssociationsContainer = customerGatewayAssociationsContainer {
            customerGatewayAssociationsDecoded0 = [CustomerGatewayAssociation]()
            for structure0 in customerGatewayAssociationsContainer {
                if let structure0 = structure0 {
                    customerGatewayAssociationsDecoded0?.append(structure0)
                }
            }
        }
        customerGatewayAssociations = customerGatewayAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetDevicesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicesInput(deviceIds: \(String(describing: deviceIds)), globalNetworkId: \(String(describing: globalNetworkId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), siteId: \(String(describing: siteId)))"}
}

extension GetDevicesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetDevicesInputHeadersMiddleware: Middleware {
    public let id: String = "GetDevicesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicesInput>
    public typealias MOutput = OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicesOutputError>
}

public struct GetDevicesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetDevicesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetDevicesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetDevicesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let deviceIds = input.operationInput.deviceIds {
            deviceIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "deviceIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let siteId = input.operationInput.siteId {
            let siteIdQueryItem = URLQueryItem(name: "siteId".urlPercentEncoding(), value: String(siteId).urlPercentEncoding())
            input.builder.withQueryItem(siteIdQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetDevicesInput>
    public typealias MOutput = OperationOutput<GetDevicesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetDevicesOutputError>
}

public struct GetDevicesInput: Equatable {
    /// <p>One or more device IDs. The maximum is 10.</p>
    public let deviceIds: [String]?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?

    public init (
        deviceIds: [String]? = nil,
        globalNetworkId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        siteId: String? = nil
    )
    {
        self.deviceIds = deviceIds
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteId = siteId
    }
}

struct GetDevicesInputBody: Equatable {
}

extension GetDevicesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetDevicesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDevicesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetDevicesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDevicesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetDevicesOutputResponse(devices: \(String(describing: devices)), nextToken: \(String(describing: nextToken)))"}
}

extension GetDevicesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetDevicesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct GetDevicesOutputResponse: Equatable {
    /// <p>The devices.</p>
    public let devices: [Device]?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        devices: [Device]? = nil,
        nextToken: String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct GetDevicesOutputResponseBody: Equatable {
    public let devices: [Device]?
    public let nextToken: String?
}

extension GetDevicesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case devices = "Devices"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([Device?].self, forKey: .devices)
        var devicesDecoded0:[Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinkAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLinkAssociationsInput(deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLinkAssociationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLinkAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetLinkAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLinkAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLinkAssociationsInput>
    public typealias MOutput = OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLinkAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLinkAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLinkAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let deviceId = input.operationInput.deviceId {
            let deviceIdQueryItem = URLQueryItem(name: "deviceId".urlPercentEncoding(), value: String(deviceId).urlPercentEncoding())
            input.builder.withQueryItem(deviceIdQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let linkId = input.operationInput.linkId {
            let linkIdQueryItem = URLQueryItem(name: "linkId".urlPercentEncoding(), value: String(linkId).urlPercentEncoding())
            input.builder.withQueryItem(linkIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLinkAssociationsInput>
    public typealias MOutput = OperationOutput<GetLinkAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLinkAssociationsOutputError>
}

public struct GetLinkAssociationsInput: Equatable {
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsInputBody: Equatable {
}

extension GetLinkAssociationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLinkAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinkAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinkAssociationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinkAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLinkAssociationsOutputResponse(linkAssociations: \(String(describing: linkAssociations)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLinkAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLinkAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.linkAssociations = output.linkAssociations
            self.nextToken = output.nextToken
        } else {
            self.linkAssociations = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinkAssociationsOutputResponse: Equatable {
    /// <p>The link associations.</p>
    public let linkAssociations: [LinkAssociation]?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        linkAssociations: [LinkAssociation]? = nil,
        nextToken: String? = nil
    )
    {
        self.linkAssociations = linkAssociations
        self.nextToken = nextToken
    }
}

struct GetLinkAssociationsOutputResponseBody: Equatable {
    public let linkAssociations: [LinkAssociation]?
    public let nextToken: String?
}

extension GetLinkAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case linkAssociations = "LinkAssociations"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkAssociationsContainer = try containerValues.decodeIfPresent([LinkAssociation?].self, forKey: .linkAssociations)
        var linkAssociationsDecoded0:[LinkAssociation]? = nil
        if let linkAssociationsContainer = linkAssociationsContainer {
            linkAssociationsDecoded0 = [LinkAssociation]()
            for structure0 in linkAssociationsContainer {
                if let structure0 = structure0 {
                    linkAssociationsDecoded0?.append(structure0)
                }
            }
        }
        linkAssociations = linkAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetLinksInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLinksInput(globalNetworkId: \(String(describing: globalNetworkId)), linkIds: \(String(describing: linkIds)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), provider: \(String(describing: provider)), siteId: \(String(describing: siteId)), type: \(String(describing: type)))"}
}

extension GetLinksInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLinksInputHeadersMiddleware: Middleware {
    public let id: String = "GetLinksInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLinksInput>
    public typealias MOutput = OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLinksOutputError>
}

public struct GetLinksInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLinksInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLinksInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLinksOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let siteId = input.operationInput.siteId {
            let siteIdQueryItem = URLQueryItem(name: "siteId".urlPercentEncoding(), value: String(siteId).urlPercentEncoding())
            input.builder.withQueryItem(siteIdQueryItem)
        }
        if let type = input.operationInput.type {
            let typeQueryItem = URLQueryItem(name: "type".urlPercentEncoding(), value: String(type).urlPercentEncoding())
            input.builder.withQueryItem(typeQueryItem)
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let linkIds = input.operationInput.linkIds {
            linkIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "linkIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let provider = input.operationInput.provider {
            let providerQueryItem = URLQueryItem(name: "provider".urlPercentEncoding(), value: String(provider).urlPercentEncoding())
            input.builder.withQueryItem(providerQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLinksInput>
    public typealias MOutput = OperationOutput<GetLinksOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLinksOutputError>
}

public struct GetLinksInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>One or more link IDs. The maximum is 10.</p>
    public let linkIds: [String]?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The link provider.</p>
    public let provider: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?
    /// <p>The link type.</p>
    public let type: String?

    public init (
        globalNetworkId: String? = nil,
        linkIds: [String]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        provider: String? = nil,
        siteId: String? = nil,
        type: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.linkIds = linkIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provider = provider
        self.siteId = siteId
        self.type = type
    }
}

struct GetLinksInputBody: Equatable {
}

extension GetLinksInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLinksOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLinksOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLinksOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLinksOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLinksOutputResponse(links: \(String(describing: links)), nextToken: \(String(describing: nextToken)))"}
}

extension GetLinksOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLinksOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.links = output.links
            self.nextToken = output.nextToken
        } else {
            self.links = nil
            self.nextToken = nil
        }
    }
}

public struct GetLinksOutputResponse: Equatable {
    /// <p>The links.</p>
    public let links: [Link]?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?

    public init (
        links: [Link]? = nil,
        nextToken: String? = nil
    )
    {
        self.links = links
        self.nextToken = nextToken
    }
}

struct GetLinksOutputResponseBody: Equatable {
    public let links: [Link]?
    public let nextToken: String?
}

extension GetLinksOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case links = "Links"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linksContainer = try containerValues.decodeIfPresent([Link?].self, forKey: .links)
        var linksDecoded0:[Link]? = nil
        if let linksContainer = linksContainer {
            linksDecoded0 = [Link]()
            for structure0 in linksContainer {
                if let structure0 = structure0 {
                    linksDecoded0?.append(structure0)
                }
            }
        }
        links = linksDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetSitesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSitesInput(globalNetworkId: \(String(describing: globalNetworkId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), siteIds: \(String(describing: siteIds)))"}
}

extension GetSitesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetSitesInputHeadersMiddleware: Middleware {
    public let id: String = "GetSitesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSitesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSitesInput>
    public typealias MOutput = OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSitesOutputError>
}

public struct GetSitesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetSitesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetSitesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetSitesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let siteIds = input.operationInput.siteIds {
            siteIds.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "siteIds".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetSitesInput>
    public typealias MOutput = OperationOutput<GetSitesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetSitesOutputError>
}

public struct GetSitesInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>One or more site IDs. The maximum is 10.</p>
    public let siteIds: [String]?

    public init (
        globalNetworkId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        siteIds: [String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.siteIds = siteIds
    }
}

struct GetSitesInputBody: Equatable {
}

extension GetSitesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetSitesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSitesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetSitesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSitesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetSitesOutputResponse(nextToken: \(String(describing: nextToken)), sites: \(String(describing: sites)))"}
}

extension GetSitesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetSitesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.sites = output.sites
        } else {
            self.nextToken = nil
            self.sites = nil
        }
    }
}

public struct GetSitesOutputResponse: Equatable {
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The sites.</p>
    public let sites: [Site]?

    public init (
        nextToken: String? = nil,
        sites: [Site]? = nil
    )
    {
        self.nextToken = nextToken
        self.sites = sites
    }
}

struct GetSitesOutputResponseBody: Equatable {
    public let sites: [Site]?
    public let nextToken: String?
}

extension GetSitesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case sites = "Sites"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sitesContainer = try containerValues.decodeIfPresent([Site?].self, forKey: .sites)
        var sitesDecoded0:[Site]? = nil
        if let sitesContainer = sitesContainer {
            sitesDecoded0 = [Site]()
            for structure0 in sitesContainer {
                if let structure0 = structure0 {
                    sitesDecoded0?.append(structure0)
                }
            }
        }
        sites = sitesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayConnectPeerAssociationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTransitGatewayConnectPeerAssociationsInput(globalNetworkId: \(String(describing: globalNetworkId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), transitGatewayConnectPeerArns: \(String(describing: transitGatewayConnectPeerArns)))"}
}

extension GetTransitGatewayConnectPeerAssociationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTransitGatewayConnectPeerAssociationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTransitGatewayConnectPeerAssociationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>
    public typealias MOutput = OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTransitGatewayConnectPeerAssociationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let transitGatewayConnectPeerArns = input.operationInput.transitGatewayConnectPeerArns {
            transitGatewayConnectPeerArns.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "transitGatewayConnectPeerArns".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTransitGatewayConnectPeerAssociationsInput>
    public typealias MOutput = OperationOutput<GetTransitGatewayConnectPeerAssociationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTransitGatewayConnectPeerAssociationsOutputError>
}

public struct GetTransitGatewayConnectPeerAssociationsInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>One or more transit gateway Connect peer Amazon Resource Names (ARNs).</p>
    public let transitGatewayConnectPeerArns: [String]?

    public init (
        globalNetworkId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        transitGatewayConnectPeerArns: [String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayConnectPeerArns = transitGatewayConnectPeerArns
    }
}

struct GetTransitGatewayConnectPeerAssociationsInputBody: Equatable {
}

extension GetTransitGatewayConnectPeerAssociationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayConnectPeerAssociationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTransitGatewayConnectPeerAssociationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTransitGatewayConnectPeerAssociationsOutputResponse(nextToken: \(String(describing: nextToken)), transitGatewayConnectPeerAssociations: \(String(describing: transitGatewayConnectPeerAssociations)))"}
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTransitGatewayConnectPeerAssociationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.transitGatewayConnectPeerAssociations = output.transitGatewayConnectPeerAssociations
        } else {
            self.nextToken = nil
            self.transitGatewayConnectPeerAssociations = nil
        }
    }
}

public struct GetTransitGatewayConnectPeerAssociationsOutputResponse: Equatable {
    /// <p>The token to use for the next page of results.</p>
    public let nextToken: String?
    /// <p>Information about the transit gateway Connect peer associations.</p>
    public let transitGatewayConnectPeerAssociations: [TransitGatewayConnectPeerAssociation]?

    public init (
        nextToken: String? = nil,
        transitGatewayConnectPeerAssociations: [TransitGatewayConnectPeerAssociation]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociations
    }
}

struct GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Equatable {
    public let transitGatewayConnectPeerAssociations: [TransitGatewayConnectPeerAssociation]?
    public let nextToken: String?
}

extension GetTransitGatewayConnectPeerAssociationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case transitGatewayConnectPeerAssociations = "TransitGatewayConnectPeerAssociations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerAssociationsContainer = try containerValues.decodeIfPresent([TransitGatewayConnectPeerAssociation?].self, forKey: .transitGatewayConnectPeerAssociations)
        var transitGatewayConnectPeerAssociationsDecoded0:[TransitGatewayConnectPeerAssociation]? = nil
        if let transitGatewayConnectPeerAssociationsContainer = transitGatewayConnectPeerAssociationsContainer {
            transitGatewayConnectPeerAssociationsDecoded0 = [TransitGatewayConnectPeerAssociation]()
            for structure0 in transitGatewayConnectPeerAssociationsContainer {
                if let structure0 = structure0 {
                    transitGatewayConnectPeerAssociationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayConnectPeerAssociations = transitGatewayConnectPeerAssociationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetTransitGatewayRegistrationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTransitGatewayRegistrationsInput(globalNetworkId: \(String(describing: globalNetworkId)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), transitGatewayArns: \(String(describing: transitGatewayArns)))"}
}

extension GetTransitGatewayRegistrationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTransitGatewayRegistrationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetTransitGatewayRegistrationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTransitGatewayRegistrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTransitGatewayRegistrationsInput>
    public typealias MOutput = OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTransitGatewayRegistrationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTransitGatewayRegistrationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTransitGatewayRegistrationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "nextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let maxResults = input.operationInput.maxResults {
            let maxResultsQueryItem = URLQueryItem(name: "maxResults".urlPercentEncoding(), value: String(maxResults).urlPercentEncoding())
            input.builder.withQueryItem(maxResultsQueryItem)
        }
        if let transitGatewayArns = input.operationInput.transitGatewayArns {
            transitGatewayArns.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "transitGatewayArns".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTransitGatewayRegistrationsInput>
    public typealias MOutput = OperationOutput<GetTransitGatewayRegistrationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTransitGatewayRegistrationsOutputError>
}

public struct GetTransitGatewayRegistrationsInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The maximum number of results to return.</p>
    public let maxResults: Int?
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Names (ARNs) of one or more transit gateways. The maximum is
    ///             10.</p>
    public let transitGatewayArns: [String]?

    public init (
        globalNetworkId: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        transitGatewayArns: [String]? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.transitGatewayArns = transitGatewayArns
    }
}

struct GetTransitGatewayRegistrationsInputBody: Equatable {
}

extension GetTransitGatewayRegistrationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTransitGatewayRegistrationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTransitGatewayRegistrationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTransitGatewayRegistrationsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTransitGatewayRegistrationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTransitGatewayRegistrationsOutputResponse(nextToken: \(String(describing: nextToken)), transitGatewayRegistrations: \(String(describing: transitGatewayRegistrations)))"}
}

extension GetTransitGatewayRegistrationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTransitGatewayRegistrationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.transitGatewayRegistrations = output.transitGatewayRegistrations
        } else {
            self.nextToken = nil
            self.transitGatewayRegistrations = nil
        }
    }
}

public struct GetTransitGatewayRegistrationsOutputResponse: Equatable {
    /// <p>The token for the next page of results.</p>
    public let nextToken: String?
    /// <p>The transit gateway registrations.</p>
    public let transitGatewayRegistrations: [TransitGatewayRegistration]?

    public init (
        nextToken: String? = nil,
        transitGatewayRegistrations: [TransitGatewayRegistration]? = nil
    )
    {
        self.nextToken = nextToken
        self.transitGatewayRegistrations = transitGatewayRegistrations
    }
}

struct GetTransitGatewayRegistrationsOutputResponseBody: Equatable {
    public let transitGatewayRegistrations: [TransitGatewayRegistration]?
    public let nextToken: String?
}

extension GetTransitGatewayRegistrationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken = "NextToken"
        case transitGatewayRegistrations = "TransitGatewayRegistrations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationsContainer = try containerValues.decodeIfPresent([TransitGatewayRegistration?].self, forKey: .transitGatewayRegistrations)
        var transitGatewayRegistrationsDecoded0:[TransitGatewayRegistration]? = nil
        if let transitGatewayRegistrationsContainer = transitGatewayRegistrationsContainer {
            transitGatewayRegistrationsDecoded0 = [TransitGatewayRegistration]()
            for structure0 in transitGatewayRegistrationsContainer {
                if let structure0 = structure0 {
                    transitGatewayRegistrationsDecoded0?.append(structure0)
                }
            }
        }
        transitGatewayRegistrations = transitGatewayRegistrationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GlobalNetwork: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkArn = "GlobalNetworkArn"
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkArn = globalNetworkArn {
            try encodeContainer.encode(globalNetworkArn, forKey: .globalNetworkArn)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let globalNetworkArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkArn)
        globalNetworkArn = globalNetworkArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(GlobalNetworkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GlobalNetwork: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GlobalNetwork(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), globalNetworkArn: \(String(describing: globalNetworkArn)), globalNetworkId: \(String(describing: globalNetworkId)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>Describes a global network.</p>
public struct GlobalNetwork: Equatable {
    /// <p>The date and time that the global network was created.</p>
    public let createdAt: Date?
    /// <p>The description of the global network.</p>
    public let description: String?
    /// <p>The Amazon Resource Name (ARN) of the global network.</p>
    public let globalNetworkArn: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The state of the global network.</p>
    public let state: GlobalNetworkState?
    /// <p>The tags for the global network.</p>
    public let tags: [Tag]?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        globalNetworkArn: String? = nil,
        globalNetworkId: String? = nil,
        state: GlobalNetworkState? = nil,
        tags: [Tag]? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.globalNetworkArn = globalNetworkArn
        self.globalNetworkId = globalNetworkId
        self.state = state
        self.tags = tags
    }
}

public enum GlobalNetworkState {
    case available
    case deleting
    case pending
    case updating
    case sdkUnknown(String)
}

extension GlobalNetworkState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [GlobalNetworkState] {
        return [
            .available,
            .deleting,
            .pending,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = GlobalNetworkState(rawValue: rawValue) ?? GlobalNetworkState.sdkUnknown(rawValue)
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request has failed due to an internal error.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    /// <p>Indicates when to retry the request.</p>
    public var retryAfterSeconds: Int?

    public init (
        message: String? = nil,
        retryAfterSeconds: Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Link: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth = "Bandwidth"
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case linkArn = "LinkArn"
        case linkId = "LinkId"
        case provider = "Provider"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkArn = linkArn {
            try encodeContainer.encode(linkArn, forKey: .linkArn)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkArn)
        linkArn = linkArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(LinkState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Link: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Link(bandwidth: \(String(describing: bandwidth)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), linkArn: \(String(describing: linkArn)), linkId: \(String(describing: linkId)), provider: \(String(describing: provider)), siteId: \(String(describing: siteId)), state: \(String(describing: state)), tags: \(String(describing: tags)), type: \(String(describing: type)))"}
}

/// <p>Describes a link.</p>
public struct Link: Equatable {
    /// <p>The bandwidth for the link.</p>
    public let bandwidth: Bandwidth?
    /// <p>The date and time that the link was created.</p>
    public let createdAt: Date?
    /// <p>The description of the link.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The Amazon Resource Name (ARN) of the link.</p>
    public let linkArn: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?
    /// <p>The provider of the link.</p>
    public let provider: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?
    /// <p>The state of the link.</p>
    public let state: LinkState?
    /// <p>The tags for the link.</p>
    public let tags: [Tag]?
    /// <p>The type of the link.</p>
    public let type: String?

    public init (
        bandwidth: Bandwidth? = nil,
        createdAt: Date? = nil,
        description: String? = nil,
        globalNetworkId: String? = nil,
        linkArn: String? = nil,
        linkId: String? = nil,
        provider: String? = nil,
        siteId: String? = nil,
        state: LinkState? = nil,
        tags: [Tag]? = nil,
        type: String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.createdAt = createdAt
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkArn = linkArn
        self.linkId = linkId
        self.provider = provider
        self.siteId = siteId
        self.state = state
        self.tags = tags
        self.type = type
    }
}

extension LinkAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkAssociationState = "LinkAssociationState"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkAssociationState = linkAssociationState {
            try encodeContainer.encode(linkAssociationState.rawValue, forKey: .linkAssociationState)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let linkAssociationStateDecoded = try containerValues.decodeIfPresent(LinkAssociationState.self, forKey: .linkAssociationState)
        linkAssociationState = linkAssociationStateDecoded
    }
}

extension LinkAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LinkAssociation(deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkAssociationState: \(String(describing: linkAssociationState)), linkId: \(String(describing: linkId)))"}
}

/// <p>Describes the association between a device and a link.</p>
public struct LinkAssociation: Equatable {
    /// <p>The device ID for the link association.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The state of the association.</p>
    public let linkAssociationState: LinkAssociationState?
    /// <p>The ID of the link.</p>
    public let linkId: String?

    public init (
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkAssociationState: LinkAssociationState? = nil,
        linkId: String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkAssociationState = linkAssociationState
        self.linkId = linkId
    }
}

public enum LinkAssociationState {
    case available
    case deleted
    case deleting
    case pending
    case sdkUnknown(String)
}

extension LinkAssociationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LinkAssociationState] {
        return [
            .available,
            .deleted,
            .deleting,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LinkAssociationState(rawValue: rawValue) ?? LinkAssociationState.sdkUnknown(rawValue)
    }
}

public enum LinkState {
    case available
    case deleting
    case pending
    case updating
    case sdkUnknown(String)
}

extension LinkState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LinkState] {
        return [
            .available,
            .deleting,
            .pending,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LinkState(rawValue: rawValue) ?? LinkState.sdkUnknown(rawValue)
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tagList: \(String(describing: tagList)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tagList = output.tagList
        } else {
            self.tagList = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>The list of tags.</p>
    public let tagList: [Tag]?

    public init (
        tagList: [Tag]? = nil
    )
    {
        self.tagList = tagList
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tagList: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tagList = "TagList"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagListContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tagList)
        var tagListDecoded0:[Tag]? = nil
        if let tagListContainer = tagListContainer {
            tagListDecoded0 = [Tag]()
            for structure0 in tagListContainer {
                if let structure0 = structure0 {
                    tagListDecoded0?.append(structure0)
                }
            }
        }
        tagList = tagListDecoded0
    }
}

extension Location: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case address = "Address"
        case latitude = "Latitude"
        case longitude = "Longitude"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let latitude = latitude {
            try encodeContainer.encode(latitude, forKey: .latitude)
        }
        if let longitude = longitude {
            try encodeContainer.encode(longitude, forKey: .longitude)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .address)
        address = addressDecoded
        let latitudeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .latitude)
        latitude = latitudeDecoded
        let longitudeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .longitude)
        longitude = longitudeDecoded
    }
}

extension Location: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CONTENT_REDACTED"
    }
}

/// <p>Describes a location.</p>
public struct Location: Equatable {
    /// <p>The physical address.</p>
    public let address: String?
    /// <p>The latitude.</p>
    public let latitude: String?
    /// <p>The longitude.</p>
    public let longitude: String?

    public init (
        address: String? = nil,
        latitude: String? = nil,
        longitude: String? = nil
    )
    {
        self.address = address
        self.latitude = latitude
        self.longitude = longitude
    }
}

public struct RegisterTransitGatewayInputBodyMiddleware: Middleware {
    public let id: String = "RegisterTransitGatewayInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTransitGatewayOutputError>
}

extension RegisterTransitGatewayInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTransitGatewayInput(globalNetworkId: \(String(describing: globalNetworkId)), transitGatewayArn: \(String(describing: transitGatewayArn)))"}
}

extension RegisterTransitGatewayInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let transitGatewayArn = transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }
}

public struct RegisterTransitGatewayInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterTransitGatewayInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterTransitGatewayInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterTransitGatewayInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterTransitGatewayOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterTransitGatewayInput>
    public typealias MOutput = OperationOutput<RegisterTransitGatewayOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterTransitGatewayOutputError>
}

public struct RegisterTransitGatewayInput: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The Amazon Resource Name (ARN) of the transit gateway. For more information, see
    ///                 <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/list_amazonec2.html#amazonec2-resources-for-iam-policies">Resources Defined by Amazon EC2</a>.</p>
    public let transitGatewayArn: String?

    public init (
        globalNetworkId: String? = nil,
        transitGatewayArn: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.transitGatewayArn = transitGatewayArn
    }
}

struct RegisterTransitGatewayInputBody: Equatable {
    public let transitGatewayArn: String?
}

extension RegisterTransitGatewayInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transitGatewayArn = "TransitGatewayArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
    }
}

extension RegisterTransitGatewayOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterTransitGatewayOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterTransitGatewayOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterTransitGatewayOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterTransitGatewayOutputResponse(transitGatewayRegistration: \(String(describing: transitGatewayRegistration)))"}
}

extension RegisterTransitGatewayOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RegisterTransitGatewayOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.transitGatewayRegistration = output.transitGatewayRegistration
        } else {
            self.transitGatewayRegistration = nil
        }
    }
}

public struct RegisterTransitGatewayOutputResponse: Equatable {
    /// <p>Information about the transit gateway registration.</p>
    public let transitGatewayRegistration: TransitGatewayRegistration?

    public init (
        transitGatewayRegistration: TransitGatewayRegistration? = nil
    )
    {
        self.transitGatewayRegistration = transitGatewayRegistration
    }
}

struct RegisterTransitGatewayOutputResponseBody: Equatable {
    public let transitGatewayRegistration: TransitGatewayRegistration?
}

extension RegisterTransitGatewayOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case transitGatewayRegistration = "TransitGatewayRegistration"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayRegistrationDecoded = try containerValues.decodeIfPresent(TransitGatewayRegistration.self, forKey: .transitGatewayRegistration)
        transitGatewayRegistration = transitGatewayRegistrationDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified resource could not be found.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The resource type.</p>
    public var resourceType: String?

    public init (
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil
    )
    {
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(limitCode: \(String(describing: limitCode)), message: \(String(describing: message)), resourceId: \(String(describing: resourceId)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.limitCode = output.limitCode
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.limitCode = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>A service limit was exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The limit code.</p>
    public var limitCode: String?
    /// <p>The error message.</p>
    public var message: String?
    /// <p>The ID of the resource.</p>
    public var resourceId: String?
    /// <p>The resource type.</p>
    public var resourceType: String?
    /// <p>The service code.</p>
    public var serviceCode: String?

    public init (
        limitCode: String? = nil,
        message: String? = nil,
        resourceId: String? = nil,
        resourceType: String? = nil,
        serviceCode: String? = nil
    )
    {
        self.limitCode = limitCode
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceId: String?
    public let resourceType: String?
    public let limitCode: String?
    public let serviceCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case limitCode = "LimitCode"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let limitCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .limitCode)
        limitCode = limitCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension Site: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdAt = "CreatedAt"
        case description = "Description"
        case globalNetworkId = "GlobalNetworkId"
        case location = "Location"
        case siteArn = "SiteArn"
        case siteId = "SiteId"
        case state = "State"
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let siteArn = siteArn {
            try encodeContainer.encode(siteArn, forKey: .siteArn)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteId)
        siteId = siteIdDecoded
        let siteArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteArn)
        siteArn = siteArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SiteState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension Site: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Site(createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), location: \(String(describing: location)), siteArn: \(String(describing: siteArn)), siteId: \(String(describing: siteId)), state: \(String(describing: state)), tags: \(String(describing: tags)))"}
}

/// <p>Describes a site.</p>
public struct Site: Equatable {
    /// <p>The date and time that the site was created.</p>
    public let createdAt: Date?
    /// <p>The description of the site.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The location of the site.</p>
    public let location: Location?
    /// <p>The Amazon Resource Name (ARN) of the site.</p>
    public let siteArn: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?
    /// <p>The state of the site.</p>
    public let state: SiteState?
    /// <p>The tags for the site.</p>
    public let tags: [Tag]?

    public init (
        createdAt: Date? = nil,
        description: String? = nil,
        globalNetworkId: String? = nil,
        location: Location? = nil,
        siteArn: String? = nil,
        siteId: String? = nil,
        state: SiteState? = nil,
        tags: [Tag]? = nil
    )
    {
        self.createdAt = createdAt
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.siteArn = siteArn
        self.siteId = siteId
        self.state = state
        self.tags = tags
    }
}

public enum SiteState {
    case available
    case deleting
    case pending
    case updating
    case sdkUnknown(String)
}

extension SiteState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SiteState] {
        return [
            .available,
            .deleting,
            .pending,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SiteState(rawValue: rawValue) ?? SiteState.sdkUnknown(rawValue)
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>Describes a tag.</p>
public struct Tag: Equatable {
    /// <p>The tag key.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let key: String?
    /// <p>The tag value.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tags to apply to the specified resource.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [Tag]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>Indicates when to retry the request.</p>
    public var retryAfterSeconds: Int?

    public init (
        message: String? = nil,
        retryAfterSeconds: Int? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransitGatewayConnectPeerAssociation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deviceId = "DeviceId"
        case globalNetworkId = "GlobalNetworkId"
        case linkId = "LinkId"
        case state = "State"
        case transitGatewayConnectPeerArn = "TransitGatewayConnectPeerArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceId = deviceId {
            try encodeContainer.encode(deviceId, forKey: .deviceId)
        }
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let transitGatewayConnectPeerArn = transitGatewayConnectPeerArn {
            try encodeContainer.encode(transitGatewayConnectPeerArn, forKey: .transitGatewayConnectPeerArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transitGatewayConnectPeerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transitGatewayConnectPeerArn)
        transitGatewayConnectPeerArn = transitGatewayConnectPeerArnDecoded
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let deviceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deviceId)
        deviceId = deviceIdDecoded
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransitGatewayConnectPeerAssociationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension TransitGatewayConnectPeerAssociation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransitGatewayConnectPeerAssociation(deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)), state: \(String(describing: state)), transitGatewayConnectPeerArn: \(String(describing: transitGatewayConnectPeerArn)))"}
}

/// <p>Describes a transit gateway Connect peer association.</p>
public struct TransitGatewayConnectPeerAssociation: Equatable {
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?
    /// <p>The state of the association.</p>
    public let state: TransitGatewayConnectPeerAssociationState?
    /// <p>The Amazon Resource Name (ARN) of the transit gateway Connect peer.</p>
    public let transitGatewayConnectPeerArn: String?

    public init (
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil,
        state: TransitGatewayConnectPeerAssociationState? = nil,
        transitGatewayConnectPeerArn: String? = nil
    )
    {
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.state = state
        self.transitGatewayConnectPeerArn = transitGatewayConnectPeerArn
    }
}

public enum TransitGatewayConnectPeerAssociationState {
    case available
    case deleted
    case deleting
    case pending
    case sdkUnknown(String)
}

extension TransitGatewayConnectPeerAssociationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransitGatewayConnectPeerAssociationState] {
        return [
            .available,
            .deleted,
            .deleting,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransitGatewayConnectPeerAssociationState(rawValue: rawValue) ?? TransitGatewayConnectPeerAssociationState.sdkUnknown(rawValue)
    }
}

extension TransitGatewayRegistration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case globalNetworkId = "GlobalNetworkId"
        case state = "State"
        case transitGatewayArn = "TransitGatewayArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let globalNetworkId = globalNetworkId {
            try encodeContainer.encode(globalNetworkId, forKey: .globalNetworkId)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let transitGatewayArn = transitGatewayArn {
            try encodeContainer.encode(transitGatewayArn, forKey: .transitGatewayArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .globalNetworkId)
        globalNetworkId = globalNetworkIdDecoded
        let transitGatewayArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .transitGatewayArn)
        transitGatewayArn = transitGatewayArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(TransitGatewayRegistrationStateReason.self, forKey: .state)
        state = stateDecoded
    }
}

extension TransitGatewayRegistration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransitGatewayRegistration(globalNetworkId: \(String(describing: globalNetworkId)), state: \(String(describing: state)), transitGatewayArn: \(String(describing: transitGatewayArn)))"}
}

/// <p>Describes the registration of a transit gateway to a global network.</p>
public struct TransitGatewayRegistration: Equatable {
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The state of the transit gateway registration.</p>
    public let state: TransitGatewayRegistrationStateReason?
    /// <p>The Amazon Resource Name (ARN) of the transit gateway.</p>
    public let transitGatewayArn: String?

    public init (
        globalNetworkId: String? = nil,
        state: TransitGatewayRegistrationStateReason? = nil,
        transitGatewayArn: String? = nil
    )
    {
        self.globalNetworkId = globalNetworkId
        self.state = state
        self.transitGatewayArn = transitGatewayArn
    }
}

public enum TransitGatewayRegistrationState {
    case available
    case deleted
    case deleting
    case failed
    case pending
    case sdkUnknown(String)
}

extension TransitGatewayRegistrationState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TransitGatewayRegistrationState] {
        return [
            .available,
            .deleted,
            .deleting,
            .failed,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .available: return "AVAILABLE"
        case .deleted: return "DELETED"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .pending: return "PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TransitGatewayRegistrationState(rawValue: rawValue) ?? TransitGatewayRegistrationState.sdkUnknown(rawValue)
    }
}

extension TransitGatewayRegistrationStateReason: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(TransitGatewayRegistrationState.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TransitGatewayRegistrationStateReason: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TransitGatewayRegistrationStateReason(code: \(String(describing: code)), message: \(String(describing: message)))"}
}

/// <p>Describes the status of a transit gateway registration.</p>
public struct TransitGatewayRegistrationStateReason: Equatable {
    /// <p>The code for the state reason.</p>
    public let code: TransitGatewayRegistrationState?
    /// <p>The message for the state reason.</p>
    public let message: String?

    public init (
        code: TransitGatewayRegistrationState? = nil,
        message: String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the resource.</p>
    public let resourceArn: String?
    /// <p>The tag keys to remove from the specified resource.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateConnectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

extension UpdateConnectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionInput(connectedLinkId: \(String(describing: connectedLinkId)), connectionId: \(String(describing: connectionId)), description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)))"}
}

extension UpdateConnectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectedLinkId = connectedLinkId {
            try encodeContainer.encode(connectedLinkId, forKey: .connectedLinkId)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let linkId = linkId {
            try encodeContainer.encode(linkId, forKey: .linkId)
        }
    }
}

public struct UpdateConnectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConnectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConnectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConnectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConnectionInput>
    public typealias MOutput = OperationOutput<UpdateConnectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConnectionOutputError>
}

public struct UpdateConnectionInput: Equatable {
    /// <p>The ID of the link for the second device in the connection.</p>
    public let connectedLinkId: String?
    /// <p>The ID of the connection.</p>
    public let connectionId: String?
    /// <p>A description of the connection.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link for the first device in the connection.</p>
    public let linkId: String?

    public init (
        connectedLinkId: String? = nil,
        connectionId: String? = nil,
        description: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil
    )
    {
        self.connectedLinkId = connectedLinkId
        self.connectionId = connectionId
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
    }
}

struct UpdateConnectionInputBody: Equatable {
    public let linkId: String?
    public let connectedLinkId: String?
    public let description: String?
}

extension UpdateConnectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connectedLinkId = "ConnectedLinkId"
        case description = "Description"
        case linkId = "LinkId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .linkId)
        linkId = linkIdDecoded
        let connectedLinkIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .connectedLinkId)
        connectedLinkId = connectedLinkIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConnectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConnectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConnectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConnectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConnectionOutputResponse(connection: \(String(describing: connection)))"}
}

extension UpdateConnectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateConnectionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.connection = output.connection
        } else {
            self.connection = nil
        }
    }
}

public struct UpdateConnectionOutputResponse: Equatable {
    /// <p>Information about the connection.</p>
    public let connection: Connection?

    public init (
        connection: Connection? = nil
    )
    {
        self.connection = connection
    }
}

struct UpdateConnectionOutputResponseBody: Equatable {
    public let connection: Connection?
}

extension UpdateConnectionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case connection = "Connection"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionDecoded = try containerValues.decodeIfPresent(Connection.self, forKey: .connection)
        connection = connectionDecoded
    }
}

public struct UpdateDeviceInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeviceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceOutputError>
}

extension UpdateDeviceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceInput(aWSLocation: \(String(describing: aWSLocation)), description: \(String(describing: description)), deviceId: \(String(describing: deviceId)), globalNetworkId: \(String(describing: globalNetworkId)), location: \(String(describing: location)), model: \(String(describing: model)), serialNumber: \(String(describing: serialNumber)), siteId: \(String(describing: siteId)), type: \(String(describing: type)), vendor: \(String(describing: vendor)))"}
}

extension UpdateDeviceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aWSLocation = aWSLocation {
            try encodeContainer.encode(aWSLocation, forKey: .aWSLocation)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let model = model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let serialNumber = serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let siteId = siteId {
            try encodeContainer.encode(siteId, forKey: .siteId)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let vendor = vendor {
            try encodeContainer.encode(vendor, forKey: .vendor)
        }
    }
}

public struct UpdateDeviceInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeviceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeviceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeviceInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeviceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeviceInput>
    public typealias MOutput = OperationOutput<UpdateDeviceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeviceOutputError>
}

public struct UpdateDeviceInput: Equatable {
    /// <p>The AWS location of the device.</p>
    public let aWSLocation: AWSLocation?
    /// <p>A description of the device.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the device.</p>
    public let deviceId: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>Describes a location.</p>
    public let location: Location?
    /// <p>The model of the device.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let model: String?
    /// <p>The serial number of the device.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let serialNumber: String?
    /// <p>The ID of the site.</p>
    public let siteId: String?
    /// <p>The type of the device.</p>
    public let type: String?
    /// <p>The vendor of the device.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let vendor: String?

    public init (
        aWSLocation: AWSLocation? = nil,
        description: String? = nil,
        deviceId: String? = nil,
        globalNetworkId: String? = nil,
        location: Location? = nil,
        model: String? = nil,
        serialNumber: String? = nil,
        siteId: String? = nil,
        type: String? = nil,
        vendor: String? = nil
    )
    {
        self.aWSLocation = aWSLocation
        self.description = description
        self.deviceId = deviceId
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.model = model
        self.serialNumber = serialNumber
        self.siteId = siteId
        self.type = type
        self.vendor = vendor
    }
}

struct UpdateDeviceInputBody: Equatable {
    public let aWSLocation: AWSLocation?
    public let description: String?
    public let type: String?
    public let vendor: String?
    public let model: String?
    public let serialNumber: String?
    public let location: Location?
    public let siteId: String?
}

extension UpdateDeviceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aWSLocation = "AWSLocation"
        case description = "Description"
        case location = "Location"
        case model = "Model"
        case serialNumber = "SerialNumber"
        case siteId = "SiteId"
        case type = "Type"
        case vendor = "Vendor"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aWSLocationDecoded = try containerValues.decodeIfPresent(AWSLocation.self, forKey: .aWSLocation)
        aWSLocation = aWSLocationDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let vendorDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vendor)
        vendor = vendorDecoded
        let modelDecoded = try containerValues.decodeIfPresent(String.self, forKey: .model)
        model = modelDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
        let siteIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .siteId)
        siteId = siteIdDecoded
    }
}

extension UpdateDeviceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeviceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeviceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeviceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeviceOutputResponse(device: \(String(describing: device)))"}
}

extension UpdateDeviceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateDeviceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct UpdateDeviceOutputResponse: Equatable {
    /// <p>Information about the device.</p>
    public let device: Device?

    public init (
        device: Device? = nil
    )
    {
        self.device = device
    }
}

struct UpdateDeviceOutputResponseBody: Equatable {
    public let device: Device?
}

extension UpdateDeviceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case device = "Device"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(Device.self, forKey: .device)
        device = deviceDecoded
    }
}

public struct UpdateGlobalNetworkInputBodyMiddleware: Middleware {
    public let id: String = "UpdateGlobalNetworkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGlobalNetworkOutputError>
}

extension UpdateGlobalNetworkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGlobalNetworkInput(description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)))"}
}

extension UpdateGlobalNetworkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateGlobalNetworkInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateGlobalNetworkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateGlobalNetworkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateGlobalNetworkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateGlobalNetworkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateGlobalNetworkInput>
    public typealias MOutput = OperationOutput<UpdateGlobalNetworkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateGlobalNetworkOutputError>
}

public struct UpdateGlobalNetworkInput: Equatable {
    /// <p>A description of the global network.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of your global network.</p>
    public let globalNetworkId: String?

    public init (
        description: String? = nil,
        globalNetworkId: String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
    }
}

struct UpdateGlobalNetworkInputBody: Equatable {
    public let description: String?
}

extension UpdateGlobalNetworkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateGlobalNetworkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateGlobalNetworkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateGlobalNetworkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateGlobalNetworkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateGlobalNetworkOutputResponse(globalNetwork: \(String(describing: globalNetwork)))"}
}

extension UpdateGlobalNetworkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateGlobalNetworkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.globalNetwork = output.globalNetwork
        } else {
            self.globalNetwork = nil
        }
    }
}

public struct UpdateGlobalNetworkOutputResponse: Equatable {
    /// <p>Information about the global network object.</p>
    public let globalNetwork: GlobalNetwork?

    public init (
        globalNetwork: GlobalNetwork? = nil
    )
    {
        self.globalNetwork = globalNetwork
    }
}

struct UpdateGlobalNetworkOutputResponseBody: Equatable {
    public let globalNetwork: GlobalNetwork?
}

extension UpdateGlobalNetworkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case globalNetwork = "GlobalNetwork"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let globalNetworkDecoded = try containerValues.decodeIfPresent(GlobalNetwork.self, forKey: .globalNetwork)
        globalNetwork = globalNetworkDecoded
    }
}

public struct UpdateLinkInputBodyMiddleware: Middleware {
    public let id: String = "UpdateLinkInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLinkOutputError>
}

extension UpdateLinkInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLinkInput(bandwidth: \(String(describing: bandwidth)), description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), linkId: \(String(describing: linkId)), provider: \(String(describing: provider)), type: \(String(describing: type)))"}
}

extension UpdateLinkInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bandwidth = bandwidth {
            try encodeContainer.encode(bandwidth, forKey: .bandwidth)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let type = type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }
}

public struct UpdateLinkInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateLinkInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateLinkInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateLinkInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateLinkOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateLinkInput>
    public typealias MOutput = OperationOutput<UpdateLinkOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateLinkOutputError>
}

public struct UpdateLinkInput: Equatable {
    /// <p>The upload and download speed in Mbps. </p>
    public let bandwidth: Bandwidth?
    /// <p>A description of the link.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The ID of the link.</p>
    public let linkId: String?
    /// <p>The provider of the link.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let provider: String?
    /// <p>The type of the link.</p>
    ///         <p>Length Constraints: Maximum length of 128 characters.</p>
    public let type: String?

    public init (
        bandwidth: Bandwidth? = nil,
        description: String? = nil,
        globalNetworkId: String? = nil,
        linkId: String? = nil,
        provider: String? = nil,
        type: String? = nil
    )
    {
        self.bandwidth = bandwidth
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.linkId = linkId
        self.provider = provider
        self.type = type
    }
}

struct UpdateLinkInputBody: Equatable {
    public let description: String?
    public let type: String?
    public let bandwidth: Bandwidth?
    public let provider: String?
}

extension UpdateLinkInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case bandwidth = "Bandwidth"
        case description = "Description"
        case provider = "Provider"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let bandwidthDecoded = try containerValues.decodeIfPresent(Bandwidth.self, forKey: .bandwidth)
        bandwidth = bandwidthDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
    }
}

extension UpdateLinkOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLinkOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLinkOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLinkOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateLinkOutputResponse(link: \(String(describing: link)))"}
}

extension UpdateLinkOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateLinkOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.link = output.link
        } else {
            self.link = nil
        }
    }
}

public struct UpdateLinkOutputResponse: Equatable {
    /// <p>Information about the link.</p>
    public let link: Link?

    public init (
        link: Link? = nil
    )
    {
        self.link = link
    }
}

struct UpdateLinkOutputResponseBody: Equatable {
    public let link: Link?
}

extension UpdateLinkOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case link = "Link"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let linkDecoded = try containerValues.decodeIfPresent(Link.self, forKey: .link)
        link = linkDecoded
    }
}

public struct UpdateSiteInputBodyMiddleware: Middleware {
    public let id: String = "UpdateSiteInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSiteOutputError>
}

extension UpdateSiteInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSiteInput(description: \(String(describing: description)), globalNetworkId: \(String(describing: globalNetworkId)), location: \(String(describing: location)), siteId: \(String(describing: siteId)))"}
}

extension UpdateSiteInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }
}

public struct UpdateSiteInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateSiteInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateSiteInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateSiteInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateSiteOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateSiteInput>
    public typealias MOutput = OperationOutput<UpdateSiteOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateSiteOutputError>
}

public struct UpdateSiteInput: Equatable {
    /// <p>A description of your site.</p>
    ///         <p>Length Constraints: Maximum length of 256 characters.</p>
    public let description: String?
    /// <p>The ID of the global network.</p>
    public let globalNetworkId: String?
    /// <p>The site location:</p>
    ///         <ul>
    ///             <li>
    ///                <p>
    ///                   <code>Address</code>: The physical address of the site.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Latitude</code>: The latitude of the site. </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Longitude</code>: The longitude of the site.</p>
    ///             </li>
    ///          </ul>
    public let location: Location?
    /// <p>The ID of your site.</p>
    public let siteId: String?

    public init (
        description: String? = nil,
        globalNetworkId: String? = nil,
        location: Location? = nil,
        siteId: String? = nil
    )
    {
        self.description = description
        self.globalNetworkId = globalNetworkId
        self.location = location
        self.siteId = siteId
    }
}

struct UpdateSiteInputBody: Equatable {
    public let description: String?
    public let location: Location?
}

extension UpdateSiteInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case location = "Location"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Location.self, forKey: .location)
        location = locationDecoded
    }
}

extension UpdateSiteOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSiteOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateSiteOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSiteOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateSiteOutputResponse(site: \(String(describing: site)))"}
}

extension UpdateSiteOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateSiteOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.site = output.site
        } else {
            self.site = nil
        }
    }
}

public struct UpdateSiteOutputResponse: Equatable {
    /// <p>Information about the site.</p>
    public let site: Site?

    public init (
        site: Site? = nil
    )
    {
        self.site = site
    }
}

struct UpdateSiteOutputResponseBody: Equatable {
    public let site: Site?
}

extension UpdateSiteOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case site = "Site"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let siteDecoded = try containerValues.decodeIfPresent(Site.self, forKey: .site)
        site = siteDecoded
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(fields: \(String(describing: fields)), message: \(String(describing: message)), reason: \(String(describing: reason)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.fields = output.fields
            self.message = output.message
            self.reason = output.reason
        } else {
            self.fields = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The fields that caused the error, if applicable.</p>
    public var fields: [ValidationExceptionField]?
    public var message: String?
    /// <p>The reason for the error.</p>
    public var reason: ValidationExceptionReason?

    public init (
        fields: [ValidationExceptionField]? = nil,
        message: String? = nil,
        reason: ValidationExceptionReason? = nil
    )
    {
        self.fields = fields
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
    public let reason: ValidationExceptionReason?
    public let fields: [ValidationExceptionField]?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension ValidationExceptionField: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationExceptionField: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationExceptionField(message: \(String(describing: message)), name: \(String(describing: name)))"}
}

/// <p>Describes a validation exception for a field.</p>
public struct ValidationExceptionField: Equatable {
    /// <p>The message for the field.</p>
    public let message: String?
    /// <p>The name of the field.</p>
    public let name: String?

    public init (
        message: String? = nil,
        name: String? = nil
    )
    {
        self.message = message
        self.name = name
    }
}

public enum ValidationExceptionReason {
    case cannotParse
    case fieldValidationFailed
    case other
    case unknownOperation
    case sdkUnknown(String)
}

extension ValidationExceptionReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ValidationExceptionReason] {
        return [
            .cannotParse,
            .fieldValidationFailed,
            .other,
            .unknownOperation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .cannotParse: return "CannotParse"
        case .fieldValidationFailed: return "FieldValidationFailed"
        case .other: return "Other"
        case .unknownOperation: return "UnknownOperation"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
    }
}
