// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You don't have sufficient access to perform this action.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Action: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sdkUnknown
        case ssmAutomation
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ssmAutomation(ssmAutomation):
                if let ssmAutomation = ssmAutomation {
                    try container.encode(ssmAutomation, forKey: .ssmAutomation)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ssmAutomationDecoded = try values.decodeIfPresent(SsmAutomation.self, forKey: .ssmAutomation)
        if let ssmAutomation = ssmAutomationDecoded {
            self = .ssmAutomation(ssmAutomation)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The action that starts at the beginning of an incident. The response plan defines the
///          action.</p>
public enum Action: Equatable {
    /// <p>The Systems Manager automation document to start as the runbook at the beginning of the
    ///          incident.</p>
    case ssmAutomation(SsmAutomation?)
    case sdkUnknown(String?)
}

extension AddRegionAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case regionName
        case sseKmsKeyId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regionName = regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
        if let sseKmsKeyId = sseKmsKeyId {
            try encodeContainer.encode(sseKmsKeyId, forKey: .sseKmsKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionName)
        regionName = regionNameDecoded
        let sseKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sseKmsKeyId)
        sseKmsKeyId = sseKmsKeyIdDecoded
    }
}

extension AddRegionAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddRegionAction(regionName: \(String(describing: regionName)), sseKmsKeyId: \(String(describing: sseKmsKeyId)))"}
}

/// <p>Defines the Region and KMS key to add to the replication set. </p>
public struct AddRegionAction: Equatable {
    /// <p>The Region name to add to the replication set.</p>
    public let regionName: String?
    /// <p>The KMS key ID to use to encrypt your replication set.</p>
    public let sseKmsKeyId: String?

    public init (
        regionName: String? = nil,
        sseKmsKeyId: String? = nil
    )
    {
        self.regionName = regionName
        self.sseKmsKeyId = sseKmsKeyId
    }
}

extension AttributeValueList: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case integerValues
        case sdkUnknown
        case stringValues
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .integerValues(integerValues):
                if let integerValues = integerValues {
                    var integerValuesContainer = container.nestedUnkeyedContainer(forKey: .integerValues)
                    for integerlist0 in integerValues {
                        try integerValuesContainer.encode(integerlist0)
                    }
                }
            case let .stringValues(stringValues):
                if let stringValues = stringValues {
                    var stringValuesContainer = container.nestedUnkeyedContainer(forKey: .stringValues)
                    for stringlist0 in stringValues {
                        try stringValuesContainer.encode(stringlist0)
                    }
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let stringValuesContainer = try values.decodeIfPresent([String?].self, forKey: .stringValues)
        var stringValuesDecoded0:[String]? = nil
        if let stringValuesContainer = stringValuesContainer {
            stringValuesDecoded0 = [String]()
            for string0 in stringValuesContainer {
                if let string0 = string0 {
                    stringValuesDecoded0?.append(string0)
                }
            }
        }
        if let stringValues = stringValuesDecoded0 {
            self = .stringValues(stringValues)
            return
        }
        let integerValuesContainer = try values.decodeIfPresent([Int?].self, forKey: .integerValues)
        var integerValuesDecoded0:[Int]? = nil
        if let integerValuesContainer = integerValuesContainer {
            integerValuesDecoded0 = [Int]()
            for integer0 in integerValuesContainer {
                if let integer0 = integer0 {
                    integerValuesDecoded0?.append(integer0)
                }
            }
        }
        if let integerValues = integerValuesDecoded0 {
            self = .integerValues(integerValues)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Use the AttributeValueList to filter by string or integer values.</p>
public enum AttributeValueList: Equatable {
    /// <p>The list of string values that the filter matches.</p>
    case stringValues([String]?)
    /// <p>The list of integer values that the filter matches.</p>
    case integerValues([Int]?)
    case sdkUnknown(String?)
}

extension AutomationExecution: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sdkUnknown
        case ssmExecutionArn
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .ssmExecutionArn(ssmExecutionArn):
                if let ssmExecutionArn = ssmExecutionArn {
                    try container.encode(ssmExecutionArn, forKey: .ssmExecutionArn)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let ssmExecutionArnDecoded = try values.decodeIfPresent(String.self, forKey: .ssmExecutionArn)
        if let ssmExecutionArn = ssmExecutionArnDecoded {
            self = .ssmExecutionArn(ssmExecutionArn)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The Systems Manager automation document
///          process
///          to start as the runbook at the beginning of the incident.</p>
public enum AutomationExecution: Equatable, Hashable {
    /// <p>The Amazon Resource Name (ARN) of the automation process.</p>
    case ssmExecutionArn(String?)
    case sdkUnknown(String?)
}

extension ChatChannel: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case chatbotSns
        case empty
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .chatbotSns(chatbotSns):
                if let chatbotSns = chatbotSns {
                    var chatbotSnsContainer = container.nestedUnkeyedContainer(forKey: .chatbotSns)
                    for chatbotsnsconfigurationset0 in chatbotSns {
                        try chatbotSnsContainer.encode(chatbotsnsconfigurationset0)
                    }
                }
            case let .empty(empty):
                if let empty = empty {
                    try container.encode(empty, forKey: .empty)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let emptyDecoded = try values.decodeIfPresent(EmptyChatChannel.self, forKey: .empty)
        if let empty = emptyDecoded {
            self = .empty(empty)
            return
        }
        let chatbotSnsContainer = try values.decodeIfPresent(Set<String>.self, forKey: .chatbotSns)
        var chatbotSnsDecoded0:Set<String>? = nil
        if let chatbotSnsContainer = chatbotSnsContainer {
            chatbotSnsDecoded0 = Set<String>()
            for string0 in chatbotSnsContainer {
                chatbotSnsDecoded0?.insert(string0)
            }
        }
        if let chatbotSns = chatbotSnsDecoded0 {
            self = .chatbotSns(chatbotSns)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The AWS Chatbot chat channel used for collaboration during an incident.</p>
public enum ChatChannel: Equatable {
    /// <p>Used to remove the chat channel from an incident record or response plan.</p>
    case empty(EmptyChatChannel?)
    /// <p>The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an
    ///          incident. You can also make updates to the incident through the chat channel
    ///          by
    ///          using the SNS topics. </p>
    case chatbotSns(Set<String>?)
    case sdkUnknown(String?)
}

extension Condition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case after
        case before
        case equals
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .after(after):
                if let after = after {
                    try container.encode(after.timeIntervalSince1970, forKey: .after)
                }
            case let .before(before):
                if let before = before {
                    try container.encode(before.timeIntervalSince1970, forKey: .before)
                }
            case let .equals(equals):
                if let equals = equals {
                    try container.encode(equals, forKey: .equals)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let beforeDecoded = try values.decodeIfPresent(Date.self, forKey: .before)
        if let before = beforeDecoded {
            self = .before(before)
            return
        }
        let afterDecoded = try values.decodeIfPresent(Date.self, forKey: .after)
        if let after = afterDecoded {
            self = .after(after)
            return
        }
        let equalsDecoded = try values.decodeIfPresent(AttributeValueList.self, forKey: .equals)
        if let equals = equalsDecoded {
            self = .equals(equals)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>A conditional statement with which to compare a value, after a timestamp, before a
///          timestamp, or equal to a string or integer. If multiple conditions are specified, the
///          conditionals become an <code>AND</code>ed statement. If multiple values are specified for a
///          conditional, the values are <code>OR</code>d.</p>
public enum Condition: Equatable {
    /// <p>Before the specified timestamp</p>
    case before(Date?)
    /// <p>After the specified timestamp.</p>
    case after(Date?)
    /// <p>The value is equal to the provided string or integer. </p>
    case equals(AttributeValueList?)
    case sdkUnknown(String?)
}

extension ConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ConflictException(message: \(String(describing: message)), resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

extension ConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceIdentifier = output.resourceIdentifier
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceIdentifier = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Updating or deleting a resource causes an inconsistent state.</p>
public struct ConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// The identifier of the requested resource
    public var resourceIdentifier: String?
    /// The resource type
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceIdentifier: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Equatable {
    public let message: String?
    public let resourceIdentifier: String?
    public let resourceType: ResourceType?
}

extension ConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceIdentifier
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

public struct CreateReplicationSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateReplicationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationSetInput>
    public typealias MOutput = OperationOutput<CreateReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationSetOutputError>
}

extension CreateReplicationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationSetInput(clientToken: \(String(describing: clientToken)), regions: \(String(describing: regions)))"}
}

extension CreateReplicationSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case regions
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .regions)
            for (dictKey0, regionmapinput0) in regions {
                try regionsContainer.encode(regionmapinput0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateReplicationSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateReplicationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationSetInput>
    public typealias MOutput = OperationOutput<CreateReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationSetOutputError>
}

public struct CreateReplicationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateReplicationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateReplicationSetInput>
    public typealias MOutput = OperationOutput<CreateReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateReplicationSetOutputError>
}

public struct CreateReplicationSetInput: Equatable {
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>The Regions that Incident Manager replicates your data to. You can have up to three Regions
    ///             in your replication set.</p>
    public let regions: [String:RegionMapInputValue]?

    public init (
        clientToken: String? = nil,
        regions: [String:RegionMapInputValue]? = nil
    )
    {
        self.clientToken = clientToken
        self.regions = regions
    }
}

struct CreateReplicationSetInputBody: Equatable {
    public let regions: [String:RegionMapInputValue]?
    public let clientToken: String?
}

extension CreateReplicationSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case regions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionsContainer = try containerValues.decodeIfPresent([String: RegionMapInputValue?].self, forKey: .regions)
        var regionsDecoded0: [String:RegionMapInputValue]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [String:RegionMapInputValue]()
            for (key0, regionmapinputvalue0) in regionsContainer {
                if let regionmapinputvalue0 = regionmapinputvalue0 {
                    regionsDecoded0?[key0] = regionmapinputvalue0
                }
            }
        }
        regions = regionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateReplicationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateReplicationSetOutputResponse(arn: \(String(describing: arn)))"}
}

extension CreateReplicationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateReplicationSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateReplicationSetOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication set. </p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateReplicationSetOutputResponseBody: Equatable {
    public let arn: String?
}

extension CreateReplicationSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateResponsePlanInputBodyMiddleware: Middleware {
    public let id: String = "CreateResponsePlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResponsePlanInput>
    public typealias MOutput = OperationOutput<CreateResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResponsePlanOutputError>
}

extension CreateResponsePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResponsePlanInput(actions: \(String(describing: actions)), chatChannel: \(String(describing: chatChannel)), clientToken: \(String(describing: clientToken)), displayName: \(String(describing: displayName)), engagements: \(String(describing: engagements)), incidentTemplate: \(String(describing: incidentTemplate)), name: \(String(describing: name)), tags: \(String(describing: tags)))"}
}

extension CreateResponsePlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplate
        case name
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionslist0 in actions {
                try actionsContainer.encode(actionslist0)
            }
        }
        if let chatChannel = chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let engagements = engagements {
            var engagementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engagements)
            for engagementset0 in engagements {
                try engagementsContainer.encode(engagementset0)
            }
        }
        if let incidentTemplate = incidentTemplate {
            try encodeContainer.encode(incidentTemplate, forKey: .incidentTemplate)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct CreateResponsePlanInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResponsePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResponsePlanInput>
    public typealias MOutput = OperationOutput<CreateResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResponsePlanOutputError>
}

public struct CreateResponsePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResponsePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResponsePlanInput>
    public typealias MOutput = OperationOutput<CreateResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResponsePlanOutputError>
}

public struct CreateResponsePlanInput: Equatable {
    /// <p>The actions that the response plan starts at the beginning of an incident.</p>
    public let actions: [Action]?
    /// <p>The
    ///             AWS Chatbot
    ///             chat channel used for collaboration during an incident.</p>
    public let chatChannel: ChatChannel?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>The long format of the response plan name. This field can contain spaces.</p>
    public let displayName: String?
    /// <p>The contacts and escalation plans that the response plan engages during an
    ///             incident.</p>
    public let engagements: Set<String>?
    /// <p>Details used to create an incident when using this response plan.</p>
    public let incidentTemplate: IncidentTemplate?
    /// <p>The short format name of the response plan. Can't include spaces.</p>
    public let name: String?
    /// <p>A list of tags that you are adding to the response plan.</p>
    public let tags: [String:String]?

    public init (
        actions: [Action]? = nil,
        chatChannel: ChatChannel? = nil,
        clientToken: String? = nil,
        displayName: String? = nil,
        engagements: Set<String>? = nil,
        incidentTemplate: IncidentTemplate? = nil,
        name: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.actions = actions
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplate = incidentTemplate
        self.name = name
        self.tags = tags
    }
}

struct CreateResponsePlanInputBody: Equatable {
    public let clientToken: String?
    public let name: String?
    public let displayName: String?
    public let incidentTemplate: IncidentTemplate?
    public let chatChannel: ChatChannel?
    public let engagements: Set<String>?
    public let actions: [Action]?
    public let tags: [String:String]?
}

extension CreateResponsePlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplate
        case name
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let incidentTemplateDecoded = try containerValues.decodeIfPresent(IncidentTemplate.self, forKey: .incidentTemplate)
        incidentTemplate = incidentTemplateDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let engagementsContainer = try containerValues.decodeIfPresent(Set<String>.self, forKey: .engagements)
        var engagementsDecoded0:Set<String>? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = Set<String>()
            for string0 in engagementsContainer {
                engagementsDecoded0?.insert(string0)
            }
        }
        engagements = engagementsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResponsePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResponsePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResponsePlanOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResponsePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResponsePlanOutputResponse(arn: \(String(describing: arn)))"}
}

extension CreateResponsePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResponsePlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.arn = output.arn
        } else {
            self.arn = nil
        }
    }
}

public struct CreateResponsePlanOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct CreateResponsePlanOutputResponseBody: Equatable {
    public let arn: String?
}

extension CreateResponsePlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

public struct CreateTimelineEventInputBodyMiddleware: Middleware {
    public let id: String = "CreateTimelineEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTimelineEventInput>
    public typealias MOutput = OperationOutput<CreateTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTimelineEventOutputError>
}

extension CreateTimelineEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTimelineEventInput(clientToken: \(String(describing: clientToken)), eventData: \(String(describing: eventData)), eventTime: \(String(describing: eventTime)), eventType: \(String(describing: eventType)), incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

extension CreateTimelineEventInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case eventData
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eventData = eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }
}

public struct CreateTimelineEventInputHeadersMiddleware: Middleware {
    public let id: String = "CreateTimelineEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTimelineEventInput>
    public typealias MOutput = OperationOutput<CreateTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTimelineEventOutputError>
}

public struct CreateTimelineEventInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateTimelineEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateTimelineEventInput>
    public typealias MOutput = OperationOutput<CreateTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateTimelineEventOutputError>
}

public struct CreateTimelineEventInput: Equatable {
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>A short description of the event.</p>
    public let eventData: String?
    /// <p>The time that the event occurred.</p>
    public let eventTime: Date?
    /// <p>The type of the event. You can create timeline events of type <code>Custom
    ///                 Event</code>.</p>
    public let eventType: String?
    /// <p>The Amazon Resource Name (ARN) of the incident record you are adding the event
    ///             to.</p>
    public let incidentRecordArn: String?

    public init (
        clientToken: String? = nil,
        eventData: String? = nil,
        eventTime: Date? = nil,
        eventType: String? = nil,
        incidentRecordArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.eventData = eventData
        self.eventTime = eventTime
        self.eventType = eventType
        self.incidentRecordArn = incidentRecordArn
    }
}

struct CreateTimelineEventInputBody: Equatable {
    public let clientToken: String?
    public let incidentRecordArn: String?
    public let eventTime: Date?
    public let eventType: String?
    public let eventData: String?
}

extension CreateTimelineEventInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case eventData
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension CreateTimelineEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateTimelineEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateTimelineEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateTimelineEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateTimelineEventOutputResponse(eventId: \(String(describing: eventId)), incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

extension CreateTimelineEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateTimelineEventOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventId = output.eventId
            self.incidentRecordArn = output.incidentRecordArn
        } else {
            self.eventId = nil
            self.incidentRecordArn = nil
        }
    }
}

public struct CreateTimelineEventOutputResponse: Equatable {
    /// <p>The ID of the event for easy reference later. </p>
    public let eventId: String?
    /// <p>The ARN of the incident record that you added the event to.</p>
    public let incidentRecordArn: String?

    public init (
        eventId: String? = nil,
        incidentRecordArn: String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

struct CreateTimelineEventOutputResponseBody: Equatable {
    public let incidentRecordArn: String?
    public let eventId: String?
}

extension CreateTimelineEventOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventId
        case incidentRecordArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

public struct DeleteIncidentRecordInputBodyMiddleware: Middleware {
    public let id: String = "DeleteIncidentRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIncidentRecordInput>
    public typealias MOutput = OperationOutput<DeleteIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIncidentRecordOutputError>
}

extension DeleteIncidentRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIncidentRecordInput(arn: \(String(describing: arn)))"}
}

extension DeleteIncidentRecordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteIncidentRecordInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteIncidentRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIncidentRecordInput>
    public typealias MOutput = OperationOutput<DeleteIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIncidentRecordOutputError>
}

public struct DeleteIncidentRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteIncidentRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteIncidentRecordInput>
    public typealias MOutput = OperationOutput<DeleteIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteIncidentRecordOutputError>
}

public struct DeleteIncidentRecordInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the incident record you are deleting.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteIncidentRecordInputBody: Equatable {
    public let arn: String?
}

extension DeleteIncidentRecordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteIncidentRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIncidentRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteIncidentRecordOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIncidentRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteIncidentRecordOutputResponse()"}
}

extension DeleteIncidentRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIncidentRecordOutputResponse: Equatable {

    public init() {}
}

struct DeleteIncidentRecordOutputResponseBody: Equatable {
}

extension DeleteIncidentRecordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteRegionAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case regionName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let regionName = regionName {
            try encodeContainer.encode(regionName, forKey: .regionName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .regionName)
        regionName = regionNameDecoded
    }
}

extension DeleteRegionAction: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteRegionAction(regionName: \(String(describing: regionName)))"}
}

/// <p>Defines the information about the Region you're deleting from your replication
///          set.</p>
public struct DeleteRegionAction: Equatable {
    /// <p>The name of the Region you're deleting from the replication set.</p>
    public let regionName: String?

    public init (
        regionName: String? = nil
    )
    {
        self.regionName = regionName
    }
}

extension DeleteReplicationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationSetInput(arn: \(String(describing: arn)))"}
}

extension DeleteReplicationSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteReplicationSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteReplicationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationSetInput>
    public typealias MOutput = OperationOutput<DeleteReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationSetOutputError>
}

public struct DeleteReplicationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteReplicationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let arn = input.operationInput.arn {
            let arnQueryItem = URLQueryItem(name: "arn".urlPercentEncoding(), value: String(arn).urlPercentEncoding())
            input.builder.withQueryItem(arnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteReplicationSetInput>
    public typealias MOutput = OperationOutput<DeleteReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteReplicationSetOutputError>
}

public struct DeleteReplicationSetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication set you're deleting.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteReplicationSetInputBody: Equatable {
}

extension DeleteReplicationSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteReplicationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteReplicationSetOutputResponse()"}
}

extension DeleteReplicationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReplicationSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteReplicationSetOutputResponseBody: Equatable {
}

extension DeleteReplicationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

extension DeleteResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyInput(policyId: \(String(describing: policyId)), resourceArn: \(String(describing: resourceArn)))"}
}

extension DeleteResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyId
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct DeleteResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResourcePolicyInput>
    public typealias MOutput = OperationOutput<DeleteResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResourcePolicyOutputError>
}

public struct DeleteResourcePolicyInput: Equatable {
    /// <p>The ID of the resource policy you're deleting.</p>
    public let policyId: String?
    /// <p>The Amazon Resource Name (ARN) of the resource you're deleting the policy from.</p>
    public let resourceArn: String?

    public init (
        policyId: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policyId = policyId
        self.resourceArn = resourceArn
    }
}

struct DeleteResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
    public let policyId: String?
}

extension DeleteResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyId
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension DeleteResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResourcePolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResourcePolicyOutputResponse()"}
}

extension DeleteResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResourcePolicyOutputResponse: Equatable {

    public init() {}
}

struct DeleteResourcePolicyOutputResponseBody: Equatable {
}

extension DeleteResourcePolicyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteResponsePlanInputBodyMiddleware: Middleware {
    public let id: String = "DeleteResponsePlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResponsePlanInput>
    public typealias MOutput = OperationOutput<DeleteResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResponsePlanOutputError>
}

extension DeleteResponsePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResponsePlanInput(arn: \(String(describing: arn)))"}
}

extension DeleteResponsePlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

public struct DeleteResponsePlanInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteResponsePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResponsePlanInput>
    public typealias MOutput = OperationOutput<DeleteResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResponsePlanOutputError>
}

public struct DeleteResponsePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteResponsePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteResponsePlanInput>
    public typealias MOutput = OperationOutput<DeleteResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteResponsePlanOutputError>
}

public struct DeleteResponsePlanInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteResponsePlanInputBody: Equatable {
    public let arn: String?
}

extension DeleteResponsePlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteResponsePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteResponsePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteResponsePlanOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteResponsePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteResponsePlanOutputResponse()"}
}

extension DeleteResponsePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteResponsePlanOutputResponse: Equatable {

    public init() {}
}

struct DeleteResponsePlanOutputResponseBody: Equatable {
}

extension DeleteResponsePlanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteTimelineEventInputBodyMiddleware: Middleware {
    public let id: String = "DeleteTimelineEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTimelineEventInput>
    public typealias MOutput = OperationOutput<DeleteTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTimelineEventOutputError>
}

extension DeleteTimelineEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTimelineEventInput(eventId: \(String(describing: eventId)), incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

extension DeleteTimelineEventInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
        case incidentRecordArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }
}

public struct DeleteTimelineEventInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteTimelineEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTimelineEventInput>
    public typealias MOutput = OperationOutput<DeleteTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTimelineEventOutputError>
}

public struct DeleteTimelineEventInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteTimelineEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteTimelineEventInput>
    public typealias MOutput = OperationOutput<DeleteTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteTimelineEventOutputError>
}

public struct DeleteTimelineEventInput: Equatable {
    /// <p>The ID of the event you are updating. You can find this by using <code>ListTimelineEvents</code>.</p>
    public let eventId: String?
    /// <p>The Amazon Resource Name (ARN) of the incident that the event is part of.</p>
    public let incidentRecordArn: String?

    public init (
        eventId: String? = nil,
        incidentRecordArn: String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

struct DeleteTimelineEventInputBody: Equatable {
    public let incidentRecordArn: String?
    public let eventId: String?
}

extension DeleteTimelineEventInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventId
        case incidentRecordArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

extension DeleteTimelineEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteTimelineEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteTimelineEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteTimelineEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteTimelineEventOutputResponse()"}
}

extension DeleteTimelineEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteTimelineEventOutputResponse: Equatable {

    public init() {}
}

struct DeleteTimelineEventOutputResponseBody: Equatable {
}

extension DeleteTimelineEventOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EmptyChatChannel: Codable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }

    public init (from decoder: Decoder) throws {
    }
}

extension EmptyChatChannel: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EmptyChatChannel()"}
}

/// <p>Used to remove the chat channel from an incident record or response plan.</p>
public struct EmptyChatChannel: Equatable {

    public init() {}
}

extension EventSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventId
        case eventTime
        case eventType
        case eventUpdatedTime
        case incidentRecordArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let eventUpdatedTime = eventUpdatedTime {
            try encodeContainer.encode(eventUpdatedTime.timeIntervalSince1970, forKey: .eventUpdatedTime)
        }
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventUpdatedTime)
        eventUpdatedTime = eventUpdatedTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
    }
}

extension EventSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSummary(eventId: \(String(describing: eventId)), eventTime: \(String(describing: eventTime)), eventType: \(String(describing: eventType)), eventUpdatedTime: \(String(describing: eventUpdatedTime)), incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

/// <p>Details about a timeline event during an incident.</p>
public struct EventSummary: Equatable {
    /// <p>The timeline event ID.</p>
    public let eventId: String?
    /// <p>The time that the event occurred.</p>
    public let eventTime: Date?
    /// <p>The type of event. The timeline event must be <code>Custom Event</code>.</p>
    public let eventType: String?
    /// <p>The time that the timeline event was last updated.</p>
    public let eventUpdatedTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the incident that the event happened during.</p>
    public let incidentRecordArn: String?

    public init (
        eventId: String? = nil,
        eventTime: Date? = nil,
        eventType: String? = nil,
        eventUpdatedTime: Date? = nil,
        incidentRecordArn: String? = nil
    )
    {
        self.eventId = eventId
        self.eventTime = eventTime
        self.eventType = eventType
        self.eventUpdatedTime = eventUpdatedTime
        self.incidentRecordArn = incidentRecordArn
    }
}

extension Filter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case condition
        case key
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = condition {
            try encodeContainer.encode(condition, forKey: .condition)
        }
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let conditionDecoded = try containerValues.decodeIfPresent(Condition.self, forKey: .condition)
        condition = conditionDecoded
    }
}

extension Filter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Filter(condition: \(String(describing: condition)), key: \(String(describing: key)))"}
}

/// <p>Filter the selection by using a condition.</p>
public struct Filter: Equatable {
    /// <p>The condition accepts before or after a specified time, equal to a string, or equal to an integer.</p>
    public let condition: Condition?
    /// <p>The key that you're filtering on.</p>
    public let key: String?

    public init (
        condition: Condition? = nil,
        key: String? = nil
    )
    {
        self.condition = condition
        self.key = key
    }
}

extension GetIncidentRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIncidentRecordInput(arn: \(String(describing: arn)))"}
}

extension GetIncidentRecordInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetIncidentRecordInputHeadersMiddleware: Middleware {
    public let id: String = "GetIncidentRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIncidentRecordInput>
    public typealias MOutput = OperationOutput<GetIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIncidentRecordOutputError>
}

public struct GetIncidentRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "GetIncidentRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<GetIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let arn = input.operationInput.arn {
            let arnQueryItem = URLQueryItem(name: "arn".urlPercentEncoding(), value: String(arn).urlPercentEncoding())
            input.builder.withQueryItem(arnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetIncidentRecordInput>
    public typealias MOutput = OperationOutput<GetIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetIncidentRecordOutputError>
}

public struct GetIncidentRecordInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the incident record.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetIncidentRecordInputBody: Equatable {
}

extension GetIncidentRecordInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetIncidentRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIncidentRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetIncidentRecordOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIncidentRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetIncidentRecordOutputResponse(incidentRecord: \(String(describing: incidentRecord)))"}
}

extension GetIncidentRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetIncidentRecordOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.incidentRecord = output.incidentRecord
        } else {
            self.incidentRecord = nil
        }
    }
}

public struct GetIncidentRecordOutputResponse: Equatable {
    /// <p>Details structure of the incident record.</p>
    public let incidentRecord: IncidentRecord?

    public init (
        incidentRecord: IncidentRecord? = nil
    )
    {
        self.incidentRecord = incidentRecord
    }
}

struct GetIncidentRecordOutputResponseBody: Equatable {
    public let incidentRecord: IncidentRecord?
}

extension GetIncidentRecordOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case incidentRecord
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordDecoded = try containerValues.decodeIfPresent(IncidentRecord.self, forKey: .incidentRecord)
        incidentRecord = incidentRecordDecoded
    }
}

extension GetReplicationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationSetInput(arn: \(String(describing: arn)))"}
}

extension GetReplicationSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetReplicationSetInputHeadersMiddleware: Middleware {
    public let id: String = "GetReplicationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationSetInput>
    public typealias MOutput = OperationOutput<GetReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationSetOutputError>
}

public struct GetReplicationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "GetReplicationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<GetReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let arn = input.operationInput.arn {
            let arnQueryItem = URLQueryItem(name: "arn".urlPercentEncoding(), value: String(arn).urlPercentEncoding())
            input.builder.withQueryItem(arnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetReplicationSetInput>
    public typealias MOutput = OperationOutput<GetReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetReplicationSetOutputError>
}

public struct GetReplicationSetInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication set you want to retrieve.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetReplicationSetInputBody: Equatable {
}

extension GetReplicationSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetReplicationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReplicationSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetReplicationSetOutputResponse(replicationSet: \(String(describing: replicationSet)))"}
}

extension GetReplicationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetReplicationSetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.replicationSet = output.replicationSet
        } else {
            self.replicationSet = nil
        }
    }
}

public struct GetReplicationSetOutputResponse: Equatable {
    /// <p>Details of the replication set.</p>
    public let replicationSet: ReplicationSet?

    public init (
        replicationSet: ReplicationSet? = nil
    )
    {
        self.replicationSet = replicationSet
    }
}

struct GetReplicationSetOutputResponseBody: Equatable {
    public let replicationSet: ReplicationSet?
}

extension GetReplicationSetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case replicationSet
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSetDecoded = try containerValues.decodeIfPresent(ReplicationSet.self, forKey: .replicationSet)
        replicationSet = replicationSetDecoded
    }
}

public struct GetResourcePoliciesInputBodyMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

extension GetResourcePoliciesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePoliciesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension GetResourcePoliciesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct GetResourcePoliciesInputHeadersMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResourcePoliciesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResourcePoliciesInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResourcePoliciesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let resourceArn = input.operationInput.resourceArn {
            let resourceArnQueryItem = URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: String(resourceArn).urlPercentEncoding())
            input.builder.withQueryItem(resourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResourcePoliciesInput>
    public typealias MOutput = OperationOutput<GetResourcePoliciesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResourcePoliciesOutputError>
}

public struct GetResourcePoliciesInput: Equatable {
    /// <p>The maximum number of resource policies to display per page of results.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the response plan with the attached resource policy. </p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct GetResourcePoliciesInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension GetResourcePoliciesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResourcePoliciesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResourcePoliciesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResourcePoliciesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResourcePoliciesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResourcePoliciesOutputResponse(nextToken: \(String(describing: nextToken)), resourcePolicies: \(String(describing: resourcePolicies)))"}
}

extension GetResourcePoliciesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResourcePoliciesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.resourcePolicies = output.resourcePolicies
        } else {
            self.nextToken = nil
            self.resourcePolicies = nil
        }
    }
}

public struct GetResourcePoliciesOutputResponse: Equatable {
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>Details about the resource policy attached to the response plan.</p>
    public let resourcePolicies: [ResourcePolicy]?

    public init (
        nextToken: String? = nil,
        resourcePolicies: [ResourcePolicy]? = nil
    )
    {
        self.nextToken = nextToken
        self.resourcePolicies = resourcePolicies
    }
}

struct GetResourcePoliciesOutputResponseBody: Equatable {
    public let resourcePolicies: [ResourcePolicy]?
    public let nextToken: String?
}

extension GetResourcePoliciesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case resourcePolicies
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcePoliciesContainer = try containerValues.decodeIfPresent([ResourcePolicy?].self, forKey: .resourcePolicies)
        var resourcePoliciesDecoded0:[ResourcePolicy]? = nil
        if let resourcePoliciesContainer = resourcePoliciesContainer {
            resourcePoliciesDecoded0 = [ResourcePolicy]()
            for structure0 in resourcePoliciesContainer {
                if let structure0 = structure0 {
                    resourcePoliciesDecoded0?.append(structure0)
                }
            }
        }
        resourcePolicies = resourcePoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetResponsePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResponsePlanInput(arn: \(String(describing: arn)))"}
}

extension GetResponsePlanInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetResponsePlanInputHeadersMiddleware: Middleware {
    public let id: String = "GetResponsePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResponsePlanInput>
    public typealias MOutput = OperationOutput<GetResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResponsePlanOutputError>
}

public struct GetResponsePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "GetResponsePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<GetResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let arn = input.operationInput.arn {
            let arnQueryItem = URLQueryItem(name: "arn".urlPercentEncoding(), value: String(arn).urlPercentEncoding())
            input.builder.withQueryItem(arnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetResponsePlanInput>
    public typealias MOutput = OperationOutput<GetResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetResponsePlanOutputError>
}

public struct GetResponsePlanInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetResponsePlanInputBody: Equatable {
}

extension GetResponsePlanInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetResponsePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetResponsePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetResponsePlanOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetResponsePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetResponsePlanOutputResponse(actions: \(String(describing: actions)), arn: \(String(describing: arn)), chatChannel: \(String(describing: chatChannel)), displayName: \(String(describing: displayName)), engagements: \(String(describing: engagements)), incidentTemplate: \(String(describing: incidentTemplate)), name: \(String(describing: name)))"}
}

extension GetResponsePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetResponsePlanOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.actions = output.actions
            self.arn = output.arn
            self.chatChannel = output.chatChannel
            self.displayName = output.displayName
            self.engagements = output.engagements
            self.incidentTemplate = output.incidentTemplate
            self.name = output.name
        } else {
            self.actions = nil
            self.arn = nil
            self.chatChannel = nil
            self.displayName = nil
            self.engagements = nil
            self.incidentTemplate = nil
            self.name = nil
        }
    }
}

public struct GetResponsePlanOutputResponse: Equatable {
    /// <p>The actions that this response plan takes at the beginning of the incident.</p>
    public let actions: [Action]?
    /// <p>The ARN of the response plan.</p>
    public let arn: String?
    /// <p>The
    ///             AWS
    ///             Chatbot chat channel used for collaboration during an
    ///             incident.</p>
    public let chatChannel: ChatChannel?
    /// <p>The long format name of the response plan. Can contain spaces.</p>
    public let displayName: String?
    /// <p>The contacts and escalation plans that the response plan engages during an
    ///             incident.</p>
    public let engagements: Set<String>?
    /// <p>Details used to create the incident when using this response plan.</p>
    public let incidentTemplate: IncidentTemplate?
    /// <p>The short format name of the response plan. Can't contain spaces.</p>
    public let name: String?

    public init (
        actions: [Action]? = nil,
        arn: String? = nil,
        chatChannel: ChatChannel? = nil,
        displayName: String? = nil,
        engagements: Set<String>? = nil,
        incidentTemplate: IncidentTemplate? = nil,
        name: String? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.chatChannel = chatChannel
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplate = incidentTemplate
        self.name = name
    }
}

struct GetResponsePlanOutputResponseBody: Equatable {
    public let arn: String?
    public let name: String?
    public let displayName: String?
    public let incidentTemplate: IncidentTemplate?
    public let chatChannel: ChatChannel?
    public let engagements: Set<String>?
    public let actions: [Action]?
}

extension GetResponsePlanOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case arn
        case chatChannel
        case displayName
        case engagements
        case incidentTemplate
        case name
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let incidentTemplateDecoded = try containerValues.decodeIfPresent(IncidentTemplate.self, forKey: .incidentTemplate)
        incidentTemplate = incidentTemplateDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let engagementsContainer = try containerValues.decodeIfPresent(Set<String>.self, forKey: .engagements)
        var engagementsDecoded0:Set<String>? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = Set<String>()
            for string0 in engagementsContainer {
                engagementsDecoded0?.insert(string0)
            }
        }
        engagements = engagementsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension GetTimelineEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTimelineEventInput(eventId: \(String(describing: eventId)), incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

extension GetTimelineEventInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetTimelineEventInputHeadersMiddleware: Middleware {
    public let id: String = "GetTimelineEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTimelineEventInput>
    public typealias MOutput = OperationOutput<GetTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTimelineEventOutputError>
}

public struct GetTimelineEventInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTimelineEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let eventId = input.operationInput.eventId {
            let eventIdQueryItem = URLQueryItem(name: "eventId".urlPercentEncoding(), value: String(eventId).urlPercentEncoding())
            input.builder.withQueryItem(eventIdQueryItem)
        }
        if let incidentRecordArn = input.operationInput.incidentRecordArn {
            let incidentRecordArnQueryItem = URLQueryItem(name: "incidentRecordArn".urlPercentEncoding(), value: String(incidentRecordArn).urlPercentEncoding())
            input.builder.withQueryItem(incidentRecordArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTimelineEventInput>
    public typealias MOutput = OperationOutput<GetTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTimelineEventOutputError>
}

public struct GetTimelineEventInput: Equatable {
    /// <p>The ID of the event. You can get an event's ID when you create it or by using <code>ListTimelineEvents</code>.</p>
    public let eventId: String?
    /// <p>The Amazon Resource Name (ARN) of the incident that the timeline event is part of.</p>
    public let incidentRecordArn: String?

    public init (
        eventId: String? = nil,
        incidentRecordArn: String? = nil
    )
    {
        self.eventId = eventId
        self.incidentRecordArn = incidentRecordArn
    }
}

struct GetTimelineEventInputBody: Equatable {
}

extension GetTimelineEventInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetTimelineEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTimelineEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTimelineEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTimelineEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTimelineEventOutputResponse(event: \(String(describing: event)))"}
}

extension GetTimelineEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTimelineEventOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.event = output.event
        } else {
            self.event = nil
        }
    }
}

public struct GetTimelineEventOutputResponse: Equatable {
    /// <p>Details about the timeline event.</p>
    public let event: TimelineEvent?

    public init (
        event: TimelineEvent? = nil
    )
    {
        self.event = event
    }
}

struct GetTimelineEventOutputResponseBody: Equatable {
    public let event: TimelineEvent?
}

extension GetTimelineEventOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case event
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(TimelineEvent.self, forKey: .event)
        event = eventDecoded
    }
}

extension IncidentRecord: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case automationExecutions
        case chatChannel
        case creationTime
        case dedupeString
        case impact
        case incidentRecordSource
        case lastModifiedBy
        case lastModifiedTime
        case notificationTargets
        case resolvedTime
        case status
        case summary
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let automationExecutions = automationExecutions {
            var automationExecutionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .automationExecutions)
            for automationexecutionset0 in automationExecutions {
                try automationExecutionsContainer.encode(automationexecutionset0)
            }
        }
        if let chatChannel = chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let dedupeString = dedupeString {
            try encodeContainer.encode(dedupeString, forKey: .dedupeString)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let incidentRecordSource = incidentRecordSource {
            try encodeContainer.encode(incidentRecordSource, forKey: .incidentRecordSource)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let notificationTargets = notificationTargets {
            var notificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationTargets)
            for notificationtargetset0 in notificationTargets {
                try notificationTargetsContainer.encode(notificationtargetset0)
            }
        }
        if let resolvedTime = resolvedTime {
            try encodeContainer.encode(resolvedTime.timeIntervalSince1970, forKey: .resolvedTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IncidentRecordStatus.self, forKey: .status)
        status = statusDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .impact)
        impact = impactDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let resolvedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resolvedTime)
        resolvedTime = resolvedTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
        let automationExecutionsContainer = try containerValues.decodeIfPresent(Set<AutomationExecution>.self, forKey: .automationExecutions)
        var automationExecutionsDecoded0:Set<AutomationExecution>? = nil
        if let automationExecutionsContainer = automationExecutionsContainer {
            automationExecutionsDecoded0 = Set<AutomationExecution>()
            for union0 in automationExecutionsContainer {
                automationExecutionsDecoded0?.insert(union0)
            }
        }
        automationExecutions = automationExecutionsDecoded0
        let incidentRecordSourceDecoded = try containerValues.decodeIfPresent(IncidentRecordSource.self, forKey: .incidentRecordSource)
        incidentRecordSource = incidentRecordSourceDecoded
        let dedupeStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dedupeString)
        dedupeString = dedupeStringDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let notificationTargetsContainer = try containerValues.decodeIfPresent(Set<NotificationTargetItem>.self, forKey: .notificationTargets)
        var notificationTargetsDecoded0:Set<NotificationTargetItem>? = nil
        if let notificationTargetsContainer = notificationTargetsContainer {
            notificationTargetsDecoded0 = Set<NotificationTargetItem>()
            for union0 in notificationTargetsContainer {
                notificationTargetsDecoded0?.insert(union0)
            }
        }
        notificationTargets = notificationTargetsDecoded0
    }
}

extension IncidentRecord: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncidentRecord(arn: \(String(describing: arn)), automationExecutions: \(String(describing: automationExecutions)), chatChannel: \(String(describing: chatChannel)), creationTime: \(String(describing: creationTime)), dedupeString: \(String(describing: dedupeString)), impact: \(String(describing: impact)), incidentRecordSource: \(String(describing: incidentRecordSource)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedTime: \(String(describing: lastModifiedTime)), notificationTargets: \(String(describing: notificationTargets)), resolvedTime: \(String(describing: resolvedTime)), status: \(String(describing: status)), summary: \(String(describing: summary)), title: \(String(describing: title)))"}
}

/// <p>The record of the incident that's created when an incident occurs.</p>
public struct IncidentRecord: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the incident record.</p>
    public let arn: String?
    /// <p>The runbook, or automation document, that's run at the beginning of the incident.</p>
    public let automationExecutions: Set<AutomationExecution>?
    /// <p>The chat channel used for collaboration during an incident.</p>
    public let chatChannel: ChatChannel?
    /// <p>The time that Incident Manager created the incident record.</p>
    public let creationTime: Date?
    /// <p>The string Incident Manager uses to prevent duplicate incidents from being created by the same incident.</p>
    public let dedupeString: String?
    /// <p>The impact of the incident on customers and applications.</p>
    public let impact: Int?
    /// <p>Details about the action that started the incident.</p>
    public let incidentRecordSource: IncidentRecordSource?
    /// <p>Who modified the incident most recently.</p>
    public let lastModifiedBy: String?
    /// <p>The time at which the incident was most recently modified.</p>
    public let lastModifiedTime: Date?
    /// <p>The SNS targets that
    ///          AWS Chatbot uses
    ///          to notify the chat channels and perform actions on the incident record.</p>
    public let notificationTargets: Set<NotificationTargetItem>?
    /// <p>The time at which the incident was resolved. This appears as a timeline event.</p>
    public let resolvedTime: Date?
    /// <p>The current status of the incident.</p>
    public let status: IncidentRecordStatus?
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what is currently happening, and context.</p>
    public let summary: String?
    /// <p>The title of the incident.</p>
    public let title: String?

    public init (
        arn: String? = nil,
        automationExecutions: Set<AutomationExecution>? = nil,
        chatChannel: ChatChannel? = nil,
        creationTime: Date? = nil,
        dedupeString: String? = nil,
        impact: Int? = nil,
        incidentRecordSource: IncidentRecordSource? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedTime: Date? = nil,
        notificationTargets: Set<NotificationTargetItem>? = nil,
        resolvedTime: Date? = nil,
        status: IncidentRecordStatus? = nil,
        summary: String? = nil,
        title: String? = nil
    )
    {
        self.arn = arn
        self.automationExecutions = automationExecutions
        self.chatChannel = chatChannel
        self.creationTime = creationTime
        self.dedupeString = dedupeString
        self.impact = impact
        self.incidentRecordSource = incidentRecordSource
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedTime = lastModifiedTime
        self.notificationTargets = notificationTargets
        self.resolvedTime = resolvedTime
        self.status = status
        self.summary = summary
        self.title = title
    }
}

extension IncidentRecordSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdBy
        case invokedBy
        case resourceArn
        case source
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let invokedBy = invokedBy {
            try encodeContainer.encode(invokedBy, forKey: .invokedBy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let invokedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .invokedBy)
        invokedBy = invokedByDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
    }
}

extension IncidentRecordSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncidentRecordSource(createdBy: \(String(describing: createdBy)), invokedBy: \(String(describing: invokedBy)), resourceArn: \(String(describing: resourceArn)), source: \(String(describing: source)))"}
}

/// <p>Details about how the incident record was created and when.</p>
public struct IncidentRecordSource: Equatable {
    /// <p>The principal that started the incident.</p>
    public let createdBy: String?
    /// <p>The principal the assumed the role specified of the <code>createdBy</code>.</p>
    public let invokedBy: String?
    /// <p>The resource that caused the incident to be created.</p>
    public let resourceArn: String?
    /// <p>The service that started the incident. This can be manually created from Incident Manager,
    ///          automatically created using an
    ///          AWS
    ///          CloudWatch alarm, or
    ///          Amazon
    ///          EventBridge event.</p>
    public let source: String?

    public init (
        createdBy: String? = nil,
        invokedBy: String? = nil,
        resourceArn: String? = nil,
        source: String? = nil
    )
    {
        self.createdBy = createdBy
        self.invokedBy = invokedBy
        self.resourceArn = resourceArn
        self.source = source
    }
}

public enum IncidentRecordStatus {
    case `open`
    case resolved
    case sdkUnknown(String)
}

extension IncidentRecordStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [IncidentRecordStatus] {
        return [
            .open,
            .resolved,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .open: return "OPEN"
        case .resolved: return "RESOLVED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = IncidentRecordStatus(rawValue: rawValue) ?? IncidentRecordStatus.sdkUnknown(rawValue)
    }
}

extension IncidentRecordSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case creationTime
        case impact
        case incidentRecordSource
        case resolvedTime
        case status
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = creationTime {
            try encodeContainer.encode(creationTime.timeIntervalSince1970, forKey: .creationTime)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let incidentRecordSource = incidentRecordSource {
            try encodeContainer.encode(incidentRecordSource, forKey: .incidentRecordSource)
        }
        if let resolvedTime = resolvedTime {
            try encodeContainer.encode(resolvedTime.timeIntervalSince1970, forKey: .resolvedTime)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IncidentRecordStatus.self, forKey: .status)
        status = statusDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .impact)
        impact = impactDecoded
        let creationTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let resolvedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .resolvedTime)
        resolvedTime = resolvedTimeDecoded
        let incidentRecordSourceDecoded = try containerValues.decodeIfPresent(IncidentRecordSource.self, forKey: .incidentRecordSource)
        incidentRecordSource = incidentRecordSourceDecoded
    }
}

extension IncidentRecordSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncidentRecordSummary(arn: \(String(describing: arn)), creationTime: \(String(describing: creationTime)), impact: \(String(describing: impact)), incidentRecordSource: \(String(describing: incidentRecordSource)), resolvedTime: \(String(describing: resolvedTime)), status: \(String(describing: status)), title: \(String(describing: title)))"}
}

/// <p>Details describing an incident record.</p>
public struct IncidentRecordSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the incident.</p>
    public let arn: String?
    /// <p>The time the incident was created.</p>
    public let creationTime: Date?
    /// <p>Defines the impact to customers and applications.</p>
    public let impact: Int?
    /// <p>What caused Incident Manager to create the incident.</p>
    public let incidentRecordSource: IncidentRecordSource?
    /// <p>The time the incident was resolved.</p>
    public let resolvedTime: Date?
    /// <p>The current status of the incident.</p>
    public let status: IncidentRecordStatus?
    /// <p>The title of the incident. This value is either provided by the response plan or
    ///          overwritten on creation.</p>
    public let title: String?

    public init (
        arn: String? = nil,
        creationTime: Date? = nil,
        impact: Int? = nil,
        incidentRecordSource: IncidentRecordSource? = nil,
        resolvedTime: Date? = nil,
        status: IncidentRecordStatus? = nil,
        title: String? = nil
    )
    {
        self.arn = arn
        self.creationTime = creationTime
        self.impact = impact
        self.incidentRecordSource = incidentRecordSource
        self.resolvedTime = resolvedTime
        self.status = status
        self.title = title
    }
}

extension IncidentTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dedupeString
        case impact
        case notificationTargets
        case summary
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dedupeString = dedupeString {
            try encodeContainer.encode(dedupeString, forKey: .dedupeString)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let notificationTargets = notificationTargets {
            var notificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationTargets)
            for notificationtargetset0 in notificationTargets {
                try notificationTargetsContainer.encode(notificationtargetset0)
            }
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .impact)
        impact = impactDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let dedupeStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .dedupeString)
        dedupeString = dedupeStringDecoded
        let notificationTargetsContainer = try containerValues.decodeIfPresent(Set<NotificationTargetItem>.self, forKey: .notificationTargets)
        var notificationTargetsDecoded0:Set<NotificationTargetItem>? = nil
        if let notificationTargetsContainer = notificationTargetsContainer {
            notificationTargetsDecoded0 = Set<NotificationTargetItem>()
            for union0 in notificationTargetsContainer {
                notificationTargetsDecoded0?.insert(union0)
            }
        }
        notificationTargets = notificationTargetsDecoded0
    }
}

extension IncidentTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "IncidentTemplate(dedupeString: \(String(describing: dedupeString)), impact: \(String(describing: impact)), notificationTargets: \(String(describing: notificationTargets)), summary: \(String(describing: summary)), title: \(String(describing: title)))"}
}

/// <p>Basic details used in creating a response plan. The response plan is then used to create an incident record.</p>
public struct IncidentTemplate: Equatable {
    /// <p>Used to stop Incident Manager from creating multiple incident records for the same incident. </p>
    public let dedupeString: String?
    /// <p>The impact of the incident on your customers and applications. </p>
    public let impact: Int?
    /// <p>The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an
    ///          incident. You can also make updates to the incident through the chat channel using the SNS
    ///          topics. </p>
    public let notificationTargets: Set<NotificationTargetItem>?
    /// <p>The summary of the incident. The summary is a brief synopsis of what occurred, what's
    ///          currently happening, and context.</p>
    public let summary: String?
    /// <p>The title of the incident. </p>
    public let title: String?

    public init (
        dedupeString: String? = nil,
        impact: Int? = nil,
        notificationTargets: Set<NotificationTargetItem>? = nil,
        summary: String? = nil,
        title: String? = nil
    )
    {
        self.dedupeString = dedupeString
        self.impact = impact
        self.notificationTargets = notificationTargets
        self.summary = summary
        self.title = title
    }
}

extension InternalServerException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServerException(message: \(String(describing: message)))"}
}

extension InternalServerException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request processing has failed because of an unknown error, exception or
///       failure.</p>
public struct InternalServerException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Equatable {
    public let message: String?
}

extension InternalServerExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ItemIdentifier: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(ItemValue.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ItemType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ItemIdentifier: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ItemIdentifier(type: \(String(describing: type)), value: \(String(describing: value)))"}
}

/// <p>Details and type of a related item.</p>
public struct ItemIdentifier: Equatable {
    /// <p>The type of related item. Incident Manager supports the following types:</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>ANALYSIS</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>INCIDENT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>METRIC</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>PARENT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>ATTACHMENT</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>OTHER</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let type: ItemType?
    /// <p>Details about the related item.</p>
    public let value: ItemValue?

    public init (
        type: ItemType? = nil,
        value: ItemValue? = nil
    )
    {
        self.type = type
        self.value = value
    }
}

public enum ItemType {
    case analysis
    case attachment
    case incident
    case metric
    case other
    case parent
    case sdkUnknown(String)
}

extension ItemType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ItemType] {
        return [
            .analysis,
            .attachment,
            .incident,
            .metric,
            .other,
            .parent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .analysis: return "ANALYSIS"
        case .attachment: return "ATTACHMENT"
        case .incident: return "INCIDENT"
        case .metric: return "METRIC"
        case .other: return "OTHER"
        case .parent: return "PARENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ItemType(rawValue: rawValue) ?? ItemType.sdkUnknown(rawValue)
    }
}

extension ItemValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case metricDefinition
        case sdkUnknown
        case url
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .arn(arn):
                if let arn = arn {
                    try container.encode(arn, forKey: .arn)
                }
            case let .metricDefinition(metricDefinition):
                if let metricDefinition = metricDefinition {
                    try container.encode(metricDefinition, forKey: .metricDefinition)
                }
            case let .url(url):
                if let url = url {
                    try container.encode(url, forKey: .url)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try values.decodeIfPresent(String.self, forKey: .arn)
        if let arn = arnDecoded {
            self = .arn(arn)
            return
        }
        let urlDecoded = try values.decodeIfPresent(String.self, forKey: .url)
        if let url = urlDecoded {
            self = .url(url)
            return
        }
        let metricDefinitionDecoded = try values.decodeIfPresent(String.self, forKey: .metricDefinition)
        if let metricDefinition = metricDefinitionDecoded {
            self = .metricDefinition(metricDefinition)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Describes a related item.</p>
public enum ItemValue: Equatable, Hashable {
    /// <p>The Amazon Resource Name (ARN) of the related item, if the related item is an Amazon
    ///          resource.</p>
    case arn(String?)
    /// <p>The URL, if the related item is a non-AWS resource.</p>
    case url(String?)
    /// <p>The metric definition, if the related item is a metric in CloudWatch.</p>
    case metricDefinition(String?)
    case sdkUnknown(String?)
}

public struct ListIncidentRecordsInputBodyMiddleware: Middleware {
    public let id: String = "ListIncidentRecordsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIncidentRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIncidentRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIncidentRecordsInput>
    public typealias MOutput = OperationOutput<ListIncidentRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIncidentRecordsOutputError>
}

extension ListIncidentRecordsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIncidentRecordsInput(filters: \(String(describing: filters)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIncidentRecordsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListIncidentRecordsInputHeadersMiddleware: Middleware {
    public let id: String = "ListIncidentRecordsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIncidentRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIncidentRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIncidentRecordsInput>
    public typealias MOutput = OperationOutput<ListIncidentRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIncidentRecordsOutputError>
}

public struct ListIncidentRecordsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListIncidentRecordsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListIncidentRecordsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListIncidentRecordsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListIncidentRecordsInput>
    public typealias MOutput = OperationOutput<ListIncidentRecordsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListIncidentRecordsOutputError>
}

public struct ListIncidentRecordsInput: Equatable {
    /// <p>Filter the list of incident records you are searching through. You can filter on the
    ///             following keys:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>creationTime</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>impact</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>status</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>createdBy</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>The maximum number of results per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        filters: [Filter]? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIncidentRecordsInputBody: Equatable {
    public let filters: [Filter]?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListIncidentRecordsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIncidentRecordsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIncidentRecordsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListIncidentRecordsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIncidentRecordsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListIncidentRecordsOutputResponse(incidentRecordSummaries: \(String(describing: incidentRecordSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListIncidentRecordsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListIncidentRecordsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.incidentRecordSummaries = output.incidentRecordSummaries
            self.nextToken = output.nextToken
        } else {
            self.incidentRecordSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListIncidentRecordsOutputResponse: Equatable {
    /// <p>The details of each listed incident record.</p>
    public let incidentRecordSummaries: [IncidentRecordSummary]?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        incidentRecordSummaries: [IncidentRecordSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.incidentRecordSummaries = incidentRecordSummaries
        self.nextToken = nextToken
    }
}

struct ListIncidentRecordsOutputResponseBody: Equatable {
    public let incidentRecordSummaries: [IncidentRecordSummary]?
    public let nextToken: String?
}

extension ListIncidentRecordsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case incidentRecordSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordSummariesContainer = try containerValues.decodeIfPresent([IncidentRecordSummary?].self, forKey: .incidentRecordSummaries)
        var incidentRecordSummariesDecoded0:[IncidentRecordSummary]? = nil
        if let incidentRecordSummariesContainer = incidentRecordSummariesContainer {
            incidentRecordSummariesDecoded0 = [IncidentRecordSummary]()
            for structure0 in incidentRecordSummariesContainer {
                if let structure0 = structure0 {
                    incidentRecordSummariesDecoded0?.append(structure0)
                }
            }
        }
        incidentRecordSummaries = incidentRecordSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRelatedItemsInputBodyMiddleware: Middleware {
    public let id: String = "ListRelatedItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRelatedItemsInput>
    public typealias MOutput = OperationOutput<ListRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRelatedItemsOutputError>
}

extension ListRelatedItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRelatedItemsInput(incidentRecordArn: \(String(describing: incidentRecordArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRelatedItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case incidentRecordArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRelatedItemsInputHeadersMiddleware: Middleware {
    public let id: String = "ListRelatedItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRelatedItemsInput>
    public typealias MOutput = OperationOutput<ListRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRelatedItemsOutputError>
}

public struct ListRelatedItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRelatedItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRelatedItemsInput>
    public typealias MOutput = OperationOutput<ListRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRelatedItemsOutputError>
}

public struct ListRelatedItemsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the incident record that you are listing related items for.</p>
    public let incidentRecordArn: String?
    /// <p>The maximum number of related items per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        incidentRecordArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.incidentRecordArn = incidentRecordArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRelatedItemsInputBody: Equatable {
    public let incidentRecordArn: String?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListRelatedItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case incidentRecordArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRelatedItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRelatedItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRelatedItemsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRelatedItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRelatedItemsOutputResponse(nextToken: \(String(describing: nextToken)), relatedItems: \(String(describing: relatedItems)))"}
}

extension ListRelatedItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRelatedItemsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.relatedItems = output.relatedItems
        } else {
            self.nextToken = nil
            self.relatedItems = nil
        }
    }
}

public struct ListRelatedItemsOutputResponse: Equatable {
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>Details about each related item.</p>
    public let relatedItems: [RelatedItem]?

    public init (
        nextToken: String? = nil,
        relatedItems: [RelatedItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.relatedItems = relatedItems
    }
}

struct ListRelatedItemsOutputResponseBody: Equatable {
    public let relatedItems: [RelatedItem]?
    public let nextToken: String?
}

extension ListRelatedItemsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case relatedItems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relatedItemsContainer = try containerValues.decodeIfPresent([RelatedItem?].self, forKey: .relatedItems)
        var relatedItemsDecoded0:[RelatedItem]? = nil
        if let relatedItemsContainer = relatedItemsContainer {
            relatedItemsDecoded0 = [RelatedItem]()
            for structure0 in relatedItemsContainer {
                if let structure0 = structure0 {
                    relatedItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedItems = relatedItemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListReplicationSetsInputBodyMiddleware: Middleware {
    public let id: String = "ListReplicationSetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReplicationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReplicationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReplicationSetsInput>
    public typealias MOutput = OperationOutput<ListReplicationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReplicationSetsOutputError>
}

extension ListReplicationSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReplicationSetsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListReplicationSetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListReplicationSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListReplicationSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReplicationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReplicationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReplicationSetsInput>
    public typealias MOutput = OperationOutput<ListReplicationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReplicationSetsOutputError>
}

public struct ListReplicationSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListReplicationSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListReplicationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListReplicationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListReplicationSetsInput>
    public typealias MOutput = OperationOutput<ListReplicationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListReplicationSetsOutputError>
}

public struct ListReplicationSetsInput: Equatable {
    /// <p>The maximum number of results per page. </p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListReplicationSetsInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListReplicationSetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListReplicationSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListReplicationSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListReplicationSetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListReplicationSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListReplicationSetsOutputResponse(nextToken: \(String(describing: nextToken)), replicationSetArns: \(String(describing: replicationSetArns)))"}
}

extension ListReplicationSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListReplicationSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.replicationSetArns = output.replicationSetArns
        } else {
            self.nextToken = nil
            self.replicationSetArns = nil
        }
    }
}

public struct ListReplicationSetsOutputResponse: Equatable {
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>The Amazon Resource Name (ARN) of the list replication set.</p>
    public let replicationSetArns: [String]?

    public init (
        nextToken: String? = nil,
        replicationSetArns: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationSetArns = replicationSetArns
    }
}

struct ListReplicationSetsOutputResponseBody: Equatable {
    public let replicationSetArns: [String]?
    public let nextToken: String?
}

extension ListReplicationSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case replicationSetArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationSetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .replicationSetArns)
        var replicationSetArnsDecoded0:[String]? = nil
        if let replicationSetArnsContainer = replicationSetArnsContainer {
            replicationSetArnsDecoded0 = [String]()
            for string0 in replicationSetArnsContainer {
                if let string0 = string0 {
                    replicationSetArnsDecoded0?.append(string0)
                }
            }
        }
        replicationSetArns = replicationSetArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListResponsePlansInputBodyMiddleware: Middleware {
    public let id: String = "ListResponsePlansInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResponsePlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResponsePlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResponsePlansInput>
    public typealias MOutput = OperationOutput<ListResponsePlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResponsePlansOutputError>
}

extension ListResponsePlansInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResponsePlansInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListResponsePlansInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListResponsePlansInputHeadersMiddleware: Middleware {
    public let id: String = "ListResponsePlansInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResponsePlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResponsePlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResponsePlansInput>
    public typealias MOutput = OperationOutput<ListResponsePlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResponsePlansOutputError>
}

public struct ListResponsePlansInputQueryItemMiddleware: Middleware {
    public let id: String = "ListResponsePlansInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListResponsePlansInput>,
                  next: H) -> Swift.Result<OperationOutput<ListResponsePlansOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListResponsePlansInput>
    public typealias MOutput = OperationOutput<ListResponsePlansOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListResponsePlansOutputError>
}

public struct ListResponsePlansInput: Equatable {
    /// <p>The maximum number of response plans per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResponsePlansInputBody: Equatable {
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListResponsePlansInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListResponsePlansOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListResponsePlansOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListResponsePlansOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListResponsePlansOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListResponsePlansOutputResponse(nextToken: \(String(describing: nextToken)), responsePlanSummaries: \(String(describing: responsePlanSummaries)))"}
}

extension ListResponsePlansOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListResponsePlansOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.responsePlanSummaries = output.responsePlanSummaries
        } else {
            self.nextToken = nil
            self.responsePlanSummaries = nil
        }
    }
}

public struct ListResponsePlansOutputResponse: Equatable {
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>Details of each response plan.</p>
    public let responsePlanSummaries: [ResponsePlanSummary]?

    public init (
        nextToken: String? = nil,
        responsePlanSummaries: [ResponsePlanSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.responsePlanSummaries = responsePlanSummaries
    }
}

struct ListResponsePlansOutputResponseBody: Equatable {
    public let responsePlanSummaries: [ResponsePlanSummary]?
    public let nextToken: String?
}

extension ListResponsePlansOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case responsePlanSummaries
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let responsePlanSummariesContainer = try containerValues.decodeIfPresent([ResponsePlanSummary?].self, forKey: .responsePlanSummaries)
        var responsePlanSummariesDecoded0:[ResponsePlanSummary]? = nil
        if let responsePlanSummariesContainer = responsePlanSummariesContainer {
            responsePlanSummariesDecoded0 = [ResponsePlanSummary]()
            for structure0 in responsePlanSummariesContainer {
                if let structure0 = structure0 {
                    responsePlanSummariesDecoded0?.append(structure0)
                }
            }
        }
        responsePlanSummaries = responsePlanSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
}

extension ListTagsForResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A list of tags for the response plan.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

public struct ListTimelineEventsInputBodyMiddleware: Middleware {
    public let id: String = "ListTimelineEventsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTimelineEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTimelineEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTimelineEventsInput>
    public typealias MOutput = OperationOutput<ListTimelineEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTimelineEventsOutputError>
}

extension ListTimelineEventsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTimelineEventsInput(filters: \(String(describing: filters)), incidentRecordArn: \(String(describing: incidentRecordArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), sortBy: \(String(describing: sortBy)), sortOrder: \(String(describing: sortOrder)))"}
}

extension ListTimelineEventsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filters
        case incidentRecordArn
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for filterlist0 in filters {
                try filtersContainer.encode(filterlist0)
            }
        }
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortBy = sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }
}

public struct ListTimelineEventsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTimelineEventsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTimelineEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTimelineEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTimelineEventsInput>
    public typealias MOutput = OperationOutput<ListTimelineEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTimelineEventsOutputError>
}

public struct ListTimelineEventsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTimelineEventsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTimelineEventsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTimelineEventsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTimelineEventsInput>
    public typealias MOutput = OperationOutput<ListTimelineEventsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTimelineEventsOutputError>
}

public struct ListTimelineEventsInput: Equatable {
    /// <p>Filters the timeline events based on the provided conditional values. You can filter
    ///             timeline events using the following keys:</p>
    ///         <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>eventTime</code>
    ///                </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>eventType</code>
    ///                </p>
    ///             </li>
    ///          </ul>
    public let filters: [Filter]?
    /// <p>The Amazon Resource Name (ARN) of the incident that the event is part of.</p>
    public let incidentRecordArn: String?
    /// <p>The maximum number of results per page.</p>
    public let maxResults: Int?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?
    /// <p>Sort by the specified key value pair.</p>
    public let sortBy: TimelineEventSort?
    /// <p>Sorts the order of timeline events by the value specified in the <code>sortBy</code>
    ///             field.</p>
    public let sortOrder: SortOrder?

    public init (
        filters: [Filter]? = nil,
        incidentRecordArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        sortBy: TimelineEventSort? = nil,
        sortOrder: SortOrder? = nil
    )
    {
        self.filters = filters
        self.incidentRecordArn = incidentRecordArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortBy = sortBy
        self.sortOrder = sortOrder
    }
}

struct ListTimelineEventsInputBody: Equatable {
    public let incidentRecordArn: String?
    public let filters: [Filter]?
    public let sortBy: TimelineEventSort?
    public let sortOrder: SortOrder?
    public let maxResults: Int?
    public let nextToken: String?
}

extension ListTimelineEventsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filters
        case incidentRecordArn
        case maxResults
        case nextToken
        case sortBy
        case sortOrder
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let filtersContainer = try containerValues.decodeIfPresent([Filter?].self, forKey: .filters)
        var filtersDecoded0:[Filter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [Filter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let sortByDecoded = try containerValues.decodeIfPresent(TimelineEventSort.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTimelineEventsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTimelineEventsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTimelineEventsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTimelineEventsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTimelineEventsOutputResponse(eventSummaries: \(String(describing: eventSummaries)), nextToken: \(String(describing: nextToken)))"}
}

extension ListTimelineEventsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTimelineEventsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSummaries = output.eventSummaries
            self.nextToken = output.nextToken
        } else {
            self.eventSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTimelineEventsOutputResponse: Equatable {
    /// <p>Details about each event that occurred during the incident.</p>
    public let eventSummaries: [EventSummary]?
    /// <p>The pagination token to continue to the next page of results.</p>
    public let nextToken: String?

    public init (
        eventSummaries: [EventSummary]? = nil,
        nextToken: String? = nil
    )
    {
        self.eventSummaries = eventSummaries
        self.nextToken = nextToken
    }
}

struct ListTimelineEventsOutputResponseBody: Equatable {
    public let eventSummaries: [EventSummary]?
    public let nextToken: String?
}

extension ListTimelineEventsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSummaries
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSummariesContainer = try containerValues.decodeIfPresent([EventSummary?].self, forKey: .eventSummaries)
        var eventSummariesDecoded0:[EventSummary]? = nil
        if let eventSummariesContainer = eventSummariesContainer {
            eventSummariesDecoded0 = [EventSummary]()
            for structure0 in eventSummariesContainer {
                if let structure0 = structure0 {
                    eventSummariesDecoded0?.append(structure0)
                }
            }
        }
        eventSummaries = eventSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotificationTargetItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sdkUnknown
        case snsTopicArn
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .snsTopicArn(snsTopicArn):
                if let snsTopicArn = snsTopicArn {
                    try container.encode(snsTopicArn, forKey: .snsTopicArn)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let snsTopicArnDecoded = try values.decodeIfPresent(String.self, forKey: .snsTopicArn)
        if let snsTopicArn = snsTopicArnDecoded {
            self = .snsTopicArn(snsTopicArn)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>The SNS topic that's used by
///          AWS
///          Chatbot to notify the incidents chat channel.</p>
public enum NotificationTargetItem: Equatable, Hashable {
    /// <p>The Amazon Resource Name (ARN) of the SNS topic.</p>
    case snsTopicArn(String?)
    case sdkUnknown(String?)
}

public struct PutResourcePolicyInputBodyMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

extension PutResourcePolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyInput(policy: \(String(describing: policy)), resourceArn: \(String(describing: resourceArn)))"}
}

extension PutResourcePolicyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policy
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policy = policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct PutResourcePolicyInputHeadersMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutResourcePolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutResourcePolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutResourcePolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutResourcePolicyInput>
    public typealias MOutput = OperationOutput<PutResourcePolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutResourcePolicyOutputError>
}

public struct PutResourcePolicyInput: Equatable {
    /// <p>Details of the resource policy.</p>
    public let policy: String?
    /// <p>The Amazon Resource Name (ARN) of the response plan you're adding the resource policy
    ///             to.</p>
    public let resourceArn: String?

    public init (
        policy: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.policy = policy
        self.resourceArn = resourceArn
    }
}

struct PutResourcePolicyInputBody: Equatable {
    public let resourceArn: String?
    public let policy: String?
}

extension PutResourcePolicyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutResourcePolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutResourcePolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutResourcePolicyOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutResourcePolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutResourcePolicyOutputResponse(policyId: \(String(describing: policyId)))"}
}

extension PutResourcePolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutResourcePolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policyId = output.policyId
        } else {
            self.policyId = nil
        }
    }
}

public struct PutResourcePolicyOutputResponse: Equatable {
    /// <p>The ID of the resource policy.</p>
    public let policyId: String?

    public init (
        policyId: String? = nil
    )
    {
        self.policyId = policyId
    }
}

struct PutResourcePolicyOutputResponseBody: Equatable {
    public let policyId: String?
}

extension PutResourcePolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policyId
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
    }
}

extension RegionInfo: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sseKmsKeyId
        case status
        case statusMessage
        case statusUpdateDateTime
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sseKmsKeyId = sseKmsKeyId {
            try encodeContainer.encode(sseKmsKeyId, forKey: .sseKmsKeyId)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let statusUpdateDateTime = statusUpdateDateTime {
            try encodeContainer.encode(statusUpdateDateTime.timeIntervalSince1970, forKey: .statusUpdateDateTime)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sseKmsKeyId)
        sseKmsKeyId = sseKmsKeyIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(RegionStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let statusUpdateDateTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .statusUpdateDateTime)
        statusUpdateDateTime = statusUpdateDateTimeDecoded
    }
}

extension RegionInfo: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegionInfo(sseKmsKeyId: \(String(describing: sseKmsKeyId)), status: \(String(describing: status)), statusMessage: \(String(describing: statusMessage)), statusUpdateDateTime: \(String(describing: statusUpdateDateTime)))"}
}

/// <p>Information about a Region in your replication set.</p>
public struct RegionInfo: Equatable {
    /// <p>The ID of the KMS key used to encrypt the data in this Region.</p>
    public let sseKmsKeyId: String?
    /// <p>The status of the Region in the replication set.</p>
    public let status: RegionStatus?
    /// <p>Information displayed about the status of the Region.</p>
    public let statusMessage: String?
    /// <p>The most recent date and time that the Region's status was updated.</p>
    public let statusUpdateDateTime: Date?

    public init (
        sseKmsKeyId: String? = nil,
        status: RegionStatus? = nil,
        statusMessage: String? = nil,
        statusUpdateDateTime: Date? = nil
    )
    {
        self.sseKmsKeyId = sseKmsKeyId
        self.status = status
        self.statusMessage = statusMessage
        self.statusUpdateDateTime = statusUpdateDateTime
    }
}

extension RegionMapInputValue: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case sseKmsKeyId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sseKmsKeyId = sseKmsKeyId {
            try encodeContainer.encode(sseKmsKeyId, forKey: .sseKmsKeyId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sseKmsKeyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sseKmsKeyId)
        sseKmsKeyId = sseKmsKeyIdDecoded
    }
}

extension RegionMapInputValue: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegionMapInputValue(sseKmsKeyId: \(String(describing: sseKmsKeyId)))"}
}

/// <p>The mapping between a Region and the key that's used to encrypt the data.</p>
public struct RegionMapInputValue: Equatable {
    /// <p>The KMS key used to encrypt the data in your replication set.</p>
    public let sseKmsKeyId: String?

    public init (
        sseKmsKeyId: String? = nil
    )
    {
        self.sseKmsKeyId = sseKmsKeyId
    }
}

public enum RegionStatus {
    /// All operations have completed successfully and the region is ready to use
    case active
    /// The region is in the process of being created.
    case creating
    /// The region is in the process of being deleted.
    case deleting
    /// The region is not healthy and we cannot automatically fix it.
    case failed
    case sdkUnknown(String)
}

extension RegionStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [RegionStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = RegionStatus(rawValue: rawValue) ?? RegionStatus.sdkUnknown(rawValue)
    }
}

extension RelatedItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case identifier
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identifier = identifier {
            try encodeContainer.encode(identifier, forKey: .identifier)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let identifierDecoded = try containerValues.decodeIfPresent(ItemIdentifier.self, forKey: .identifier)
        identifier = identifierDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
    }
}

extension RelatedItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RelatedItem(identifier: \(String(describing: identifier)), title: \(String(describing: title)))"}
}

/// <p>Resources that responders use to triage and mitigate the incident.</p>
public struct RelatedItem: Equatable {
    /// <p>Details about the related item.</p>
    public let identifier: ItemIdentifier?
    /// <p>The title of the related item.</p>
    public let title: String?

    public init (
        identifier: ItemIdentifier? = nil,
        title: String? = nil
    )
    {
        self.identifier = identifier
        self.title = title
    }
}

extension RelatedItemsUpdate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case itemToAdd
        case itemToRemove
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .itemToAdd(itemToAdd):
                if let itemToAdd = itemToAdd {
                    try container.encode(itemToAdd, forKey: .itemToAdd)
                }
            case let .itemToRemove(itemToRemove):
                if let itemToRemove = itemToRemove {
                    try container.encode(itemToRemove, forKey: .itemToRemove)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let itemToAddDecoded = try values.decodeIfPresent(RelatedItem.self, forKey: .itemToAdd)
        if let itemToAdd = itemToAddDecoded {
            self = .itemToAdd(itemToAdd)
            return
        }
        let itemToRemoveDecoded = try values.decodeIfPresent(ItemIdentifier.self, forKey: .itemToRemove)
        if let itemToRemove = itemToRemoveDecoded {
            self = .itemToRemove(itemToRemove)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Details about the related item you're adding.</p>
public enum RelatedItemsUpdate: Equatable {
    /// <p>Details about the related item you're adding.</p>
    case itemToAdd(RelatedItem?)
    /// <p>Details about the related item you're deleting.</p>
    case itemToRemove(ItemIdentifier?)
    case sdkUnknown(String?)
}

extension ReplicationSet: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case createdBy
        case createdTime
        case deletionProtected
        case lastModifiedBy
        case lastModifiedTime
        case regionMap
        case status
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdBy = createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let createdTime = createdTime {
            try encodeContainer.encode(createdTime.timeIntervalSince1970, forKey: .createdTime)
        }
        if let deletionProtected = deletionProtected {
            try encodeContainer.encode(deletionProtected, forKey: .deletionProtected)
        }
        if let lastModifiedBy = lastModifiedBy {
            try encodeContainer.encode(lastModifiedBy, forKey: .lastModifiedBy)
        }
        if let lastModifiedTime = lastModifiedTime {
            try encodeContainer.encode(lastModifiedTime.timeIntervalSince1970, forKey: .lastModifiedTime)
        }
        if let regionMap = regionMap {
            var regionMapContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .regionMap)
            for (dictKey0, regioninfomap0) in regionMap {
                try regionMapContainer.encode(regioninfomap0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionMapContainer = try containerValues.decodeIfPresent([String: RegionInfo?].self, forKey: .regionMap)
        var regionMapDecoded0: [String:RegionInfo]? = nil
        if let regionMapContainer = regionMapContainer {
            regionMapDecoded0 = [String:RegionInfo]()
            for (key0, regioninfo0) in regionMapContainer {
                if let regioninfo0 = regioninfo0 {
                    regionMapDecoded0?[key0] = regioninfo0
                }
            }
        }
        regionMap = regionMapDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(ReplicationSetStatus.self, forKey: .status)
        status = statusDecoded
        let deletionProtectedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtected)
        deletionProtected = deletionProtectedDecoded
        let createdTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdTime)
        createdTime = createdTimeDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModifiedTime)
        lastModifiedTime = lastModifiedTimeDecoded
        let lastModifiedByDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModifiedBy)
        lastModifiedBy = lastModifiedByDecoded
    }
}

extension ReplicationSet: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ReplicationSet(createdBy: \(String(describing: createdBy)), createdTime: \(String(describing: createdTime)), deletionProtected: \(String(describing: deletionProtected)), lastModifiedBy: \(String(describing: lastModifiedBy)), lastModifiedTime: \(String(describing: lastModifiedTime)), regionMap: \(String(describing: regionMap)), status: \(String(describing: status)))"}
}

/// <p>The set of Regions that your Incident Manager data will be replicated to and the KMS key used
///          to encrypt the data. </p>
public struct ReplicationSet: Equatable {
    /// <p>Details about who created the replication set.</p>
    public let createdBy: String?
    /// <p>When the replication set was created.</p>
    public let createdTime: Date?
    /// <p>Determines if the replication set deletion protection is enabled or not. If deletion
    ///          protection is enabled, you can't delete the last Region in the replication set. </p>
    public let deletionProtected: Bool?
    /// <p>Who last modified the replication set.</p>
    public let lastModifiedBy: String?
    /// <p>When the replication set was last updated.</p>
    public let lastModifiedTime: Date?
    /// <p>The map between each Region in your replication set and the KMS key that is used to
    ///          encrypt the data in that Region.</p>
    public let regionMap: [String:RegionInfo]?
    /// <p>The status of the replication set. If the replication set is still pending, you can't
    ///          use Incident Manager functionality.</p>
    public let status: ReplicationSetStatus?

    public init (
        createdBy: String? = nil,
        createdTime: Date? = nil,
        deletionProtected: Bool? = nil,
        lastModifiedBy: String? = nil,
        lastModifiedTime: Date? = nil,
        regionMap: [String:RegionInfo]? = nil,
        status: ReplicationSetStatus? = nil
    )
    {
        self.createdBy = createdBy
        self.createdTime = createdTime
        self.deletionProtected = deletionProtected
        self.lastModifiedBy = lastModifiedBy
        self.lastModifiedTime = lastModifiedTime
        self.regionMap = regionMap
        self.status = status
    }
}

public enum ReplicationSetStatus {
    /// All operations have completed successfully and the replication set is ready to use
    case active
    /// Replication set is in the process of being created.
    case creating
    /// Replication set is in the process of being deleted.
    case deleting
    /// Replication set is not healthy and we cannot fix it.
    case failed
    /// Replication set is in the process of being updated.
    case updating
    case sdkUnknown(String)
}

extension ReplicationSetStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReplicationSetStatus] {
        return [
            .active,
            .creating,
            .deleting,
            .failed,
            .updating,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "ACTIVE"
        case .creating: return "CREATING"
        case .deleting: return "DELETING"
        case .failed: return "FAILED"
        case .updating: return "UPDATING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReplicationSetStatus(rawValue: rawValue) ?? ReplicationSetStatus.sdkUnknown(rawValue)
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.resourceIdentifier = output.resourceIdentifier
            self.resourceType = output.resourceType
        } else {
            self.message = nil
            self.resourceIdentifier = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request references a resource which does not exist. </p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// The identifier for the requested resource
    public var resourceIdentifier: String?
    /// The resource type
    public var resourceType: ResourceType?

    public init (
        message: String? = nil,
        resourceIdentifier: String? = nil,
        resourceType: ResourceType? = nil
    )
    {
        self.message = message
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let message: String?
    public let resourceIdentifier: String?
    public let resourceType: ResourceType?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case resourceIdentifier
        case resourceType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ResourcePolicy: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case policyDocument
        case policyId
        case ramResourceShareRegion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyDocument = policyDocument {
            try encodeContainer.encode(policyDocument, forKey: .policyDocument)
        }
        if let policyId = policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let ramResourceShareRegion = ramResourceShareRegion {
            try encodeContainer.encode(ramResourceShareRegion, forKey: .ramResourceShareRegion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDocumentDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyDocument)
        policyDocument = policyDocumentDecoded
        let policyIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let ramResourceShareRegionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ramResourceShareRegion)
        ramResourceShareRegion = ramResourceShareRegionDecoded
    }
}

extension ResourcePolicy: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourcePolicy(policyDocument: \(String(describing: policyDocument)), policyId: \(String(describing: policyId)), ramResourceShareRegion: \(String(describing: ramResourceShareRegion)))"}
}

/// <p>The resource policy that allows Incident Manager to perform actions on resources on your behalf.</p>
public struct ResourcePolicy: Equatable {
    /// <p>The JSON blob that describes the policy.</p>
    public let policyDocument: String?
    /// <p>The ID of the resource policy.</p>
    public let policyId: String?
    /// <p>The Region that policy allows resources to be used in.</p>
    public let ramResourceShareRegion: String?

    public init (
        policyDocument: String? = nil,
        policyId: String? = nil,
        ramResourceShareRegion: String? = nil
    )
    {
        self.policyDocument = policyDocument
        self.policyId = policyId
        self.ramResourceShareRegion = ramResourceShareRegion
    }
}

public enum ResourceType {
    case incidentRecord
    case replicationSet
    case resourcePolicy
    case responsePlan
    case timelineEvent
    case sdkUnknown(String)
}

extension ResourceType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ResourceType] {
        return [
            .incidentRecord,
            .replicationSet,
            .resourcePolicy,
            .responsePlan,
            .timelineEvent,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .incidentRecord: return "INCIDENT_RECORD"
        case .replicationSet: return "REPLICATION_SET"
        case .resourcePolicy: return "RESOURCE_POLICY"
        case .responsePlan: return "RESPONSE_PLAN"
        case .timelineEvent: return "TIMELINE_EVENT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
    }
}

extension ResponsePlanSummary: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case displayName
        case name
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
    }
}

extension ResponsePlanSummary: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResponsePlanSummary(arn: \(String(describing: arn)), displayName: \(String(describing: displayName)), name: \(String(describing: name)))"}
}

/// <p>Details of the response plan that are used when creating an incident.</p>
public struct ResponsePlanSummary: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    public let arn: String?
    /// <p>The human readable name of the response plan. This can include spaces.</p>
    public let displayName: String?
    /// <p>The name of the response plan. This can't include spaces.</p>
    public let name: String?

    public init (
        arn: String? = nil,
        displayName: String? = nil,
        name: String? = nil
    )
    {
        self.arn = arn
        self.displayName = displayName
        self.name = name
    }
}

public enum ServiceCode {
    case ssmIncidents
    case sdkUnknown(String)
}

extension ServiceCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ServiceCode] {
        return [
            .ssmIncidents,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ssmIncidents: return "ssm-incidents"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ServiceCode(rawValue: rawValue) ?? ServiceCode.sdkUnknown(rawValue)
    }
}

extension ServiceQuotaExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceQuotaExceededException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), resourceIdentifier: \(String(describing: resourceIdentifier)), resourceType: \(String(describing: resourceType)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ServiceQuotaExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceIdentifier = output.resourceIdentifier
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.resourceIdentifier = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Request would cause a service quota to be exceeded.</p>
public struct ServiceQuotaExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// Originating quota code
    public var quotaCode: String?
    /// The identifier for the requested resource
    public var resourceIdentifier: String?
    /// The resource type
    public var resourceType: ResourceType?
    /// Originating service code
    public var serviceCode: ServiceCode?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        resourceIdentifier: String? = nil,
        resourceType: ResourceType? = nil,
        serviceCode: ServiceCode? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Equatable {
    public let message: String?
    public let resourceIdentifier: String?
    public let resourceType: ResourceType?
    public let serviceCode: ServiceCode?
    public let quotaCode: String?
}

extension ServiceQuotaExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case quotaCode
        case resourceIdentifier
        case resourceType
        case serviceCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let resourceIdentifierDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceIdentifier)
        resourceIdentifier = resourceIdentifierDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(ServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

public enum SortOrder {
    case ascending
    case descending
    case sdkUnknown(String)
}

extension SortOrder : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SortOrder] {
        return [
            .ascending,
            .descending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ascending: return "ASCENDING"
        case .descending: return "DESCENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
    }
}

extension SsmAutomation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case documentName
        case documentVersion
        case parameters
        case roleArn
        case targetAccount
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let documentName = documentName {
            try encodeContainer.encode(documentName, forKey: .documentName)
        }
        if let documentVersion = documentVersion {
            try encodeContainer.encode(documentVersion, forKey: .documentVersion)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .parameters)
            for (dictKey0, ssmparameters0) in parameters {
                try parametersContainer.encode(ssmparameters0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let targetAccount = targetAccount {
            try encodeContainer.encode(targetAccount.rawValue, forKey: .targetAccount)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let documentNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentName)
        documentName = documentNameDecoded
        let documentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .documentVersion)
        documentVersion = documentVersionDecoded
        let targetAccountDecoded = try containerValues.decodeIfPresent(SsmTargetAccount.self, forKey: .targetAccount)
        targetAccount = targetAccountDecoded
        let parametersContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .parameters)
        var parametersDecoded0: [String:[String]]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [String:[String]]()
            for (key0, ssmparametervalues0) in parametersContainer {
                var ssmparametervalues0Decoded0: [String]? = nil
                if let ssmparametervalues0 = ssmparametervalues0 {
                    ssmparametervalues0Decoded0 = [String]()
                    for string1 in ssmparametervalues0 {
                        if let string1 = string1 {
                            ssmparametervalues0Decoded0?.append(string1)
                        }
                    }
                }
                parametersDecoded0?[key0] = ssmparametervalues0Decoded0
            }
        }
        parameters = parametersDecoded0
    }
}

extension SsmAutomation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SsmAutomation(documentName: \(String(describing: documentName)), documentVersion: \(String(describing: documentVersion)), parameters: \(String(describing: parameters)), roleArn: \(String(describing: roleArn)), targetAccount: \(String(describing: targetAccount)))"}
}

/// <p>Details about the Systems Manager automation document that will be used as a runbook during an incident.</p>
public struct SsmAutomation: Equatable {
    /// <p>The automation document's name.</p>
    public let documentName: String?
    /// <p>The automation document's version to use when running.</p>
    public let documentVersion: String?
    /// <p>The key-value pair parameters to use when running the automation document.</p>
    public let parameters: [String:[String]]?
    /// <p>The Amazon Resource Name (ARN) of the role that the automation document will assume when running commands.</p>
    public let roleArn: String?
    /// <p>The account that the automation document will be run in. This can be in either the management account or an application account.</p>
    public let targetAccount: SsmTargetAccount?

    public init (
        documentName: String? = nil,
        documentVersion: String? = nil,
        parameters: [String:[String]]? = nil,
        roleArn: String? = nil,
        targetAccount: SsmTargetAccount? = nil
    )
    {
        self.documentName = documentName
        self.documentVersion = documentVersion
        self.parameters = parameters
        self.roleArn = roleArn
        self.targetAccount = targetAccount
    }
}

public enum SsmTargetAccount {
    case impactedAccount
    case responsePlanOwnerAccount
    case sdkUnknown(String)
}

extension SsmTargetAccount : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SsmTargetAccount] {
        return [
            .impactedAccount,
            .responsePlanOwnerAccount,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .impactedAccount: return "IMPACTED_ACCOUNT"
        case .responsePlanOwnerAccount: return "RESPONSE_PLAN_OWNER_ACCOUNT"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SsmTargetAccount(rawValue: rawValue) ?? SsmTargetAccount.sdkUnknown(rawValue)
    }
}

public struct StartIncidentInputBodyMiddleware: Middleware {
    public let id: String = "StartIncidentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartIncidentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartIncidentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartIncidentInput>
    public typealias MOutput = OperationOutput<StartIncidentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartIncidentOutputError>
}

extension StartIncidentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartIncidentInput(clientToken: \(String(describing: clientToken)), impact: \(String(describing: impact)), relatedItems: \(String(describing: relatedItems)), responsePlanArn: \(String(describing: responsePlanArn)), title: \(String(describing: title)), triggerDetails: \(String(describing: triggerDetails)))"}
}

extension StartIncidentInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case impact
        case relatedItems
        case responsePlanArn
        case title
        case triggerDetails
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let relatedItems = relatedItems {
            var relatedItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedItems)
            for relateditemlist0 in relatedItems {
                try relatedItemsContainer.encode(relateditemlist0)
            }
        }
        if let responsePlanArn = responsePlanArn {
            try encodeContainer.encode(responsePlanArn, forKey: .responsePlanArn)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let triggerDetails = triggerDetails {
            try encodeContainer.encode(triggerDetails, forKey: .triggerDetails)
        }
    }
}

public struct StartIncidentInputHeadersMiddleware: Middleware {
    public let id: String = "StartIncidentInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartIncidentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartIncidentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartIncidentInput>
    public typealias MOutput = OperationOutput<StartIncidentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartIncidentOutputError>
}

public struct StartIncidentInputQueryItemMiddleware: Middleware {
    public let id: String = "StartIncidentInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartIncidentInput>,
                  next: H) -> Swift.Result<OperationOutput<StartIncidentOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartIncidentInput>
    public typealias MOutput = OperationOutput<StartIncidentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartIncidentOutputError>
}

public struct StartIncidentInput: Equatable {
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>Defines the impact to the customers. Providing an impact overwrites the impact
    ///             provided by a response plan.</p>
    ///         <p class="title">
    ///             <b>Possible impacts:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>1</code> - Critical impact, this typically relates to full application
    ///                     failure that impacts many to all customers. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>2</code> - High impact, partial application failure with impact to many
    ///                     customers.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>3</code> -  Medium impact, the application is providing reduced service
    ///                     to customers.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>4</code> -  Low impact, customer might aren't impacted by the problem
    ///                     yet.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>5</code> - No impact, customers aren't currently impacted but urgent
    ///                     action is needed to avoid impact.</p>
    ///             </li>
    ///          </ul>
    public let impact: Int?
    /// <p>Add related items to the incident for other responders to use. Related items are AWS
    ///             resources, external links, or files uploaded to an S3 bucket. </p>
    public let relatedItems: [RelatedItem]?
    /// <p>The Amazon Resource Name (ARN) of the response plan that pre-defines summary, chat
    ///             channels, SNS topics, runbooks, title, and impact of the incident. </p>
    public let responsePlanArn: String?
    /// <p>Provide a title for the incident. Providing a title overwrites the title provided by
    ///             the response plan. </p>
    public let title: String?
    /// <p>Details of what created the incident record in Incident Manager.</p>
    public let triggerDetails: TriggerDetails?

    public init (
        clientToken: String? = nil,
        impact: Int? = nil,
        relatedItems: [RelatedItem]? = nil,
        responsePlanArn: String? = nil,
        title: String? = nil,
        triggerDetails: TriggerDetails? = nil
    )
    {
        self.clientToken = clientToken
        self.impact = impact
        self.relatedItems = relatedItems
        self.responsePlanArn = responsePlanArn
        self.title = title
        self.triggerDetails = triggerDetails
    }
}

struct StartIncidentInputBody: Equatable {
    public let clientToken: String?
    public let responsePlanArn: String?
    public let title: String?
    public let impact: Int?
    public let triggerDetails: TriggerDetails?
    public let relatedItems: [RelatedItem]?
}

extension StartIncidentInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case impact
        case relatedItems
        case responsePlanArn
        case title
        case triggerDetails
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let responsePlanArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .responsePlanArn)
        responsePlanArn = responsePlanArnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .impact)
        impact = impactDecoded
        let triggerDetailsDecoded = try containerValues.decodeIfPresent(TriggerDetails.self, forKey: .triggerDetails)
        triggerDetails = triggerDetailsDecoded
        let relatedItemsContainer = try containerValues.decodeIfPresent([RelatedItem?].self, forKey: .relatedItems)
        var relatedItemsDecoded0:[RelatedItem]? = nil
        if let relatedItemsContainer = relatedItemsContainer {
            relatedItemsDecoded0 = [RelatedItem]()
            for structure0 in relatedItemsContainer {
                if let structure0 = structure0 {
                    relatedItemsDecoded0?.append(structure0)
                }
            }
        }
        relatedItems = relatedItemsDecoded0
    }
}

extension StartIncidentOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartIncidentOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartIncidentOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartIncidentOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartIncidentOutputResponse(incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

extension StartIncidentOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartIncidentOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.incidentRecordArn = output.incidentRecordArn
        } else {
            self.incidentRecordArn = nil
        }
    }
}

public struct StartIncidentOutputResponse: Equatable {
    /// <p>The ARN of the newly created incident record.</p>
    public let incidentRecordArn: String?

    public init (
        incidentRecordArn: String? = nil
    )
    {
        self.incidentRecordArn = incidentRecordArn
    }
}

struct StartIncidentOutputResponseBody: Equatable {
    public let incidentRecordArn: String?
}

extension StartIncidentOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case incidentRecordArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tagmap0) in tags {
                try tagsContainer.encode(tagmap0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the response plan you're adding the tags to.</p>
    public let resourceArn: String?
    /// <p>A list of tags that you are adding to the response plan.</p>
    public let tags: [String:String]?

    public init (
        resourceArn: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ThrottlingException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ThrottlingException(message: \(String(describing: message)), quotaCode: \(String(describing: quotaCode)), serviceCode: \(String(describing: serviceCode)))"}
}

extension ThrottlingException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was denied due to request throttling.</p>
public struct ThrottlingException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// Originating quota code
    public var quotaCode: String?
    /// Originating service code
    public var serviceCode: ServiceCode?

    public init (
        message: String? = nil,
        quotaCode: String? = nil,
        serviceCode: ServiceCode? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Equatable {
    public let message: String?
    public let serviceCode: ServiceCode?
    public let quotaCode: String?
}

extension ThrottlingExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(ServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension TimelineEvent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventData
        case eventId
        case eventTime
        case eventType
        case eventUpdatedTime
        case incidentRecordArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventData = eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let eventUpdatedTime = eventUpdatedTime {
            try encodeContainer.encode(eventUpdatedTime.timeIntervalSince1970, forKey: .eventUpdatedTime)
        }
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventUpdatedTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventUpdatedTime)
        eventUpdatedTime = eventUpdatedTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension TimelineEvent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimelineEvent(eventData: \(String(describing: eventData)), eventId: \(String(describing: eventId)), eventTime: \(String(describing: eventTime)), eventType: \(String(describing: eventType)), eventUpdatedTime: \(String(describing: eventUpdatedTime)), incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

/// <p>A significant event that happened during the incident. </p>
public struct TimelineEvent: Equatable {
    /// <p>A short description of the event.</p>
    public let eventData: String?
    /// <p>The ID of the timeline event.</p>
    public let eventId: String?
    /// <p>The time that the event occurred.</p>
    public let eventTime: Date?
    /// <p>The type of event that occurred. Currently Incident Manager supports only the <code>Custom
    ///             Event</code> type.</p>
    public let eventType: String?
    /// <p>The time that the timeline event was last updated.</p>
    public let eventUpdatedTime: Date?
    /// <p>The Amazon Resource Name (ARN) of the incident that the event occurred during.</p>
    public let incidentRecordArn: String?

    public init (
        eventData: String? = nil,
        eventId: String? = nil,
        eventTime: Date? = nil,
        eventType: String? = nil,
        eventUpdatedTime: Date? = nil,
        incidentRecordArn: String? = nil
    )
    {
        self.eventData = eventData
        self.eventId = eventId
        self.eventTime = eventTime
        self.eventType = eventType
        self.eventUpdatedTime = eventUpdatedTime
        self.incidentRecordArn = incidentRecordArn
    }
}

public enum TimelineEventSort {
    case eventTime
    case sdkUnknown(String)
}

extension TimelineEventSort : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TimelineEventSort] {
        return [
            .eventTime,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .eventTime: return "EVENT_TIME"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TimelineEventSort(rawValue: rawValue) ?? TimelineEventSort.sdkUnknown(rawValue)
    }
}

extension TriggerDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case rawData
        case source
        case timestamp
        case triggerArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rawData = rawData {
            try encodeContainer.encode(rawData, forKey: .rawData)
        }
        if let source = source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp.timeIntervalSince1970, forKey: .timestamp)
        }
        if let triggerArn = triggerArn {
            try encodeContainer.encode(triggerArn, forKey: .triggerArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .source)
        source = sourceDecoded
        let triggerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .triggerArn)
        triggerArn = triggerArnDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let rawDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rawData)
        rawData = rawDataDecoded
    }
}

extension TriggerDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TriggerDetails(rawData: \(String(describing: rawData)), source: \(String(describing: source)), timestamp: \(String(describing: timestamp)), triggerArn: \(String(describing: triggerArn)))"}
}

/// <p>Details about what caused the incident to be created in Incident Manager.</p>
public struct TriggerDetails: Equatable {
    /// <p>Raw data passed from either EventBridge, CloudWatch, or Incident Manager when an
    ///          incident is created.</p>
    public let rawData: String?
    /// <p>Identifies the service that sourced the event. All events sourced from within AWS begin
    ///          with "aws." Customer-generated events can have any value here, as long as it doesn't begin
    ///          with "aws." We recommend the use of Java package-name style reverse domain-name strings. </p>
    public let source: String?
    /// <p>The time that the incident was detected.</p>
    public let timestamp: Date?
    /// <p>The ARN of the source that detected the incident.</p>
    public let triggerArn: String?

    public init (
        rawData: String? = nil,
        source: String? = nil,
        timestamp: Date? = nil,
        triggerArn: String? = nil
    )
    {
        self.rawData = rawData
        self.source = source
        self.timestamp = timestamp
        self.triggerArn = triggerArn
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resourceArn: \(String(describing: resourceArn)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the response plan you're removing a tag from.</p>
    public let resourceArn: String?
    /// <p>The name of the tag you're removing from the response plan.</p>
    public let tagKeys: [String]?

    public init (
        resourceArn: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateDeletionProtectionInputBodyMiddleware: Middleware {
    public let id: String = "UpdateDeletionProtectionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeletionProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeletionProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeletionProtectionInput>
    public typealias MOutput = OperationOutput<UpdateDeletionProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeletionProtectionOutputError>
}

extension UpdateDeletionProtectionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeletionProtectionInput(arn: \(String(describing: arn)), clientToken: \(String(describing: clientToken)), deletionProtected: \(String(describing: deletionProtected)))"}
}

extension UpdateDeletionProtectionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientToken
        case deletionProtected
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let deletionProtected = deletionProtected {
            try encodeContainer.encode(deletionProtected, forKey: .deletionProtected)
        }
    }
}

public struct UpdateDeletionProtectionInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateDeletionProtectionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeletionProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeletionProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeletionProtectionInput>
    public typealias MOutput = OperationOutput<UpdateDeletionProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeletionProtectionOutputError>
}

public struct UpdateDeletionProtectionInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateDeletionProtectionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateDeletionProtectionInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateDeletionProtectionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateDeletionProtectionInput>
    public typealias MOutput = OperationOutput<UpdateDeletionProtectionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateDeletionProtectionOutputError>
}

public struct UpdateDeletionProtectionInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the replication set you're updating.</p>
    public let arn: String?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>Details if deletion protection is enabled or disabled in your account.</p>
    public let deletionProtected: Bool?

    public init (
        arn: String? = nil,
        clientToken: String? = nil,
        deletionProtected: Bool? = nil
    )
    {
        self.arn = arn
        self.clientToken = clientToken
        self.deletionProtected = deletionProtected
    }
}

struct UpdateDeletionProtectionInputBody: Equatable {
    public let arn: String?
    public let deletionProtected: Bool?
    public let clientToken: String?
}

extension UpdateDeletionProtectionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case clientToken
        case deletionProtected
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let deletionProtectedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .deletionProtected)
        deletionProtected = deletionProtectedDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDeletionProtectionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDeletionProtectionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateDeletionProtectionOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDeletionProtectionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateDeletionProtectionOutputResponse()"}
}

extension UpdateDeletionProtectionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDeletionProtectionOutputResponse: Equatable {

    public init() {}
}

struct UpdateDeletionProtectionOutputResponseBody: Equatable {
}

extension UpdateDeletionProtectionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateIncidentRecordInputBodyMiddleware: Middleware {
    public let id: String = "UpdateIncidentRecordInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIncidentRecordInput>
    public typealias MOutput = OperationOutput<UpdateIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIncidentRecordOutputError>
}

extension UpdateIncidentRecordInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIncidentRecordInput(arn: \(String(describing: arn)), chatChannel: \(String(describing: chatChannel)), clientToken: \(String(describing: clientToken)), impact: \(String(describing: impact)), notificationTargets: \(String(describing: notificationTargets)), status: \(String(describing: status)), summary: \(String(describing: summary)), title: \(String(describing: title)))"}
}

extension UpdateIncidentRecordInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case chatChannel
        case clientToken
        case impact
        case notificationTargets
        case status
        case summary
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let chatChannel = chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let impact = impact {
            try encodeContainer.encode(impact, forKey: .impact)
        }
        if let notificationTargets = notificationTargets {
            var notificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationTargets)
            for notificationtargetset0 in notificationTargets {
                try notificationTargetsContainer.encode(notificationtargetset0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let summary = summary {
            try encodeContainer.encode(summary, forKey: .summary)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }
}

public struct UpdateIncidentRecordInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateIncidentRecordInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIncidentRecordInput>
    public typealias MOutput = OperationOutput<UpdateIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIncidentRecordOutputError>
}

public struct UpdateIncidentRecordInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateIncidentRecordInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateIncidentRecordInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateIncidentRecordOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateIncidentRecordInput>
    public typealias MOutput = OperationOutput<UpdateIncidentRecordOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateIncidentRecordOutputError>
}

public struct UpdateIncidentRecordInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the incident record you are updating.</p>
    public let arn: String?
    /// <p>The AWS Chatbot chat channel for responders to collaborate in.</p>
    public let chatChannel: ChatChannel?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>Defines the impact to customers and applications. Providing an impact overwrites the
    ///             impact provided by the response plan.</p>
    ///         <p class="title">
    ///             <b>Possible impacts:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                 <p>
    ///                   <code>1</code> - Critical impact, this typically relates to full application
    ///                     failure that impacts many to all customers. </p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>2</code> - High impact, partial application failure with impact to many
    ///                     customers.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>3</code> -  Medium impact, the application is providing reduced service
    ///                     to customers.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>4</code> -  Low impact, customer might aren't impacted by the problem
    ///                     yet.</p>
    ///             </li>
    ///             <li>
    ///                 <p>
    ///                   <code>5</code> - No impact, customers aren't currently impacted but urgent
    ///                     action is needed to avoid impact.</p>
    ///             </li>
    ///          </ul>
    public let impact: Int?
    /// <p>The SNS targets that AWS Chatbot uses to notify the chat channel of updates to an
    ///             incident. You can also make updates to the incident through the chat channel using the
    ///             SNS topics. </p>
    ///         <p>Using multiple SNS topics creates redundancy in the case that a Region is down during
    ///             the incident.</p>
    public let notificationTargets: Set<NotificationTargetItem>?
    /// <p>The status of the incident. An incident can be <code>Open</code> or <code>Resolved</code>.</p>
    public let status: IncidentRecordStatus?
    /// <p>The summary describes what has happened during the incident.</p>
    public let summary: String?
    /// <p>The title of the incident is a brief and easily recognizable.</p>
    public let title: String?

    public init (
        arn: String? = nil,
        chatChannel: ChatChannel? = nil,
        clientToken: String? = nil,
        impact: Int? = nil,
        notificationTargets: Set<NotificationTargetItem>? = nil,
        status: IncidentRecordStatus? = nil,
        summary: String? = nil,
        title: String? = nil
    )
    {
        self.arn = arn
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.impact = impact
        self.notificationTargets = notificationTargets
        self.status = status
        self.summary = summary
        self.title = title
    }
}

struct UpdateIncidentRecordInputBody: Equatable {
    public let clientToken: String?
    public let arn: String?
    public let title: String?
    public let summary: String?
    public let impact: Int?
    public let status: IncidentRecordStatus?
    public let chatChannel: ChatChannel?
    public let notificationTargets: Set<NotificationTargetItem>?
}

extension UpdateIncidentRecordInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case arn
        case chatChannel
        case clientToken
        case impact
        case notificationTargets
        case status
        case summary
        case title
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let summaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .summary)
        summary = summaryDecoded
        let impactDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .impact)
        impact = impactDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IncidentRecordStatus.self, forKey: .status)
        status = statusDecoded
        let chatChannelDecoded = try containerValues.decodeIfPresent(ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let notificationTargetsContainer = try containerValues.decodeIfPresent(Set<NotificationTargetItem>.self, forKey: .notificationTargets)
        var notificationTargetsDecoded0:Set<NotificationTargetItem>? = nil
        if let notificationTargetsContainer = notificationTargetsContainer {
            notificationTargetsDecoded0 = Set<NotificationTargetItem>()
            for union0 in notificationTargetsContainer {
                notificationTargetsDecoded0?.insert(union0)
            }
        }
        notificationTargets = notificationTargetsDecoded0
    }
}

extension UpdateIncidentRecordOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIncidentRecordOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateIncidentRecordOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIncidentRecordOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateIncidentRecordOutputResponse()"}
}

extension UpdateIncidentRecordOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIncidentRecordOutputResponse: Equatable {

    public init() {}
}

struct UpdateIncidentRecordOutputResponseBody: Equatable {
}

extension UpdateIncidentRecordOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateRelatedItemsInputBodyMiddleware: Middleware {
    public let id: String = "UpdateRelatedItemsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRelatedItemsInput>
    public typealias MOutput = OperationOutput<UpdateRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRelatedItemsOutputError>
}

extension UpdateRelatedItemsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRelatedItemsInput(clientToken: \(String(describing: clientToken)), incidentRecordArn: \(String(describing: incidentRecordArn)), relatedItemsUpdate: \(String(describing: relatedItemsUpdate)))"}
}

extension UpdateRelatedItemsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case incidentRecordArn
        case relatedItemsUpdate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
        if let relatedItemsUpdate = relatedItemsUpdate {
            try encodeContainer.encode(relatedItemsUpdate, forKey: .relatedItemsUpdate)
        }
    }
}

public struct UpdateRelatedItemsInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateRelatedItemsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRelatedItemsInput>
    public typealias MOutput = OperationOutput<UpdateRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRelatedItemsOutputError>
}

public struct UpdateRelatedItemsInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateRelatedItemsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateRelatedItemsInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateRelatedItemsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateRelatedItemsInput>
    public typealias MOutput = OperationOutput<UpdateRelatedItemsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateRelatedItemsOutputError>
}

public struct UpdateRelatedItemsInput: Equatable {
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>The Amazon Resource Name (ARN) of the incident record you are updating related items
    ///             in.</p>
    public let incidentRecordArn: String?
    /// <p>Details about the item you are adding or deleting.</p>
    public let relatedItemsUpdate: RelatedItemsUpdate?

    public init (
        clientToken: String? = nil,
        incidentRecordArn: String? = nil,
        relatedItemsUpdate: RelatedItemsUpdate? = nil
    )
    {
        self.clientToken = clientToken
        self.incidentRecordArn = incidentRecordArn
        self.relatedItemsUpdate = relatedItemsUpdate
    }
}

struct UpdateRelatedItemsInputBody: Equatable {
    public let clientToken: String?
    public let incidentRecordArn: String?
    public let relatedItemsUpdate: RelatedItemsUpdate?
}

extension UpdateRelatedItemsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case incidentRecordArn
        case relatedItemsUpdate
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let relatedItemsUpdateDecoded = try containerValues.decodeIfPresent(RelatedItemsUpdate.self, forKey: .relatedItemsUpdate)
        relatedItemsUpdate = relatedItemsUpdateDecoded
    }
}

extension UpdateRelatedItemsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateRelatedItemsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateRelatedItemsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateRelatedItemsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateRelatedItemsOutputResponse()"}
}

extension UpdateRelatedItemsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateRelatedItemsOutputResponse: Equatable {

    public init() {}
}

struct UpdateRelatedItemsOutputResponseBody: Equatable {
}

extension UpdateRelatedItemsOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UpdateReplicationSetAction: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case addRegionAction
        case deleteRegionAction
        case sdkUnknown
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .addRegionAction(addRegionAction):
                if let addRegionAction = addRegionAction {
                    try container.encode(addRegionAction, forKey: .addRegionAction)
                }
            case let .deleteRegionAction(deleteRegionAction):
                if let deleteRegionAction = deleteRegionAction {
                    try container.encode(deleteRegionAction, forKey: .deleteRegionAction)
                }
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init (from decoder: Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let addRegionActionDecoded = try values.decodeIfPresent(AddRegionAction.self, forKey: .addRegionAction)
        if let addRegionAction = addRegionActionDecoded {
            self = .addRegionAction(addRegionAction)
            return
        }
        let deleteRegionActionDecoded = try values.decodeIfPresent(DeleteRegionAction.self, forKey: .deleteRegionAction)
        if let deleteRegionAction = deleteRegionActionDecoded {
            self = .deleteRegionAction(deleteRegionAction)
            return
        }
        self = .sdkUnknown("")
    }
}

/// <p>Details used when updating the replication set.</p>
public enum UpdateReplicationSetAction: Equatable {
    /// <p>Details about the Region that you're adding to the replication set.</p>
    case addRegionAction(AddRegionAction?)
    /// <p>Details about the Region that you're deleting to the replication set.</p>
    case deleteRegionAction(DeleteRegionAction?)
    case sdkUnknown(String?)
}

public struct UpdateReplicationSetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateReplicationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationSetInput>
    public typealias MOutput = OperationOutput<UpdateReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationSetOutputError>
}

extension UpdateReplicationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationSetInput(actions: \(String(describing: actions)), arn: \(String(describing: arn)), clientToken: \(String(describing: clientToken)))"}
}

extension UpdateReplicationSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case arn
        case clientToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for updateactionlist0 in actions {
                try actionsContainer.encode(updateactionlist0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

public struct UpdateReplicationSetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateReplicationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationSetInput>
    public typealias MOutput = OperationOutput<UpdateReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationSetOutputError>
}

public struct UpdateReplicationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateReplicationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateReplicationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateReplicationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateReplicationSetInput>
    public typealias MOutput = OperationOutput<UpdateReplicationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateReplicationSetOutputError>
}

public struct UpdateReplicationSetInput: Equatable {
    /// <p>An action to add or delete a Region.</p>
    public let actions: [UpdateReplicationSetAction]?
    /// <p>The Amazon Resource Name (ARN) of the replication set you're updating.</p>
    public let arn: String?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?

    public init (
        actions: [UpdateReplicationSetAction]? = nil,
        arn: String? = nil,
        clientToken: String? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.clientToken = clientToken
    }
}

struct UpdateReplicationSetInputBody: Equatable {
    public let arn: String?
    public let actions: [UpdateReplicationSetAction]?
    public let clientToken: String?
}

extension UpdateReplicationSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case arn
        case clientToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let actionsContainer = try containerValues.decodeIfPresent([UpdateReplicationSetAction?].self, forKey: .actions)
        var actionsDecoded0:[UpdateReplicationSetAction]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [UpdateReplicationSetAction]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateReplicationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationSetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateReplicationSetOutputResponse()"}
}

extension UpdateReplicationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateReplicationSetOutputResponse: Equatable {

    public init() {}
}

struct UpdateReplicationSetOutputResponseBody: Equatable {
}

extension UpdateReplicationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateResponsePlanInputBodyMiddleware: Middleware {
    public let id: String = "UpdateResponsePlanInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResponsePlanInput>
    public typealias MOutput = OperationOutput<UpdateResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResponsePlanOutputError>
}

extension UpdateResponsePlanInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResponsePlanInput(actions: \(String(describing: actions)), arn: \(String(describing: arn)), chatChannel: \(String(describing: chatChannel)), clientToken: \(String(describing: clientToken)), displayName: \(String(describing: displayName)), engagements: \(String(describing: engagements)), incidentTemplateDedupeString: \(String(describing: incidentTemplateDedupeString)), incidentTemplateImpact: \(String(describing: incidentTemplateImpact)), incidentTemplateNotificationTargets: \(String(describing: incidentTemplateNotificationTargets)), incidentTemplateSummary: \(String(describing: incidentTemplateSummary)), incidentTemplateTitle: \(String(describing: incidentTemplateTitle)))"}
}

extension UpdateResponsePlanInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case actions
        case arn
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplateDedupeString
        case incidentTemplateImpact
        case incidentTemplateNotificationTargets
        case incidentTemplateSummary
        case incidentTemplateTitle
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for actionslist0 in actions {
                try actionsContainer.encode(actionslist0)
            }
        }
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let chatChannel = chatChannel {
            try encodeContainer.encode(chatChannel, forKey: .chatChannel)
        }
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let displayName = displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let engagements = engagements {
            var engagementsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .engagements)
            for engagementset0 in engagements {
                try engagementsContainer.encode(engagementset0)
            }
        }
        if let incidentTemplateDedupeString = incidentTemplateDedupeString {
            try encodeContainer.encode(incidentTemplateDedupeString, forKey: .incidentTemplateDedupeString)
        }
        if let incidentTemplateImpact = incidentTemplateImpact {
            try encodeContainer.encode(incidentTemplateImpact, forKey: .incidentTemplateImpact)
        }
        if let incidentTemplateNotificationTargets = incidentTemplateNotificationTargets {
            var incidentTemplateNotificationTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .incidentTemplateNotificationTargets)
            for notificationtargetset0 in incidentTemplateNotificationTargets {
                try incidentTemplateNotificationTargetsContainer.encode(notificationtargetset0)
            }
        }
        if let incidentTemplateSummary = incidentTemplateSummary {
            try encodeContainer.encode(incidentTemplateSummary, forKey: .incidentTemplateSummary)
        }
        if let incidentTemplateTitle = incidentTemplateTitle {
            try encodeContainer.encode(incidentTemplateTitle, forKey: .incidentTemplateTitle)
        }
    }
}

public struct UpdateResponsePlanInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateResponsePlanInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResponsePlanInput>
    public typealias MOutput = OperationOutput<UpdateResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResponsePlanOutputError>
}

public struct UpdateResponsePlanInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateResponsePlanInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateResponsePlanInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateResponsePlanOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateResponsePlanInput>
    public typealias MOutput = OperationOutput<UpdateResponsePlanOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateResponsePlanOutputError>
}

public struct UpdateResponsePlanInput: Equatable {
    /// <p>The actions that this response plan takes at the beginning of an incident.</p>
    public let actions: [Action]?
    /// <p>The Amazon Resource Name (ARN) of the response plan.</p>
    public let arn: String?
    /// <p>The
    ///             AWS
    ///             Chatbot chat channel used for collaboration during an
    ///             incident.</p>
    public let chatChannel: ChatChannel?
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>The long format name of the response plan. Can't contain spaces.</p>
    public let displayName: String?
    /// <p>The contacts and escalation plans that Incident Manager engages at the start of the incident.</p>
    public let engagements: Set<String>?
    /// <p>Used to create only one incident record for an incident.</p>
    public let incidentTemplateDedupeString: String?
    /// <p>Defines the impact to the customers. Providing an impact overwrites the impact
    ///             provided by a response plan.</p>
    ///         <p class="title">
    ///             <b>Possible impacts:</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>5</code> - Severe impact</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>4</code> - High impact</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>3</code> - Medium impact</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>2</code> - Low impact</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>1</code> - No impact</p>
    ///             </li>
    ///          </ul>
    public let incidentTemplateImpact: Int?
    /// <p>The SNS targets that
    ///             AWS
    ///             Chatbot uses to notify the chat channels and perform actions on the
    ///             incident record.</p>
    public let incidentTemplateNotificationTargets: Set<NotificationTargetItem>?
    /// <p>A brief summary of the incident. This typically contains what has happened, what's
    ///             currently happening, and next steps.</p>
    public let incidentTemplateSummary: String?
    /// <p>The short format name of the incident. Can't contain spaces.</p>
    public let incidentTemplateTitle: String?

    public init (
        actions: [Action]? = nil,
        arn: String? = nil,
        chatChannel: ChatChannel? = nil,
        clientToken: String? = nil,
        displayName: String? = nil,
        engagements: Set<String>? = nil,
        incidentTemplateDedupeString: String? = nil,
        incidentTemplateImpact: Int? = nil,
        incidentTemplateNotificationTargets: Set<NotificationTargetItem>? = nil,
        incidentTemplateSummary: String? = nil,
        incidentTemplateTitle: String? = nil
    )
    {
        self.actions = actions
        self.arn = arn
        self.chatChannel = chatChannel
        self.clientToken = clientToken
        self.displayName = displayName
        self.engagements = engagements
        self.incidentTemplateDedupeString = incidentTemplateDedupeString
        self.incidentTemplateImpact = incidentTemplateImpact
        self.incidentTemplateNotificationTargets = incidentTemplateNotificationTargets
        self.incidentTemplateSummary = incidentTemplateSummary
        self.incidentTemplateTitle = incidentTemplateTitle
    }
}

struct UpdateResponsePlanInputBody: Equatable {
    public let clientToken: String?
    public let arn: String?
    public let displayName: String?
    public let incidentTemplateTitle: String?
    public let incidentTemplateImpact: Int?
    public let incidentTemplateSummary: String?
    public let incidentTemplateDedupeString: String?
    public let incidentTemplateNotificationTargets: Set<NotificationTargetItem>?
    public let chatChannel: ChatChannel?
    public let engagements: Set<String>?
    public let actions: [Action]?
}

extension UpdateResponsePlanInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case actions
        case arn
        case chatChannel
        case clientToken
        case displayName
        case engagements
        case incidentTemplateDedupeString
        case incidentTemplateImpact
        case incidentTemplateNotificationTargets
        case incidentTemplateSummary
        case incidentTemplateTitle
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let incidentTemplateTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentTemplateTitle)
        incidentTemplateTitle = incidentTemplateTitleDecoded
        let incidentTemplateImpactDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .incidentTemplateImpact)
        incidentTemplateImpact = incidentTemplateImpactDecoded
        let incidentTemplateSummaryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentTemplateSummary)
        incidentTemplateSummary = incidentTemplateSummaryDecoded
        let incidentTemplateDedupeStringDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentTemplateDedupeString)
        incidentTemplateDedupeString = incidentTemplateDedupeStringDecoded
        let incidentTemplateNotificationTargetsContainer = try containerValues.decodeIfPresent(Set<NotificationTargetItem>.self, forKey: .incidentTemplateNotificationTargets)
        var incidentTemplateNotificationTargetsDecoded0:Set<NotificationTargetItem>? = nil
        if let incidentTemplateNotificationTargetsContainer = incidentTemplateNotificationTargetsContainer {
            incidentTemplateNotificationTargetsDecoded0 = Set<NotificationTargetItem>()
            for union0 in incidentTemplateNotificationTargetsContainer {
                incidentTemplateNotificationTargetsDecoded0?.insert(union0)
            }
        }
        incidentTemplateNotificationTargets = incidentTemplateNotificationTargetsDecoded0
        let chatChannelDecoded = try containerValues.decodeIfPresent(ChatChannel.self, forKey: .chatChannel)
        chatChannel = chatChannelDecoded
        let engagementsContainer = try containerValues.decodeIfPresent(Set<String>.self, forKey: .engagements)
        var engagementsDecoded0:Set<String>? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = Set<String>()
            for string0 in engagementsContainer {
                engagementsDecoded0?.insert(string0)
            }
        }
        engagements = engagementsDecoded0
        let actionsContainer = try containerValues.decodeIfPresent([Action?].self, forKey: .actions)
        var actionsDecoded0:[Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Action]()
            for union0 in actionsContainer {
                if let union0 = union0 {
                    actionsDecoded0?.append(union0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension UpdateResponsePlanOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateResponsePlanOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateResponsePlanOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateResponsePlanOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateResponsePlanOutputResponse()"}
}

extension UpdateResponsePlanOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateResponsePlanOutputResponse: Equatable {

    public init() {}
}

struct UpdateResponsePlanOutputResponseBody: Equatable {
}

extension UpdateResponsePlanOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateTimelineEventInputBodyMiddleware: Middleware {
    public let id: String = "UpdateTimelineEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTimelineEventInput>
    public typealias MOutput = OperationOutput<UpdateTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTimelineEventOutputError>
}

extension UpdateTimelineEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTimelineEventInput(clientToken: \(String(describing: clientToken)), eventData: \(String(describing: eventData)), eventId: \(String(describing: eventId)), eventTime: \(String(describing: eventTime)), eventType: \(String(describing: eventType)), incidentRecordArn: \(String(describing: incidentRecordArn)))"}
}

extension UpdateTimelineEventInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case eventData
        case eventId
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let eventData = eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let eventId = eventId {
            try encodeContainer.encode(eventId, forKey: .eventId)
        }
        if let eventTime = eventTime {
            try encodeContainer.encode(eventTime.timeIntervalSince1970, forKey: .eventTime)
        }
        if let eventType = eventType {
            try encodeContainer.encode(eventType, forKey: .eventType)
        }
        if let incidentRecordArn = incidentRecordArn {
            try encodeContainer.encode(incidentRecordArn, forKey: .incidentRecordArn)
        }
    }
}

public struct UpdateTimelineEventInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateTimelineEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTimelineEventInput>
    public typealias MOutput = OperationOutput<UpdateTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTimelineEventOutputError>
}

public struct UpdateTimelineEventInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateTimelineEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateTimelineEventInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateTimelineEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateTimelineEventInput>
    public typealias MOutput = OperationOutput<UpdateTimelineEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateTimelineEventOutputError>
}

public struct UpdateTimelineEventInput: Equatable {
    /// <p>A token ensuring that the action is called only once with the specified details.</p>
    public var clientToken: String?
    /// <p>A short description of the event.</p>
    public let eventData: String?
    /// <p>The ID of the event you are updating. You can find this by using <code>ListTimelineEvents</code>.</p>
    public let eventId: String?
    /// <p>The time that the event occurred.</p>
    public let eventTime: Date?
    /// <p>The type of the event. You can update events of type <code>Custom Event</code>.</p>
    public let eventType: String?
    /// <p>The Amazon Resource Name (ARN) of the incident that the timeline event is part
    ///             of.</p>
    public let incidentRecordArn: String?

    public init (
        clientToken: String? = nil,
        eventData: String? = nil,
        eventId: String? = nil,
        eventTime: Date? = nil,
        eventType: String? = nil,
        incidentRecordArn: String? = nil
    )
    {
        self.clientToken = clientToken
        self.eventData = eventData
        self.eventId = eventId
        self.eventTime = eventTime
        self.eventType = eventType
        self.incidentRecordArn = incidentRecordArn
    }
}

struct UpdateTimelineEventInputBody: Equatable {
    public let clientToken: String?
    public let incidentRecordArn: String?
    public let eventId: String?
    public let eventTime: Date?
    public let eventType: String?
    public let eventData: String?
}

extension UpdateTimelineEventInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case clientToken
        case eventData
        case eventId
        case eventTime
        case eventType
        case incidentRecordArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let incidentRecordArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .incidentRecordArn)
        incidentRecordArn = incidentRecordArnDecoded
        let eventIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventId)
        eventId = eventIdDecoded
        let eventTimeDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .eventTime)
        eventTime = eventTimeDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension UpdateTimelineEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateTimelineEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateTimelineEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateTimelineEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateTimelineEventOutputResponse()"}
}

extension UpdateTimelineEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateTimelineEventOutputResponse: Equatable {

    public init() {}
}

struct UpdateTimelineEventOutputResponseBody: Equatable {
}

extension UpdateTimelineEventOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ValidationException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ValidationException(message: \(String(describing: message)))"}
}

extension ValidationException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The input fails to satisfy the constraints specified by an AWS service.</p>
public struct ValidationException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Equatable {
    public let message: String?
}

extension ValidationExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}
