// Code generated by smithy-swift-codegen. DO NOT EDIT!

import AWSClientRuntime
import ClientRuntime
import Foundation

public class LexModelBuildingServiceClient {
    let client: SdkHttpClient
    let config: LexModelBuildingServiceClientConfiguration
    let serviceName = "Lex Model Building Service"
    let encoder: RequestEncoder
    let decoder: ResponseDecoder

    public init(config: LexModelBuildingServiceClientConfiguration) {
        client = SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public class LexModelBuildingServiceClientConfiguration: ClientRuntime.Configuration, AWSClientConfiguration {

        public var region: String
        public var credentialsProvider: AWSCredentialsProvider
        public var signingRegion: String
        public var endpointResolver: EndpointResolver

        public init (
            credentialsProvider: AWSCredentialsProvider,
            endpointResolver: EndpointResolver,
            region: String,
            signingRegion: String
        ) throws
        {
            self.credentialsProvider = credentialsProvider
            self.endpointResolver = endpointResolver
            self.region = region
            self.signingRegion = signingRegion
        }

        public convenience init(credentialsProvider: AWSCredentialsProvider) throws {
            let region = "us-east-1"
            let signingRegion = "us-east-1"
            let endpointResolver = DefaultEndpointResolver()
            try self.init(
                credentialsProvider: credentialsProvider,
                endpointResolver: endpointResolver,
                region: region,
                signingRegion: signingRegion
            )
        }

        public static func `default`() throws -> LexModelBuildingServiceClientConfiguration {
            let awsCredsProvider = try AWSCredentialsProvider.fromEnv()
            return try LexModelBuildingServiceClientConfiguration(credentialsProvider: awsCredsProvider)
        }
    }
}

extension LexModelBuildingServiceClient: LexModelBuildingServiceClientProtocol {
    /// <p>Creates a new version of the bot based on the <code>$LATEST</code>
    ///       version. If the <code>$LATEST</code> version of this resource hasn't
    ///       changed since you created the last version, Amazon Lex doesn't create a new
    ///       version. It returns the last created version.</p>
    ///          <note>
    ///             <p>You can update only the <code>$LATEST</code> version of the bot.
    ///         You can't update the numbered versions that you create with the
    ///           <code>CreateBotVersion</code> operation.</p>
    ///          </note>
    ///          <p> When you create the first version of a bot, Amazon Lex sets the version
    ///       to 1. Subsequent versions increment by 1. For more information, see <a>versioning-intro</a>. </p>
    ///          <p> This operation requires permission for the
    ///         <code>lex:CreateBotVersion</code> action. </p>
    public func createBotVersion(input: CreateBotVersionInput, completion: @escaping (SdkResult<CreateBotVersionOutputResponse, CreateBotVersionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(name)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createBotVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateBotVersionInput, CreateBotVersionOutputResponse, CreateBotVersionOutputError>(id: "createBotVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateBotVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateBotVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateBotVersionInput, CreateBotVersionOutputResponse, CreateBotVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateBotVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new version of an intent based on the
    ///         <code>$LATEST</code> version of the intent. If the <code>$LATEST</code>
    ///       version of this intent hasn't changed since you last updated it, Amazon Lex
    ///       doesn't create a new version. It returns the last version you
    ///       created.</p>
    ///          <note>
    ///             <p>You can update only the <code>$LATEST</code> version of the
    ///         intent. You can't update the numbered versions that you create with the
    ///           <code>CreateIntentVersion</code> operation.</p>
    ///          </note>
    ///          <p> When you create a version of an intent, Amazon Lex sets the version to
    ///       1. Subsequent versions increment by 1. For more information, see <a>versioning-intro</a>. </p>
    ///          <p>This operation requires permissions to perform the
    ///         <code>lex:CreateIntentVersion</code> action. </p>
    public func createIntentVersion(input: CreateIntentVersionInput, completion: @escaping (SdkResult<CreateIntentVersionOutputResponse, CreateIntentVersionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/intents/\(name)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createIntentVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateIntentVersionInput, CreateIntentVersionOutputResponse, CreateIntentVersionOutputError>(id: "createIntentVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateIntentVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateIntentVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateIntentVersionInput, CreateIntentVersionOutputResponse, CreateIntentVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateIntentVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a new version of a slot type based on the
    ///         <code>$LATEST</code> version of the specified slot type. If the
    ///         <code>$LATEST</code> version of this resource has not changed since the
    ///       last version that you created, Amazon Lex doesn't create a new version. It
    ///       returns the last version that you created. </p>
    ///          <note>
    ///             <p>You can update only the <code>$LATEST</code> version of a slot
    ///         type. You can't update the numbered versions that you create with the
    ///           <code>CreateSlotTypeVersion</code> operation.</p>
    ///          </note>
    ///
    ///          <p>When you create a version of a slot type, Amazon Lex sets the version to
    ///       1. Subsequent versions increment by 1. For more information, see <a>versioning-intro</a>. </p>
    ///
    ///          <p>This operation requires permissions for the
    ///         <code>lex:CreateSlotTypeVersion</code> action.</p>
    public func createSlotTypeVersion(input: CreateSlotTypeVersionInput, completion: @escaping (SdkResult<CreateSlotTypeVersionOutputResponse, CreateSlotTypeVersionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/slottypes/\(name)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "createSlotTypeVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<CreateSlotTypeVersionInput, CreateSlotTypeVersionOutputResponse, CreateSlotTypeVersionOutputError>(id: "createSlotTypeVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotTypeVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotTypeVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<CreateSlotTypeVersionInput, CreateSlotTypeVersionOutputResponse, CreateSlotTypeVersionOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: CreateSlotTypeVersionInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes all versions of the bot, including the <code>$LATEST</code>
    ///       version. To delete a specific version of the bot, use the <a>DeleteBotVersion</a> operation. The <code>DeleteBot</code>
    ///       operation doesn't immediately remove the bot schema. Instead, it is marked
    ///       for deletion and removed later.</p>
    ///          <p>Amazon Lex stores utterances indefinitely for improving the ability of
    ///       your bot to respond to user inputs. These utterances are not removed when
    ///       the bot is deleted. To remove the utterances, use the <a>DeleteUtterances</a> operation.</p>
    ///          <p>If a bot has an alias, you can't delete it. Instead, the
    ///         <code>DeleteBot</code> operation returns a
    ///         <code>ResourceInUseException</code> exception that includes a reference
    ///       to the alias that refers to the bot. To remove the reference to the bot,
    ///       delete the alias. If you get the same exception again, delete the
    ///       referring alias until the <code>DeleteBot</code> operation is
    ///       successful.</p>
    ///
    ///          <p>This operation requires permissions for the
    ///         <code>lex:DeleteBot</code> action.</p>
    public func deleteBot(input: DeleteBotInput, completion: @escaping (SdkResult<DeleteBotOutputResponse, DeleteBotOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotInput, DeleteBotOutputResponse, DeleteBotOutputError>(id: "deleteBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotInput, DeleteBotOutputResponse, DeleteBotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes an alias for the specified bot. </p>
    ///          <p>You can't delete an alias that is used in the association between a
    ///       bot and a messaging channel. If an alias is used in a channel association,
    ///       the <code>DeleteBot</code> operation returns a
    ///         <code>ResourceInUseException</code> exception that includes a reference
    ///       to the channel association that refers to the bot. You can remove the
    ///       reference to the alias by deleting the channel association. If you get the
    ///       same exception again, delete the referring association until the
    ///         <code>DeleteBotAlias</code> operation is successful.</p>
    public func deleteBotAlias(input: DeleteBotAliasInput, completion: @escaping (SdkResult<DeleteBotAliasOutputResponse, DeleteBotAliasOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/aliases/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBotAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotAliasInput, DeleteBotAliasOutputResponse, DeleteBotAliasOutputError>(id: "deleteBotAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotAliasInput, DeleteBotAliasOutputResponse, DeleteBotAliasOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes the association between an Amazon Lex bot and a messaging
    ///       platform.</p>
    ///          <p>This operation requires permission for the
    ///         <code>lex:DeleteBotChannelAssociation</code> action.</p>
    public func deleteBotChannelAssociation(input: DeleteBotChannelAssociationInput, completion: @escaping (SdkResult<DeleteBotChannelAssociationOutputResponse, DeleteBotChannelAssociationOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        guard let botAlias = input.botAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botAlias unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/aliases/\(botAlias)/channels/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBotChannelAssociation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotChannelAssociationInput, DeleteBotChannelAssociationOutputResponse, DeleteBotChannelAssociationOutputError>(id: "deleteBotChannelAssociation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotChannelAssociationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotChannelAssociationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotChannelAssociationInput, DeleteBotChannelAssociationOutputResponse, DeleteBotChannelAssociationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specific version of a bot. To delete all versions of a
    ///       bot, use the <a>DeleteBot</a> operation. </p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:DeleteBotVersion</code> action.</p>
    public func deleteBotVersion(input: DeleteBotVersionInput, completion: @escaping (SdkResult<DeleteBotVersionOutputResponse, DeleteBotVersionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(name)/versions/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteBotVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteBotVersionInput, DeleteBotVersionOutputResponse, DeleteBotVersionOutputError>(id: "deleteBotVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteBotVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteBotVersionInput, DeleteBotVersionOutputResponse, DeleteBotVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes all versions of the intent, including the
    ///         <code>$LATEST</code> version. To delete a specific version of the
    ///       intent, use the <a>DeleteIntentVersion</a> operation.</p>
    ///          <p> You can delete a version of an intent only if it is not
    ///       referenced. To delete an intent that is referred to in one or more bots
    ///       (see <a>how-it-works</a>), you must remove those references
    ///       first. </p>
    ///          <note>
    ///             <p> If you get the <code>ResourceInUseException</code> exception, it
    ///         provides an example reference that shows where the intent is referenced.
    ///         To remove the reference to the intent, either update the bot or delete
    ///         it. If you get the same exception when you attempt to delete the intent
    ///         again, repeat until the intent has no references and the call to
    ///           <code>DeleteIntent</code> is successful. </p>
    ///          </note>
    ///
    ///          <p> This operation requires permission for the
    ///         <code>lex:DeleteIntent</code> action. </p>
    public func deleteIntent(input: DeleteIntentInput, completion: @escaping (SdkResult<DeleteIntentOutputResponse, DeleteIntentOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/intents/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntentInput, DeleteIntentOutputResponse, DeleteIntentOutputError>(id: "deleteIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteIntentInput, DeleteIntentOutputResponse, DeleteIntentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specific version of an intent. To delete all versions of
    ///       a intent, use the <a>DeleteIntent</a> operation. </p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:DeleteIntentVersion</code> action.</p>
    public func deleteIntentVersion(input: DeleteIntentVersionInput, completion: @escaping (SdkResult<DeleteIntentVersionOutputResponse, DeleteIntentVersionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/intents/\(name)/versions/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteIntentVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteIntentVersionInput, DeleteIntentVersionOutputResponse, DeleteIntentVersionOutputError>(id: "deleteIntentVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntentVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteIntentVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteIntentVersionInput, DeleteIntentVersionOutputResponse, DeleteIntentVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes all versions of the slot type, including the
    ///         <code>$LATEST</code> version. To delete a specific version of the slot
    ///       type, use the <a>DeleteSlotTypeVersion</a> operation.</p>
    ///          <p> You can delete a version of a slot type only if it is not
    ///       referenced. To delete a slot type that is referred to in one or more
    ///       intents, you must remove those references first. </p>
    ///          <note>
    ///             <p> If you get the <code>ResourceInUseException</code> exception,
    ///         the exception provides an example reference that shows the intent where
    ///         the slot type is referenced. To remove the reference to the slot type,
    ///         either update the intent or delete it. If you get the same exception
    ///         when you attempt to delete the slot type again, repeat until the slot
    ///         type has no references and the <code>DeleteSlotType</code> call is
    ///         successful. </p>
    ///          </note>
    ///          <p>This operation requires permission for the
    ///         <code>lex:DeleteSlotType</code> action.</p>
    public func deleteSlotType(input: DeleteSlotTypeInput, completion: @escaping (SdkResult<DeleteSlotTypeOutputResponse, DeleteSlotTypeOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/slottypes/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSlotType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSlotTypeInput, DeleteSlotTypeOutputResponse, DeleteSlotTypeOutputError>(id: "deleteSlotType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSlotTypeInput, DeleteSlotTypeOutputResponse, DeleteSlotTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes a specific version of a slot type. To delete all versions
    ///       of a slot type, use the <a>DeleteSlotType</a> operation. </p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:DeleteSlotTypeVersion</code> action.</p>
    public func deleteSlotTypeVersion(input: DeleteSlotTypeVersionInput, completion: @escaping (SdkResult<DeleteSlotTypeVersionOutputResponse, DeleteSlotTypeVersionOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/slottypes/\(name)/version/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteSlotTypeVersion")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteSlotTypeVersionInput, DeleteSlotTypeVersionOutputResponse, DeleteSlotTypeVersionOutputError>(id: "deleteSlotTypeVersion")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotTypeVersionInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteSlotTypeVersionInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteSlotTypeVersionInput, DeleteSlotTypeVersionOutputResponse, DeleteSlotTypeVersionOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Deletes stored utterances.</p>
    ///          <p>Amazon Lex stores the utterances that users send to your bot. Utterances
    ///       are stored for 15 days for use with the <a>GetUtterancesView</a> operation, and then stored indefinitely for use in improving the
    ///       ability of your bot to respond to user input.</p>
    ///          <p>Use the <code>DeleteUtterances</code> operation to manually delete
    ///       stored utterances for a specific user. When you use the
    ///         <code>DeleteUtterances</code> operation, utterances stored for improving
    ///       your bot's ability to respond to user input are deleted immediately.
    ///       Utterances stored for use with the <code>GetUtterancesView</code>
    ///       operation are deleted after 15 days.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:DeleteUtterances</code> action.</p>
    public func deleteUtterances(input: DeleteUtterancesInput, completion: @escaping (SdkResult<DeleteUtterancesOutputResponse, DeleteUtterancesOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        guard let userId = input.userId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component userId unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/utterances/\(userId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "deleteUtterances")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<DeleteUtterancesInput, DeleteUtterancesOutputResponse, DeleteUtterancesOutputError>(id: "deleteUtterances")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: DeleteUtterancesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: DeleteUtterancesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<DeleteUtterancesInput, DeleteUtterancesOutputResponse, DeleteUtterancesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns metadata information for a specific bot. You must provide
    ///       the bot name and the bot version or alias. </p>
    ///          <p> This operation requires permissions for the
    ///         <code>lex:GetBot</code> action. </p>
    public func getBot(input: GetBotInput, completion: @escaping (SdkResult<GetBotOutputResponse, GetBotOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        guard let versionOrAlias = input.versionOrAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component versionOrAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(name)/versions/\(versionOrAlias)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBotInput, GetBotOutputResponse, GetBotOutputError>(id: "getBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBotInput, GetBotOutputResponse, GetBotOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about an Amazon Lex bot alias. For more information
    ///       about aliases, see <a>versioning-aliases</a>.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetBotAlias</code> action.</p>
    public func getBotAlias(input: GetBotAliasInput, completion: @escaping (SdkResult<GetBotAliasOutputResponse, GetBotAliasOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/aliases/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBotAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBotAliasInput, GetBotAliasOutputResponse, GetBotAliasOutputError>(id: "getBotAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBotAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBotAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBotAliasInput, GetBotAliasOutputResponse, GetBotAliasOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns a list of aliases for a specified Amazon Lex bot.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetBotAliases</code> action.</p>
    public func getBotAliases(input: GetBotAliasesInput, completion: @escaping (SdkResult<GetBotAliasesOutputResponse, GetBotAliasesOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/aliases"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBotAliases")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBotAliasesInput, GetBotAliasesOutputResponse, GetBotAliasesOutputError>(id: "getBotAliases")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBotAliasesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBotAliasesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBotAliasesInput, GetBotAliasesOutputResponse, GetBotAliasesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about the association between an Amazon Lex bot and
    ///       a messaging platform.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetBotChannelAssociation</code> action.</p>
    public func getBotChannelAssociation(input: GetBotChannelAssociationInput, completion: @escaping (SdkResult<GetBotChannelAssociationOutputResponse, GetBotChannelAssociationOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        guard let botAlias = input.botAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botAlias unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/aliases/\(botAlias)/channels/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBotChannelAssociation")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBotChannelAssociationInput, GetBotChannelAssociationOutputResponse, GetBotChannelAssociationOutputError>(id: "getBotChannelAssociation")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBotChannelAssociationInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBotChannelAssociationInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBotChannelAssociationInput, GetBotChannelAssociationOutputResponse, GetBotChannelAssociationOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p> Returns a list of all of the channels associated with the
    ///       specified bot. </p>
    ///          <p>The <code>GetBotChannelAssociations</code> operation requires
    ///       permissions for the <code>lex:GetBotChannelAssociations</code>
    ///       action.</p>
    public func getBotChannelAssociations(input: GetBotChannelAssociationsInput, completion: @escaping (SdkResult<GetBotChannelAssociationsOutputResponse, GetBotChannelAssociationsOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        guard let botAlias = input.botAlias else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botAlias unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/aliases/\(botAlias)/channels"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBotChannelAssociations")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBotChannelAssociationsInput, GetBotChannelAssociationsOutputResponse, GetBotChannelAssociationsOutputError>(id: "getBotChannelAssociations")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBotChannelAssociationsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBotChannelAssociationsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBotChannelAssociationsInput, GetBotChannelAssociationsOutputResponse, GetBotChannelAssociationsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about all of the versions of a bot.</p>
    ///          <p>The <code>GetBotVersions</code> operation returns a
    ///         <code>BotMetadata</code> object for each version of a bot. For example,
    ///       if a bot has three numbered versions, the <code>GetBotVersions</code>
    ///       operation returns four <code>BotMetadata</code> objects in the response,
    ///       one for each numbered version and one for the <code>$LATEST</code>
    ///       version. </p>
    ///          <p>The <code>GetBotVersions</code> operation always returns at least
    ///       one version, the <code>$LATEST</code> version.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetBotVersions</code> action.</p>
    public func getBotVersions(input: GetBotVersionsInput, completion: @escaping (SdkResult<GetBotVersionsOutputResponse, GetBotVersionsOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(name)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBotVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBotVersionsInput, GetBotVersionsOutputResponse, GetBotVersionsOutputError>(id: "getBotVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBotVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBotVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBotVersionsInput, GetBotVersionsOutputResponse, GetBotVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns bot information as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>If you provide the <code>nameContains</code> field, the
    ///           response includes information for the <code>$LATEST</code> version of
    ///           all bots whose name contains the specified string.</p>
    ///             </li>
    ///             <li>
    ///                <p>If you don't specify the <code>nameContains</code> field, the
    ///           operation returns information about the <code>$LATEST</code> version
    ///           of all of your bots.</p>
    ///             </li>
    ///          </ul>
    ///          <p>This operation requires permission for the <code>lex:GetBots</code>
    ///       action.</p>
    public func getBots(input: GetBotsInput, completion: @escaping (SdkResult<GetBotsOutputResponse, GetBotsOutputError>) -> Void)
    {
        let urlPath = "/bots"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBots")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBotsInput, GetBotsOutputResponse, GetBotsOutputError>(id: "getBots")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBotsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBotsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBotsInput, GetBotsOutputResponse, GetBotsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a built-in intent.</p>
    ///          <p>This operation requires permission for the
    ///         <code>lex:GetBuiltinIntent</code> action.</p>
    public func getBuiltinIntent(input: GetBuiltinIntentInput, completion: @escaping (SdkResult<GetBuiltinIntentOutputResponse, GetBuiltinIntentOutputError>) -> Void)
    {
        guard let signature = input.signature else {
            completion(.failure(.client(ClientError.serializationFailed("uri component signature unexpectedly nil"))))
            return
        }
        let urlPath = "/builtins/intents/\(signature)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBuiltinIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBuiltinIntentInput, GetBuiltinIntentOutputResponse, GetBuiltinIntentOutputError>(id: "getBuiltinIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBuiltinIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBuiltinIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBuiltinIntentInput, GetBuiltinIntentOutputResponse, GetBuiltinIntentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of built-in intents that meet the specified
    ///       criteria.</p>
    ///          <p>This operation requires permission for the
    ///         <code>lex:GetBuiltinIntents</code> action.</p>
    public func getBuiltinIntents(input: GetBuiltinIntentsInput, completion: @escaping (SdkResult<GetBuiltinIntentsOutputResponse, GetBuiltinIntentsOutputError>) -> Void)
    {
        let urlPath = "/builtins/intents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBuiltinIntents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBuiltinIntentsInput, GetBuiltinIntentsOutputResponse, GetBuiltinIntentsOutputError>(id: "getBuiltinIntents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBuiltinIntentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBuiltinIntentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBuiltinIntentsInput, GetBuiltinIntentsOutputResponse, GetBuiltinIntentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of built-in slot types that meet the specified
    ///       criteria.</p>
    ///          <p>For a list of built-in slot types, see <a href="https://developer.amazon.com/public/solutions/alexa/alexa-skills-kit/docs/built-in-intent-ref/slot-type-reference">Slot Type Reference</a> in the <i>Alexa Skills
    ///         Kit</i>.</p>
    ///
    ///          <p>This operation requires permission for the
    ///         <code>lex:GetBuiltInSlotTypes</code> action.</p>
    public func getBuiltinSlotTypes(input: GetBuiltinSlotTypesInput, completion: @escaping (SdkResult<GetBuiltinSlotTypesOutputResponse, GetBuiltinSlotTypesOutputError>) -> Void)
    {
        let urlPath = "/builtins/slottypes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getBuiltinSlotTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetBuiltinSlotTypesInput, GetBuiltinSlotTypesOutputResponse, GetBuiltinSlotTypesOutputError>(id: "getBuiltinSlotTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetBuiltinSlotTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetBuiltinSlotTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetBuiltinSlotTypesInput, GetBuiltinSlotTypesOutputResponse, GetBuiltinSlotTypesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Exports the contents of a Amazon Lex resource in a specified format.
    ///     </p>
    public func getExport(input: GetExportInput, completion: @escaping (SdkResult<GetExportOutputResponse, GetExportOutputError>) -> Void)
    {
        let urlPath = "/exports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getExport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetExportInput, GetExportOutputResponse, GetExportOutputError>(id: "getExport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetExportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetExportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetExportInput, GetExportOutputResponse, GetExportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about an import job started with the
    ///         <code>StartImport</code> operation.</p>
    public func getImport(input: GetImportInput, completion: @escaping (SdkResult<GetImportOutputResponse, GetImportOutputError>) -> Void)
    {
        guard let importId = input.importId else {
            completion(.failure(.client(ClientError.serializationFailed("uri component importId unexpectedly nil"))))
            return
        }
        let urlPath = "/imports/\(importId)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getImport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetImportInput, GetImportOutputResponse, GetImportOutputError>(id: "getImport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetImportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetImportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetImportInput, GetImportOutputResponse, GetImportOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p> Returns information about an intent. In addition to the intent
    ///       name, you must specify the intent version. </p>
    ///          <p> This operation requires permissions to perform the
    ///         <code>lex:GetIntent</code> action. </p>
    public func getIntent(input: GetIntentInput, completion: @escaping (SdkResult<GetIntentOutputResponse, GetIntentOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/intents/\(name)/versions/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIntentInput, GetIntentOutputResponse, GetIntentOutputError>(id: "getIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetIntentInput, GetIntentOutputResponse, GetIntentOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about all of the versions of an intent.</p>
    ///          <p>The <code>GetIntentVersions</code> operation returns an
    ///         <code>IntentMetadata</code> object for each version of an intent. For
    ///       example, if an intent has three numbered versions, the
    ///         <code>GetIntentVersions</code> operation returns four
    ///         <code>IntentMetadata</code> objects in the response, one for each
    ///       numbered version and one for the <code>$LATEST</code> version. </p>
    ///          <p>The <code>GetIntentVersions</code> operation always returns at
    ///       least one version, the <code>$LATEST</code> version.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetIntentVersions</code> action.</p>
    public func getIntentVersions(input: GetIntentVersionsInput, completion: @escaping (SdkResult<GetIntentVersionsOutputResponse, GetIntentVersionsOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/intents/\(name)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIntentVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIntentVersionsInput, GetIntentVersionsOutputResponse, GetIntentVersionsOutputError>(id: "getIntentVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIntentVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIntentVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetIntentVersionsInput, GetIntentVersionsOutputResponse, GetIntentVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns intent information as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>If you specify the <code>nameContains</code> field, returns the
    ///             <code>$LATEST</code> version of all intents that contain the
    ///           specified string.</p>
    ///             </li>
    ///             <li>
    ///                <p> If you don't specify the <code>nameContains</code> field,
    ///           returns information about the <code>$LATEST</code> version of all
    ///           intents. </p>
    ///             </li>
    ///          </ul>
    ///          <p> The operation requires permission for the
    ///         <code>lex:GetIntents</code> action. </p>
    public func getIntents(input: GetIntentsInput, completion: @escaping (SdkResult<GetIntentsOutputResponse, GetIntentsOutputError>) -> Void)
    {
        let urlPath = "/intents"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getIntents")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetIntentsInput, GetIntentsOutputResponse, GetIntentsOutputError>(id: "getIntents")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetIntentsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetIntentsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetIntentsInput, GetIntentsOutputResponse, GetIntentsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns information about a specific version of a slot type. In
    ///       addition to specifying the slot type name, you must specify the slot type
    ///       version.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetSlotType</code> action.</p>
    public func getSlotType(input: GetSlotTypeInput, completion: @escaping (SdkResult<GetSlotTypeOutputResponse, GetSlotTypeOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        guard let version = input.version else {
            completion(.failure(.client(ClientError.serializationFailed("uri component version unexpectedly nil"))))
            return
        }
        let urlPath = "/slottypes/\(name)/versions/\(version)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSlotType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSlotTypeInput, GetSlotTypeOutputResponse, GetSlotTypeOutputError>(id: "getSlotType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSlotTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSlotTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSlotTypeInput, GetSlotTypeOutputResponse, GetSlotTypeOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets information about all versions of a slot type.</p>
    ///          <p>The <code>GetSlotTypeVersions</code> operation returns a
    ///         <code>SlotTypeMetadata</code> object for each version of a slot type.
    ///       For example, if a slot type has three numbered versions, the
    ///         <code>GetSlotTypeVersions</code> operation returns four
    ///         <code>SlotTypeMetadata</code> objects in the response, one for each
    ///       numbered version and one for the <code>$LATEST</code> version. </p>
    ///          <p>The <code>GetSlotTypeVersions</code> operation always returns at
    ///       least one version, the <code>$LATEST</code> version.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetSlotTypeVersions</code> action.</p>
    public func getSlotTypeVersions(input: GetSlotTypeVersionsInput, completion: @escaping (SdkResult<GetSlotTypeVersionsOutputResponse, GetSlotTypeVersionsOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/slottypes/\(name)/versions"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSlotTypeVersions")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSlotTypeVersionsInput, GetSlotTypeVersionsOutputResponse, GetSlotTypeVersionsOutputError>(id: "getSlotTypeVersions")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSlotTypeVersionsInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSlotTypeVersionsInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSlotTypeVersionsInput, GetSlotTypeVersionsOutputResponse, GetSlotTypeVersionsOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Returns slot type information as follows: </p>
    ///          <ul>
    ///             <li>
    ///                <p>If you specify the <code>nameContains</code> field, returns the
    ///             <code>$LATEST</code> version of all slot types that contain the
    ///           specified string.</p>
    ///             </li>
    ///             <li>
    ///                <p> If you don't specify the <code>nameContains</code> field,
    ///           returns information about the <code>$LATEST</code> version of all slot
    ///           types. </p>
    ///             </li>
    ///          </ul>
    ///          <p> The operation requires permission for the
    ///         <code>lex:GetSlotTypes</code> action. </p>
    public func getSlotTypes(input: GetSlotTypesInput, completion: @escaping (SdkResult<GetSlotTypesOutputResponse, GetSlotTypesOutputError>) -> Void)
    {
        let urlPath = "/slottypes"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getSlotTypes")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetSlotTypesInput, GetSlotTypesOutputResponse, GetSlotTypesOutputError>(id: "getSlotTypes")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetSlotTypesInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetSlotTypesInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetSlotTypesInput, GetSlotTypesOutputResponse, GetSlotTypesOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Use the <code>GetUtterancesView</code> operation to get information
    ///       about the utterances that your users have made to your bot. You can use
    ///       this list to tune the utterances that your bot responds to.</p>
    ///          <p>For example, say that you have created a bot to order flowers.
    ///       After your users have used your bot for a while, use the
    ///         <code>GetUtterancesView</code> operation to see the requests that they
    ///       have made and whether they have been successful. You might find that the
    ///       utterance "I want flowers" is not being recognized. You could add this
    ///       utterance to the <code>OrderFlowers</code> intent so that your bot
    ///       recognizes that utterance.</p>
    ///          <p>After you publish a new version of a bot, you can get information
    ///       about the old version and the new so that you can compare the performance
    ///       across the two versions. </p>
    ///          <p>Utterance statistics are generated once a day. Data is available
    ///       for the last 15 days. You can request information for up to 5 versions of
    ///       your bot in each request. Amazon Lex returns the most frequent utterances
    ///       received by the bot in the last 15 days. The response contains information
    ///       about a maximum of 100 utterances for each version.</p>
    ///          <p>If you set <code>childDirected</code> field to true when you
    ///       created your bot, or if you opted out of participating in improving Amazon Lex,
    ///       utterances are not available.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:GetUtterancesView</code> action.</p>
    public func getUtterancesView(input: GetUtterancesViewInput, completion: @escaping (SdkResult<GetUtterancesViewOutputResponse, GetUtterancesViewOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/utterances"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "getUtterancesView")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<GetUtterancesViewInput, GetUtterancesViewOutputResponse, GetUtterancesViewOutputError>(id: "getUtterancesView")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: GetUtterancesViewInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: GetUtterancesViewInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<GetUtterancesViewInput, GetUtterancesViewOutputResponse, GetUtterancesViewOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Gets a list of tags associated with the specified resource. Only bots,
    ///       bot aliases, and bot channels can have tags associated with them.</p>
    public func listTagsForResource(input: ListTagsForResourceInput, completion: @escaping (SdkResult<ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .get)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "listTagsForResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(id: "listTagsForResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ListTagsForResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<ListTagsForResourceInput, ListTagsForResourceOutputResponse, ListTagsForResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an Amazon Lex conversational bot or replaces an existing bot.
    ///       When you create or update a bot you are only required to specify a name, a
    ///       locale, and whether the bot is directed toward children under age 13. You
    ///       can use this to add intents later, or to remove intents from an existing
    ///       bot. When you create a bot with the minimum information, the bot is
    ///       created or updated but Amazon Lex returns the <code></code> response
    ///         <code>FAILED</code>. You can build the bot after you add one or more
    ///       intents. For more information about Amazon Lex bots, see <a>how-it-works</a>. </p>
    ///          <p>If you specify the name of an existing bot, the fields in the
    ///       request replace the existing values in the <code>$LATEST</code> version of
    ///       the bot. Amazon Lex removes any fields that you don't provide values for in the
    ///       request, except for the <code>idleTTLInSeconds</code> and
    ///         <code>privacySettings</code> fields, which are set to their default
    ///       values. If you don't specify values for required fields, Amazon Lex throws an
    ///       exception.</p>
    ///
    ///          <p>This operation requires permissions for the <code>lex:PutBot</code>
    ///       action. For more information, see <a>security-iam</a>.</p>
    public func putBot(input: PutBotInput, completion: @escaping (SdkResult<PutBotOutputResponse, PutBotOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(name)/versions/$LATEST"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putBot")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutBotInput, PutBotOutputResponse, PutBotOutputError>(id: "putBot")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutBotInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutBotInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutBotInput, PutBotOutputResponse, PutBotOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutBotInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an alias for the specified version of the bot or replaces
    ///       an alias for the specified bot. To change the version of the bot that the
    ///       alias points to, replace the alias. For more information about aliases,
    ///       see <a>versioning-aliases</a>.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:PutBotAlias</code> action. </p>
    public func putBotAlias(input: PutBotAliasInput, completion: @escaping (SdkResult<PutBotAliasOutputResponse, PutBotAliasOutputError>) -> Void)
    {
        guard let botName = input.botName else {
            completion(.failure(.client(ClientError.serializationFailed("uri component botName unexpectedly nil"))))
            return
        }
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/bots/\(botName)/aliases/\(name)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putBotAlias")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutBotAliasInput, PutBotAliasOutputResponse, PutBotAliasOutputError>(id: "putBotAlias")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutBotAliasInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutBotAliasInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutBotAliasInput, PutBotAliasOutputResponse, PutBotAliasOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutBotAliasInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates an intent or replaces an existing intent.</p>
    ///          <p>To define the interaction between the user and your bot, you use
    ///       one or more intents. For a pizza ordering bot, for example, you would
    ///       create an <code>OrderPizza</code> intent. </p>
    ///          <p>To create an intent or replace an existing intent, you must provide
    ///       the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>Intent name. For example, <code>OrderPizza</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>Sample utterances. For example, "Can I order a pizza, please."
    ///           and "I want to order a pizza."</p>
    ///             </li>
    ///             <li>
    ///                <p>Information to be gathered. You specify slot types for the
    ///           information that your bot will request from the user. You can specify
    ///           standard slot types, such as a date or a time, or custom slot types
    ///           such as the size and crust of a pizza.</p>
    ///             </li>
    ///             <li>
    ///                <p>How the intent will be fulfilled. You can provide a Lambda
    ///           function or configure the intent to return the intent information to
    ///           the client application. If you use a Lambda function, when all of the
    ///           intent information is available, Amazon Lex invokes your Lambda function.
    ///           If you configure your intent to return the intent information to the
    ///           client application. </p>
    ///             </li>
    ///          </ul>
    ///          <p>You can specify other optional information in the request, such
    ///       as:</p>
    ///
    ///          <ul>
    ///             <li>
    ///                <p>A confirmation prompt to ask the user to confirm an intent. For
    ///           example, "Shall I order your pizza?"</p>
    ///             </li>
    ///             <li>
    ///                <p>A conclusion statement to send to the user after the intent has
    ///           been fulfilled. For example, "I placed your pizza order."</p>
    ///             </li>
    ///             <li>
    ///                <p>A follow-up prompt that asks the user for additional activity.
    ///           For example, asking "Do you want to order a drink with your
    ///           pizza?"</p>
    ///             </li>
    ///          </ul>
    ///          <p>If you specify an existing intent name to update the intent, Amazon Lex
    ///       replaces the values in the <code>$LATEST</code> version of the intent with
    ///       the values in the request. Amazon Lex removes fields that you don't provide in
    ///       the request. If you don't specify the required fields, Amazon Lex throws an
    ///       exception. When you update the <code>$LATEST</code> version of an intent,
    ///       the <code>status</code> field of any bot that uses the
    ///         <code>$LATEST</code> version of the intent is set to
    ///         <code>NOT_BUILT</code>.</p>
    ///          <p>For more information, see <a>how-it-works</a>.</p>
    ///          <p>This operation requires permissions for the
    ///         <code>lex:PutIntent</code> action.</p>
    public func putIntent(input: PutIntentInput, completion: @escaping (SdkResult<PutIntentOutputResponse, PutIntentOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/intents/\(name)/versions/$LATEST"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putIntent")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutIntentInput, PutIntentOutputResponse, PutIntentOutputError>(id: "putIntent")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutIntentInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutIntentInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutIntentInput, PutIntentOutputResponse, PutIntentOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutIntentInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Creates a custom slot type or replaces an existing custom slot
    ///       type.</p>
    ///          <p>To create a custom slot type, specify a name for the slot type and
    ///       a set of enumeration values, which are the values that a slot of this type
    ///       can assume. For more information, see <a>how-it-works</a>.</p>
    ///          <p>If you specify the name of an existing slot type, the fields in the
    ///       request replace the existing values in the <code>$LATEST</code> version of
    ///       the slot type. Amazon Lex removes the fields that you don't provide in the
    ///       request. If you don't specify required fields, Amazon Lex throws an exception.
    ///       When you update the <code>$LATEST</code> version of a slot type, if a bot
    ///       uses the <code>$LATEST</code> version of an intent that contains the slot
    ///       type, the bot's <code>status</code> field is set to
    ///       <code>NOT_BUILT</code>.</p>
    ///
    ///          <p>This operation requires permissions for the
    ///         <code>lex:PutSlotType</code> action.</p>
    public func putSlotType(input: PutSlotTypeInput, completion: @escaping (SdkResult<PutSlotTypeOutputResponse, PutSlotTypeOutputError>) -> Void)
    {
        guard let name = input.name else {
            completion(.failure(.client(ClientError.serializationFailed("uri component name unexpectedly nil"))))
            return
        }
        let urlPath = "/slottypes/\(name)/versions/$LATEST"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .put)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "putSlotType")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<PutSlotTypeInput, PutSlotTypeOutputResponse, PutSlotTypeOutputError>(id: "putSlotType")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: PutSlotTypeInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: PutSlotTypeInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<PutSlotTypeInput, PutSlotTypeOutputResponse, PutSlotTypeOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: PutSlotTypeInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Starts a job to import a resource to Amazon Lex.</p>
    public func startImport(input: StartImportInput, completion: @escaping (SdkResult<StartImportOutputResponse, StartImportOutputError>) -> Void)
    {
        let urlPath = "/imports"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "startImport")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<StartImportInput, StartImportOutputResponse, StartImportOutputError>(id: "startImport")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: StartImportInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: StartImportInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<StartImportInput, StartImportOutputResponse, StartImportOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: StartImportInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Adds the specified tags to the specified resource. If a tag key
    ///       already exists, the existing value is replaced with the new value.</p>
    public func tagResource(input: TagResourceInput, completion: @escaping (SdkResult<TagResourceOutputResponse, TagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "tagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(id: "tagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<TagResourceInput, TagResourceOutputResponse, TagResourceOutputError>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .before, middleware: TagResourceInputBodyMiddleware())
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

    /// <p>Removes tags from a bot, bot alias or bot channel.</p>
    public func untagResource(input: UntagResourceInput, completion: @escaping (SdkResult<UntagResourceOutputResponse, UntagResourceOutputError>) -> Void)
    {
        guard let resourceArn = input.resourceArn else {
            completion(.failure(.client(ClientError.serializationFailed("uri component resourceArn unexpectedly nil"))))
            return
        }
        let urlPath = "/tags/\(resourceArn)"
        let context = HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .delete)
                      .withPath(value: urlPath)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "untagResource")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withHost(value: "models.lex.\(config.region).amazonaws.com")
                      .withSigningName(value: "lex")
                      .withSigningRegion(value: config.signingRegion)
        var operation = OperationStack<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(id: "untagResource")
        operation.addDefaultOperationMiddlewares()
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputHeadersMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: UntagResourceInputQueryItemMiddleware())
        operation.serializeStep.intercept(position: .before, middleware: ContentTypeMiddleware<UntagResourceInput, UntagResourceOutputResponse, UntagResourceOutputError>(contentType: "application/json"))
        operation.deserializeStep.intercept(position: .before, middleware: LoggerMiddleware(clientLogMode: config.clientLogMode))
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware(endpointResolver: config.endpointResolver, serviceId: serviceName))
        operation.finalizeStep.intercept(position: .after, middleware: RetrierMiddleware(retrier: config.retrier))
        let sigv4Config = SigV4Config(unsignedBody: false)
        operation.finalizeStep.intercept(position: .before,
                                                 middleware: SigV4Middleware(config: sigv4Config))
        operation.buildStep.intercept(position: .before, middleware: UserAgentMiddleware(metadata: AWSUserAgentMetadata.fromEnv(apiMetadata: APIMetadata(serviceId: serviceName, version: "1.0"))))
        let result = operation.handleMiddleware(context: context.build(), input: input, next: client.getHandler())
        completion(result)
    }

}
