// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

#if swift(>=5.5)
@available(macOS 12.0, iOS 15.0, tvOS 15.0, watchOS 8.0, macCatalyst 15.0, *)
public extension CloudWatchLogsClient {
    /// Associates the specified Key Management Service customer master key (CMK) with the specified log group.
    ///          Associating an KMS CMK with a log group overrides any existing associations between the log group and a CMK.
    ///       After a CMK is associated with a log group, all newly ingested data for the log group is encrypted using the CMK.
    ///       This association is stored as long as the data encrypted with the CMK is still within CloudWatch Logs.
    ///       This enables CloudWatch Logs to decrypt this data whenever it is requested.
    ///
    ///             CloudWatch Logs supports only symmetric CMKs. Do not use an associate an asymmetric CMK
    ///         with your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
    ///           Keys.
    ///
    ///          It can take up to 5 minutes for this operation to take effect.
    ///          If you attempt to associate a CMK with a log group but the CMK does not exist or the
    ///       CMK is disabled, you receive an InvalidParameterException error.
    func associateKmsKey(input: AssociateKmsKeyInput) async throws -> AssociateKmsKeyOutputResponse
    {
        typealias associateKmsKeyContinuation = CheckedContinuation<AssociateKmsKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: associateKmsKeyContinuation) in
            associateKmsKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Cancels the specified export task.
    ///          The task must be in the PENDING or RUNNING state.
    func cancelExportTask(input: CancelExportTaskInput) async throws -> CancelExportTaskOutputResponse
    {
        typealias cancelExportTaskContinuation = CheckedContinuation<CancelExportTaskOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: cancelExportTaskContinuation) in
            cancelExportTask(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates an export task, which allows you to efficiently export data from a
    ///       log group to an Amazon S3 bucket. When you perform a CreateExportTask
    ///       operation, you must use credentials that have permission to write to the S3 bucket
    ///       that you specify as the destination.
    ///          This is an asynchronous call. If all the required information is provided, this
    ///       operation initiates an export task and responds with the ID of the task. After the task has started,
    ///       you can use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_DescribeExportTasks.html">DescribeExportTasks to get the status of the export task. Each account can
    ///       only have one active (RUNNING or PENDING) export task at a time.
    ///       To cancel an export task, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_CancelExportTask.html">CancelExportTask.
    ///          You can export logs from multiple log groups or multiple time ranges to the same S3
    ///       bucket. To separate out log data for each export task, you can specify a prefix to be used as
    ///       the Amazon S3 key prefix for all exported objects.
    ///          Exporting to S3 buckets that are encrypted with AES-256 is supported. Exporting to S3 buckets
    ///       encrypted with SSE-KMS is not supported.
    func createExportTask(input: CreateExportTaskInput) async throws -> CreateExportTaskOutputResponse
    {
        typealias createExportTaskContinuation = CheckedContinuation<CreateExportTaskOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createExportTaskContinuation) in
            createExportTask(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a log group with the specified name. You can create up to 20,000 log groups per account.
    ///          You must use the following guidelines when naming a log group:
    ///
    ///
    ///                Log group names must be unique within a region for an Amazon Web Services account.
    ///
    ///
    ///                Log group names can be between 1 and 512 characters long.
    ///
    ///
    ///                Log group names consist of the following characters: a-z, A-Z, 0-9, '_' (underscore), '-' (hyphen),
    ///           '/' (forward slash), '.' (period), and '#' (number sign)
    ///
    ///
    ///          When you create a log group, by default the log events in the log group never expire. To set
    ///     a retention policy so that events expire and are deleted after a specified time, use
    ///       <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutRetentionPolicy.html">PutRetentionPolicy.
    ///          If you associate a Key Management Service customer master key (CMK) with the log group, ingested data is encrypted using the CMK.
    ///       This association is stored as long as the data encrypted with the CMK is still within CloudWatch Logs.
    ///       This enables CloudWatch Logs to decrypt this data whenever it is requested.
    ///          If you attempt to associate a CMK with the log group but the CMK does not exist or the
    ///       CMK is disabled, you receive an InvalidParameterException error.
    ///
    ///             CloudWatch Logs supports only symmetric CMKs. Do not associate an asymmetric CMK with
    ///         your log group. For more information, see <a href="https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html">Using Symmetric and Asymmetric
    ///           Keys.
    ///
    func createLogGroup(input: CreateLogGroupInput) async throws -> CreateLogGroupOutputResponse
    {
        typealias createLogGroupContinuation = CheckedContinuation<CreateLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLogGroupContinuation) in
            createLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates a log stream for the specified log group. A log stream is a sequence of log events
    ///       that originate from a single source, such as an application instance or a resource that is
    ///       being monitored.
    ///          There is no limit on the number of log streams that you can create for a log group. There is a limit
    ///     of 50 TPS on CreateLogStream operations, after which transactions are throttled.
    ///          You must use the following guidelines when naming a log stream:
    ///
    ///
    ///                Log stream names must be unique within the log group.
    ///
    ///
    ///                Log stream names can be between 1 and 512 characters long.
    ///
    ///
    ///                The ':' (colon) and '*' (asterisk) characters are not allowed.
    ///
    ///
    func createLogStream(input: CreateLogStreamInput) async throws -> CreateLogStreamOutputResponse
    {
        typealias createLogStreamContinuation = CheckedContinuation<CreateLogStreamOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: createLogStreamContinuation) in
            createLogStream(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified destination, and eventually disables all the
    ///       subscription filters that publish to it. This operation does not delete the
    ///       physical resource encapsulated by the destination.
    func deleteDestination(input: DeleteDestinationInput) async throws -> DeleteDestinationOutputResponse
    {
        typealias deleteDestinationContinuation = CheckedContinuation<DeleteDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteDestinationContinuation) in
            deleteDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified log group and permanently deletes all the archived
    ///       log events associated with the log group.
    func deleteLogGroup(input: DeleteLogGroupInput) async throws -> DeleteLogGroupOutputResponse
    {
        typealias deleteLogGroupContinuation = CheckedContinuation<DeleteLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLogGroupContinuation) in
            deleteLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified log stream and permanently deletes all the archived log events associated
    ///       with the log stream.
    func deleteLogStream(input: DeleteLogStreamInput) async throws -> DeleteLogStreamOutputResponse
    {
        typealias deleteLogStreamContinuation = CheckedContinuation<DeleteLogStreamOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteLogStreamContinuation) in
            deleteLogStream(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified metric filter.
    func deleteMetricFilter(input: DeleteMetricFilterInput) async throws -> DeleteMetricFilterOutputResponse
    {
        typealias deleteMetricFilterContinuation = CheckedContinuation<DeleteMetricFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteMetricFilterContinuation) in
            deleteMetricFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a saved CloudWatch Logs Insights query definition.
    ///       A query definition contains details about a saved CloudWatch Logs Insights query.
    ///          Each DeleteQueryDefinition operation can delete one query definition.
    ///          You must have the logs:DeleteQueryDefinition permission to be able to perform
    ///       this operation.
    func deleteQueryDefinition(input: DeleteQueryDefinitionInput) async throws -> DeleteQueryDefinitionOutputResponse
    {
        typealias deleteQueryDefinitionContinuation = CheckedContinuation<DeleteQueryDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteQueryDefinitionContinuation) in
            deleteQueryDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes a resource policy from this account. This revokes
    ///     the access of the identities in that policy to put log events to this account.
    func deleteResourcePolicy(input: DeleteResourcePolicyInput) async throws -> DeleteResourcePolicyOutputResponse
    {
        typealias deleteResourcePolicyContinuation = CheckedContinuation<DeleteResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteResourcePolicyContinuation) in
            deleteResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified retention policy.
    ///          Log events do not expire if they belong to log groups without a retention policy.
    func deleteRetentionPolicy(input: DeleteRetentionPolicyInput) async throws -> DeleteRetentionPolicyOutputResponse
    {
        typealias deleteRetentionPolicyContinuation = CheckedContinuation<DeleteRetentionPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteRetentionPolicyContinuation) in
            deleteRetentionPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Deletes the specified subscription filter.
    func deleteSubscriptionFilter(input: DeleteSubscriptionFilterInput) async throws -> DeleteSubscriptionFilterOutputResponse
    {
        typealias deleteSubscriptionFilterContinuation = CheckedContinuation<DeleteSubscriptionFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: deleteSubscriptionFilterContinuation) in
            deleteSubscriptionFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists all your destinations. The results are ASCII-sorted by destination name.
    func describeDestinations(input: DescribeDestinationsInput) async throws -> DescribeDestinationsOutputResponse
    {
        typealias describeDestinationsContinuation = CheckedContinuation<DescribeDestinationsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeDestinationsContinuation) in
            describeDestinations(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the specified export tasks. You can list all your export tasks or filter
    ///       the results based on task ID or task status.
    func describeExportTasks(input: DescribeExportTasksInput) async throws -> DescribeExportTasksOutputResponse
    {
        typealias describeExportTasksContinuation = CheckedContinuation<DescribeExportTasksOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeExportTasksContinuation) in
            describeExportTasks(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the specified log groups. You can list all your log groups or filter the results by prefix.
    ///       The results are ASCII-sorted by log group name.
    ///          CloudWatch Logs doesnâ€™t support IAM policies that control access to the DescribeLogGroups action by using the
    ///       aws:ResourceTag/key-name
    ///              condition key. Other CloudWatch Logs actions
    ///       do support the use of the aws:ResourceTag/key-name
    ///              condition key to control access.
    ///       For more information about using tags to control access, see
    ///       <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags.
    func describeLogGroups(input: DescribeLogGroupsInput) async throws -> DescribeLogGroupsOutputResponse
    {
        typealias describeLogGroupsContinuation = CheckedContinuation<DescribeLogGroupsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeLogGroupsContinuation) in
            describeLogGroups(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the log streams for the specified log group.
    ///       You can list all the log streams or filter the results by prefix.
    ///       You can also control how the results are ordered.
    ///          This operation has a limit of five transactions per second, after which transactions are throttled.
    func describeLogStreams(input: DescribeLogStreamsInput) async throws -> DescribeLogStreamsOutputResponse
    {
        typealias describeLogStreamsContinuation = CheckedContinuation<DescribeLogStreamsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeLogStreamsContinuation) in
            describeLogStreams(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the specified metric filters. You can list all of the metric filters or filter
    ///       the results by log name, prefix, metric name, or metric namespace. The results are
    ///       ASCII-sorted by filter name.
    func describeMetricFilters(input: DescribeMetricFiltersInput) async throws -> DescribeMetricFiltersOutputResponse
    {
        typealias describeMetricFiltersContinuation = CheckedContinuation<DescribeMetricFiltersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeMetricFiltersContinuation) in
            describeMetricFilters(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of CloudWatch Logs Insights queries that are scheduled, executing, or have
    ///       been executed recently in this account. You can request all queries or limit it to queries of
    ///       a specific log group or queries with a certain status.
    func describeQueries(input: DescribeQueriesInput) async throws -> DescribeQueriesOutputResponse
    {
        typealias describeQueriesContinuation = CheckedContinuation<DescribeQueriesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeQueriesContinuation) in
            describeQueries(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// This operation returns a paginated list of your saved CloudWatch Logs Insights query definitions.
    ///          You can use the queryDefinitionNamePrefix parameter to limit the results to only the
    ///       query definitions that have names that start with a certain string.
    func describeQueryDefinitions(input: DescribeQueryDefinitionsInput) async throws -> DescribeQueryDefinitionsOutputResponse
    {
        typealias describeQueryDefinitionsContinuation = CheckedContinuation<DescribeQueryDefinitionsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeQueryDefinitionsContinuation) in
            describeQueryDefinitions(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the resource policies in this account.
    func describeResourcePolicies(input: DescribeResourcePoliciesInput) async throws -> DescribeResourcePoliciesOutputResponse
    {
        typealias describeResourcePoliciesContinuation = CheckedContinuation<DescribeResourcePoliciesOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeResourcePoliciesContinuation) in
            describeResourcePolicies(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the subscription filters for the specified log group. You can list all the subscription filters or filter the results by prefix.
    ///       The results are ASCII-sorted by filter name.
    func describeSubscriptionFilters(input: DescribeSubscriptionFiltersInput) async throws -> DescribeSubscriptionFiltersOutputResponse
    {
        typealias describeSubscriptionFiltersContinuation = CheckedContinuation<DescribeSubscriptionFiltersOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: describeSubscriptionFiltersContinuation) in
            describeSubscriptionFilters(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Disassociates the associated Key Management Service customer master key (CMK) from the specified log group.
    ///          After the KMS CMK is disassociated from the log group, CloudWatch Logs stops encrypting newly ingested data for the log group.
    ///       All previously ingested data remains encrypted, and CloudWatch Logs requires permissions for the CMK whenever the encrypted data is requested.
    ///          Note that it can take up to 5 minutes for this operation to take effect.
    func disassociateKmsKey(input: DisassociateKmsKeyInput) async throws -> DisassociateKmsKeyOutputResponse
    {
        typealias disassociateKmsKeyContinuation = CheckedContinuation<DisassociateKmsKeyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: disassociateKmsKeyContinuation) in
            disassociateKmsKey(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists log events from the specified log group. You can list all the log events or filter the results
    ///       using a filter pattern, a time range, and the name of the log stream.
    ///          By default, this operation returns as many log events as can fit in 1 MB (up to 10,000
    ///       log events) or all the events found within the time range that you specify. If the results
    ///       include a token, then there are more log events available, and you can get additional results
    ///       by specifying the token in a subsequent call. This operation can return empty results
    ///     while there are more log events available through the token.
    ///          The returned log events are sorted by event timestamp, the timestamp when the event was ingested
    ///     by CloudWatch Logs, and the ID of the PutLogEvents request.
    func filterLogEvents(input: FilterLogEventsInput) async throws -> FilterLogEventsOutputResponse
    {
        typealias filterLogEventsContinuation = CheckedContinuation<FilterLogEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: filterLogEventsContinuation) in
            filterLogEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists log events from the specified log stream. You can list all of the log events or
    ///       filter using a time range.
    ///
    ///          By default, this operation returns as many log events as can fit in a response size of 1MB (up to 10,000 log events).
    ///       You can get additional log events by specifying one of the tokens in a subsequent call.
    ///       This operation can return empty results while there are more log events available through the token.
    func getLogEvents(input: GetLogEventsInput) async throws -> GetLogEventsOutputResponse
    {
        typealias getLogEventsContinuation = CheckedContinuation<GetLogEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLogEventsContinuation) in
            getLogEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns a list of the fields that are included in log events in the specified log group, along with the percentage of log events
    ///     that contain each field. The search is limited to a time period that you specify.
    ///          In the results, fields that start with @ are fields generated by CloudWatch Logs. For
    ///       example, @timestamp is the timestamp of each log event. For more information about the fields that are
    ///       generated by CloudWatch logs, see
    ///       <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_AnalyzeLogData-discoverable-fields.html">Supported Logs and Discovered Fields.
    ///          The response results are sorted by the frequency percentage, starting
    ///     with the highest percentage.
    func getLogGroupFields(input: GetLogGroupFieldsInput) async throws -> GetLogGroupFieldsOutputResponse
    {
        typealias getLogGroupFieldsContinuation = CheckedContinuation<GetLogGroupFieldsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLogGroupFieldsContinuation) in
            getLogGroupFields(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Retrieves all of the fields and values of a single log event. All fields are retrieved,
    ///       even if the original query that produced the logRecordPointer retrieved only a
    ///       subset of fields. Fields are returned as field name/field value pairs.
    ///          The full unparsed log event is returned within @message.
    func getLogRecord(input: GetLogRecordInput) async throws -> GetLogRecordOutputResponse
    {
        typealias getLogRecordContinuation = CheckedContinuation<GetLogRecordOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getLogRecordContinuation) in
            getLogRecord(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Returns the results from the specified query.
    ///          Only the fields requested in the query are returned, along with a @ptr
    ///       field, which is the identifier for the log record. You can use the value of @ptr
    ///       in a <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_GetLogRecord.html">GetLogRecord
    ///       operation to get the full log record.
    ///
    ///             GetQueryResults
    ///       does not start a query execution. To run a query, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_StartQuery.html">StartQuery.
    ///          If the value of the Status field in the output is Running, this operation
    ///       returns only partial results. If you see a value of Scheduled or Running for the status,
    ///       you can retry the operation later to see the final results.
    func getQueryResults(input: GetQueryResultsInput) async throws -> GetQueryResultsOutputResponse
    {
        typealias getQueryResultsContinuation = CheckedContinuation<GetQueryResultsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: getQueryResultsContinuation) in
            getQueryResults(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Lists the tags for the specified log group.
    func listTagsLogGroup(input: ListTagsLogGroupInput) async throws -> ListTagsLogGroupOutputResponse
    {
        typealias listTagsLogGroupContinuation = CheckedContinuation<ListTagsLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: listTagsLogGroupContinuation) in
            listTagsLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates a destination. This operation is used only to create destinations for cross-account subscriptions.
    ///          A destination encapsulates a physical resource (such
    ///       as an Amazon Kinesis stream) and enables you to subscribe to a real-time stream of log events
    ///       for a different account, ingested using <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents.
    ///          Through an access policy, a destination controls what is written to it.
    ///       By default, PutDestination does not set any access policy with the destination,
    ///       which means a cross-account user cannot call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutSubscriptionFilter.html">PutSubscriptionFilter against
    ///       this destination. To enable this, the destination owner must call <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutDestinationPolicy.html">PutDestinationPolicy after PutDestination.
    ///          To perform a PutDestination operation, you must also have the
    ///     iam:PassRole permission.
    func putDestination(input: PutDestinationInput) async throws -> PutDestinationOutputResponse
    {
        typealias putDestinationContinuation = CheckedContinuation<PutDestinationOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putDestinationContinuation) in
            putDestination(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates an access policy associated with an existing
    ///       destination. An access policy is an <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/policies_overview.html">IAM policy document that is used
    ///       to authorize claims to register a subscription filter against a given destination.
    ///          If multiple Amazon Web Services accounts are sending logs to this destination, each sender account must be
    ///     listed separately in the policy. The policy does not support specifying *
    ///     as the Principal or the use of the aws:PrincipalOrgId global key.
    func putDestinationPolicy(input: PutDestinationPolicyInput) async throws -> PutDestinationPolicyOutputResponse
    {
        typealias putDestinationPolicyContinuation = CheckedContinuation<PutDestinationPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putDestinationPolicyContinuation) in
            putDestinationPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Uploads a batch of log events to the specified log stream.
    ///          You must include the sequence token obtained from the response of the previous call. An
    ///       upload in a newly created log stream does not require a sequence token. You can also get the
    ///       sequence token in the expectedSequenceToken field from
    ///         InvalidSequenceTokenException. If you call PutLogEvents twice
    ///       within a narrow time period using the same value for sequenceToken, both calls
    ///       might be successful or one might be rejected.
    ///          The batch of events must satisfy the following constraints:
    ///
    ///
    ///                The maximum batch size is 1,048,576 bytes. This size is calculated as the sum of
    ///           all event messages in UTF-8, plus 26 bytes for each log event.
    ///
    ///
    ///                None of the log events in the batch can be more than 2 hours in the future.
    ///
    ///
    ///                None of the log events in the batch can be older than 14 days or older than the retention
    ///           period of the log group.
    ///
    ///
    ///                The log events in the batch must be in chronological order by their timestamp. The
    ///           timestamp is the time the event occurred, expressed as the number of milliseconds after
    ///           Jan 1, 1970 00:00:00 UTC. (In Amazon Web Services Tools for PowerShell and the Amazon Web Services SDK for .NET, the
    ///           timestamp is specified in .NET format: yyyy-mm-ddThh:mm:ss. For example,
    ///           2017-09-15T13:45:30.)
    ///
    ///
    ///                A batch of log events in a single request cannot span more than 24 hours. Otherwise, the operation fails.
    ///
    ///
    ///                The maximum number of log events in a batch is 10,000.
    ///
    ///
    ///                There is a quota of 5 requests per second per log stream. Additional requests are throttled. This quota can't be changed.
    ///
    ///
    ///          If a call to PutLogEvents returns "UnrecognizedClientException" the most likely cause is an invalid Amazon Web Services access key ID or secret key.
    func putLogEvents(input: PutLogEventsInput) async throws -> PutLogEventsOutputResponse
    {
        typealias putLogEventsContinuation = CheckedContinuation<PutLogEventsOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putLogEventsContinuation) in
            putLogEvents(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates a metric filter and associates it with the specified log group.
    ///       Metric filters allow you to configure rules to extract metric data from log events ingested
    ///       through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents.
    ///          The maximum number of metric filters that can be associated with a log group is
    ///       100.
    ///          When you create a metric filter, you can also optionally assign a unit and dimensions
    ///     to the metric that is created.
    ///
    ///             Metrics extracted from log events are charged as custom metrics.
    ///       To prevent unexpected high charges, do not specify high-cardinality fields such as
    ///       IPAddress or requestID as dimensions. Each different value
    ///       found for
    ///       a dimension is treated as a separate metric and accrues charges as a separate custom metric.
    ///
    ///             To help prevent accidental high charges, Amazon disables a metric filter
    ///         if it generates 1000 different name/value pairs for the dimensions that you
    ///         have specified within a certain amount of time.
    ///             You can also set up a billing alarm to alert you if your charges are higher than
    ///         expected. For more information,
    ///         see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/monitor_estimated_charges_with_cloudwatch.html">
    ///           Creating a Billing Alarm to Monitor Your Estimated Amazon Web Services Charges.
    ///
    ///
    func putMetricFilter(input: PutMetricFilterInput) async throws -> PutMetricFilterOutputResponse
    {
        typealias putMetricFilterContinuation = CheckedContinuation<PutMetricFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putMetricFilterContinuation) in
            putMetricFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates a query definition for CloudWatch Logs Insights. For
    ///       more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/AnalyzingLogData.html">Analyzing Log Data with CloudWatch Logs Insights.
    ///
    ///          To update a query definition, specify its
    ///         queryDefinitionId in your request. The values of name, queryString,
    ///       and logGroupNames are changed to the values that you specify in your update
    ///       operation. No current values are retained from the current query definition. For example, if
    ///       you update a current query definition that includes log groups, and you don't specify the
    ///         logGroupNames parameter in your update operation, the query definition changes
    ///       to contain no log groups.
    ///          You must have the logs:PutQueryDefinition permission to be able to perform
    ///     this operation.
    func putQueryDefinition(input: PutQueryDefinitionInput) async throws -> PutQueryDefinitionOutputResponse
    {
        typealias putQueryDefinitionContinuation = CheckedContinuation<PutQueryDefinitionOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putQueryDefinitionContinuation) in
            putQueryDefinition(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates a resource policy allowing other Amazon Web Services services to put log events to
    ///       this account, such as Amazon Route 53. An account can have up to 10 resource policies per Amazon Web Services
    ///       Region.
    func putResourcePolicy(input: PutResourcePolicyInput) async throws -> PutResourcePolicyOutputResponse
    {
        typealias putResourcePolicyContinuation = CheckedContinuation<PutResourcePolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putResourcePolicyContinuation) in
            putResourcePolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Sets the retention of the specified log group. A retention policy allows you to
    ///       configure the number of days for which to retain log events in the specified log
    ///       group.
    func putRetentionPolicy(input: PutRetentionPolicyInput) async throws -> PutRetentionPolicyOutputResponse
    {
        typealias putRetentionPolicyContinuation = CheckedContinuation<PutRetentionPolicyOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putRetentionPolicyContinuation) in
            putRetentionPolicy(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Creates or updates a subscription filter and associates it with the specified log
    ///       group. Subscription filters allow you to subscribe to a real-time stream of log events
    ///       ingested through <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_PutLogEvents.html">PutLogEvents and have them delivered to a specific
    ///       destination. When log events are sent to the
    ///       receiving service, they are Base64 encoded
    ///       and compressed with the gzip format.
    ///          The following destinations are supported for subscription filters:
    ///
    ///
    ///                An Amazon Kinesis stream belonging to the same account as the subscription filter,
    ///           for same-account delivery.
    ///
    ///
    ///                A logical destination that belongs to a different account, for cross-account delivery.
    ///
    ///
    ///                An Amazon Kinesis Firehose delivery stream that belongs to the same account as the
    ///           subscription filter, for same-account delivery.
    ///
    ///
    ///                An Lambda function that belongs to the same account as the subscription filter,
    ///           for same-account delivery.
    ///
    ///
    ///          Each log group can have up to two subscription filters associated with it. If you are
    ///       updating an existing filter, you must specify the correct name in filterName.
    ///
    ///          To perform a PutSubscriptionFilter operation, you must also have the
    ///       iam:PassRole permission.
    func putSubscriptionFilter(input: PutSubscriptionFilterInput) async throws -> PutSubscriptionFilterOutputResponse
    {
        typealias putSubscriptionFilterContinuation = CheckedContinuation<PutSubscriptionFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: putSubscriptionFilterContinuation) in
            putSubscriptionFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Schedules a query of a log group using CloudWatch Logs Insights. You specify the log group
    ///       and time range to query and the query string to use.
    ///          For more information, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/CWL_QuerySyntax.html">CloudWatch Logs Insights Query Syntax.
    ///
    ///          Queries time out after 15 minutes of execution. If your queries are timing out, reduce the
    ///       time range being searched or partition your query into a number of queries.
    func startQuery(input: StartQueryInput) async throws -> StartQueryOutputResponse
    {
        typealias startQueryContinuation = CheckedContinuation<StartQueryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: startQueryContinuation) in
            startQuery(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Stops a CloudWatch Logs Insights query that is in progress. If the query has already ended, the operation
    ///     returns an error indicating that the specified query is not running.
    func stopQuery(input: StopQueryInput) async throws -> StopQueryOutputResponse
    {
        typealias stopQueryContinuation = CheckedContinuation<StopQueryOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: stopQueryContinuation) in
            stopQuery(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Adds or updates the specified tags for the specified log group.
    ///          To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup.
    ///       To remove tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_UntagLogGroup.html">UntagLogGroup.
    ///          For more information about tags, see <a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/Working-with-log-groups-and-streams.html#log-group-tagging">Tag Log Groups in Amazon CloudWatch Logs
    ///       in the Amazon CloudWatch Logs User Guide.
    ///          CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
    ///       log groups using the aws:Resource/key-name
    ///              or aws:TagKeys condition keys.
    ///       For more information about using tags to control access, see
    ///       <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/access_tags.html">Controlling access to Amazon Web Services resources using tags.
    func tagLogGroup(input: TagLogGroupInput) async throws -> TagLogGroupOutputResponse
    {
        typealias tagLogGroupContinuation = CheckedContinuation<TagLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: tagLogGroupContinuation) in
            tagLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Tests the filter pattern of a metric filter against a sample of log event messages. You
    ///       can use this operation to validate the correctness of a metric filter pattern.
    func testMetricFilter(input: TestMetricFilterInput) async throws -> TestMetricFilterOutputResponse
    {
        typealias testMetricFilterContinuation = CheckedContinuation<TestMetricFilterOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: testMetricFilterContinuation) in
            testMetricFilter(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

    /// Removes the specified tags from the specified log group.
    ///          To list the tags for a log group, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_ListTagsLogGroup.html">ListTagsLogGroup.
    ///       To add tags, use <a href="https://docs.aws.amazon.com/AmazonCloudWatchLogs/latest/APIReference/API_TagLogGroup.html">TagLogGroup.
    ///          CloudWatch Logs doesnâ€™t support IAM policies that prevent users from assigning specified tags to
    ///       log groups using the aws:Resource/key-name
    ///              or aws:TagKeys condition keys.
    ///
    func untagLogGroup(input: UntagLogGroupInput) async throws -> UntagLogGroupOutputResponse
    {
        typealias untagLogGroupContinuation = CheckedContinuation<UntagLogGroupOutputResponse, Swift.Error>
        return try await withCheckedThrowingContinuation { (continuation: untagLogGroupContinuation) in
            untagLogGroup(input: input) { result in
                switch result {
                    case .success(let output):
                        continuation.resume(returning: output)
                    case .failure(let error):
                        continuation.resume(throwing: error)
                }
            }
        }
    }

}
#endif
