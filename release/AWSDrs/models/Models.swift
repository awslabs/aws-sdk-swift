// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// TYou do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DrsClientTypes.CPU: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores
        case modelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cores != 0 {
            try encodeContainer.encode(cores, forKey: .cores)
        }
        if let modelName = modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresDecoded = try containerValues.decode(Swift.Int.self, forKey: .cores)
        cores = coresDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension DrsClientTypes {
    /// Information about a server's CPU.
    public struct CPU: Swift.Equatable {
        /// The number of CPU cores.
        public var cores: Swift.Int
        /// The model name of the CPU.
        public var modelName: Swift.String?

        public init (
            cores: Swift.Int = 0,
            modelName: Swift.String? = nil
        )
        {
            self.cores = cores
            self.modelName = modelName
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be completed due to a conflict with the current state of the target resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicy0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicy0)
            }
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension CreateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateReplicationConfigurationTemplate"
    }
}

public struct CreateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    /// This member is required.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    /// This member is required.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    /// This member is required.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    /// This member is required.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    /// This member is required.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    /// This member is required.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    /// This member is required.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The instance type to be used for the replication server.
    /// This member is required.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    /// This member is required.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    /// This member is required.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    /// This member is required.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// A set of tags to be associated with the Replication Configuration Template resource.
    public var tags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    /// This member is required.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let tags: [Swift.String:Swift.String]?
}

extension CreateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: CreateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.pitPolicy = output.pitPolicy
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.pitPolicy = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct CreateReplicationConfigurationTemplateOutputResponse: Swift.Equatable {
    /// The Replication Configuration Template ARN.
    public var arn: Swift.String?
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// A set of tags to be associated with the Replication Configuration Template resource.
    public var tags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
}

extension CreateReplicationConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
    }
}

extension DrsClientTypes.DataReplicationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationErrorString.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension DrsClientTypes {
    /// Error in data replication.
    public struct DataReplicationError: Swift.Equatable {
        /// Error in data replication.
        public var error: DrsClientTypes.DataReplicationErrorString?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init (
            error: DrsClientTypes.DataReplicationErrorString? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension DrsClientTypes {
    public enum DataReplicationErrorString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentNotSeen
        case failedToAttachStagingDisks
        case failedToAuthenticateWithService
        case failedToBootReplicationServer
        case failedToConnectAgentToReplicationServer
        case failedToCreateSecurityGroup
        case failedToCreateStagingDisks
        case failedToDownloadReplicationSoftware
        case failedToLaunchReplicationServer
        case failedToPairReplicationServerWithAgent
        case failedToStartDataTransfer
        case notConverging
        case snapshotsFailure
        case unstableNetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationErrorString] {
            return [
                .agentNotSeen,
                .failedToAttachStagingDisks,
                .failedToAuthenticateWithService,
                .failedToBootReplicationServer,
                .failedToConnectAgentToReplicationServer,
                .failedToCreateSecurityGroup,
                .failedToCreateStagingDisks,
                .failedToDownloadReplicationSoftware,
                .failedToLaunchReplicationServer,
                .failedToPairReplicationServerWithAgent,
                .failedToStartDataTransfer,
                .notConverging,
                .snapshotsFailure,
                .unstableNetwork,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
            case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
            case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
            case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
            case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
            case .notConverging: return "NOT_CONVERGING"
            case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationErrorString(rawValue: rawValue) ?? DataReplicationErrorString.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.DataReplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case replicatedDisks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for datareplicationinforeplicateddisks0 in replicatedDisks {
                try replicatedDisksContainer.encode(datareplicationinforeplicateddisks0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.DataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.DataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
    }
}

extension DrsClientTypes {
    /// Information about Data Replication
    public struct DataReplicationInfo: Swift.Equatable {
        /// Error in data replication.
        public var dataReplicationError: DrsClientTypes.DataReplicationError?
        /// Information about whether the data replication has been initiated.
        public var dataReplicationInitiation: DrsClientTypes.DataReplicationInitiation?
        /// The state of the data replication.
        public var dataReplicationState: DrsClientTypes.DataReplicationState?
        /// An estimate of when the data replication will be completed.
        public var etaDateTime: Swift.String?
        /// Data replication lag duration.
        public var lagDuration: Swift.String?
        /// The disks that should be replicated.
        public var replicatedDisks: [DrsClientTypes.DataReplicationInfoReplicatedDisk]?

        public init (
            dataReplicationError: DrsClientTypes.DataReplicationError? = nil,
            dataReplicationInitiation: DrsClientTypes.DataReplicationInitiation? = nil,
            dataReplicationState: DrsClientTypes.DataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            replicatedDisks: [DrsClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.replicatedDisks = replicatedDisks
        }
    }

}

extension DrsClientTypes.DataReplicationInfoReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalStorageBytes)
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .replicatedStorageBytes)
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .rescannedStorageBytes)
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .backloggedStorageBytes)
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension DrsClientTypes {
    /// A disk that should be replicated.
    public struct DataReplicationInfoReplicatedDisk: Swift.Equatable {
        /// The size of the replication backlog in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// The name of the device.
        public var deviceName: Swift.String?
        /// The amount of data replicated so far in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// The amount of data to be rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// The total amount of data to be replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init (
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension DrsClientTypes.DataReplicationInitiation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextAttemptDateTime
        case startDateTime
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextAttemptDateTime = nextAttemptDateTime {
            try encodeContainer.encode(nextAttemptDateTime, forKey: .nextAttemptDateTime)
        }
        if let startDateTime = startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for datareplicationinitiationsteps0 in steps {
                try stepsContainer.encode(datareplicationinitiationsteps0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let nextAttemptDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextAttemptDateTime)
        nextAttemptDateTime = nextAttemptDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DrsClientTypes.DataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[DrsClientTypes.DataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DrsClientTypes.DataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension DrsClientTypes {
    /// Data replication initiation.
    public struct DataReplicationInitiation: Swift.Equatable {
        /// The date and time of the next attempt to initiate data replication.
        public var nextAttemptDateTime: Swift.String?
        /// The date and time of the current attempt to initiate data replication.
        public var startDateTime: Swift.String?
        /// The steps of the current attempt to initiate data replication.
        public var steps: [DrsClientTypes.DataReplicationInitiationStep]?

        public init (
            nextAttemptDateTime: Swift.String? = nil,
            startDateTime: Swift.String? = nil,
            steps: [DrsClientTypes.DataReplicationInitiationStep]? = nil
        )
        {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension DrsClientTypes.DataReplicationInitiationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DrsClientTypes {
    /// Data replication initiation step.
    public struct DataReplicationInitiationStep: Swift.Equatable {
        /// The name of the step.
        public var name: DrsClientTypes.DataReplicationInitiationStepName?
        /// The status of the step.
        public var status: DrsClientTypes.DataReplicationInitiationStepStatus?

        public init (
            name: DrsClientTypes.DataReplicationInitiationStepName? = nil,
            status: DrsClientTypes.DataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension DrsClientTypes {
    public enum DataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachStagingDisks
        case authenticateWithService
        case bootReplicationServer
        case connectAgentToReplicationServer
        case createSecurityGroup
        case createStagingDisks
        case downloadReplicationSoftware
        case launchReplicationServer
        case pairReplicationServerWithAgent
        case startDataTransfer
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepName] {
            return [
                .attachStagingDisks,
                .authenticateWithService,
                .bootReplicationServer,
                .connectAgentToReplicationServer,
                .createSecurityGroup,
                .createStagingDisks,
                .downloadReplicationSoftware,
                .launchReplicationServer,
                .pairReplicationServerWithAgent,
                .startDataTransfer,
                .wait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
            case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
            case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
            case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
            case .createStagingDisks: return "CREATE_STAGING_DISKS"
            case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
            case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
            case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .startDataTransfer: return "START_DATA_TRANSFER"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepName(rawValue: rawValue) ?? DataReplicationInitiationStepName.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum DataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepStatus(rawValue: rawValue) ?? DataReplicationInitiationStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum DataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case paused
        case rescan
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .paused,
                .rescan,
                .stalled,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .paused: return "PAUSED"
            case .rescan: return "RESCAN"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationState(rawValue: rawValue) ?? DataReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }
}

extension DeleteJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteJob"
    }
}

public struct DeleteJobInput: Swift.Equatable {
    /// The ID of the Job to be deleted.
    /// This member is required.
    public var jobID: Swift.String?

    public init (
        jobID: Swift.String? = nil
    )
    {
        self.jobID = jobID
    }
}

struct DeleteJobInputBody: Swift.Equatable {
    let jobID: Swift.String?
}

extension DeleteJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension DeleteJobOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteJobOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteJobOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteJobOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteJobOutputResponse: Swift.Equatable {

}

extension DeleteRecoveryInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension DeleteRecoveryInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteRecoveryInstance"
    }
}

public struct DeleteRecoveryInstanceInput: Swift.Equatable {
    /// RThe ID of the Recovery Instance to be deleted.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init (
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct DeleteRecoveryInstanceInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension DeleteRecoveryInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension DeleteRecoveryInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecoveryInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteRecoveryInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecoveryInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecoveryInstanceOutputResponse: Swift.Equatable {

}

extension DeleteReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
    }
}

extension DeleteReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteReplicationConfigurationTemplate"
    }
}

public struct DeleteReplicationConfigurationTemplateInput: Swift.Equatable {
    /// The ID of the Replication Configuration Template to be deleted.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?

    public init (
        replicationConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
    }
}

struct DeleteReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
}

extension DeleteReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
    }
}

extension DeleteReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteReplicationConfigurationTemplateOutputResponse: Swift.Equatable {

}

extension DeleteSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DeleteSourceServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteSourceServer"
    }
}

public struct DeleteSourceServerInput: Swift.Equatable {
    /// The ID of the Source Server to be deleted.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DeleteSourceServerInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DeleteSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DeleteSourceServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSourceServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteSourceServerOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSourceServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSourceServerOutputResponse: Swift.Equatable {

}

extension DescribeJobLogItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobLogItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobLogItems"
    }
}

public struct DescribeJobLogItemsInput: Swift.Equatable {
    /// The ID of the Job for which Job log items will be retrieved.
    /// This member is required.
    public var jobID: Swift.String?
    /// Maximum number of Job log items to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Job log items to retrieve.
    public var nextToken: Swift.String?

    public init (
        jobID: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.jobID = jobID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsInputBody: Swift.Equatable {
    let jobID: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobLogItemsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobLogItemsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobLogItemsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobLogItemsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobLogItemsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobLogItemsOutputResponse: Swift.Equatable {
    /// An array of Job log items.
    public var items: [DrsClientTypes.JobLog]?
    /// The token of the next Job log items to retrieve.
    public var nextToken: Swift.String?

    public init (
        items: [DrsClientTypes.JobLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsOutputResponseBody: Swift.Equatable {
    let items: [DrsClientTypes.JobLog]?
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.JobLog?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.JobLog]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.JobLog]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobs"
    }
}

public struct DescribeJobsInput: Swift.Equatable {
    /// A set of filters by which to return Jobs.
    /// This member is required.
    public var filters: DrsClientTypes.DescribeJobsRequestFilters?
    /// Maximum number of Jobs to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Job to retrieve.
    public var nextToken: Swift.String?

    public init (
        filters: DrsClientTypes.DescribeJobsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobsInputBody: Swift.Equatable {
    let filters: DrsClientTypes.DescribeJobsRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeJobsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeJobsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeJobsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeJobsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeJobsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobsOutputResponse: Swift.Equatable {
    /// An array of Jobs.
    public var items: [DrsClientTypes.Job]?
    /// The token of the next Job to retrieve.
    public var nextToken: Swift.String?

    public init (
        items: [DrsClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobsOutputResponseBody: Swift.Equatable {
    let items: [DrsClientTypes.Job]?
    let nextToken: Swift.String?
}

extension DescribeJobsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.Job?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.Job]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.Job]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DrsClientTypes.DescribeJobsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDate
        case jobIDs
        case toDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = fromDate {
            try encodeContainer.encode(fromDate, forKey: .fromDate)
        }
        if let jobIDs = jobIDs {
            var jobIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIDs)
            for describejobsrequestfiltersjobids0 in jobIDs {
                try jobIDsContainer.encode(describejobsrequestfiltersjobids0)
            }
        }
        if let toDate = toDate {
            try encodeContainer.encode(toDate, forKey: .toDate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIDs)
        var jobIDsDecoded0:[Swift.String]? = nil
        if let jobIDsContainer = jobIDsContainer {
            jobIDsDecoded0 = [Swift.String]()
            for string0 in jobIDsContainer {
                if let string0 = string0 {
                    jobIDsDecoded0?.append(string0)
                }
            }
        }
        jobIDs = jobIDsDecoded0
        let fromDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Jobs.
    public struct DescribeJobsRequestFilters: Swift.Equatable {
        /// The start date in a date range query.
        public var fromDate: Swift.String?
        /// An array of Job IDs that should be returned. An empty array means all jobs.
        public var jobIDs: [Swift.String]?
        /// The end date in a date range query.
        public var toDate: Swift.String?

        public init (
            fromDate: Swift.String? = nil,
            jobIDs: [Swift.String]? = nil,
            toDate: Swift.String? = nil
        )
        {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }
    }

}

extension DescribeRecoveryInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeRecoveryInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeRecoveryInstances"
    }
}

public struct DescribeRecoveryInstancesInput: Swift.Equatable {
    /// A set of filters by which to return Recovery Instances.
    /// This member is required.
    public var filters: DrsClientTypes.DescribeRecoveryInstancesRequestFilters?
    /// Maximum number of Recovery Instances to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Recovery Instance to retrieve.
    public var nextToken: Swift.String?

    public init (
        filters: DrsClientTypes.DescribeRecoveryInstancesRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRecoveryInstancesInputBody: Swift.Equatable {
    let filters: DrsClientTypes.DescribeRecoveryInstancesRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeRecoveryInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeRecoveryInstancesRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRecoveryInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecoveryInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecoveryInstancesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecoveryInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRecoveryInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeRecoveryInstancesOutputResponse: Swift.Equatable {
    /// An array of Recovery Instances.
    public var items: [DrsClientTypes.RecoveryInstance]?
    /// The token of the next Recovery Instance to retrieve.
    public var nextToken: Swift.String?

    public init (
        items: [DrsClientTypes.RecoveryInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeRecoveryInstancesOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [DrsClientTypes.RecoveryInstance]?
}

extension DescribeRecoveryInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstance?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.RecoveryInstance]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.RecoveryInstance]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

extension DrsClientTypes.DescribeRecoveryInstancesRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceIDs = recoveryInstanceIDs {
            var recoveryInstanceIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recoveryInstanceIDs)
            for recoveryinstanceids0 in recoveryInstanceIDs {
                try recoveryInstanceIDsContainer.encode(recoveryinstanceids0)
            }
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recoveryInstanceIDs)
        var recoveryInstanceIDsDecoded0:[Swift.String]? = nil
        if let recoveryInstanceIDsContainer = recoveryInstanceIDsContainer {
            recoveryInstanceIDsDecoded0 = [Swift.String]()
            for string0 in recoveryInstanceIDsContainer {
                if let string0 = string0 {
                    recoveryInstanceIDsDecoded0?.append(string0)
                }
            }
        }
        recoveryInstanceIDs = recoveryInstanceIDsDecoded0
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Recovery Instances.
    public struct DescribeRecoveryInstancesRequestFilters: Swift.Equatable {
        /// An array of Recovery Instance IDs that should be returned. An empty array means all Recovery Instances.
        public var recoveryInstanceIDs: [Swift.String]?
        /// An array of Source Server IDs for which associated Recovery Instances should be returned.
        public var sourceServerIDs: [Swift.String]?

        public init (
            recoveryInstanceIDs: [Swift.String]? = nil,
            sourceServerIDs: [Swift.String]? = nil
        )
        {
            self.recoveryInstanceIDs = recoveryInstanceIDs
            self.sourceServerIDs = sourceServerIDs
        }
    }

}

extension DescribeRecoverySnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case order
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let order = order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DescribeRecoverySnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeRecoverySnapshots"
    }
}

public struct DescribeRecoverySnapshotsInput: Swift.Equatable {
    /// A set of filters by which to return Recovery Snapshots.
    public var filters: DrsClientTypes.DescribeRecoverySnapshotsRequestFilters?
    /// Maximum number of Recovery Snapshots to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Recovery Snapshot to retrieve.
    public var nextToken: Swift.String?
    /// The sorted ordering by which to return Recovery Snapshots.
    public var order: DrsClientTypes.RecoverySnapshotsOrder?
    /// Filter Recovery Snapshots by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        filters: DrsClientTypes.DescribeRecoverySnapshotsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        order: DrsClientTypes.RecoverySnapshotsOrder? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.order = order
        self.sourceServerID = sourceServerID
    }
}

struct DescribeRecoverySnapshotsInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let filters: DrsClientTypes.DescribeRecoverySnapshotsRequestFilters?
    let order: DrsClientTypes.RecoverySnapshotsOrder?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeRecoverySnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case order
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeRecoverySnapshotsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let orderDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoverySnapshotsOrder.self, forKey: .order)
        order = orderDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRecoverySnapshotsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRecoverySnapshotsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRecoverySnapshotsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRecoverySnapshotsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeRecoverySnapshotsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeRecoverySnapshotsOutputResponse: Swift.Equatable {
    /// An array of Recovery Snapshots.
    public var items: [DrsClientTypes.RecoverySnapshot]?
    /// The token of the next Recovery Snapshot to retrieve.
    public var nextToken: Swift.String?

    public init (
        items: [DrsClientTypes.RecoverySnapshot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeRecoverySnapshotsOutputResponseBody: Swift.Equatable {
    let items: [DrsClientTypes.RecoverySnapshot]?
    let nextToken: Swift.String?
}

extension DescribeRecoverySnapshotsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoverySnapshot?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.RecoverySnapshot]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.RecoverySnapshot]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DrsClientTypes.DescribeRecoverySnapshotsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDateTime
        case toDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDateTime = fromDateTime {
            try encodeContainer.encode(fromDateTime, forKey: .fromDateTime)
        }
        if let toDateTime = toDateTime {
            try encodeContainer.encode(toDateTime, forKey: .toDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDateTime)
        fromDateTime = fromDateTimeDecoded
        let toDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDateTime)
        toDateTime = toDateTimeDecoded
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Recovery Snapshots.
    public struct DescribeRecoverySnapshotsRequestFilters: Swift.Equatable {
        /// The start date in a date range query.
        public var fromDateTime: Swift.String?
        /// The end date in a date range query.
        public var toDateTime: Swift.String?

        public init (
            fromDateTime: Swift.String? = nil,
            toDateTime: Swift.String? = nil
        )
        {
            self.fromDateTime = fromDateTime
            self.toDateTime = toDateTime
        }
    }

}

extension DescribeReplicationConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs {
            var replicationConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationConfigurationTemplateIDs)
            for replicationconfigurationtemplateids0 in replicationConfigurationTemplateIDs {
                try replicationConfigurationTemplateIDsContainer.encode(replicationconfigurationtemplateids0)
            }
        }
    }
}

extension DescribeReplicationConfigurationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeReplicationConfigurationTemplates"
    }
}

public struct DescribeReplicationConfigurationTemplatesInput: Swift.Equatable {
    /// Maximum number of Replication Configuration Templates to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Replication Configuration Template to retrieve.
    public var nextToken: Swift.String?
    /// The IDs of the Replication Configuration Templates to retrieve. An empty list means all Replication Configuration Templates.
    /// This member is required.
    public var replicationConfigurationTemplateIDs: [Swift.String]?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        replicationConfigurationTemplateIDs: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
    }
}

struct DescribeReplicationConfigurationTemplatesInputBody: Swift.Equatable {
    let replicationConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationConfigurationTemplateIDs)
        var replicationConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let replicationConfigurationTemplateIDsContainer = replicationConfigurationTemplateIDsContainer {
            replicationConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in replicationConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    replicationConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeReplicationConfigurationTemplatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeReplicationConfigurationTemplatesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeReplicationConfigurationTemplatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeReplicationConfigurationTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeReplicationConfigurationTemplatesOutputResponse: Swift.Equatable {
    /// An array of Replication Configuration Templates.
    public var items: [DrsClientTypes.ReplicationConfigurationTemplate]?
    /// The token of the next Replication Configuration Template to retrieve.
    public var nextToken: Swift.String?

    public init (
        items: [DrsClientTypes.ReplicationConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeReplicationConfigurationTemplatesOutputResponseBody: Swift.Equatable {
    let items: [DrsClientTypes.ReplicationConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.ReplicationConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.ReplicationConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSourceServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSourceServers"
    }
}

public struct DescribeSourceServersInput: Swift.Equatable {
    /// A set of filters by which to return Source Servers.
    /// This member is required.
    public var filters: DrsClientTypes.DescribeSourceServersRequestFilters?
    /// Maximum number of Source Servers to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Source Server to retrieve.
    public var nextToken: Swift.String?

    public init (
        filters: DrsClientTypes.DescribeSourceServersRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersInputBody: Swift.Equatable {
    let filters: DrsClientTypes.DescribeSourceServersRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeSourceServersRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decode(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSourceServersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeSourceServersOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSourceServersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DescribeSourceServersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeSourceServersOutputResponse: Swift.Equatable {
    /// An array of Source Servers.
    public var items: [DrsClientTypes.SourceServer]?
    /// The token of the next Source Server to retrieve.
    public var nextToken: Swift.String?

    public init (
        items: [DrsClientTypes.SourceServer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersOutputResponseBody: Swift.Equatable {
    let items: [DrsClientTypes.SourceServer]?
    let nextToken: Swift.String?
}

extension DescribeSourceServersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.SourceServer?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.SourceServer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.SourceServer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DrsClientTypes.DescribeSourceServersRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hardwareId
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hardwareId = hardwareId {
            try encodeContainer.encode(hardwareId, forKey: .hardwareId)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for describesourceserversrequestfiltersids0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(describesourceserversrequestfiltersids0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let hardwareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hardwareId)
        hardwareId = hardwareIdDecoded
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Source Servers.
    public struct DescribeSourceServersRequestFilters: Swift.Equatable {
        /// An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.
        public var hardwareId: Swift.String?
        /// An array of Source Servers IDs that should be returned. An empty array means all Source Servers.
        public var sourceServerIDs: [Swift.String]?

        public init (
            hardwareId: Swift.String? = nil,
            sourceServerIDs: [Swift.String]? = nil
        )
        {
            self.hardwareId = hardwareId
            self.sourceServerIDs = sourceServerIDs
        }
    }

}

extension DisconnectRecoveryInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension DisconnectRecoveryInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectRecoveryInstance"
    }
}

public struct DisconnectRecoveryInstanceInput: Swift.Equatable {
    /// The ID of the Recovery Instance to disconnect.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init (
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct DisconnectRecoveryInstanceInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension DisconnectRecoveryInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension DisconnectRecoveryInstanceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectRecoveryInstanceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectRecoveryInstanceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectRecoveryInstanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisconnectRecoveryInstanceOutputResponse: Swift.Equatable {

}

extension DisconnectSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DisconnectSourceServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectSourceServer"
    }
}

public struct DisconnectSourceServerInput: Swift.Equatable {
    /// The ID of the Source Server to disconnect.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DisconnectSourceServerInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DisconnectSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DisconnectSourceServerOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectSourceServerOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DisconnectSourceServerOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectSourceServerOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: DisconnectSourceServerOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.lastLaunchResult = output.lastLaunchResult
            self.lifeCycle = output.lifeCycle
            self.recoveryInstanceId = output.recoveryInstanceId
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.lastLaunchResult = nil
            self.lifeCycle = nil
            self.recoveryInstanceId = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
        }
    }
}

public struct DisconnectSourceServerOutputResponse: Swift.Equatable {
    /// The ARN of the Source Server.
    public var arn: Swift.String?
    /// The Data Replication Info of the Source Server.
    public var dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    /// The status of the last recovery launch of this Source Server.
    public var lastLaunchResult: DrsClientTypes.LastLaunchResult?
    /// The lifecycle information of this Source Server.
    public var lifeCycle: DrsClientTypes.LifeCycle?
    /// The ID of the Recovery Instance associated with this Source Server.
    public var recoveryInstanceId: Swift.String?
    /// The source properties of the Source Server.
    public var sourceProperties: DrsClientTypes.SourceProperties?
    /// The ID of the Source Server.
    public var sourceServerID: Swift.String?
    /// The tags associated with the Source Server.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: DrsClientTypes.DataReplicationInfo? = nil,
        lastLaunchResult: DrsClientTypes.LastLaunchResult? = nil,
        lifeCycle: DrsClientTypes.LifeCycle? = nil,
        recoveryInstanceId: Swift.String? = nil,
        sourceProperties: DrsClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.lastLaunchResult = lastLaunchResult
        self.lifeCycle = lifeCycle
        self.recoveryInstanceId = recoveryInstanceId
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

struct DisconnectSourceServerOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let recoveryInstanceId: Swift.String?
    let lastLaunchResult: DrsClientTypes.LastLaunchResult?
    let dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    let lifeCycle: DrsClientTypes.LifeCycle?
    let sourceProperties: DrsClientTypes.SourceProperties?
}

extension DisconnectSourceServerOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case lastLaunchResult
        case lifeCycle
        case recoveryInstanceId
        case sourceProperties
        case sourceServerID
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recoveryInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceId)
        recoveryInstanceId = recoveryInstanceIdDecoded
        let lastLaunchResultDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchResult.self, forKey: .lastLaunchResult)
        lastLaunchResult = lastLaunchResultDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension DrsClientTypes.Disk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes
        case deviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let bytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytes)
        bytes = bytesDecoded
    }
}

extension DrsClientTypes {
    /// An object representing a data storage device on a server.
    public struct Disk: Swift.Equatable {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The disk or device name.
        public var deviceName: Swift.String?

        public init (
            bytes: Swift.Int = 0,
            deviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.deviceName = deviceName
        }
    }

}

extension DrsClientTypes {
    public enum EC2InstanceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notFound
        case pending
        case running
        case shuttingDown
        case stopped
        case stopping
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [EC2InstanceState] {
            return [
                .notFound,
                .pending,
                .running,
                .shuttingDown,
                .stopped,
                .stopping,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notFound: return "NOT_FOUND"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .shuttingDown: return "SHUTTING-DOWN"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EC2InstanceState(rawValue: rawValue) ?? EC2InstanceState.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum FailbackReplicationError: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentNotSeen
        case failbackClientNotSeen
        case failedToConfigureReplicationSoftware
        case failedToDownloadReplicationSoftwareToFailbackClient
        case failedToEstablishAgentReplicatorSoftwareCommunication
        case failedToEstablishRecoveryInstanceCommunication
        case failedToPairAgentWithReplicationSoftware
        case notConverging
        case unstableNetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [FailbackReplicationError] {
            return [
                .agentNotSeen,
                .failbackClientNotSeen,
                .failedToConfigureReplicationSoftware,
                .failedToDownloadReplicationSoftwareToFailbackClient,
                .failedToEstablishAgentReplicatorSoftwareCommunication,
                .failedToEstablishRecoveryInstanceCommunication,
                .failedToPairAgentWithReplicationSoftware,
                .notConverging,
                .unstableNetwork,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failbackClientNotSeen: return "FAILBACK_CLIENT_NOT_SEEN"
            case .failedToConfigureReplicationSoftware: return "FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE"
            case .failedToDownloadReplicationSoftwareToFailbackClient: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"
            case .failedToEstablishAgentReplicatorSoftwareCommunication: return "FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"
            case .failedToEstablishRecoveryInstanceCommunication: return "FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"
            case .failedToPairAgentWithReplicationSoftware: return "FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE"
            case .notConverging: return "NOT_CONVERGING"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailbackReplicationError(rawValue: rawValue) ?? FailbackReplicationError.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum FailbackState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failbackCompleted
        case failbackError
        case failbackInProgress
        case failbackNotStarted
        case failbackReadyForLaunch
        case sdkUnknown(Swift.String)

        public static var allCases: [FailbackState] {
            return [
                .failbackCompleted,
                .failbackError,
                .failbackInProgress,
                .failbackNotStarted,
                .failbackReadyForLaunch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failbackCompleted: return "FAILBACK_COMPLETED"
            case .failbackError: return "FAILBACK_ERROR"
            case .failbackInProgress: return "FAILBACK_IN_PROGRESS"
            case .failbackNotStarted: return "FAILBACK_NOT_STARTED"
            case .failbackReadyForLaunch: return "FAILBACK_READY_FOR_LAUNCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailbackState(rawValue: rawValue) ?? FailbackState.sdkUnknown(rawValue)
        }
    }
}

extension GetFailbackReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension GetFailbackReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetFailbackReplicationConfiguration"
    }
}

public struct GetFailbackReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the Recovery Instance whose failback replication configuration should be returned.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init (
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct GetFailbackReplicationConfigurationInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension GetFailbackReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension GetFailbackReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFailbackReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFailbackReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFailbackReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetFailbackReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.bandwidthThrottling = output.bandwidthThrottling
            self.name = output.name
            self.recoveryInstanceID = output.recoveryInstanceID
            self.usePrivateIP = output.usePrivateIP
        } else {
            self.bandwidthThrottling = 0
            self.name = nil
            self.recoveryInstanceID = nil
            self.usePrivateIP = nil
        }
    }
}

public struct GetFailbackReplicationConfigurationOutputResponse: Swift.Equatable {
    /// Configure bandwidth throttling for the outbound data transfer rate of the Recovery Instance in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// The name of the Failback Replication Configuration.
    public var name: Swift.String?
    /// The ID of the Recovery Instance.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?
    /// Whether to use Private IP for the failback replication of the Recovery Instance.
    public var usePrivateIP: Swift.Bool?

    public init (
        bandwidthThrottling: Swift.Int = 0,
        name: Swift.String? = nil,
        recoveryInstanceID: Swift.String? = nil,
        usePrivateIP: Swift.Bool? = nil
    )
    {
        self.bandwidthThrottling = bandwidthThrottling
        self.name = name
        self.recoveryInstanceID = recoveryInstanceID
        self.usePrivateIP = usePrivateIP
    }
}

struct GetFailbackReplicationConfigurationOutputResponseBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
    let name: Swift.String?
    let bandwidthThrottling: Swift.Int
    let usePrivateIP: Swift.Bool?
}

extension GetFailbackReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthThrottling
        case name
        case recoveryInstanceID
        case usePrivateIP
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let usePrivateIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .usePrivateIP)
        usePrivateIP = usePrivateIPDecoded
    }
}

extension GetLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLaunchConfiguration"
    }
}

public struct GetLaunchConfigurationInput: Swift.Equatable {
    /// The ID of the Source Server that we want to retrieve a Launch Configuration for.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetLaunchConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLaunchConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLaunchConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLaunchConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct GetLaunchConfigurationOutputResponse: Swift.Equatable {
    /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
    public var copyPrivateIp: Swift.Bool?
    /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
    public var copyTags: Swift.Bool?
    /// The EC2 launch template ID of this launch configuration.
    public var ec2LaunchTemplateID: Swift.String?
    /// The state of the Recovery Instance in EC2 after the recovery operation.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// The licensing configuration to be used for this launch configuration.
    public var licensing: DrsClientTypes.Licensing?
    /// The name of the launch configuration.
    public var name: Swift.String?
    /// The ID of the Source Server for this launch configuration.
    public var sourceServerID: Swift.String?
    /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct GetLaunchConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
}

extension GetLaunchConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

extension GetReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetReplicationConfiguration"
    }
}

public struct GetReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the Source Serve for this Replication Configuration.r
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: GetReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.pitPolicy = output.pitPolicy
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.pitPolicy = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct GetReplicationConfigurationOutputResponse: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The name of the Replication Configuration.
    public var name: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The configuration of the disks of the Source Server to be replicated.
    public var replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The ID of the Source Server for this Replication Configuration.
    public var sourceServerID: Swift.String?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.pitPolicy = pitPolicy
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct GetReplicationConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
}

extension GetReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
    }
}

extension DrsClientTypes.IdentificationHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsInstanceID
        case fqdn
        case hostname
        case vmWareUuid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsInstanceID = awsInstanceID {
            try encodeContainer.encode(awsInstanceID, forKey: .awsInstanceID)
        }
        if let fqdn = fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let vmWareUuid = vmWareUuid {
            try encodeContainer.encode(vmWareUuid, forKey: .vmWareUuid)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fqdnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vmWareUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmWareUuid)
        vmWareUuid = vmWareUuidDecoded
        let awsInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsInstanceID)
        awsInstanceID = awsInstanceIDDecoded
    }
}

extension DrsClientTypes {
    /// Hints used to uniquely identify a machine.
    public struct IdentificationHints: Swift.Equatable {
        /// AWS Instance ID identification hint.
        public var awsInstanceID: Swift.String?
        /// Fully Qualified Domain Name identification hint.
        public var fqdn: Swift.String?
        /// Hostname identification hint.
        public var hostname: Swift.String?
        /// vCenter VM path identification hint.
        public var vmWareUuid: Swift.String?

        public init (
            awsInstanceID: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            hostname: Swift.String? = nil,
            vmWareUuid: Swift.String? = nil
        )
        {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmWareUuid = vmWareUuid
        }
    }

}

extension InitializeServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/InitializeService"
    }
}

public struct InitializeServiceInput: Swift.Equatable {

}

struct InitializeServiceInputBody: Swift.Equatable {
}

extension InitializeServiceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension InitializeServiceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InitializeServiceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InitializeServiceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InitializeServiceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct InitializeServiceOutputResponse: Swift.Equatable {

}

extension DrsClientTypes {
    public enum InitiatedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case diagnostic
        case failback
        case startDrill
        case startRecovery
        case terminateRecoveryInstances
        case sdkUnknown(Swift.String)

        public static var allCases: [InitiatedBy] {
            return [
                .diagnostic,
                .failback,
                .startDrill,
                .startRecovery,
                .terminateRecoveryInstances,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .diagnostic: return "DIAGNOSTIC"
            case .failback: return "FAILBACK"
            case .startDrill: return "START_DRILL"
            case .startRecovery: return "START_RECOVERY"
            case .terminateRecoveryInstances: return "TERMINATE_RECOVERY_INSTANCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InitiatedBy(rawValue: rawValue) ?? InitiatedBy.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.retryAfterSeconds = 0
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?
    /// The number of seconds after which the request should be safe to retry.
    public var retryAfterSeconds: Swift.Int

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DrsClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case endDateTime
        case initiatedBy
        case jobID
        case participatingServers
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let initiatedBy = initiatedBy {
            try encodeContainer.encode(initiatedBy.rawValue, forKey: .initiatedBy)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let participatingServers = participatingServers {
            var participatingServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participatingServers)
            for participatingservers0 in participatingServers {
                try participatingServersContainer.encode(participatingservers0)
            }
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobType.self, forKey: .type)
        type = typeDecoded
        let initiatedByDecoded = try containerValues.decodeIfPresent(DrsClientTypes.InitiatedBy.self, forKey: .initiatedBy)
        initiatedBy = initiatedByDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let participatingServersContainer = try containerValues.decodeIfPresent([DrsClientTypes.ParticipatingServer?].self, forKey: .participatingServers)
        var participatingServersDecoded0:[DrsClientTypes.ParticipatingServer]? = nil
        if let participatingServersContainer = participatingServersContainer {
            participatingServersDecoded0 = [DrsClientTypes.ParticipatingServer]()
            for structure0 in participatingServersContainer {
                if let structure0 = structure0 {
                    participatingServersDecoded0?.append(structure0)
                }
            }
        }
        participatingServers = participatingServersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DrsClientTypes {
    /// A job is an asynchronous workflow.
    public struct Job: Swift.Equatable {
        /// The ARN of a Job.
        public var arn: Swift.String?
        /// The date and time of when the Job was created.
        public var creationDateTime: Swift.String?
        /// The date and time of when the Job ended.
        public var endDateTime: Swift.String?
        /// A string representing who initiated the Job.
        public var initiatedBy: DrsClientTypes.InitiatedBy?
        /// The ID of the Job.
        /// This member is required.
        public var jobID: Swift.String?
        /// A list of servers that the Job is acting upon.
        public var participatingServers: [DrsClientTypes.ParticipatingServer]?
        /// The status of the Job.
        public var status: DrsClientTypes.JobStatus?
        /// A list of tags associated with the Job.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the Job.
        public var type: DrsClientTypes.JobType?

        public init (
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            initiatedBy: DrsClientTypes.InitiatedBy? = nil,
            jobID: Swift.String? = nil,
            participatingServers: [DrsClientTypes.ParticipatingServer]? = nil,
            status: DrsClientTypes.JobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: DrsClientTypes.JobType? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension DrsClientTypes.JobLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventData
        case logDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let eventData = eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let logDateTime = logDateTime {
            try encodeContainer.encode(logDateTime, forKey: .logDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logDateTime)
        logDateTime = logDateTimeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobLogEvent.self, forKey: .event)
        event = eventDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobLogEventData.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension DrsClientTypes {
    /// A log outputted by a Job.
    public struct JobLog: Swift.Equatable {
        /// The event represents the type of a log.
        public var event: DrsClientTypes.JobLogEvent?
        /// Metadata associated with a Job log.
        public var eventData: DrsClientTypes.JobLogEventData?
        /// The date and time the log was taken.
        public var logDateTime: Swift.String?

        public init (
            event: DrsClientTypes.JobLogEvent? = nil,
            eventData: DrsClientTypes.JobLogEventData? = nil,
            logDateTime: Swift.String? = nil
        )
        {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }
    }

}

extension DrsClientTypes {
    public enum JobLogEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cleanupEnd
        case cleanupFail
        case cleanupStart
        case conversionEnd
        case conversionFail
        case conversionStart
        case jobCancel
        case jobEnd
        case jobStart
        case launchFailed
        case launchStart
        case serverSkipped
        case snapshotEnd
        case snapshotFail
        case snapshotStart
        case usingPreviousSnapshot
        case usingPreviousSnapshotFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLogEvent] {
            return [
                .cleanupEnd,
                .cleanupFail,
                .cleanupStart,
                .conversionEnd,
                .conversionFail,
                .conversionStart,
                .jobCancel,
                .jobEnd,
                .jobStart,
                .launchFailed,
                .launchStart,
                .serverSkipped,
                .snapshotEnd,
                .snapshotFail,
                .snapshotStart,
                .usingPreviousSnapshot,
                .usingPreviousSnapshotFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cleanupEnd: return "CLEANUP_END"
            case .cleanupFail: return "CLEANUP_FAIL"
            case .cleanupStart: return "CLEANUP_START"
            case .conversionEnd: return "CONVERSION_END"
            case .conversionFail: return "CONVERSION_FAIL"
            case .conversionStart: return "CONVERSION_START"
            case .jobCancel: return "JOB_CANCEL"
            case .jobEnd: return "JOB_END"
            case .jobStart: return "JOB_START"
            case .launchFailed: return "LAUNCH_FAILED"
            case .launchStart: return "LAUNCH_START"
            case .serverSkipped: return "SERVER_SKIPPED"
            case .snapshotEnd: return "SNAPSHOT_END"
            case .snapshotFail: return "SNAPSHOT_FAIL"
            case .snapshotStart: return "SNAPSHOT_START"
            case .usingPreviousSnapshot: return "USING_PREVIOUS_SNAPSHOT"
            case .usingPreviousSnapshotFailed: return "USING_PREVIOUS_SNAPSHOT_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobLogEvent(rawValue: rawValue) ?? JobLogEvent.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.JobLogEventData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionServerID
        case rawError
        case sourceServerID
        case targetInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversionServerID = conversionServerID {
            try encodeContainer.encode(conversionServerID, forKey: .conversionServerID)
        }
        if let rawError = rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceID = targetInstanceID {
            try encodeContainer.encode(targetInstanceID, forKey: .targetInstanceID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let conversionServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversionServerID)
        conversionServerID = conversionServerIDDecoded
        let targetInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetInstanceID)
        targetInstanceID = targetInstanceIDDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension DrsClientTypes {
    /// Metadata associated with a Job log.
    public struct JobLogEventData: Swift.Equatable {
        /// The ID of a conversion server.
        public var conversionServerID: Swift.String?
        /// A string representing a job error.
        public var rawError: Swift.String?
        /// The ID of a Source Server.
        public var sourceServerID: Swift.String?
        /// The ID of a Recovery Instance.
        public var targetInstanceID: Swift.String?

        public init (
            conversionServerID: Swift.String? = nil,
            rawError: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            targetInstanceID: Swift.String? = nil
        )
        {
            self.conversionServerID = conversionServerID
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }
    }

}

extension DrsClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case pending
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .pending,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case launch
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .launch,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .launch: return "LAUNCH"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LastLaunchResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case notStarted
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LastLaunchResult] {
            return [
                .failed,
                .notStarted,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .notStarted: return "NOT_STARTED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastLaunchResult(rawValue: rawValue) ?? LastLaunchResult.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LastLaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case drill
        case recovery
        case sdkUnknown(Swift.String)

        public static var allCases: [LastLaunchType] {
            return [
                .drill,
                .recovery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .drill: return "DRILL"
            case .recovery: return "RECOVERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastLaunchType(rawValue: rawValue) ?? LastLaunchType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LaunchDisposition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchDisposition] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchDisposition(rawValue: rawValue) ?? LaunchDisposition.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case launched
        case pending
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .failed,
                .inProgress,
                .launched,
                .pending,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .pending: return "PENDING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.Licensing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osByol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osByol = osByol {
            try encodeContainer.encode(osByol, forKey: .osByol)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osByolDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .osByol)
        osByol = osByolDecoded
    }
}

extension DrsClientTypes {
    /// Configuration of a machine's license.
    public struct Licensing: Swift.Equatable {
        /// Whether to enable "Bring your own license" or not.
        public var osByol: Swift.Bool?

        public init (
            osByol: Swift.Bool? = nil
        )
        {
            self.osByol = osByol
        }
    }

}

extension DrsClientTypes.LifeCycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedToServiceDateTime
        case elapsedReplicationDuration
        case firstByteDateTime
        case lastLaunch
        case lastSeenByServiceDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToServiceDateTime = addedToServiceDateTime {
            try encodeContainer.encode(addedToServiceDateTime, forKey: .addedToServiceDateTime)
        }
        if let elapsedReplicationDuration = elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let firstByteDateTime = firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let lastLaunch = lastLaunch {
            try encodeContainer.encode(lastLaunch, forKey: .lastLaunch)
        }
        if let lastSeenByServiceDateTime = lastSeenByServiceDateTime {
            try encodeContainer.encode(lastSeenByServiceDateTime, forKey: .lastSeenByServiceDateTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addedToServiceDateTime)
        addedToServiceDateTime = addedToServiceDateTimeDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
        let lastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenByServiceDateTime)
        lastSeenByServiceDateTime = lastSeenByServiceDateTimeDecoded
        let lastLaunchDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycleLastLaunch.self, forKey: .lastLaunch)
        lastLaunch = lastLaunchDecoded
    }
}

extension DrsClientTypes {
    /// An object representing the Source Server Lifecycle.
    public struct LifeCycle: Swift.Equatable {
        /// The date and time of when the Source Server was added to the service.
        public var addedToServiceDateTime: Swift.String?
        /// The amount of time that the Source Server has been replicating for.
        public var elapsedReplicationDuration: Swift.String?
        /// The date and time of the first byte that was replicated from the Source Server.
        public var firstByteDateTime: Swift.String?
        /// An object containing information regarding the last launch of the Source Server.
        public var lastLaunch: DrsClientTypes.LifeCycleLastLaunch?
        /// The date and time this Source Server was last seen by the service.
        public var lastSeenByServiceDateTime: Swift.String?

        public init (
            addedToServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            firstByteDateTime: Swift.String? = nil,
            lastLaunch: DrsClientTypes.LifeCycleLastLaunch? = nil,
            lastSeenByServiceDateTime: Swift.String? = nil
        )
        {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastLaunch = lastLaunch
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
        }
    }

}

extension DrsClientTypes.LifeCycleLastLaunch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiated
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiated = initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycleLastLaunchInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
    }
}

extension DrsClientTypes {
    /// An object containing information regarding the last launch of a Source Server.
    public struct LifeCycleLastLaunch: Swift.Equatable {
        /// An object containing information regarding the initiation of the last launch of a Source Server.
        public var initiated: DrsClientTypes.LifeCycleLastLaunchInitiated?

        public init (
            initiated: DrsClientTypes.LifeCycleLastLaunchInitiated? = nil
        )
        {
            self.initiated = initiated
        }
    }

}

extension DrsClientTypes.LifeCycleLastLaunchInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DrsClientTypes {
    /// An object containing information regarding the initiation of the last launch of a Source Server.
    public struct LifeCycleLastLaunchInitiated: Swift.Equatable {
        /// The date and time the last Source Server launch was initiated.
        public var apiCallDateTime: Swift.String?
        /// The ID of the Job that was used to last launch the Source Server.
        public var jobID: Swift.String?
        /// The Job type that was used to last launch the Source Server.
        public var type: DrsClientTypes.LastLaunchType?

        public init (
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil,
            type: DrsClientTypes.LastLaunchType? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
            self.type = type
        }
    }

}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource whose tags should be returned.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags of the requested resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DrsClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ips
        case isPrimary
        case macAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for ipslist0 in ips {
                try ipsContainer.encode(ipslist0)
            }
        }
        if let isPrimary = isPrimary {
            try encodeContainer.encode(isPrimary, forKey: .isPrimary)
        }
        if let macAddress = macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ips)
        var ipsDecoded0:[Swift.String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [Swift.String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
        let isPrimaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrimary)
        isPrimary = isPrimaryDecoded
    }
}

extension DrsClientTypes {
    /// Network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// Network interface IPs.
        public var ips: [Swift.String]?
        /// Whether this is the primary network interface.
        public var isPrimary: Swift.Bool?
        /// The MAC address of the network interface.
        public var macAddress: Swift.String?

        public init (
            ips: [Swift.String]? = nil,
            isPrimary: Swift.Bool? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }
    }

}

extension DrsClientTypes.OS: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fullString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fullString = fullString {
            try encodeContainer.encode(fullString, forKey: .fullString)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullString)
        fullString = fullStringDecoded
    }
}

extension DrsClientTypes {
    /// Operating System.
    public struct OS: Swift.Equatable {
        /// The long name of the Operating System.
        public var fullString: Swift.String?

        public init (
            fullString: Swift.String? = nil
        )
        {
            self.fullString = fullString
        }
    }

}

extension DrsClientTypes.PITPolicyRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case interval
        case retentionDuration
        case ruleID
        case units
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if retentionDuration != 0 {
            try encodeContainer.encode(retentionDuration, forKey: .retentionDuration)
        }
        if ruleID != 0 {
            try encodeContainer.encode(ruleID, forKey: .ruleID)
        }
        if let units = units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIDDecoded = try containerValues.decode(Swift.Int.self, forKey: .ruleID)
        ruleID = ruleIDDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(DrsClientTypes.PITPolicyRuleUnits.self, forKey: .units)
        units = unitsDecoded
        let intervalDecoded = try containerValues.decode(Swift.Int.self, forKey: .interval)
        interval = intervalDecoded
        let retentionDurationDecoded = try containerValues.decode(Swift.Int.self, forKey: .retentionDuration)
        retentionDuration = retentionDurationDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DrsClientTypes {
    /// A rule in the Point in Time (PIT) policy representing when to take snapshots and how long to retain them for.
    public struct PITPolicyRule: Swift.Equatable {
        /// Whether this rule is enabled or not.
        public var enabled: Swift.Bool?
        /// How often, in the chosen units, a snapshot should be taken.
        /// This member is required.
        public var interval: Swift.Int
        /// The duration to retain a snapshot for, in the chosen units.
        /// This member is required.
        public var retentionDuration: Swift.Int
        /// The ID of the rule.
        public var ruleID: Swift.Int
        /// The units used to measure the interval and retentionDuration.
        /// This member is required.
        public var units: DrsClientTypes.PITPolicyRuleUnits?

        public init (
            enabled: Swift.Bool? = nil,
            interval: Swift.Int = 0,
            retentionDuration: Swift.Int = 0,
            ruleID: Swift.Int = 0,
            units: DrsClientTypes.PITPolicyRuleUnits? = nil
        )
        {
            self.enabled = enabled
            self.interval = interval
            self.retentionDuration = retentionDuration
            self.ruleID = ruleID
            self.units = units
        }
    }

}

extension DrsClientTypes {
    public enum PITPolicyRuleUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case minute
        case sdkUnknown(Swift.String)

        public static var allCases: [PITPolicyRuleUnits] {
            return [
                .day,
                .hour,
                .minute,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PITPolicyRuleUnits(rawValue: rawValue) ?? PITPolicyRuleUnits.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.ParticipatingServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchStatus
        case recoveryInstanceID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchStatus = launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let recoveryInstanceID = recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
    }
}

extension DrsClientTypes {
    /// Represents a server participating in an asynchronous Job.
    public struct ParticipatingServer: Swift.Equatable {
        /// The launch status of a participating server.
        public var launchStatus: DrsClientTypes.LaunchStatus?
        /// The Recovery Instance ID of a participating server.
        public var recoveryInstanceID: Swift.String?
        /// The Source Server ID of a participating server.
        public var sourceServerID: Swift.String?

        public init (
            launchStatus: DrsClientTypes.LaunchStatus? = nil,
            recoveryInstanceID: Swift.String? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.launchStatus = launchStatus
            self.recoveryInstanceID = recoveryInstanceID
            self.sourceServerID = sourceServerID
        }
    }

}

extension DrsClientTypes.RecoveryInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case ec2InstanceID
        case ec2InstanceState
        case failback
        case isDrill
        case jobID
        case pointInTimeSnapshotDateTime
        case recoveryInstanceID
        case recoveryInstanceProperties
        case sourceServerID
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataReplicationInfo = dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let ec2InstanceID = ec2InstanceID {
            try encodeContainer.encode(ec2InstanceID, forKey: .ec2InstanceID)
        }
        if let ec2InstanceState = ec2InstanceState {
            try encodeContainer.encode(ec2InstanceState.rawValue, forKey: .ec2InstanceState)
        }
        if let failback = failback {
            try encodeContainer.encode(failback, forKey: .failback)
        }
        if let isDrill = isDrill {
            try encodeContainer.encode(isDrill, forKey: .isDrill)
        }
        if let jobID = jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let pointInTimeSnapshotDateTime = pointInTimeSnapshotDateTime {
            try encodeContainer.encode(pointInTimeSnapshotDateTime, forKey: .pointInTimeSnapshotDateTime)
        }
        if let recoveryInstanceID = recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
        if let recoveryInstanceProperties = recoveryInstanceProperties {
            try encodeContainer.encode(recoveryInstanceProperties, forKey: .recoveryInstanceProperties)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceID)
        ec2InstanceID = ec2InstanceIDDecoded
        let ec2InstanceStateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.EC2InstanceState.self, forKey: .ec2InstanceState)
        ec2InstanceState = ec2InstanceStateDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let failbackDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceFailback.self, forKey: .failback)
        failback = failbackDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let recoveryInstancePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceProperties.self, forKey: .recoveryInstanceProperties)
        recoveryInstanceProperties = recoveryInstancePropertiesDecoded
        let pointInTimeSnapshotDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pointInTimeSnapshotDateTime)
        pointInTimeSnapshotDateTime = pointInTimeSnapshotDateTimeDecoded
        let isDrillDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDrill)
        isDrill = isDrillDecoded
    }
}

extension DrsClientTypes {
    /// A Recovery Instance is a replica of a Source Server running on EC2.
    public struct RecoveryInstance: Swift.Equatable {
        /// The ARN of the Recovery Instance.
        public var arn: Swift.String?
        /// The Data Replication Info of the Recovery Instance.
        public var dataReplicationInfo: DrsClientTypes.RecoveryInstanceDataReplicationInfo?
        /// The EC2 instance ID of the Recovery Instance.
        public var ec2InstanceID: Swift.String?
        /// The state of the EC2 instance for this Recovery Instance.
        public var ec2InstanceState: DrsClientTypes.EC2InstanceState?
        /// An object representing failback related information of the Recovery Instance.
        public var failback: DrsClientTypes.RecoveryInstanceFailback?
        /// Whether this Recovery Instance was created for a drill or for an actual Recovery event.
        public var isDrill: Swift.Bool?
        /// The ID of the Job that created the Recovery Instance.
        public var jobID: Swift.String?
        /// The date and time of the Point in Time (PIT) snapshot that this Recovery Instance was launched from.
        public var pointInTimeSnapshotDateTime: Swift.String?
        /// The ID of the Recovery Instance.
        public var recoveryInstanceID: Swift.String?
        /// Properties of the Recovery Instance machine.
        public var recoveryInstanceProperties: DrsClientTypes.RecoveryInstanceProperties?
        /// The Source Server ID that this Recovery Instance is associated with.
        public var sourceServerID: Swift.String?
        /// An array of tags that are associated with the Recovery Instance.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dataReplicationInfo: DrsClientTypes.RecoveryInstanceDataReplicationInfo? = nil,
            ec2InstanceID: Swift.String? = nil,
            ec2InstanceState: DrsClientTypes.EC2InstanceState? = nil,
            failback: DrsClientTypes.RecoveryInstanceFailback? = nil,
            isDrill: Swift.Bool? = nil,
            jobID: Swift.String? = nil,
            pointInTimeSnapshotDateTime: Swift.String? = nil,
            recoveryInstanceID: Swift.String? = nil,
            recoveryInstanceProperties: DrsClientTypes.RecoveryInstanceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.ec2InstanceID = ec2InstanceID
            self.ec2InstanceState = ec2InstanceState
            self.failback = failback
            self.isDrill = isDrill
            self.jobID = jobID
            self.pointInTimeSnapshotDateTime = pointInTimeSnapshotDateTime
            self.recoveryInstanceID = recoveryInstanceID
            self.recoveryInstanceProperties = recoveryInstanceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.FailbackReplicationError.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension DrsClientTypes {
    /// Error in data replication.
    public struct RecoveryInstanceDataReplicationError: Swift.Equatable {
        /// Error in data replication.
        public var error: DrsClientTypes.FailbackReplicationError?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init (
            error: DrsClientTypes.FailbackReplicationError? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case replicatedDisks
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for recoveryinstancedatareplicationinforeplicateddisks0 in replicatedDisks {
                try replicatedDisksContainer.encode(recoveryinstancedatareplicationinforeplicateddisks0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
    }
}

extension DrsClientTypes {
    /// Information about Data Replication
    public struct RecoveryInstanceDataReplicationInfo: Swift.Equatable {
        /// Information about Data Replication
        public var dataReplicationError: DrsClientTypes.RecoveryInstanceDataReplicationError?
        /// Information about whether the data replication has been initiated.
        public var dataReplicationInitiation: DrsClientTypes.RecoveryInstanceDataReplicationInitiation?
        /// The state of the data replication.
        public var dataReplicationState: DrsClientTypes.RecoveryInstanceDataReplicationState?
        /// An estimate of when the data replication will be completed.
        public var etaDateTime: Swift.String?
        /// Data replication lag duration.
        public var lagDuration: Swift.String?
        /// The disks that should be replicated.
        public var replicatedDisks: [DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]?

        public init (
            dataReplicationError: DrsClientTypes.RecoveryInstanceDataReplicationError? = nil,
            dataReplicationInitiation: DrsClientTypes.RecoveryInstanceDataReplicationInitiation? = nil,
            dataReplicationState: DrsClientTypes.RecoveryInstanceDataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            replicatedDisks: [DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.replicatedDisks = replicatedDisks
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .totalStorageBytes)
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .replicatedStorageBytes)
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .rescannedStorageBytes)
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .backloggedStorageBytes)
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension DrsClientTypes {
    /// A disk that should be replicated.
    public struct RecoveryInstanceDataReplicationInfoReplicatedDisk: Swift.Equatable {
        /// The size of the replication backlog in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// The name of the device.
        public var deviceName: Swift.String?
        /// The amount of data replicated so far in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// The amount of data to be rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// The total amount of data to be replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init (
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInitiation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startDateTime
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startDateTime = startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recoveryinstancedatareplicationinitiationsteps0 in steps {
                try stepsContainer.encode(recoveryinstancedatareplicationinitiationsteps0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension DrsClientTypes {
    /// Data replication initiation.
    public struct RecoveryInstanceDataReplicationInitiation: Swift.Equatable {
        /// The date and time of the current attempt to initiate data replication.
        public var startDateTime: Swift.String?
        /// The steps of the current attempt to initiate data replication.
        public var steps: [DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]?

        public init (
            startDateTime: Swift.String? = nil,
            steps: [DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]? = nil
        )
        {
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DrsClientTypes {
    /// Data replication initiation step.
    public struct RecoveryInstanceDataReplicationInitiationStep: Swift.Equatable {
        /// The name of the step.
        public var name: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepName?
        /// The status of the step.
        public var status: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepStatus?

        public init (
            name: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepName? = nil,
            status: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension DrsClientTypes {
    public enum RecoveryInstanceDataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completeVolumeMapping
        case configureReplicationSoftware
        case downloadReplicationSoftwareToFailbackClient
        case establishAgentReplicatorSoftwareCommunication
        case establishRecoveryInstanceCommunication
        case linkFailbackClientWithRecoveryInstance
        case pairAgentWithReplicationSoftware
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryInstanceDataReplicationInitiationStepName] {
            return [
                .completeVolumeMapping,
                .configureReplicationSoftware,
                .downloadReplicationSoftwareToFailbackClient,
                .establishAgentReplicatorSoftwareCommunication,
                .establishRecoveryInstanceCommunication,
                .linkFailbackClientWithRecoveryInstance,
                .pairAgentWithReplicationSoftware,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completeVolumeMapping: return "COMPLETE_VOLUME_MAPPING"
            case .configureReplicationSoftware: return "CONFIGURE_REPLICATION_SOFTWARE"
            case .downloadReplicationSoftwareToFailbackClient: return "DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"
            case .establishAgentReplicatorSoftwareCommunication: return "ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"
            case .establishRecoveryInstanceCommunication: return "ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"
            case .linkFailbackClientWithRecoveryInstance: return "LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE"
            case .pairAgentWithReplicationSoftware: return "PAIR_AGENT_WITH_REPLICATION_SOFTWARE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryInstanceDataReplicationInitiationStepName(rawValue: rawValue) ?? RecoveryInstanceDataReplicationInitiationStepName.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum RecoveryInstanceDataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryInstanceDataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryInstanceDataReplicationInitiationStepStatus(rawValue: rawValue) ?? RecoveryInstanceDataReplicationInitiationStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum RecoveryInstanceDataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case paused
        case rescan
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryInstanceDataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .paused,
                .rescan,
                .stalled,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .paused: return "PAUSED"
            case .rescan: return "RESCAN"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryInstanceDataReplicationState(rawValue: rawValue) ?? RecoveryInstanceDataReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.RecoveryInstanceDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes
        case ebsVolumeID
        case internalDeviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let ebsVolumeID = ebsVolumeID {
            try encodeContainer.encode(ebsVolumeID, forKey: .ebsVolumeID)
        }
        if let internalDeviceName = internalDeviceName {
            try encodeContainer.encode(internalDeviceName, forKey: .internalDeviceName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let internalDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internalDeviceName)
        internalDeviceName = internalDeviceNameDecoded
        let bytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .bytes)
        bytes = bytesDecoded
        let ebsVolumeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsVolumeID)
        ebsVolumeID = ebsVolumeIDDecoded
    }
}

extension DrsClientTypes {
    /// An object representing a block storage device on the Recovery Instance.
    public struct RecoveryInstanceDisk: Swift.Equatable {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The EBS Volume ID of this disk.
        public var ebsVolumeID: Swift.String?
        /// The internal device name of this disk. This is the name that is visible on the machine itself and not from the EC2 console.
        public var internalDeviceName: Swift.String?

        public init (
            bytes: Swift.Int = 0,
            ebsVolumeID: Swift.String? = nil,
            internalDeviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.ebsVolumeID = ebsVolumeID
            self.internalDeviceName = internalDeviceName
        }
    }

}

extension DrsClientTypes.RecoveryInstanceFailback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentLastSeenByServiceDateTime
        case elapsedReplicationDuration
        case failbackClientID
        case failbackClientLastSeenByServiceDateTime
        case failbackInitiationTime
        case failbackJobID
        case failbackToOriginalServer
        case firstByteDateTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentLastSeenByServiceDateTime = agentLastSeenByServiceDateTime {
            try encodeContainer.encode(agentLastSeenByServiceDateTime, forKey: .agentLastSeenByServiceDateTime)
        }
        if let elapsedReplicationDuration = elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let failbackClientID = failbackClientID {
            try encodeContainer.encode(failbackClientID, forKey: .failbackClientID)
        }
        if let failbackClientLastSeenByServiceDateTime = failbackClientLastSeenByServiceDateTime {
            try encodeContainer.encode(failbackClientLastSeenByServiceDateTime, forKey: .failbackClientLastSeenByServiceDateTime)
        }
        if let failbackInitiationTime = failbackInitiationTime {
            try encodeContainer.encode(failbackInitiationTime, forKey: .failbackInitiationTime)
        }
        if let failbackJobID = failbackJobID {
            try encodeContainer.encode(failbackJobID, forKey: .failbackJobID)
        }
        if let failbackToOriginalServer = failbackToOriginalServer {
            try encodeContainer.encode(failbackToOriginalServer, forKey: .failbackToOriginalServer)
        }
        if let firstByteDateTime = firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failbackClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackClientID)
        failbackClientID = failbackClientIDDecoded
        let failbackJobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackJobID)
        failbackJobID = failbackJobIDDecoded
        let failbackInitiationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackInitiationTime)
        failbackInitiationTime = failbackInitiationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.FailbackState.self, forKey: .state)
        state = stateDecoded
        let agentLastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentLastSeenByServiceDateTime)
        agentLastSeenByServiceDateTime = agentLastSeenByServiceDateTimeDecoded
        let failbackClientLastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackClientLastSeenByServiceDateTime)
        failbackClientLastSeenByServiceDateTime = failbackClientLastSeenByServiceDateTimeDecoded
        let failbackToOriginalServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failbackToOriginalServer)
        failbackToOriginalServer = failbackToOriginalServerDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
    }
}

extension DrsClientTypes {
    /// An object representing failback related information of the Recovery Instance.
    public struct RecoveryInstanceFailback: Swift.Equatable {
        /// The date and time the agent on the Recovery Instance was last seen by the service.
        public var agentLastSeenByServiceDateTime: Swift.String?
        /// The amount of time that the Recovery Instance has been replicating for.
        public var elapsedReplicationDuration: Swift.String?
        /// The ID of the failback client that this Recovery Instance is associated with.
        public var failbackClientID: Swift.String?
        /// The date and time that the failback client was last seen by the service.
        public var failbackClientLastSeenByServiceDateTime: Swift.String?
        /// The date and time that the failback initiation started.
        public var failbackInitiationTime: Swift.String?
        /// The Job ID of the last failback log for this Recovery Instance.
        public var failbackJobID: Swift.String?
        /// Whether we are failing back to the original Source Server for this Recovery Instance.
        public var failbackToOriginalServer: Swift.Bool?
        /// The date and time of the first byte that was replicated from the Recovery Instance.
        public var firstByteDateTime: Swift.String?
        /// The state of the failback process that this Recovery Instance is in.
        public var state: DrsClientTypes.FailbackState?

        public init (
            agentLastSeenByServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            failbackClientID: Swift.String? = nil,
            failbackClientLastSeenByServiceDateTime: Swift.String? = nil,
            failbackInitiationTime: Swift.String? = nil,
            failbackJobID: Swift.String? = nil,
            failbackToOriginalServer: Swift.Bool? = nil,
            firstByteDateTime: Swift.String? = nil,
            state: DrsClientTypes.FailbackState? = nil
        )
        {
            self.agentLastSeenByServiceDateTime = agentLastSeenByServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.failbackClientID = failbackClientID
            self.failbackClientLastSeenByServiceDateTime = failbackClientLastSeenByServiceDateTime
            self.failbackInitiationTime = failbackInitiationTime
            self.failbackJobID = failbackJobID
            self.failbackToOriginalServer = failbackToOriginalServer
            self.firstByteDateTime = firstByteDateTime
            self.state = state
        }
    }

}

extension DrsClientTypes.RecoveryInstanceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpus0 in cpus {
                try cpusContainer.encode(cpus0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for recoveryinstancedisks0 in disks {
                try disksContainer.encode(recoveryinstancedisks0)
            }
        }
        if let identificationHints = identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(DrsClientTypes.IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([DrsClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[DrsClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [DrsClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstanceDisk?].self, forKey: .disks)
        var disksDecoded0:[DrsClientTypes.RecoveryInstanceDisk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [DrsClientTypes.RecoveryInstanceDisk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([DrsClientTypes.CPU?].self, forKey: .cpus)
        var cpusDecoded0:[DrsClientTypes.CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [DrsClientTypes.CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .ramBytes)
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(DrsClientTypes.OS.self, forKey: .os)
        os = osDecoded
    }
}

extension DrsClientTypes {
    /// Properties of the Recovery Instance machine.
    public struct RecoveryInstanceProperties: Swift.Equatable {
        /// An array of CPUs.
        public var cpus: [DrsClientTypes.CPU]?
        /// An array of disks.
        public var disks: [DrsClientTypes.RecoveryInstanceDisk]?
        /// Hints used to uniquely identify a machine.
        public var identificationHints: DrsClientTypes.IdentificationHints?
        /// The date and time the Recovery Instance properties were last updated on.
        public var lastUpdatedDateTime: Swift.String?
        /// An array of network interfaces.
        public var networkInterfaces: [DrsClientTypes.NetworkInterface]?
        /// Operating system.
        public var os: DrsClientTypes.OS?
        /// The amount of RAM in bytes.
        public var ramBytes: Swift.Int

        public init (
            cpus: [DrsClientTypes.CPU]? = nil,
            disks: [DrsClientTypes.RecoveryInstanceDisk]? = nil,
            identificationHints: DrsClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [DrsClientTypes.NetworkInterface]? = nil,
            os: DrsClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
        }
    }

}

extension DrsClientTypes.RecoverySnapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshots
        case expectedTimestamp
        case snapshotID
        case sourceServerID
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsSnapshots = ebsSnapshots {
            var ebsSnapshotsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ebsSnapshots)
            for ebssnapshotslist0 in ebsSnapshots {
                try ebsSnapshotsContainer.encode(ebssnapshotslist0)
            }
        }
        if let expectedTimestamp = expectedTimestamp {
            try encodeContainer.encode(expectedTimestamp, forKey: .expectedTimestamp)
        }
        if let snapshotID = snapshotID {
            try encodeContainer.encode(snapshotID, forKey: .snapshotID)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let timestamp = timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotID)
        snapshotID = snapshotIDDecoded
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let expectedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedTimestamp)
        expectedTimestamp = expectedTimestampDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let ebsSnapshotsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ebsSnapshots)
        var ebsSnapshotsDecoded0:[Swift.String]? = nil
        if let ebsSnapshotsContainer = ebsSnapshotsContainer {
            ebsSnapshotsDecoded0 = [Swift.String]()
            for string0 in ebsSnapshotsContainer {
                if let string0 = string0 {
                    ebsSnapshotsDecoded0?.append(string0)
                }
            }
        }
        ebsSnapshots = ebsSnapshotsDecoded0
    }
}

extension DrsClientTypes {
    /// A snapshot of a Source Server used during recovery.
    public struct RecoverySnapshot: Swift.Equatable {
        /// A list of EBS snapshots.
        public var ebsSnapshots: [Swift.String]?
        /// The timestamp of when we expect the snapshot to be taken.
        /// This member is required.
        public var expectedTimestamp: Swift.String?
        /// The ID of the Recovery Snapshot.
        /// This member is required.
        public var snapshotID: Swift.String?
        /// The ID of the Source Server that the snapshot was taken for.
        /// This member is required.
        public var sourceServerID: Swift.String?
        /// The actual timestamp that the snapshot was taken.
        public var timestamp: Swift.String?

        public init (
            ebsSnapshots: [Swift.String]? = nil,
            expectedTimestamp: Swift.String? = nil,
            snapshotID: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.ebsSnapshots = ebsSnapshots
            self.expectedTimestamp = expectedTimestamp
            self.snapshotID = snapshotID
            self.sourceServerID = sourceServerID
            self.timestamp = timestamp
        }
    }

}

extension DrsClientTypes {
    public enum RecoverySnapshotsOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoverySnapshotsOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoverySnapshotsOrder(rawValue: rawValue) ?? RecoverySnapshotsOrder.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum ReplicationConfigurationDataPlaneRouting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateIp
        case publicIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDataPlaneRouting] {
            return [
                .privateIp,
                .publicIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateIp: return "PRIVATE_IP"
            case .publicIp: return "PUBLIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDataPlaneRouting(rawValue: rawValue) ?? ReplicationConfigurationDataPlaneRouting.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum ReplicationConfigurationDefaultLargeStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case gp2
        case gp3
        case st1
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDefaultLargeStagingDiskType] {
            return [
                .gp2,
                .gp3,
                .st1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .st1: return "ST1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDefaultLargeStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationDefaultLargeStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum ReplicationConfigurationEbsEncryption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case `default`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationEbsEncryption] {
            return [
                .custom,
                .default,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationEbsEncryption(rawValue: rawValue) ?? ReplicationConfigurationEbsEncryption.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.ReplicationConfigurationReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case iops
        case isBootDisk
        case stagingDiskType
        case throughput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let isBootDisk = isBootDisk {
            try encodeContainer.encode(isBootDisk, forKey: .isBootDisk)
        }
        if let stagingDiskType = stagingDiskType {
            try encodeContainer.encode(stagingDiskType.rawValue, forKey: .stagingDiskType)
        }
        if throughput != 0 {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let isBootDiskDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBootDisk)
        isBootDisk = isBootDiskDecoded
        let stagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType.self, forKey: .stagingDiskType)
        stagingDiskType = stagingDiskTypeDecoded
        let iopsDecoded = try containerValues.decode(Swift.Int.self, forKey: .iops)
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decode(Swift.Int.self, forKey: .throughput)
        throughput = throughputDecoded
    }
}

extension DrsClientTypes {
    /// The configuration of a disk of the Source Server to be replicated.
    public struct ReplicationConfigurationReplicatedDisk: Swift.Equatable {
        /// The name of the device.
        public var deviceName: Swift.String?
        /// The requested number of I/O operations per second (IOPS).
        public var iops: Swift.Int
        /// Whether to boot from this disk or not.
        public var isBootDisk: Swift.Bool?
        /// The Staging Disk EBS volume type to be used during replication.
        public var stagingDiskType: DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// The throughput to use for the EBS volume in MiB/s. This parameter is valid only for gp3 volumes.
        public var throughput: Swift.Int

        public init (
            deviceName: Swift.String? = nil,
            iops: Swift.Int = 0,
            isBootDisk: Swift.Bool? = nil,
            stagingDiskType: DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType? = nil,
            throughput: Swift.Int = 0
        )
        {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }
    }

}

extension DrsClientTypes {
    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case gp2
        case gp3
        case io1
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationReplicatedDiskStagingDiskType] {
            return [
                .auto,
                .gp2,
                .gp3,
                .io1,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .io1: return "IO1"
            case .sc1: return "SC1"
            case .st1: return "ST1"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationReplicatedDiskStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationReplicatedDiskStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.ReplicationConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicy0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicy0)
            }
        }
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
    }
}

extension DrsClientTypes {
    public struct ReplicationConfigurationTemplate: Swift.Equatable {
        /// The Replication Configuration Template ARN.
        public var arn: Swift.String?
        /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
        public var associateDefaultSecurityGroup: Swift.Bool?
        /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
        public var bandwidthThrottling: Swift.Int
        /// Whether to create a Public IP for the Recovery Instance by default.
        public var createPublicIP: Swift.Bool?
        /// The data plane routing mechanism that will be used for replication.
        public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
        /// The Staging Disk EBS volume type to be used during replication.
        public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
        /// The type of EBS encryption to be used during replication.
        public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
        /// The ARN of the EBS encryption key to be used during replication.
        public var ebsEncryptionKeyArn: Swift.String?
        /// The Point in time (PIT) policy to manage snapshots taken during replication.
        public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
        /// The Replication Configuration Template ID.
        /// This member is required.
        public var replicationConfigurationTemplateID: Swift.String?
        /// The instance type to be used for the replication server.
        public var replicationServerInstanceType: Swift.String?
        /// The security group IDs that will be used by the replication server.
        public var replicationServersSecurityGroupsIDs: [Swift.String]?
        /// The subnet to be used by the replication staging area.
        public var stagingAreaSubnetId: Swift.String?
        /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
        public var stagingAreaTags: [Swift.String:Swift.String]?
        /// A set of tags to be associated with the Replication Configuration Template resource.
        public var tags: [Swift.String:Swift.String]?
        /// Whether to use a dedicated Replication Server in the replication staging area.
        public var useDedicatedReplicationServer: Swift.Bool?

        public init (
            arn: Swift.String? = nil,
            associateDefaultSecurityGroup: Swift.Bool? = nil,
            bandwidthThrottling: Swift.Int = 0,
            createPublicIP: Swift.Bool? = nil,
            dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
            defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
            ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
            ebsEncryptionKeyArn: Swift.String? = nil,
            pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
            replicationConfigurationTemplateID: Swift.String? = nil,
            replicationServerInstanceType: Swift.String? = nil,
            replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
            stagingAreaSubnetId: Swift.String? = nil,
            stagingAreaTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDedicatedReplicationServer: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.pitPolicy = pitPolicy
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
        } else {
            self.code = nil
            self.message = nil
            self.resourceId = nil
            self.resourceType = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource for this operation was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RetryDataReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension RetryDataReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RetryDataReplication"
    }
}

public struct RetryDataReplicationInput: Swift.Equatable {
    /// The ID of the Source Server whose data replication should be retried.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init (
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct RetryDataReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension RetryDataReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension RetryDataReplicationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RetryDataReplicationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RetryDataReplicationOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RetryDataReplicationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: RetryDataReplicationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.lastLaunchResult = output.lastLaunchResult
            self.lifeCycle = output.lifeCycle
            self.recoveryInstanceId = output.recoveryInstanceId
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.lastLaunchResult = nil
            self.lifeCycle = nil
            self.recoveryInstanceId = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.tags = nil
        }
    }
}

public struct RetryDataReplicationOutputResponse: Swift.Equatable {
    /// The ARN of the Source Server.
    public var arn: Swift.String?
    /// The Data Replication Info of the Source Server.
    public var dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    /// The status of the last recovery launch of this Source Server.
    public var lastLaunchResult: DrsClientTypes.LastLaunchResult?
    /// The lifecycle information of this Source Server.
    public var lifeCycle: DrsClientTypes.LifeCycle?
    /// The ID of the Recovery Instance associated with this Source Server.
    public var recoveryInstanceId: Swift.String?
    /// The source properties of the Source Server.
    public var sourceProperties: DrsClientTypes.SourceProperties?
    /// The ID of the Source Server.
    public var sourceServerID: Swift.String?
    /// The tags associated with the Source Server.
    public var tags: [Swift.String:Swift.String]?

    public init (
        arn: Swift.String? = nil,
        dataReplicationInfo: DrsClientTypes.DataReplicationInfo? = nil,
        lastLaunchResult: DrsClientTypes.LastLaunchResult? = nil,
        lifeCycle: DrsClientTypes.LifeCycle? = nil,
        recoveryInstanceId: Swift.String? = nil,
        sourceProperties: DrsClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.lastLaunchResult = lastLaunchResult
        self.lifeCycle = lifeCycle
        self.recoveryInstanceId = recoveryInstanceId
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.tags = tags
    }
}

struct RetryDataReplicationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let recoveryInstanceId: Swift.String?
    let lastLaunchResult: DrsClientTypes.LastLaunchResult?
    let dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    let lifeCycle: DrsClientTypes.LifeCycle?
    let sourceProperties: DrsClientTypes.SourceProperties?
}

extension RetryDataReplicationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case lastLaunchResult
        case lifeCycle
        case recoveryInstanceId
        case sourceProperties
        case sourceServerID
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recoveryInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceId)
        recoveryInstanceId = recoveryInstanceIdDecoded
        let lastLaunchResultDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchResult.self, forKey: .lastLaunchResult)
        lastLaunchResult = lastLaunchResultDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.resourceId = output.resourceId
            self.resourceType = output.resourceType
            self.serviceCode = output.serviceCode
        } else {
            self.code = nil
            self.message = nil
            self.quotaCode = nil
            self.resourceId = nil
            self.resourceType = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request could not be completed because its exceeded the service quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?
    /// Quota code.
    public var quotaCode: Swift.String?
    /// The ID of the resource.
    public var resourceId: Swift.String?
    /// The type of the resource.
    public var resourceType: Swift.String?
    /// Service code.
    public var serviceCode: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
        self.quotaCode = quotaCode
        self.resourceId = resourceId
        self.resourceType = resourceType
        self.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension DrsClientTypes.SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
        case recommendedInstanceType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpus0 in cpus {
                try cpusContainer.encode(cpus0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for disks0 in disks {
                try disksContainer.encode(disks0)
            }
        }
        if let identificationHints = identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if let os = os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
        if let recommendedInstanceType = recommendedInstanceType {
            try encodeContainer.encode(recommendedInstanceType, forKey: .recommendedInstanceType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recommendedInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedInstanceType)
        recommendedInstanceType = recommendedInstanceTypeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(DrsClientTypes.IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([DrsClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[DrsClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [DrsClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([DrsClientTypes.Disk?].self, forKey: .disks)
        var disksDecoded0:[DrsClientTypes.Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [DrsClientTypes.Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([DrsClientTypes.CPU?].self, forKey: .cpus)
        var cpusDecoded0:[DrsClientTypes.CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [DrsClientTypes.CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decode(Swift.Int.self, forKey: .ramBytes)
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(DrsClientTypes.OS.self, forKey: .os)
        os = osDecoded
    }
}

extension DrsClientTypes {
    /// Properties of the Source Server machine.
    public struct SourceProperties: Swift.Equatable {
        /// An array of CPUs.
        public var cpus: [DrsClientTypes.CPU]?
        /// An array of disks.
        public var disks: [DrsClientTypes.Disk]?
        /// Hints used to uniquely identify a machine.
        public var identificationHints: DrsClientTypes.IdentificationHints?
        /// The date and time the Source Properties were last updated on.
        public var lastUpdatedDateTime: Swift.String?
        /// An array of network interfaces.
        public var networkInterfaces: [DrsClientTypes.NetworkInterface]?
        /// Operating system.
        public var os: DrsClientTypes.OS?
        /// The amount of RAM in bytes.
        public var ramBytes: Swift.Int
        /// The recommended EC2 instance type that will be used when recovering the Source Server.
        public var recommendedInstanceType: Swift.String?

        public init (
            cpus: [DrsClientTypes.CPU]? = nil,
            disks: [DrsClientTypes.Disk]? = nil,
            identificationHints: DrsClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [DrsClientTypes.NetworkInterface]? = nil,
            os: DrsClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0,
            recommendedInstanceType: Swift.String? = nil
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
        }
    }

}

extension DrsClientTypes.SourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case lastLaunchResult
        case lifeCycle
        case recoveryInstanceId
        case sourceProperties
        case sourceServerID
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataReplicationInfo = dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let lastLaunchResult = lastLaunchResult {
            try encodeContainer.encode(lastLaunchResult.rawValue, forKey: .lastLaunchResult)
        }
        if let lifeCycle = lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let recoveryInstanceId = recoveryInstanceId {
            try encodeContainer.encode(recoveryInstanceId, forKey: .recoveryInstanceId)
        }
        if let sourceProperties = sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recoveryInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceId)
        recoveryInstanceId = recoveryInstanceIdDecoded
        let lastLaunchResultDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchResult.self, forKey: .lastLaunchResult)
        lastLaunchResult = lastLaunchResultDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
    }
}

extension DrsClientTypes {
    public struct SourceServer: Swift.Equatable {
        /// The ARN of the Source Server.
        public var arn: Swift.String?
        /// The Data Replication Info of the Source Server.
        public var dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
        /// The status of the last recovery launch of this Source Server.
        public var lastLaunchResult: DrsClientTypes.LastLaunchResult?
        /// The lifecycle information of this Source Server.
        public var lifeCycle: DrsClientTypes.LifeCycle?
        /// The ID of the Recovery Instance associated with this Source Server.
        public var recoveryInstanceId: Swift.String?
        /// The source properties of the Source Server.
        public var sourceProperties: DrsClientTypes.SourceProperties?
        /// The ID of the Source Server.
        public var sourceServerID: Swift.String?
        /// The tags associated with the Source Server.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            dataReplicationInfo: DrsClientTypes.DataReplicationInfo? = nil,
            lastLaunchResult: DrsClientTypes.LastLaunchResult? = nil,
            lifeCycle: DrsClientTypes.LifeCycle? = nil,
            recoveryInstanceId: Swift.String? = nil,
            sourceProperties: DrsClientTypes.SourceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.lastLaunchResult = lastLaunchResult
            self.lifeCycle = lifeCycle
            self.recoveryInstanceId = recoveryInstanceId
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
        }
    }

}

extension StartFailbackLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceIDs = recoveryInstanceIDs {
            var recoveryInstanceIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recoveryInstanceIDs)
            for startfailbackrequestrecoveryinstanceids0 in recoveryInstanceIDs {
                try recoveryInstanceIDsContainer.encode(startfailbackrequestrecoveryinstanceids0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartFailbackLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartFailbackLaunch"
    }
}

public struct StartFailbackLaunchInput: Swift.Equatable {
    /// The IDs of the Recovery Instance whose failback launch we want to request.
    /// This member is required.
    public var recoveryInstanceIDs: [Swift.String]?
    /// The tags to be associated with the failback launch Job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        recoveryInstanceIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.recoveryInstanceIDs = recoveryInstanceIDs
        self.tags = tags
    }
}

struct StartFailbackLaunchInputBody: Swift.Equatable {
    let recoveryInstanceIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension StartFailbackLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recoveryInstanceIDs)
        var recoveryInstanceIDsDecoded0:[Swift.String]? = nil
        if let recoveryInstanceIDsContainer = recoveryInstanceIDsContainer {
            recoveryInstanceIDsDecoded0 = [Swift.String]()
            for string0 in recoveryInstanceIDsContainer {
                if let string0 = string0 {
                    recoveryInstanceIDsDecoded0?.append(string0)
                }
            }
        }
        recoveryInstanceIDs = recoveryInstanceIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartFailbackLaunchOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartFailbackLaunchOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartFailbackLaunchOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartFailbackLaunchOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartFailbackLaunchOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartFailbackLaunchOutputResponse: Swift.Equatable {
    /// The failback launch Job.
    public var job: DrsClientTypes.Job?

    public init (
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartFailbackLaunchOutputResponseBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension StartFailbackLaunchOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension StartRecoveryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDrill
        case sourceServers
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isDrill = isDrill {
            try encodeContainer.encode(isDrill, forKey: .isDrill)
        }
        if let sourceServers = sourceServers {
            var sourceServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServers)
            for startrecoveryrequestsourceservers0 in sourceServers {
                try sourceServersContainer.encode(startrecoveryrequestsourceservers0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartRecoveryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartRecovery"
    }
}

public struct StartRecoveryInput: Swift.Equatable {
    /// Whether this Source Server Recovery operation is a drill or not.
    public var isDrill: Swift.Bool?
    /// The Source Servers that we want to start a Recovery Job for.
    /// This member is required.
    public var sourceServers: [DrsClientTypes.StartRecoveryRequestSourceServer]?
    /// The tags to be associated with the Recovery Job.
    public var tags: [Swift.String:Swift.String]?

    public init (
        isDrill: Swift.Bool? = nil,
        sourceServers: [DrsClientTypes.StartRecoveryRequestSourceServer]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.isDrill = isDrill
        self.sourceServers = sourceServers
        self.tags = tags
    }
}

struct StartRecoveryInputBody: Swift.Equatable {
    let sourceServers: [DrsClientTypes.StartRecoveryRequestSourceServer]?
    let isDrill: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension StartRecoveryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDrill
        case sourceServers
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServersContainer = try containerValues.decodeIfPresent([DrsClientTypes.StartRecoveryRequestSourceServer?].self, forKey: .sourceServers)
        var sourceServersDecoded0:[DrsClientTypes.StartRecoveryRequestSourceServer]? = nil
        if let sourceServersContainer = sourceServersContainer {
            sourceServersDecoded0 = [DrsClientTypes.StartRecoveryRequestSourceServer]()
            for structure0 in sourceServersContainer {
                if let structure0 = structure0 {
                    sourceServersDecoded0?.append(structure0)
                }
            }
        }
        sourceServers = sourceServersDecoded0
        let isDrillDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDrill)
        isDrill = isDrillDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartRecoveryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartRecoveryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartRecoveryOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartRecoveryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: StartRecoveryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartRecoveryOutputResponse: Swift.Equatable {
    /// The Recovery Job.
    public var job: DrsClientTypes.Job?

    public init (
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartRecoveryOutputResponseBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension StartRecoveryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension DrsClientTypes.StartRecoveryRequestSourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoverySnapshotID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoverySnapshotID = recoverySnapshotID {
            try encodeContainer.encode(recoverySnapshotID, forKey: .recoverySnapshotID)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let recoverySnapshotIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoverySnapshotID)
        recoverySnapshotID = recoverySnapshotIDDecoded
    }
}

extension DrsClientTypes {
    /// An object representing the Source Server to recover.
    public struct StartRecoveryRequestSourceServer: Swift.Equatable {
        /// The ID of a Recovery Snapshot we want to recover from. Omit this field to launch from the latest data by taking an on-demand snapshot.
        public var recoverySnapshotID: Swift.String?
        /// The ID of the Source Server you want to recover.
        /// This member is required.
        public var sourceServerID: Swift.String?

        public init (
            recoverySnapshotID: Swift.String? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.recoverySnapshotID = recoverySnapshotID
            self.sourceServerID = sourceServerID
        }
    }

}

extension StopFailbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension StopFailbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StopFailback"
    }
}

public struct StopFailbackInput: Swift.Equatable {
    /// The ID of the Recovery Instance we want to stop failback for.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init (
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct StopFailbackInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension StopFailbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension StopFailbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopFailbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopFailbackOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopFailbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopFailbackOutputResponse: Swift.Equatable {

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsmap0) in tags {
                try tagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be added or updated.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

}

extension DrsClientTypes {
    public enum TargetInstanceTypeRightSizingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetInstanceTypeRightSizingMethod] {
            return [
                .basic,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetInstanceTypeRightSizingMethod(rawValue: rawValue) ?? TargetInstanceTypeRightSizingMethod.sdkUnknown(rawValue)
        }
    }
}

extension TerminateRecoveryInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceIDs = recoveryInstanceIDs {
            var recoveryInstanceIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recoveryInstanceIDs)
            for recoveryinstancesforterminationrequest0 in recoveryInstanceIDs {
                try recoveryInstanceIDsContainer.encode(recoveryinstancesforterminationrequest0)
            }
        }
    }
}

extension TerminateRecoveryInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TerminateRecoveryInstances"
    }
}

public struct TerminateRecoveryInstancesInput: Swift.Equatable {
    /// The IDs of the Recovery Instances that should be terminated.
    /// This member is required.
    public var recoveryInstanceIDs: [Swift.String]?

    public init (
        recoveryInstanceIDs: [Swift.String]? = nil
    )
    {
        self.recoveryInstanceIDs = recoveryInstanceIDs
    }
}

struct TerminateRecoveryInstancesInputBody: Swift.Equatable {
    let recoveryInstanceIDs: [Swift.String]?
}

extension TerminateRecoveryInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recoveryInstanceIDs)
        var recoveryInstanceIDsDecoded0:[Swift.String]? = nil
        if let recoveryInstanceIDsContainer = recoveryInstanceIDsContainer {
            recoveryInstanceIDsDecoded0 = [Swift.String]()
            for string0 in recoveryInstanceIDsContainer {
                if let string0 = string0 {
                    recoveryInstanceIDsDecoded0?.append(string0)
                }
            }
        }
        recoveryInstanceIDs = recoveryInstanceIDsDecoded0
    }
}

extension TerminateRecoveryInstancesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TerminateRecoveryInstancesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TerminateRecoveryInstancesOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TerminateRecoveryInstancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: TerminateRecoveryInstancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct TerminateRecoveryInstancesOutputResponse: Swift.Equatable {
    /// The Job for terminating the Recovery Instances.
    public var job: DrsClientTypes.Job?

    public init (
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct TerminateRecoveryInstancesOutputResponseBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension TerminateRecoveryInstancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.quotaCode = output.quotaCode
            self.serviceCode = output.serviceCode
        } else {
            self.message = nil
            self.quotaCode = nil
            self.serviceCode = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?
    /// Quota code.
    public var quotaCode: Swift.String?
    /// The number of seconds after which the request should be safe to retry.
    public var retryAfterSeconds: Swift.String?
    /// Service code.
    public var serviceCode: Swift.String?

    public init (
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.message = message
        self.quotaCode = quotaCode
        self.retryAfterSeconds = retryAfterSeconds
        self.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UninitializedAccountException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UninitializedAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.message = output.message
        } else {
            self.code = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The account performing the request has not been initialized.
public struct UninitializedAccountException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    public var message: Swift.String?

    public init (
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.code = code
        self.message = message
    }
}

struct UninitializedAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension UninitializedAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        var items = [ClientRuntime.URLQueryItem]()
        if let tagKeys = tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

}

extension UpdateFailbackReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthThrottling
        case name
        case recoveryInstanceID
        case usePrivateIP
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recoveryInstanceID = recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
        if let usePrivateIP = usePrivateIP {
            try encodeContainer.encode(usePrivateIP, forKey: .usePrivateIP)
        }
    }
}

extension UpdateFailbackReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateFailbackReplicationConfiguration"
    }
}

public struct UpdateFailbackReplicationConfigurationInput: Swift.Equatable {
    /// Configure bandwidth throttling for the outbound data transfer rate of the Recovery Instance in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// The name of the Failback Replication Configuration.
    public var name: Swift.String?
    /// The ID of the Recovery Instance.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?
    /// Whether to use Private IP for the failback replication of the Recovery Instance.
    public var usePrivateIP: Swift.Bool?

    public init (
        bandwidthThrottling: Swift.Int = 0,
        name: Swift.String? = nil,
        recoveryInstanceID: Swift.String? = nil,
        usePrivateIP: Swift.Bool? = nil
    )
    {
        self.bandwidthThrottling = bandwidthThrottling
        self.name = name
        self.recoveryInstanceID = recoveryInstanceID
        self.usePrivateIP = usePrivateIP
    }
}

struct UpdateFailbackReplicationConfigurationInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
    let name: Swift.String?
    let bandwidthThrottling: Swift.Int
    let usePrivateIP: Swift.Bool?
}

extension UpdateFailbackReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthThrottling
        case name
        case recoveryInstanceID
        case usePrivateIP
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let usePrivateIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .usePrivateIP)
        usePrivateIP = usePrivateIPDecoded
    }
}

extension UpdateFailbackReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFailbackReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFailbackReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFailbackReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFailbackReplicationConfigurationOutputResponse: Swift.Equatable {

}

extension UpdateLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyPrivateIp = copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let launchDisposition = launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLaunchConfiguration"
    }
}

public struct UpdateLaunchConfigurationInput: Swift.Equatable {
    /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
    public var copyPrivateIp: Swift.Bool?
    /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
    public var copyTags: Swift.Bool?
    /// The state of the Recovery Instance in EC2 after the recovery operation.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// The licensing configuration to be used for this launch configuration.
    public var licensing: DrsClientTypes.Licensing?
    /// The name of the launch configuration.
    public var name: Swift.String?
    /// The ID of the Source Server that we want to retrieve a Launch Configuration for.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
}

extension UpdateLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

extension UpdateLaunchConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateLaunchConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateLaunchConfigurationOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateLaunchConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateLaunchConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationOutputResponse: Swift.Equatable {
    /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
    public var copyPrivateIp: Swift.Bool?
    /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
    public var copyTags: Swift.Bool?
    /// The EC2 launch template ID of this launch configuration.
    public var ec2LaunchTemplateID: Swift.String?
    /// The state of the Recovery Instance in EC2 after the recovery operation.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// The licensing configuration to be used for this launch configuration.
    public var licensing: DrsClientTypes.Licensing?
    /// The name of the launch configuration.
    public var name: Swift.String?
    /// The ID of the Source Server for this launch configuration.
    public var sourceServerID: Swift.String?
    /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init (
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
}

extension UpdateLaunchConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
    }
}

extension UpdateReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicy0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicy0)
            }
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for replicationconfigurationreplicateddisks0 in replicatedDisks {
                try replicatedDisksContainer.encode(replicationconfigurationreplicateddisks0)
            }
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let sourceServerID = sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfiguration"
    }
}

public struct UpdateReplicationConfigurationInput: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The name of the Replication Configuration.
    public var name: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The configuration of the disks of the Source Server to be replicated.
    public var replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The ID of the Source Server for this Replication Configuration.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.pitPolicy = pitPolicy
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
}

extension UpdateReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
    }
}

extension UpdateReplicationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateReplicationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.pitPolicy = output.pitPolicy
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.pitPolicy = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationOutputResponse: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The name of the Replication Configuration.
    public var name: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The configuration of the disks of the Source Server to be replicated.
    public var replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The ID of the Source Server for this Replication Configuration.
    public var sourceServerID: Swift.String?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.pitPolicy = pitPolicy
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationOutputResponseBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
}

extension UpdateReplicationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
    }
}

extension UpdateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicy0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicy0)
            }
        }
        if let replicationConfigurationTemplateID = replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for replicationserverssecuritygroupsids0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(replicationserverssecuritygroupsids0)
            }
        }
        if let stagingAreaSubnetId = stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsmap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsmap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfigurationTemplate"
    }
}

public struct UpdateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// The Replication Configuration Template ARN.
    public var arn: Swift.String?
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
}

extension UpdateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
    }
}

extension UpdateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateReplicationConfigurationTemplateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UninitializedAccountException" : self = .uninitializedAccountException(try UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateReplicationConfigurationTemplateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case uninitializedAccountException(UninitializedAccountException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateReplicationConfigurationTemplateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: UpdateReplicationConfigurationTemplateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.pitPolicy = output.pitPolicy
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.pitPolicy = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationTemplateOutputResponse: Swift.Equatable {
    /// The Replication Configuration Template ARN.
    public var arn: Swift.String?
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// A set of tags to be associated with the Replication Configuration Template resource.
    public var tags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init (
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateOutputResponseBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
}

extension UpdateReplicationConfigurationTemplateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decode(Swift.Int.self, forKey: .bandwidthThrottling)
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().toData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.code = output.code
            self.fieldList = output.fieldList
            self.message = output.message
            self.reason = output.reason
        } else {
            self.code = nil
            self.fieldList = nil
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by the AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var code: Swift.String?
    /// A list of fields that failed validation.
    public var fieldList: [DrsClientTypes.ValidationExceptionField]?
    public var message: Swift.String?
    /// Validation exception reason.
    public var reason: DrsClientTypes.ValidationExceptionReason?

    public init (
        code: Swift.String? = nil,
        fieldList: [DrsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DrsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.code = code
        self.fieldList = fieldList
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let reason: DrsClientTypes.ValidationExceptionReason?
    let fieldList: [DrsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case fieldList
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([DrsClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[DrsClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [DrsClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension DrsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DrsClientTypes {
    /// Validate exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Validate exception field message.
        public var message: Swift.String?
        /// Validate exception field name.
        public var name: Swift.String?

        public init (
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension DrsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
