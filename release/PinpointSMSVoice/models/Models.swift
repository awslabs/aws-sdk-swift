// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AlreadyExistsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AlreadyExistsException(message: \(String(describing: message)))"}
}

extension AlreadyExistsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource specified in your request already exists.
public struct AlreadyExistsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct AlreadyExistsExceptionBody: Equatable {
    public let message: String?
}

extension AlreadyExistsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "BadRequestException(message: \(String(describing: message)))"}
}

extension BadRequestException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input you provided is invalid.
public struct BadRequestException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Equatable {
    public let message: String?
}

extension BadRequestExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CallInstructionsMessageType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case text = "Text"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
    }
}

extension CallInstructionsMessageType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CallInstructionsMessageType(text: \(String(describing: text)))"}
}

/// An object that defines a message that contains text formatted using Amazon Pinpoint Voice Instructions markup.
public struct CallInstructionsMessageType: Equatable {
    /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
    public let text: String?

    public init (
        text: String? = nil
    )
    {
        self.text = text
    }
}

extension CloudWatchLogsDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case iamRoleArn = "IamRoleArn"
        case logGroupArn = "LogGroupArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
        if let logGroupArn = logGroupArn {
            try encodeContainer.encode(logGroupArn, forKey: .logGroupArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
        let logGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .logGroupArn)
        logGroupArn = logGroupArnDecoded
    }
}

extension CloudWatchLogsDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CloudWatchLogsDestination(iamRoleArn: \(String(describing: iamRoleArn)), logGroupArn: \(String(describing: logGroupArn)))"}
}

/// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
public struct CloudWatchLogsDestination: Equatable {
    /// The Amazon Resource Name (ARN) of an Amazon Identity and Access Management (IAM) role that is able to write event data to an Amazon CloudWatch destination.
    public let iamRoleArn: String?
    /// The name of the Amazon CloudWatch Log Group that you want to record events in.
    public let logGroupArn: String?

    public init (
        iamRoleArn: String? = nil,
        logGroupArn: String? = nil
    )
    {
        self.iamRoleArn = iamRoleArn
        self.logGroupArn = logGroupArn
    }
}

public struct CreateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

extension CreateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension CreateConfigurationSetEventDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
        if let eventDestinationName = eventDestinationName {
            try encodeContainer.encode(eventDestinationName, forKey: .eventDestinationName)
        }
    }
}

public struct CreateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

public struct CreateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetEventDestinationOutputError>
}

/// Create a new event destination in a configuration set.
public struct CreateConfigurationSetEventDestinationInput: Equatable {
    /// ConfigurationSetName
    public let configurationSetName: String?
    /// An object that defines a single event destination.
    public let eventDestination: EventDestinationDefinition?
    /// A name that identifies the event destination.
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestinationDefinition? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct CreateConfigurationSetEventDestinationInputBody: Equatable {
    public let eventDestination: EventDestinationDefinition?
    public let eventDestinationName: String?
}

extension CreateConfigurationSetEventDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
        case eventDestinationName = "EventDestinationName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
        let eventDestinationNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventDestinationName)
        eventDestinationName = eventDestinationNameDecoded
    }
}

extension CreateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetEventDestinationOutputError: Swift.Error, Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetEventDestinationOutputResponse()"}
}

extension CreateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the event destination was created successfully.
public struct CreateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension CreateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct CreateConfigurationSetInputBodyMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

extension CreateConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension CreateConfigurationSetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
    }
}

public struct CreateConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

public struct CreateConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateConfigurationSetInput>
    public typealias MOutput = OperationOutput<CreateConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateConfigurationSetOutputError>
}

/// A request to create a new configuration set.
public struct CreateConfigurationSetInput: Equatable {
    /// The name that you want to give the configuration set.
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct CreateConfigurationSetInputBody: Equatable {
    public let configurationSetName: String?
}

extension CreateConfigurationSetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSetName = "ConfigurationSetName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
    }
}

extension CreateConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AlreadyExistsException" : self = .alreadyExistsException(try AlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateConfigurationSetOutputError: Swift.Error, Equatable {
    case alreadyExistsException(AlreadyExistsException)
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case limitExceededException(LimitExceededException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateConfigurationSetOutputResponse()"}
}

extension CreateConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the configuration set was successfully created.
public struct CreateConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct CreateConfigurationSetOutputResponseBody: Equatable {
}

extension CreateConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension DeleteConfigurationSetEventDestinationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

public struct DeleteConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetEventDestinationOutputError>
}

public struct DeleteConfigurationSetEventDestinationInput: Equatable {
    /// ConfigurationSetName
    public let configurationSetName: String?
    /// EventDestinationName
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestinationName = eventDestinationName
    }
}

struct DeleteConfigurationSetEventDestinationInputBody: Equatable {
}

extension DeleteConfigurationSetEventDestinationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetEventDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetEventDestinationOutputResponse()"}
}

extension DeleteConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the event destination was deleted successfully.
public struct DeleteConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension DeleteConfigurationSetInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteConfigurationSetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

public struct DeleteConfigurationSetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteConfigurationSetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteConfigurationSetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteConfigurationSetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteConfigurationSetInput>
    public typealias MOutput = OperationOutput<DeleteConfigurationSetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteConfigurationSetOutputError>
}

public struct DeleteConfigurationSetInput: Equatable {
    /// ConfigurationSetName
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct DeleteConfigurationSetInputBody: Equatable {
}

extension DeleteConfigurationSetInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteConfigurationSetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteConfigurationSetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteConfigurationSetOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteConfigurationSetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteConfigurationSetOutputResponse()"}
}

extension DeleteConfigurationSetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the configuration set was deleted successfully.
public struct DeleteConfigurationSetOutputResponse: Equatable {

    public init() {}
}

struct DeleteConfigurationSetOutputResponseBody: Equatable {
}

extension DeleteConfigurationSetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension EventDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case name = "Name"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let snsDestinationDecoded = try containerValues.decodeIfPresent(SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension EventDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestination(cloudWatchLogsDestination: \(String(describing: cloudWatchLogsDestination)), enabled: \(String(describing: enabled)), kinesisFirehoseDestination: \(String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(String(describing: matchingEventTypes)), name: \(String(describing: name)), snsDestination: \(String(describing: snsDestination)))"}
}

/// An object that defines an event destination.
public struct EventDestination: Equatable {
    /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
    public let cloudWatchLogsDestination: CloudWatchLogsDestination?
    /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
    public let enabled: Bool
    /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
    public let kinesisFirehoseDestination: KinesisFirehoseDestination?
    /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
    public let matchingEventTypes: [EventType]?
    /// A name that identifies the event destination configuration.
    public let name: String?
    /// An object that contains information about an event destination that sends data to Amazon SNS.
    public let snsDestination: SnsDestination?

    public init (
        cloudWatchLogsDestination: CloudWatchLogsDestination? = nil,
        enabled: Bool = false,
        kinesisFirehoseDestination: KinesisFirehoseDestination? = nil,
        matchingEventTypes: [EventType]? = nil,
        name: String? = nil,
        snsDestination: SnsDestination? = nil
    )
    {
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.enabled = enabled
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.name = name
        self.snsDestination = snsDestination
    }
}

extension EventDestinationDefinition: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case cloudWatchLogsDestination = "CloudWatchLogsDestination"
        case enabled = "Enabled"
        case kinesisFirehoseDestination = "KinesisFirehoseDestination"
        case matchingEventTypes = "MatchingEventTypes"
        case snsDestination = "SnsDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudWatchLogsDestination = cloudWatchLogsDestination {
            try encodeContainer.encode(cloudWatchLogsDestination, forKey: .cloudWatchLogsDestination)
        }
        if enabled != false {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let kinesisFirehoseDestination = kinesisFirehoseDestination {
            try encodeContainer.encode(kinesisFirehoseDestination, forKey: .kinesisFirehoseDestination)
        }
        if let matchingEventTypes = matchingEventTypes {
            var matchingEventTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .matchingEventTypes)
            for eventtypes0 in matchingEventTypes {
                try matchingEventTypesContainer.encode(eventtypes0.rawValue)
            }
        }
        if let snsDestination = snsDestination {
            try encodeContainer.encode(snsDestination, forKey: .snsDestination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudWatchLogsDestinationDecoded = try containerValues.decodeIfPresent(CloudWatchLogsDestination.self, forKey: .cloudWatchLogsDestination)
        cloudWatchLogsDestination = cloudWatchLogsDestinationDecoded
        let enabledDecoded = try containerValues.decode(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let kinesisFirehoseDestinationDecoded = try containerValues.decodeIfPresent(KinesisFirehoseDestination.self, forKey: .kinesisFirehoseDestination)
        kinesisFirehoseDestination = kinesisFirehoseDestinationDecoded
        let matchingEventTypesContainer = try containerValues.decodeIfPresent([EventType?].self, forKey: .matchingEventTypes)
        var matchingEventTypesDecoded0:[EventType]? = nil
        if let matchingEventTypesContainer = matchingEventTypesContainer {
            matchingEventTypesDecoded0 = [EventType]()
            for string0 in matchingEventTypesContainer {
                if let string0 = string0 {
                    matchingEventTypesDecoded0?.append(string0)
                }
            }
        }
        matchingEventTypes = matchingEventTypesDecoded0
        let snsDestinationDecoded = try containerValues.decodeIfPresent(SnsDestination.self, forKey: .snsDestination)
        snsDestination = snsDestinationDecoded
    }
}

extension EventDestinationDefinition: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventDestinationDefinition(cloudWatchLogsDestination: \(String(describing: cloudWatchLogsDestination)), enabled: \(String(describing: enabled)), kinesisFirehoseDestination: \(String(describing: kinesisFirehoseDestination)), matchingEventTypes: \(String(describing: matchingEventTypes)), snsDestination: \(String(describing: snsDestination)))"}
}

/// An object that defines a single event destination.
public struct EventDestinationDefinition: Equatable {
    /// An object that contains information about an event destination that sends data to Amazon CloudWatch Logs.
    public let cloudWatchLogsDestination: CloudWatchLogsDestination?
    /// Indicates whether or not the event destination is enabled. If the event destination is enabled, then Amazon Pinpoint sends response data to the specified event destination.
    public let enabled: Bool
    /// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
    public let kinesisFirehoseDestination: KinesisFirehoseDestination?
    /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
    public let matchingEventTypes: [EventType]?
    /// An object that contains information about an event destination that sends data to Amazon SNS.
    public let snsDestination: SnsDestination?

    public init (
        cloudWatchLogsDestination: CloudWatchLogsDestination? = nil,
        enabled: Bool = false,
        kinesisFirehoseDestination: KinesisFirehoseDestination? = nil,
        matchingEventTypes: [EventType]? = nil,
        snsDestination: SnsDestination? = nil
    )
    {
        self.cloudWatchLogsDestination = cloudWatchLogsDestination
        self.enabled = enabled
        self.kinesisFirehoseDestination = kinesisFirehoseDestination
        self.matchingEventTypes = matchingEventTypes
        self.snsDestination = snsDestination
    }
}

/// The types of events that are sent to the event destination.
public enum EventType {
    case answered
    case busy
    case completedCall
    case failed
    case initiatedCall
    case noAnswer
    case ringing
    case sdkUnknown(String)
}

extension EventType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventType] {
        return [
            .answered,
            .busy,
            .completedCall,
            .failed,
            .initiatedCall,
            .noAnswer,
            .ringing,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .answered: return "ANSWERED"
        case .busy: return "BUSY"
        case .completedCall: return "COMPLETED_CALL"
        case .failed: return "FAILED"
        case .initiatedCall: return "INITIATED_CALL"
        case .noAnswer: return "NO_ANSWER"
        case .ringing: return "RINGING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
    }
}

extension GetConfigurationSetEventDestinationsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetEventDestinationsInput(configurationSetName: \(String(describing: configurationSetName)))"}
}

extension GetConfigurationSetEventDestinationsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetConfigurationSetEventDestinationsInputHeadersMiddleware: Middleware {
    public let id: String = "GetConfigurationSetEventDestinationsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetEventDestinationsOutputError>
}

public struct GetConfigurationSetEventDestinationsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetConfigurationSetEventDestinationsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetConfigurationSetEventDestinationsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetConfigurationSetEventDestinationsInput>
    public typealias MOutput = OperationOutput<GetConfigurationSetEventDestinationsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetConfigurationSetEventDestinationsOutputError>
}

public struct GetConfigurationSetEventDestinationsInput: Equatable {
    /// ConfigurationSetName
    public let configurationSetName: String?

    public init (
        configurationSetName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
    }
}

struct GetConfigurationSetEventDestinationsInputBody: Equatable {
}

extension GetConfigurationSetEventDestinationsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetConfigurationSetEventDestinationsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetConfigurationSetEventDestinationsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetConfigurationSetEventDestinationsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetConfigurationSetEventDestinationsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetConfigurationSetEventDestinationsOutputResponse(eventDestinations: \(String(describing: eventDestinations)))"}
}

extension GetConfigurationSetEventDestinationsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetConfigurationSetEventDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventDestinations = output.eventDestinations
        } else {
            self.eventDestinations = nil
        }
    }
}

/// An object that contains information about an event destination.
public struct GetConfigurationSetEventDestinationsOutputResponse: Equatable {
    /// An array of EventDestination objects. Each EventDestination object includes ARNs and other information that define an event destination.
    public let eventDestinations: [EventDestination]?

    public init (
        eventDestinations: [EventDestination]? = nil
    )
    {
        self.eventDestinations = eventDestinations
    }
}

struct GetConfigurationSetEventDestinationsOutputResponseBody: Equatable {
    public let eventDestinations: [EventDestination]?
}

extension GetConfigurationSetEventDestinationsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestinations = "EventDestinations"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationsContainer = try containerValues.decodeIfPresent([EventDestination?].self, forKey: .eventDestinations)
        var eventDestinationsDecoded0:[EventDestination]? = nil
        if let eventDestinationsContainer = eventDestinationsContainer {
            eventDestinationsDecoded0 = [EventDestination]()
            for structure0 in eventDestinationsContainer {
                if let structure0 = structure0 {
                    eventDestinationsDecoded0?.append(structure0)
                }
            }
        }
        eventDestinations = eventDestinationsDecoded0
    }
}

extension InternalServiceErrorException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalServiceErrorException(message: \(String(describing: message)))"}
}

extension InternalServiceErrorException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalServiceErrorExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The API encountered an unexpected error and couldn't complete the request. You might be able to successfully issue the request again in the future.
public struct InternalServiceErrorException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServiceErrorExceptionBody: Equatable {
    public let message: String?
}

extension InternalServiceErrorExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisFirehoseDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deliveryStreamArn = "DeliveryStreamArn"
        case iamRoleArn = "IamRoleArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveryStreamArn = deliveryStreamArn {
            try encodeContainer.encode(deliveryStreamArn, forKey: .deliveryStreamArn)
        }
        if let iamRoleArn = iamRoleArn {
            try encodeContainer.encode(iamRoleArn, forKey: .iamRoleArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveryStreamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .deliveryStreamArn)
        deliveryStreamArn = deliveryStreamArnDecoded
        let iamRoleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .iamRoleArn)
        iamRoleArn = iamRoleArnDecoded
    }
}

extension KinesisFirehoseDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KinesisFirehoseDestination(deliveryStreamArn: \(String(describing: deliveryStreamArn)), iamRoleArn: \(String(describing: iamRoleArn)))"}
}

/// An object that contains information about an event destination that sends data to Amazon Kinesis Data Firehose.
public struct KinesisFirehoseDestination: Equatable {
    /// The Amazon Resource Name (ARN) of an IAM role that can write data to an Amazon Kinesis Data Firehose stream.
    public let deliveryStreamArn: String?
    /// The Amazon Resource Name (ARN) of the Amazon Kinesis Data Firehose destination that you want to use in the event destination.
    public let iamRoleArn: String?

    public init (
        deliveryStreamArn: String? = nil,
        iamRoleArn: String? = nil
    )
    {
        self.deliveryStreamArn = deliveryStreamArn
        self.iamRoleArn = iamRoleArn
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// There are too many instances of the specified resource type.
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListConfigurationSetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsInput(nextToken: \(String(describing: nextToken)), pageSize: \(String(describing: pageSize)))"}
}

extension ListConfigurationSetsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListConfigurationSetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

public struct ListConfigurationSetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListConfigurationSetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListConfigurationSetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListConfigurationSetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let nextToken = input.operationInput.nextToken {
            let nextTokenQueryItem = URLQueryItem(name: "NextToken".urlPercentEncoding(), value: String(nextToken).urlPercentEncoding())
            input.builder.withQueryItem(nextTokenQueryItem)
        }
        if let pageSize = input.operationInput.pageSize {
            let pageSizeQueryItem = URLQueryItem(name: "PageSize".urlPercentEncoding(), value: String(pageSize).urlPercentEncoding())
            input.builder.withQueryItem(pageSizeQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListConfigurationSetsInput>
    public typealias MOutput = OperationOutput<ListConfigurationSetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListConfigurationSetsOutputError>
}

public struct ListConfigurationSetsInput: Equatable {
    /// A token returned from a previous call to the API that indicates the position in the list of results.
    public let nextToken: String?
    /// Used to specify the number of items that should be returned in the response.
    public let pageSize: String?

    public init (
        nextToken: String? = nil,
        pageSize: String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageSize = pageSize
    }
}

struct ListConfigurationSetsInputBody: Equatable {
}

extension ListConfigurationSetsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListConfigurationSetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListConfigurationSetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListConfigurationSetsOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListConfigurationSetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListConfigurationSetsOutputResponse(configurationSets: \(String(describing: configurationSets)), nextToken: \(String(describing: nextToken)))"}
}

extension ListConfigurationSetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListConfigurationSetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.configurationSets = output.configurationSets
            self.nextToken = output.nextToken
        } else {
            self.configurationSets = nil
            self.nextToken = nil
        }
    }
}

/// An object that contains information about the configuration sets for your account in the current region.
public struct ListConfigurationSetsOutputResponse: Equatable {
    /// An object that contains a list of configuration sets for your account in the current region.
    public let configurationSets: [String]?
    /// A token returned from a previous call to ListConfigurationSets to indicate the position in the list of configuration sets.
    public let nextToken: String?

    public init (
        configurationSets: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.configurationSets = configurationSets
        self.nextToken = nextToken
    }
}

struct ListConfigurationSetsOutputResponseBody: Equatable {
    public let configurationSets: [String]?
    public let nextToken: String?
}

extension ListConfigurationSetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case configurationSets = "ConfigurationSets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSetsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .configurationSets)
        var configurationSetsDecoded0:[String]? = nil
        if let configurationSetsContainer = configurationSetsContainer {
            configurationSetsDecoded0 = [String]()
            for string0 in configurationSetsContainer {
                if let string0 = string0 {
                    configurationSetsDecoded0?.append(string0)
                }
            }
        }
        configurationSets = configurationSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension NotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NotFoundException(message: \(String(describing: message)))"}
}

extension NotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource you attempted to access doesn't exist.
public struct NotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Equatable {
    public let message: String?
}

extension NotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PlainTextMessageType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension PlainTextMessageType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PlainTextMessageType(languageCode: \(String(describing: languageCode)), text: \(String(describing: text)), voiceId: \(String(describing: voiceId)))"}
}

/// An object that defines a message that contains unformatted text.
public struct PlainTextMessageType: Equatable {
    /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
    public let languageCode: String?
    /// The plain (not SSML-formatted) text to deliver to the recipient.
    public let text: String?
    /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
    public let voiceId: String?

    public init (
        languageCode: String? = nil,
        text: String? = nil,
        voiceId: String? = nil
    )
    {
        self.languageCode = languageCode
        self.text = text
        self.voiceId = voiceId
    }
}

extension SSMLMessageType: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case languageCode = "LanguageCode"
        case text = "Text"
        case voiceId = "VoiceId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let languageCode = languageCode {
            try encodeContainer.encode(languageCode, forKey: .languageCode)
        }
        if let text = text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let voiceId = voiceId {
            try encodeContainer.encode(voiceId, forKey: .voiceId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let languageCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .languageCode)
        languageCode = languageCodeDecoded
        let textDecoded = try containerValues.decodeIfPresent(String.self, forKey: .text)
        text = textDecoded
        let voiceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .voiceId)
        voiceId = voiceIdDecoded
    }
}

extension SSMLMessageType: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SSMLMessageType(languageCode: \(String(describing: languageCode)), text: \(String(describing: text)), voiceId: \(String(describing: voiceId)))"}
}

/// An object that defines a message that contains SSML-formatted text.
public struct SSMLMessageType: Equatable {
    /// The language to use when delivering the message. For a complete list of supported languages, see the Amazon Polly Developer Guide.
    public let languageCode: String?
    /// The SSML-formatted text to deliver to the recipient.
    public let text: String?
    /// The name of the voice that you want to use to deliver the message. For a complete list of supported voices, see the Amazon Polly Developer Guide.
    public let voiceId: String?

    public init (
        languageCode: String? = nil,
        text: String? = nil,
        voiceId: String? = nil
    )
    {
        self.languageCode = languageCode
        self.text = text
        self.voiceId = voiceId
    }
}

public struct SendVoiceMessageInputBodyMiddleware: Middleware {
    public let id: String = "SendVoiceMessageInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendVoiceMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<SendVoiceMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendVoiceMessageInput>
    public typealias MOutput = OperationOutput<SendVoiceMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendVoiceMessageOutputError>
}

extension SendVoiceMessageInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendVoiceMessageInput(callerId: \(String(describing: callerId)), configurationSetName: \(String(describing: configurationSetName)), content: \(String(describing: content)), destinationPhoneNumber: \(String(describing: destinationPhoneNumber)), originationPhoneNumber: \(String(describing: originationPhoneNumber)))"}
}

extension SendVoiceMessageInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callerId = "CallerId"
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case originationPhoneNumber = "OriginationPhoneNumber"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callerId = callerId {
            try encodeContainer.encode(callerId, forKey: .callerId)
        }
        if let configurationSetName = configurationSetName {
            try encodeContainer.encode(configurationSetName, forKey: .configurationSetName)
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let destinationPhoneNumber = destinationPhoneNumber {
            try encodeContainer.encode(destinationPhoneNumber, forKey: .destinationPhoneNumber)
        }
        if let originationPhoneNumber = originationPhoneNumber {
            try encodeContainer.encode(originationPhoneNumber, forKey: .originationPhoneNumber)
        }
    }
}

public struct SendVoiceMessageInputHeadersMiddleware: Middleware {
    public let id: String = "SendVoiceMessageInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendVoiceMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<SendVoiceMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendVoiceMessageInput>
    public typealias MOutput = OperationOutput<SendVoiceMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendVoiceMessageOutputError>
}

public struct SendVoiceMessageInputQueryItemMiddleware: Middleware {
    public let id: String = "SendVoiceMessageInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SendVoiceMessageInput>,
                  next: H) -> Swift.Result<OperationOutput<SendVoiceMessageOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SendVoiceMessageInput>
    public typealias MOutput = OperationOutput<SendVoiceMessageOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SendVoiceMessageOutputError>
}

/// SendVoiceMessageRequest
public struct SendVoiceMessageInput: Equatable {
    /// The phone number that appears on recipients' devices when they receive the message.
    public let callerId: String?
    /// The name of the configuration set that you want to use to send the message.
    public let configurationSetName: String?
    /// An object that contains a voice message and information about the recipient that you want to send it to.
    public let content: VoiceMessageContent?
    /// The phone number that you want to send the voice message to.
    public let destinationPhoneNumber: String?
    /// The phone number that Amazon Pinpoint should use to send the voice message. This isn't necessarily the phone number that appears on recipients' devices when they receive the message, because you can specify a CallerId parameter in the request.
    public let originationPhoneNumber: String?

    public init (
        callerId: String? = nil,
        configurationSetName: String? = nil,
        content: VoiceMessageContent? = nil,
        destinationPhoneNumber: String? = nil,
        originationPhoneNumber: String? = nil
    )
    {
        self.callerId = callerId
        self.configurationSetName = configurationSetName
        self.content = content
        self.destinationPhoneNumber = destinationPhoneNumber
        self.originationPhoneNumber = originationPhoneNumber
    }
}

struct SendVoiceMessageInputBody: Equatable {
    public let callerId: String?
    public let configurationSetName: String?
    public let content: VoiceMessageContent?
    public let destinationPhoneNumber: String?
    public let originationPhoneNumber: String?
}

extension SendVoiceMessageInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case callerId = "CallerId"
        case configurationSetName = "ConfigurationSetName"
        case content = "Content"
        case destinationPhoneNumber = "DestinationPhoneNumber"
        case originationPhoneNumber = "OriginationPhoneNumber"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callerIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .callerId)
        callerId = callerIdDecoded
        let configurationSetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .configurationSetName)
        configurationSetName = configurationSetNameDecoded
        let contentDecoded = try containerValues.decodeIfPresent(VoiceMessageContent.self, forKey: .content)
        content = contentDecoded
        let destinationPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destinationPhoneNumber)
        destinationPhoneNumber = destinationPhoneNumberDecoded
        let originationPhoneNumberDecoded = try containerValues.decodeIfPresent(String.self, forKey: .originationPhoneNumber)
        originationPhoneNumber = originationPhoneNumberDecoded
    }
}

extension SendVoiceMessageOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendVoiceMessageOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SendVoiceMessageOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendVoiceMessageOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SendVoiceMessageOutputResponse(messageId: \(String(describing: messageId)))"}
}

extension SendVoiceMessageOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SendVoiceMessageOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.messageId = output.messageId
        } else {
            self.messageId = nil
        }
    }
}

/// An object that that contains the Message ID of a Voice message that was sent successfully.
public struct SendVoiceMessageOutputResponse: Equatable {
    /// A unique identifier for the voice message.
    public let messageId: String?

    public init (
        messageId: String? = nil
    )
    {
        self.messageId = messageId
    }
}

struct SendVoiceMessageOutputResponseBody: Equatable {
    public let messageId: String?
}

extension SendVoiceMessageOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case messageId = "MessageId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageId)
        messageId = messageIdDecoded
    }
}

extension SnsDestination: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case topicArn = "TopicArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SnsDestination: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SnsDestination(topicArn: \(String(describing: topicArn)))"}
}

/// An object that contains information about an event destination that sends data to Amazon SNS.
public struct SnsDestination: Equatable {
    /// The Amazon Resource Name (ARN) of the Amazon SNS topic that you want to publish events to.
    public let topicArn: String?

    public init (
        topicArn: String? = nil
    )
    {
        self.topicArn = topicArn
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(message: \(String(describing: message)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've issued too many requests to the resource. Wait a few minutes, and then try again.
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let message: String?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct UpdateConfigurationSetEventDestinationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

extension UpdateConfigurationSetEventDestinationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationInput(configurationSetName: \(String(describing: configurationSetName)), eventDestination: \(String(describing: eventDestination)), eventDestinationName: \(String(describing: eventDestinationName)))"}
}

extension UpdateConfigurationSetEventDestinationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventDestination = eventDestination {
            try encodeContainer.encode(eventDestination, forKey: .eventDestination)
        }
    }
}

public struct UpdateConfigurationSetEventDestinationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

public struct UpdateConfigurationSetEventDestinationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateConfigurationSetEventDestinationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateConfigurationSetEventDestinationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateConfigurationSetEventDestinationInput>
    public typealias MOutput = OperationOutput<UpdateConfigurationSetEventDestinationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateConfigurationSetEventDestinationOutputError>
}

/// UpdateConfigurationSetEventDestinationRequest
public struct UpdateConfigurationSetEventDestinationInput: Equatable {
    /// ConfigurationSetName
    public let configurationSetName: String?
    /// An object that defines a single event destination.
    public let eventDestination: EventDestinationDefinition?
    /// EventDestinationName
    public let eventDestinationName: String?

    public init (
        configurationSetName: String? = nil,
        eventDestination: EventDestinationDefinition? = nil,
        eventDestinationName: String? = nil
    )
    {
        self.configurationSetName = configurationSetName
        self.eventDestination = eventDestination
        self.eventDestinationName = eventDestinationName
    }
}

struct UpdateConfigurationSetEventDestinationInputBody: Equatable {
    public let eventDestination: EventDestinationDefinition?
}

extension UpdateConfigurationSetEventDestinationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventDestination = "EventDestination"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDestinationDecoded = try containerValues.decodeIfPresent(EventDestinationDefinition.self, forKey: .eventDestination)
        eventDestination = eventDestinationDecoded
    }
}

extension UpdateConfigurationSetEventDestinationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateConfigurationSetEventDestinationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServiceErrorException" : self = .internalServiceErrorException(try InternalServiceErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateConfigurationSetEventDestinationOutputError: Swift.Error, Equatable {
    case badRequestException(BadRequestException)
    case internalServiceErrorException(InternalServiceErrorException)
    case notFoundException(NotFoundException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateConfigurationSetEventDestinationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateConfigurationSetEventDestinationOutputResponse()"}
}

extension UpdateConfigurationSetEventDestinationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

/// An empty object that indicates that the event destination was updated successfully.
public struct UpdateConfigurationSetEventDestinationOutputResponse: Equatable {

    public init() {}
}

struct UpdateConfigurationSetEventDestinationOutputResponseBody: Equatable {
}

extension UpdateConfigurationSetEventDestinationOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension VoiceMessageContent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case callInstructionsMessage = "CallInstructionsMessage"
        case plainTextMessage = "PlainTextMessage"
        case sSMLMessage = "SSMLMessage"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let callInstructionsMessage = callInstructionsMessage {
            try encodeContainer.encode(callInstructionsMessage, forKey: .callInstructionsMessage)
        }
        if let plainTextMessage = plainTextMessage {
            try encodeContainer.encode(plainTextMessage, forKey: .plainTextMessage)
        }
        if let sSMLMessage = sSMLMessage {
            try encodeContainer.encode(sSMLMessage, forKey: .sSMLMessage)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let callInstructionsMessageDecoded = try containerValues.decodeIfPresent(CallInstructionsMessageType.self, forKey: .callInstructionsMessage)
        callInstructionsMessage = callInstructionsMessageDecoded
        let plainTextMessageDecoded = try containerValues.decodeIfPresent(PlainTextMessageType.self, forKey: .plainTextMessage)
        plainTextMessage = plainTextMessageDecoded
        let sSMLMessageDecoded = try containerValues.decodeIfPresent(SSMLMessageType.self, forKey: .sSMLMessage)
        sSMLMessage = sSMLMessageDecoded
    }
}

extension VoiceMessageContent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VoiceMessageContent(callInstructionsMessage: \(String(describing: callInstructionsMessage)), plainTextMessage: \(String(describing: plainTextMessage)), sSMLMessage: \(String(describing: sSMLMessage)))"}
}

/// An object that contains a voice message and information about the recipient that you want to send it to.
public struct VoiceMessageContent: Equatable {
    /// An object that defines a message that contains text formatted using Amazon Pinpoint Voice Instructions markup.
    public let callInstructionsMessage: CallInstructionsMessageType?
    /// An object that defines a message that contains unformatted text.
    public let plainTextMessage: PlainTextMessageType?
    /// An object that defines a message that contains SSML-formatted text.
    public let sSMLMessage: SSMLMessageType?

    public init (
        callInstructionsMessage: CallInstructionsMessageType? = nil,
        plainTextMessage: PlainTextMessageType? = nil,
        sSMLMessage: SSMLMessageType? = nil
    )
    {
        self.callInstructionsMessage = callInstructionsMessage
        self.plainTextMessage = plainTextMessage
        self.sSMLMessage = sSMLMessage
    }
}
