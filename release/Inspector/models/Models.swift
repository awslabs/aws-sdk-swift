// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

public enum AccessDeniedErrorCode {
    case accessDeniedToAssessmentRun
    case accessDeniedToAssessmentTarget
    case accessDeniedToAssessmentTemplate
    case accessDeniedToFinding
    case accessDeniedToIamRole
    case accessDeniedToResourceGroup
    case accessDeniedToRulesPackage
    case accessDeniedToSnsTopic
    case sdkUnknown(String)
}

extension AccessDeniedErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AccessDeniedErrorCode] {
        return [
            .accessDeniedToAssessmentRun,
            .accessDeniedToAssessmentTarget,
            .accessDeniedToAssessmentTemplate,
            .accessDeniedToFinding,
            .accessDeniedToIamRole,
            .accessDeniedToResourceGroup,
            .accessDeniedToRulesPackage,
            .accessDeniedToSnsTopic,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDeniedToAssessmentRun: return "ACCESS_DENIED_TO_ASSESSMENT_RUN"
        case .accessDeniedToAssessmentTarget: return "ACCESS_DENIED_TO_ASSESSMENT_TARGET"
        case .accessDeniedToAssessmentTemplate: return "ACCESS_DENIED_TO_ASSESSMENT_TEMPLATE"
        case .accessDeniedToFinding: return "ACCESS_DENIED_TO_FINDING"
        case .accessDeniedToIamRole: return "ACCESS_DENIED_TO_IAM_ROLE"
        case .accessDeniedToResourceGroup: return "ACCESS_DENIED_TO_RESOURCE_GROUP"
        case .accessDeniedToRulesPackage: return "ACCESS_DENIED_TO_RULES_PACKAGE"
        case .accessDeniedToSnsTopic: return "ACCESS_DENIED_TO_SNS_TOPIC"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AccessDeniedErrorCode(rawValue: rawValue) ?? AccessDeniedErrorCode.sdkUnknown(rawValue)
    }
}

extension AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccessDeniedException(canRetry: \(String(describing: canRetry)), errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You do not have required permissions to access the requested resource.</p>
public struct AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Code that indicates the type of error that is generated.</p>
    public var errorCode: AccessDeniedErrorCode?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        errorCode: AccessDeniedErrorCode? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Equatable {
    public let message: String?
    public let errorCode: AccessDeniedErrorCode?
    public let canRetry: Bool?
}

extension AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(AccessDeniedErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct AddAttributesToFindingsInputBodyMiddleware: Middleware {
    public let id: String = "AddAttributesToFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddAttributesToFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddAttributesToFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddAttributesToFindingsInput>
    public typealias MOutput = OperationOutput<AddAttributesToFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddAttributesToFindingsOutputError>
}

extension AddAttributesToFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddAttributesToFindingsInput(attributes: \(String(describing: attributes)), findingArns: \(String(describing: findingArns)))"}
}

extension AddAttributesToFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case findingArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for userattributelist0 in attributes {
                try attributesContainer.encode(userattributelist0)
            }
        }
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for addremoveattributesfindingarnlist0 in findingArns {
                try findingArnsContainer.encode(addremoveattributesfindingarnlist0)
            }
        }
    }
}

public struct AddAttributesToFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "AddAttributesToFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddAttributesToFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddAttributesToFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddAttributesToFindingsInput>
    public typealias MOutput = OperationOutput<AddAttributesToFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddAttributesToFindingsOutputError>
}

public struct AddAttributesToFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "AddAttributesToFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddAttributesToFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<AddAttributesToFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddAttributesToFindingsInput>
    public typealias MOutput = OperationOutput<AddAttributesToFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddAttributesToFindingsOutputError>
}

public struct AddAttributesToFindingsInput: Equatable {
    /// <p>The array of attributes that you want to assign to specified findings.</p>
    public let attributes: [Attribute]?
    /// <p>The ARNs that specify the findings that you want to assign attributes to.</p>
    public let findingArns: [String]?

    public init (
        attributes: [Attribute]? = nil,
        findingArns: [String]? = nil
    )
    {
        self.attributes = attributes
        self.findingArns = findingArns
    }
}

struct AddAttributesToFindingsInputBody: Equatable {
    public let findingArns: [String]?
    public let attributes: [Attribute]?
}

extension AddAttributesToFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributes
        case findingArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension AddAttributesToFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddAttributesToFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddAttributesToFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddAttributesToFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddAttributesToFindingsOutputResponse(failedItems: \(String(describing: failedItems)))"}
}

extension AddAttributesToFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddAttributesToFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedItems = output.failedItems
        } else {
            self.failedItems = nil
        }
    }
}

public struct AddAttributesToFindingsOutputResponse: Equatable {
    /// <p>Attribute details that cannot be described. An error code is provided for each failed
    ///          item.</p>
    public let failedItems: [String:FailedItemDetails]?

    public init (
        failedItems: [String:FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

struct AddAttributesToFindingsOutputResponseBody: Equatable {
    public let failedItems: [String:FailedItemDetails]?
}

extension AddAttributesToFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedItems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension AgentAlreadyRunningAssessment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentId
        case assessmentRunArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension AgentAlreadyRunningAssessment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentAlreadyRunningAssessment(agentId: \(String(describing: agentId)), assessmentRunArn: \(String(describing: assessmentRunArn)))"}
}

/// <p>Used in the exception error that is thrown if you start an assessment run for an
///          assessment target that includes an EC2 instance that is already participating in another
///          started assessment run.</p>
public struct AgentAlreadyRunningAssessment: Equatable {
    /// <p>ID of the agent that is running on an EC2 instance that is already participating in
    ///          another started assessment run.</p>
    public let agentId: String?
    /// <p>The ARN of the assessment run that has already been started.</p>
    public let assessmentRunArn: String?

    public init (
        agentId: String? = nil,
        assessmentRunArn: String? = nil
    )
    {
        self.agentId = agentId
        self.assessmentRunArn = assessmentRunArn
    }
}

extension AgentFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentHealthCodes
        case agentHealths
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealthCodes = agentHealthCodes {
            var agentHealthCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentHealthCodes)
            for agenthealthcodelist0 in agentHealthCodes {
                try agentHealthCodesContainer.encode(agenthealthcodelist0.rawValue)
            }
        }
        if let agentHealths = agentHealths {
            var agentHealthsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentHealths)
            for agenthealthlist0 in agentHealths {
                try agentHealthsContainer.encode(agenthealthlist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentHealthsContainer = try containerValues.decodeIfPresent([AgentHealth?].self, forKey: .agentHealths)
        var agentHealthsDecoded0:[AgentHealth]? = nil
        if let agentHealthsContainer = agentHealthsContainer {
            agentHealthsDecoded0 = [AgentHealth]()
            for string0 in agentHealthsContainer {
                if let string0 = string0 {
                    agentHealthsDecoded0?.append(string0)
                }
            }
        }
        agentHealths = agentHealthsDecoded0
        let agentHealthCodesContainer = try containerValues.decodeIfPresent([AgentHealthCode?].self, forKey: .agentHealthCodes)
        var agentHealthCodesDecoded0:[AgentHealthCode]? = nil
        if let agentHealthCodesContainer = agentHealthCodesContainer {
            agentHealthCodesDecoded0 = [AgentHealthCode]()
            for string0 in agentHealthCodesContainer {
                if let string0 = string0 {
                    agentHealthCodesDecoded0?.append(string0)
                }
            }
        }
        agentHealthCodes = agentHealthCodesDecoded0
    }
}

extension AgentFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentFilter(agentHealthCodes: \(String(describing: agentHealthCodes)), agentHealths: \(String(describing: agentHealths)))"}
}

/// <p>Contains information about an Amazon Inspector agent. This data type is used as a
///          request parameter in the <a>ListAssessmentRunAgents</a> action.</p>
public struct AgentFilter: Equatable {
    /// <p>The detailed health state of the agent. Values can be set to <b>IDLE</b>, <b>RUNNING</b>, <b>SHUTDOWN</b>, <b>UNHEALTHY</b>, <b>THROTTLED</b>, and <b>UNKNOWN</b>. </p>
    public let agentHealthCodes: [AgentHealthCode]?
    /// <p>The current health state of the agent. Values can be set to <b>HEALTHY</b> or <b>UNHEALTHY</b>.</p>
    public let agentHealths: [AgentHealth]?

    public init (
        agentHealthCodes: [AgentHealthCode]? = nil,
        agentHealths: [AgentHealth]? = nil
    )
    {
        self.agentHealthCodes = agentHealthCodes
        self.agentHealths = agentHealths
    }
}

public enum AgentHealth {
    case healthy
    case unhealthy
    case unknown
    case sdkUnknown(String)
}

extension AgentHealth : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AgentHealth] {
        return [
            .healthy,
            .unhealthy,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .healthy: return "HEALTHY"
        case .unhealthy: return "UNHEALTHY"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AgentHealth(rawValue: rawValue) ?? AgentHealth.sdkUnknown(rawValue)
    }
}

public enum AgentHealthCode {
    case idle
    case running
    case shutdown
    case throttled
    case unhealthy
    case unknown
    case sdkUnknown(String)
}

extension AgentHealthCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AgentHealthCode] {
        return [
            .idle,
            .running,
            .shutdown,
            .throttled,
            .unhealthy,
            .unknown,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .idle: return "IDLE"
        case .running: return "RUNNING"
        case .shutdown: return "SHUTDOWN"
        case .throttled: return "THROTTLED"
        case .unhealthy: return "UNHEALTHY"
        case .unknown: return "UNKNOWN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AgentHealthCode(rawValue: rawValue) ?? AgentHealthCode.sdkUnknown(rawValue)
    }
}

extension AgentPreview: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentHealth
        case agentId
        case agentVersion
        case autoScalingGroup
        case hostname
        case ipv4Address
        case kernelVersion
        case operatingSystem
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealth = agentHealth {
            try encodeContainer.encode(agentHealth.rawValue, forKey: .agentHealth)
        }
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let agentVersion = agentVersion {
            try encodeContainer.encode(agentVersion, forKey: .agentVersion)
        }
        if let autoScalingGroup = autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipv4Address = ipv4Address {
            try encodeContainer.encode(ipv4Address, forKey: .ipv4Address)
        }
        if let kernelVersion = kernelVersion {
            try encodeContainer.encode(kernelVersion, forKey: .kernelVersion)
        }
        if let operatingSystem = operatingSystem {
            try encodeContainer.encode(operatingSystem, forKey: .operatingSystem)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let agentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let agentHealthDecoded = try containerValues.decodeIfPresent(AgentHealth.self, forKey: .agentHealth)
        agentHealth = agentHealthDecoded
        let agentVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentVersion)
        agentVersion = agentVersionDecoded
        let operatingSystemDecoded = try containerValues.decodeIfPresent(String.self, forKey: .operatingSystem)
        operatingSystem = operatingSystemDecoded
        let kernelVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kernelVersion)
        kernelVersion = kernelVersionDecoded
        let ipv4AddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .ipv4Address)
        ipv4Address = ipv4AddressDecoded
    }
}

extension AgentPreview: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentPreview(agentHealth: \(String(describing: agentHealth)), agentId: \(String(describing: agentId)), agentVersion: \(String(describing: agentVersion)), autoScalingGroup: \(String(describing: autoScalingGroup)), hostname: \(String(describing: hostname)), ipv4Address: \(String(describing: ipv4Address)), kernelVersion: \(String(describing: kernelVersion)), operatingSystem: \(String(describing: operatingSystem)))"}
}

/// <p>Used as a response element in the <a>PreviewAgents</a> action.</p>
public struct AgentPreview: Equatable {
    /// <p>The health status of the Amazon Inspector Agent.</p>
    public let agentHealth: AgentHealth?
    /// <p>The ID of the EC2 instance where the agent is installed.</p>
    public let agentId: String?
    /// <p>The version of the Amazon Inspector Agent.</p>
    public let agentVersion: String?
    /// <p>The Auto Scaling group for the EC2 instance where the agent is installed.</p>
    public let autoScalingGroup: String?
    /// <p>The hostname of the EC2 instance on which the Amazon Inspector Agent is
    ///          installed.</p>
    public let hostname: String?
    /// <p>The IP address of the EC2 instance on which the Amazon Inspector Agent is
    ///          installed.</p>
    public let ipv4Address: String?
    /// <p>The kernel version of the operating system running on the EC2 instance on which the
    ///          Amazon Inspector Agent is installed.</p>
    public let kernelVersion: String?
    /// <p>The operating system running on the EC2 instance on which the Amazon Inspector Agent
    ///          is installed.</p>
    public let operatingSystem: String?

    public init (
        agentHealth: AgentHealth? = nil,
        agentId: String? = nil,
        agentVersion: String? = nil,
        autoScalingGroup: String? = nil,
        hostname: String? = nil,
        ipv4Address: String? = nil,
        kernelVersion: String? = nil,
        operatingSystem: String? = nil
    )
    {
        self.agentHealth = agentHealth
        self.agentId = agentId
        self.agentVersion = agentVersion
        self.autoScalingGroup = autoScalingGroup
        self.hostname = hostname
        self.ipv4Address = ipv4Address
        self.kernelVersion = kernelVersion
        self.operatingSystem = operatingSystem
    }
}

extension AgentsAlreadyRunningAssessmentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AgentsAlreadyRunningAssessmentException(agents: \(String(describing: agents)), agentsTruncated: \(String(describing: agentsTruncated)), canRetry: \(String(describing: canRetry)), message: \(String(describing: message)))"}
}

extension AgentsAlreadyRunningAssessmentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AgentsAlreadyRunningAssessmentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agents = output.agents
            self.agentsTruncated = output.agentsTruncated
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.agents = nil
            self.agentsTruncated = nil
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You started an assessment run, but one of the instances is already participating in
///          another assessment run.</p>
public struct AgentsAlreadyRunningAssessmentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p></p>
    public var agents: [AgentAlreadyRunningAssessment]?
    /// <p></p>
    public var agentsTruncated: Bool?
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        agents: [AgentAlreadyRunningAssessment]? = nil,
        agentsTruncated: Bool? = nil,
        canRetry: Bool? = nil,
        message: String? = nil
    )
    {
        self.agents = agents
        self.agentsTruncated = agentsTruncated
        self.canRetry = canRetry
        self.message = message
    }
}

struct AgentsAlreadyRunningAssessmentExceptionBody: Equatable {
    public let message: String?
    public let agents: [AgentAlreadyRunningAssessment]?
    public let agentsTruncated: Bool?
    public let canRetry: Bool?
}

extension AgentsAlreadyRunningAssessmentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agents
        case agentsTruncated
        case canRetry
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let agentsContainer = try containerValues.decodeIfPresent([AgentAlreadyRunningAssessment?].self, forKey: .agents)
        var agentsDecoded0:[AgentAlreadyRunningAssessment]? = nil
        if let agentsContainer = agentsContainer {
            agentsDecoded0 = [AgentAlreadyRunningAssessment]()
            for structure0 in agentsContainer {
                if let structure0 = structure0 {
                    agentsDecoded0?.append(structure0)
                }
            }
        }
        agents = agentsDecoded0
        let agentsTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .agentsTruncated)
        agentsTruncated = agentsTruncatedDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension AssessmentRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case assessmentTemplateArn
        case completedAt
        case createdAt
        case dataCollected
        case durationInSeconds
        case findingCounts
        case name
        case notifications
        case rulesPackageArns
        case startedAt
        case state
        case stateChangedAt
        case stateChanges
        case userAttributesForFindings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataCollected = dataCollected {
            try encodeContainer.encode(dataCollected, forKey: .dataCollected)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let findingCounts = findingCounts {
            var findingCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .findingCounts)
            for (dictKey0, assessmentrunfindingcounts0) in findingCounts {
                try findingCountsContainer.encode(assessmentrunfindingcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for assessmentrunnotificationlist0 in notifications {
                try notificationsContainer.encode(assessmentrunnotificationlist0)
            }
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for assessmentrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(assessmentrulespackagearnlist0)
            }
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangedAt = stateChangedAt {
            try encodeContainer.encode(stateChangedAt.timeIntervalSince1970, forKey: .stateChangedAt)
        }
        if let stateChanges = stateChanges {
            var stateChangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stateChanges)
            for assessmentrunstatechangelist0 in stateChanges {
                try stateChangesContainer.encode(assessmentrunstatechangelist0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for userattributelist0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(userattributelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AssessmentRunState.self, forKey: .state)
        state = stateDecoded
        let durationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let stateChangedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stateChangedAt)
        stateChangedAt = stateChangedAtDecoded
        let dataCollectedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .dataCollected)
        dataCollected = dataCollectedDecoded
        let stateChangesContainer = try containerValues.decodeIfPresent([AssessmentRunStateChange?].self, forKey: .stateChanges)
        var stateChangesDecoded0:[AssessmentRunStateChange]? = nil
        if let stateChangesContainer = stateChangesContainer {
            stateChangesDecoded0 = [AssessmentRunStateChange]()
            for structure0 in stateChangesContainer {
                if let structure0 = structure0 {
                    stateChangesDecoded0?.append(structure0)
                }
            }
        }
        stateChanges = stateChangesDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([AssessmentRunNotification?].self, forKey: .notifications)
        var notificationsDecoded0:[AssessmentRunNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [AssessmentRunNotification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let findingCountsContainer = try containerValues.decodeIfPresent([String: Int?].self, forKey: .findingCounts)
        var findingCountsDecoded0: [String:Int]? = nil
        if let findingCountsContainer = findingCountsContainer {
            findingCountsDecoded0 = [String:Int]()
            for (key0, findingcount0) in findingCountsContainer {
                if let findingcount0 = findingcount0 {
                    findingCountsDecoded0?[key0] = findingcount0
                }
            }
        }
        findingCounts = findingCountsDecoded0
    }
}

extension AssessmentRun: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentRun(arn: \(String(describing: arn)), assessmentTemplateArn: \(String(describing: assessmentTemplateArn)), completedAt: \(String(describing: completedAt)), createdAt: \(String(describing: createdAt)), dataCollected: \(String(describing: dataCollected)), durationInSeconds: \(String(describing: durationInSeconds)), findingCounts: \(String(describing: findingCounts)), name: \(String(describing: name)), notifications: \(String(describing: notifications)), rulesPackageArns: \(String(describing: rulesPackageArns)), startedAt: \(String(describing: startedAt)), state: \(String(describing: state)), stateChangedAt: \(String(describing: stateChangedAt)), stateChanges: \(String(describing: stateChanges)), userAttributesForFindings: \(String(describing: userAttributesForFindings)))"}
}

/// <p>A snapshot of an Amazon Inspector assessment run that contains the findings of the
///          assessment run .</p>
///          <p>Used as the response element in the <a>DescribeAssessmentRuns</a>
///          action.</p>
public struct AssessmentRun: Equatable {
    /// <p>The ARN of the assessment run.</p>
    public let arn: String?
    /// <p>The ARN of the assessment template that is associated with the assessment
    ///          run.</p>
    public let assessmentTemplateArn: String?
    /// <p>The assessment run completion time that corresponds to the rules packages evaluation
    ///          completion time or failure.</p>
    public let completedAt: Date?
    /// <p>The time when <a>StartAssessmentRun</a> was called.</p>
    public let createdAt: Date?
    /// <p>A Boolean value (true or false) that specifies whether the process of collecting data
    ///          from the agents is completed.</p>
    public let dataCollected: Bool?
    /// <p>The duration of the assessment run.</p>
    public let durationInSeconds: Int
    /// <p>Provides a total count of generated findings per severity.</p>
    public let findingCounts: [String:Int]?
    /// <p>The auto-generated name for the assessment run.</p>
    public let name: String?
    /// <p>A list of notifications for the event subscriptions. A notification about a
    ///          particular generated finding is added to this list only once.</p>
    public let notifications: [AssessmentRunNotification]?
    /// <p>The rules packages selected for the assessment run.</p>
    public let rulesPackageArns: [String]?
    /// <p>The time when <a>StartAssessmentRun</a> was called.</p>
    public let startedAt: Date?
    /// <p>The state of the assessment run.</p>
    public let state: AssessmentRunState?
    /// <p>The last time when the assessment run's state changed.</p>
    public let stateChangedAt: Date?
    /// <p>A list of the assessment run state changes.</p>
    public let stateChanges: [AssessmentRunStateChange]?
    /// <p>The user-defined attributes that are assigned to every generated finding.</p>
    public let userAttributesForFindings: [Attribute]?

    public init (
        arn: String? = nil,
        assessmentTemplateArn: String? = nil,
        completedAt: Date? = nil,
        createdAt: Date? = nil,
        dataCollected: Bool? = nil,
        durationInSeconds: Int = 0,
        findingCounts: [String:Int]? = nil,
        name: String? = nil,
        notifications: [AssessmentRunNotification]? = nil,
        rulesPackageArns: [String]? = nil,
        startedAt: Date? = nil,
        state: AssessmentRunState? = nil,
        stateChangedAt: Date? = nil,
        stateChanges: [AssessmentRunStateChange]? = nil,
        userAttributesForFindings: [Attribute]? = nil
    )
    {
        self.arn = arn
        self.assessmentTemplateArn = assessmentTemplateArn
        self.completedAt = completedAt
        self.createdAt = createdAt
        self.dataCollected = dataCollected
        self.durationInSeconds = durationInSeconds
        self.findingCounts = findingCounts
        self.name = name
        self.notifications = notifications
        self.rulesPackageArns = rulesPackageArns
        self.startedAt = startedAt
        self.state = state
        self.stateChangedAt = stateChangedAt
        self.stateChanges = stateChanges
        self.userAttributesForFindings = userAttributesForFindings
    }
}

extension AssessmentRunAgent: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentHealth
        case agentHealthCode
        case agentHealthDetails
        case agentId
        case assessmentRunArn
        case autoScalingGroup
        case telemetryMetadata
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentHealth = agentHealth {
            try encodeContainer.encode(agentHealth.rawValue, forKey: .agentHealth)
        }
        if let agentHealthCode = agentHealthCode {
            try encodeContainer.encode(agentHealthCode.rawValue, forKey: .agentHealthCode)
        }
        if let agentHealthDetails = agentHealthDetails {
            try encodeContainer.encode(agentHealthDetails, forKey: .agentHealthDetails)
        }
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let autoScalingGroup = autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let telemetryMetadata = telemetryMetadata {
            var telemetryMetadataContainer = encodeContainer.nestedUnkeyedContainer(forKey: .telemetryMetadata)
            for telemetrymetadatalist0 in telemetryMetadata {
                try telemetryMetadataContainer.encode(telemetrymetadatalist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let agentHealthDecoded = try containerValues.decodeIfPresent(AgentHealth.self, forKey: .agentHealth)
        agentHealth = agentHealthDecoded
        let agentHealthCodeDecoded = try containerValues.decodeIfPresent(AgentHealthCode.self, forKey: .agentHealthCode)
        agentHealthCode = agentHealthCodeDecoded
        let agentHealthDetailsDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentHealthDetails)
        agentHealthDetails = agentHealthDetailsDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let telemetryMetadataContainer = try containerValues.decodeIfPresent([TelemetryMetadata?].self, forKey: .telemetryMetadata)
        var telemetryMetadataDecoded0:[TelemetryMetadata]? = nil
        if let telemetryMetadataContainer = telemetryMetadataContainer {
            telemetryMetadataDecoded0 = [TelemetryMetadata]()
            for structure0 in telemetryMetadataContainer {
                if let structure0 = structure0 {
                    telemetryMetadataDecoded0?.append(structure0)
                }
            }
        }
        telemetryMetadata = telemetryMetadataDecoded0
    }
}

extension AssessmentRunAgent: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentRunAgent(agentHealth: \(String(describing: agentHealth)), agentHealthCode: \(String(describing: agentHealthCode)), agentHealthDetails: \(String(describing: agentHealthDetails)), agentId: \(String(describing: agentId)), assessmentRunArn: \(String(describing: assessmentRunArn)), autoScalingGroup: \(String(describing: autoScalingGroup)), telemetryMetadata: \(String(describing: telemetryMetadata)))"}
}

/// <p>Contains information about an Amazon Inspector agent. This data type is used as a
///          response element in the <a>ListAssessmentRunAgents</a> action.</p>
public struct AssessmentRunAgent: Equatable {
    /// <p>The current health state of the agent.</p>
    public let agentHealth: AgentHealth?
    /// <p>The detailed health state of the agent.</p>
    public let agentHealthCode: AgentHealthCode?
    /// <p>The description for the agent health code.</p>
    public let agentHealthDetails: String?
    /// <p>The AWS account of the EC2 instance where the agent is installed.</p>
    public let agentId: String?
    /// <p>The ARN of the assessment run that is associated with the agent.</p>
    public let assessmentRunArn: String?
    /// <p>The Auto Scaling group of the EC2 instance that is specified by the agent
    ///          ID.</p>
    public let autoScalingGroup: String?
    /// <p>The Amazon Inspector application data metrics that are collected by the
    ///          agent.</p>
    public let telemetryMetadata: [TelemetryMetadata]?

    public init (
        agentHealth: AgentHealth? = nil,
        agentHealthCode: AgentHealthCode? = nil,
        agentHealthDetails: String? = nil,
        agentId: String? = nil,
        assessmentRunArn: String? = nil,
        autoScalingGroup: String? = nil,
        telemetryMetadata: [TelemetryMetadata]? = nil
    )
    {
        self.agentHealth = agentHealth
        self.agentHealthCode = agentHealthCode
        self.agentHealthDetails = agentHealthDetails
        self.agentId = agentId
        self.assessmentRunArn = assessmentRunArn
        self.autoScalingGroup = autoScalingGroup
        self.telemetryMetadata = telemetryMetadata
    }
}

extension AssessmentRunFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case completionTimeRange
        case durationRange
        case namePattern
        case rulesPackageArns
        case startTimeRange
        case stateChangeTimeRange
        case states
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTimeRange = completionTimeRange {
            try encodeContainer.encode(completionTimeRange, forKey: .completionTimeRange)
        }
        if let durationRange = durationRange {
            try encodeContainer.encode(durationRange, forKey: .durationRange)
        }
        if let namePattern = namePattern {
            try encodeContainer.encode(namePattern, forKey: .namePattern)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for filterrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(filterrulespackagearnlist0)
            }
        }
        if let startTimeRange = startTimeRange {
            try encodeContainer.encode(startTimeRange, forKey: .startTimeRange)
        }
        if let stateChangeTimeRange = stateChangeTimeRange {
            try encodeContainer.encode(stateChangeTimeRange, forKey: .stateChangeTimeRange)
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for assessmentrunstatelist0 in states {
                try statesContainer.encode(assessmentrunstatelist0.rawValue)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePattern)
        namePattern = namePatternDecoded
        let statesContainer = try containerValues.decodeIfPresent([AssessmentRunState?].self, forKey: .states)
        var statesDecoded0:[AssessmentRunState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [AssessmentRunState]()
            for string0 in statesContainer {
                if let string0 = string0 {
                    statesDecoded0?.append(string0)
                }
            }
        }
        states = statesDecoded0
        let durationRangeDecoded = try containerValues.decodeIfPresent(DurationRange.self, forKey: .durationRange)
        durationRange = durationRangeDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let startTimeRangeDecoded = try containerValues.decodeIfPresent(TimestampRange.self, forKey: .startTimeRange)
        startTimeRange = startTimeRangeDecoded
        let completionTimeRangeDecoded = try containerValues.decodeIfPresent(TimestampRange.self, forKey: .completionTimeRange)
        completionTimeRange = completionTimeRangeDecoded
        let stateChangeTimeRangeDecoded = try containerValues.decodeIfPresent(TimestampRange.self, forKey: .stateChangeTimeRange)
        stateChangeTimeRange = stateChangeTimeRangeDecoded
    }
}

extension AssessmentRunFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentRunFilter(completionTimeRange: \(String(describing: completionTimeRange)), durationRange: \(String(describing: durationRange)), namePattern: \(String(describing: namePattern)), rulesPackageArns: \(String(describing: rulesPackageArns)), startTimeRange: \(String(describing: startTimeRange)), stateChangeTimeRange: \(String(describing: stateChangeTimeRange)), states: \(String(describing: states)))"}
}

/// <p>Used as the request parameter in the <a>ListAssessmentRuns</a>
///          action.</p>
public struct AssessmentRunFilter: Equatable {
    /// <p>For a record to match a filter, the value that is specified for this data type
    ///          property must inclusively match any value between the specified minimum and maximum values
    ///          of the <b>completedAt</b> property of the <a>AssessmentRun</a> data type.</p>
    public let completionTimeRange: TimestampRange?
    /// <p>For a record to match a filter, the value that is specified for this data type
    ///          property must inclusively match any value between the specified minimum and maximum values
    ///          of the <b>durationInSeconds</b> property of the <a>AssessmentRun</a> data type.</p>
    public let durationRange: DurationRange?
    /// <p>For a record to match a filter, an explicit value or a string containing a wildcard
    ///          that is specified for this data type property must match the value of the <b>assessmentRunName</b> property of the <a>AssessmentRun</a>
    ///          data type.</p>
    public let namePattern: String?
    /// <p>For a record to match a filter, the value that is specified for this data type
    ///          property must be contained in the list of values of the <b>rulesPackages</b> property of the <a>AssessmentRun</a> data
    ///          type.</p>
    public let rulesPackageArns: [String]?
    /// <p>For a record to match a filter, the value that is specified for this data type
    ///          property must inclusively match any value between the specified minimum and maximum values
    ///          of the <b>startTime</b> property of the <a>AssessmentRun</a> data type.</p>
    public let startTimeRange: TimestampRange?
    /// <p>For a record to match a filter, the value that is specified for this data type
    ///          property must match the <b>stateChangedAt</b> property of the
    ///             <a>AssessmentRun</a> data type.</p>
    public let stateChangeTimeRange: TimestampRange?
    /// <p>For a record to match a filter, one of the values specified for this data type
    ///          property must be the exact match of the value of the <b>assessmentRunState</b> property of the <a>AssessmentRun</a> data
    ///          type.</p>
    public let states: [AssessmentRunState]?

    public init (
        completionTimeRange: TimestampRange? = nil,
        durationRange: DurationRange? = nil,
        namePattern: String? = nil,
        rulesPackageArns: [String]? = nil,
        startTimeRange: TimestampRange? = nil,
        stateChangeTimeRange: TimestampRange? = nil,
        states: [AssessmentRunState]? = nil
    )
    {
        self.completionTimeRange = completionTimeRange
        self.durationRange = durationRange
        self.namePattern = namePattern
        self.rulesPackageArns = rulesPackageArns
        self.startTimeRange = startTimeRange
        self.stateChangeTimeRange = stateChangeTimeRange
        self.states = states
    }
}

extension AssessmentRunInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentRunInProgressException(assessmentRunArns: \(String(describing: assessmentRunArns)), assessmentRunArnsTruncated: \(String(describing: assessmentRunArnsTruncated)), canRetry: \(String(describing: canRetry)), message: \(String(describing: message)))"}
}

extension AssessmentRunInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AssessmentRunInProgressExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentRunArns = output.assessmentRunArns
            self.assessmentRunArnsTruncated = output.assessmentRunArnsTruncated
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.assessmentRunArns = nil
            self.assessmentRunArnsTruncated = nil
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You cannot perform a specified action if an assessment run is currently in
///          progress.</p>
public struct AssessmentRunInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The ARNs of the assessment runs that are currently in progress.</p>
    public var assessmentRunArns: [String]?
    /// <p>Boolean value that indicates whether the ARN list of the assessment runs is
    ///          truncated.</p>
    public var assessmentRunArnsTruncated: Bool?
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        assessmentRunArns: [String]? = nil,
        assessmentRunArnsTruncated: Bool? = nil,
        canRetry: Bool? = nil,
        message: String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.assessmentRunArnsTruncated = assessmentRunArnsTruncated
        self.canRetry = canRetry
        self.message = message
    }
}

struct AssessmentRunInProgressExceptionBody: Equatable {
    public let message: String?
    public let assessmentRunArns: [String]?
    public let assessmentRunArnsTruncated: Bool?
    public let canRetry: Bool?
}

extension AssessmentRunInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArns
        case assessmentRunArnsTruncated
        case canRetry
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let assessmentRunArnsTruncatedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .assessmentRunArnsTruncated)
        assessmentRunArnsTruncated = assessmentRunArnsTruncatedDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

extension AssessmentRunNotification: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case date
        case error
        case event
        case message
        case snsPublishStatusCode
        case snsTopicArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let date = date {
            try encodeContainer.encode(date.timeIntervalSince1970, forKey: .date)
        }
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let snsPublishStatusCode = snsPublishStatusCode {
            try encodeContainer.encode(snsPublishStatusCode.rawValue, forKey: .snsPublishStatusCode)
        }
        if let snsTopicArn = snsTopicArn {
            try encodeContainer.encode(snsTopicArn, forKey: .snsTopicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .date)
        date = dateDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .error)
        error = errorDecoded
        let snsTopicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .snsTopicArn)
        snsTopicArn = snsTopicArnDecoded
        let snsPublishStatusCodeDecoded = try containerValues.decodeIfPresent(AssessmentRunNotificationSnsStatusCode.self, forKey: .snsPublishStatusCode)
        snsPublishStatusCode = snsPublishStatusCodeDecoded
    }
}

extension AssessmentRunNotification: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentRunNotification(date: \(String(describing: date)), error: \(String(describing: error)), event: \(String(describing: event)), message: \(String(describing: message)), snsPublishStatusCode: \(String(describing: snsPublishStatusCode)), snsTopicArn: \(String(describing: snsTopicArn)))"}
}

/// <p>Used as one of the elements of the <a>AssessmentRun</a> data
///          type.</p>
public struct AssessmentRunNotification: Equatable {
    /// <p>The date of the notification.</p>
    public let date: Date?
    /// <p>The Boolean value that specifies whether the notification represents an
    ///          error.</p>
    public let error: Bool?
    /// <p>The event for which a notification is sent.</p>
    public let event: InspectorEvent?
    /// <p>The message included in the notification.</p>
    public let message: String?
    /// <p>The status code of the SNS notification.</p>
    public let snsPublishStatusCode: AssessmentRunNotificationSnsStatusCode?
    /// <p>The SNS topic to which the SNS notification is sent.</p>
    public let snsTopicArn: String?

    public init (
        date: Date? = nil,
        error: Bool? = nil,
        event: InspectorEvent? = nil,
        message: String? = nil,
        snsPublishStatusCode: AssessmentRunNotificationSnsStatusCode? = nil,
        snsTopicArn: String? = nil
    )
    {
        self.date = date
        self.error = error
        self.event = event
        self.message = message
        self.snsPublishStatusCode = snsPublishStatusCode
        self.snsTopicArn = snsTopicArn
    }
}

public enum AssessmentRunNotificationSnsStatusCode {
    case accessDenied
    case internalError
    case success
    case topicDoesNotExist
    case sdkUnknown(String)
}

extension AssessmentRunNotificationSnsStatusCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssessmentRunNotificationSnsStatusCode] {
        return [
            .accessDenied,
            .internalError,
            .success,
            .topicDoesNotExist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .internalError: return "INTERNAL_ERROR"
        case .success: return "SUCCESS"
        case .topicDoesNotExist: return "TOPIC_DOES_NOT_EXIST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssessmentRunNotificationSnsStatusCode(rawValue: rawValue) ?? AssessmentRunNotificationSnsStatusCode.sdkUnknown(rawValue)
    }
}

public enum AssessmentRunState {
    case canceled
    case collectingData
    case completed
    case completedWithErrors
    case created
    case dataCollected
    case error
    case evaluatingRules
    case failed
    case startDataCollectionInProgress
    case startDataCollectionPending
    case startEvaluatingRulesPending
    case stopDataCollectionPending
    case sdkUnknown(String)
}

extension AssessmentRunState : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssessmentRunState] {
        return [
            .canceled,
            .collectingData,
            .completed,
            .completedWithErrors,
            .created,
            .dataCollected,
            .error,
            .evaluatingRules,
            .failed,
            .startDataCollectionInProgress,
            .startDataCollectionPending,
            .startEvaluatingRulesPending,
            .stopDataCollectionPending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .canceled: return "CANCELED"
        case .collectingData: return "COLLECTING_DATA"
        case .completed: return "COMPLETED"
        case .completedWithErrors: return "COMPLETED_WITH_ERRORS"
        case .created: return "CREATED"
        case .dataCollected: return "DATA_COLLECTED"
        case .error: return "ERROR"
        case .evaluatingRules: return "EVALUATING_RULES"
        case .failed: return "FAILED"
        case .startDataCollectionInProgress: return "START_DATA_COLLECTION_IN_PROGRESS"
        case .startDataCollectionPending: return "START_DATA_COLLECTION_PENDING"
        case .startEvaluatingRulesPending: return "START_EVALUATING_RULES_PENDING"
        case .stopDataCollectionPending: return "STOP_DATA_COLLECTION_PENDING"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssessmentRunState(rawValue: rawValue) ?? AssessmentRunState.sdkUnknown(rawValue)
    }
}

extension AssessmentRunStateChange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case state
        case stateChangedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangedAt = stateChangedAt {
            try encodeContainer.encode(stateChangedAt.timeIntervalSince1970, forKey: .stateChangedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateChangedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stateChangedAt)
        stateChangedAt = stateChangedAtDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AssessmentRunState.self, forKey: .state)
        state = stateDecoded
    }
}

extension AssessmentRunStateChange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentRunStateChange(state: \(String(describing: state)), stateChangedAt: \(String(describing: stateChangedAt)))"}
}

/// <p>Used as one of the elements of the <a>AssessmentRun</a> data
///          type.</p>
public struct AssessmentRunStateChange: Equatable {
    /// <p>The assessment run state.</p>
    public let state: AssessmentRunState?
    /// <p>The last time the assessment run state changed.</p>
    public let stateChangedAt: Date?

    public init (
        state: AssessmentRunState? = nil,
        stateChangedAt: Date? = nil
    )
    {
        self.state = state
        self.stateChangedAt = stateChangedAt
    }
}

extension AssessmentTarget: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case name
        case resourceGroupArn
        case updatedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension AssessmentTarget: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentTarget(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), name: \(String(describing: name)), resourceGroupArn: \(String(describing: resourceGroupArn)), updatedAt: \(String(describing: updatedAt)))"}
}

/// <p>Contains information about an Amazon Inspector application. This data type is used as
///          the response element in the <a>DescribeAssessmentTargets</a> action.</p>
public struct AssessmentTarget: Equatable {
    /// <p>The ARN that specifies the Amazon Inspector assessment target.</p>
    public let arn: String?
    /// <p>The time at which the assessment target is created.</p>
    public let createdAt: Date?
    /// <p>The name of the Amazon Inspector assessment target.</p>
    public let name: String?
    /// <p>The ARN that specifies the resource group that is associated with the assessment
    ///          target.</p>
    public let resourceGroupArn: String?
    /// <p>The time at which <a>UpdateAssessmentTarget</a> is called.</p>
    public let updatedAt: Date?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        name: String? = nil,
        resourceGroupArn: String? = nil,
        updatedAt: Date? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.resourceGroupArn = resourceGroupArn
        self.updatedAt = updatedAt
    }
}

extension AssessmentTargetFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetNamePattern
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetNamePattern = assessmentTargetNamePattern {
            try encodeContainer.encode(assessmentTargetNamePattern, forKey: .assessmentTargetNamePattern)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetNamePatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetNamePattern)
        assessmentTargetNamePattern = assessmentTargetNamePatternDecoded
    }
}

extension AssessmentTargetFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentTargetFilter(assessmentTargetNamePattern: \(String(describing: assessmentTargetNamePattern)))"}
}

/// <p>Used as the request parameter in the <a>ListAssessmentTargets</a>
///          action.</p>
public struct AssessmentTargetFilter: Equatable {
    /// <p>For a record to match a filter, an explicit value or a string that contains a
    ///          wildcard that is specified for this data type property must match the value of the
    ///             <b>assessmentTargetName</b> property of the <a>AssessmentTarget</a> data type.</p>
    public let assessmentTargetNamePattern: String?

    public init (
        assessmentTargetNamePattern: String? = nil
    )
    {
        self.assessmentTargetNamePattern = assessmentTargetNamePattern
    }
}

extension AssessmentTemplate: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case assessmentRunCount
        case assessmentTargetArn
        case createdAt
        case durationInSeconds
        case lastAssessmentRunArn
        case name
        case rulesPackageArns
        case userAttributesForFindings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assessmentRunCount = assessmentRunCount {
            try encodeContainer.encode(assessmentRunCount, forKey: .assessmentRunCount)
        }
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let lastAssessmentRunArn = lastAssessmentRunArn {
            try encodeContainer.encode(lastAssessmentRunArn, forKey: .lastAssessmentRunArn)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for assessmenttemplaterulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(assessmenttemplaterulespackagearnlist0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for userattributelist0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(userattributelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let durationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
        let lastAssessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastAssessmentRunArn)
        lastAssessmentRunArn = lastAssessmentRunArnDecoded
        let assessmentRunCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .assessmentRunCount)
        assessmentRunCount = assessmentRunCountDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension AssessmentTemplate: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentTemplate(arn: \(String(describing: arn)), assessmentRunCount: \(String(describing: assessmentRunCount)), assessmentTargetArn: \(String(describing: assessmentTargetArn)), createdAt: \(String(describing: createdAt)), durationInSeconds: \(String(describing: durationInSeconds)), lastAssessmentRunArn: \(String(describing: lastAssessmentRunArn)), name: \(String(describing: name)), rulesPackageArns: \(String(describing: rulesPackageArns)), userAttributesForFindings: \(String(describing: userAttributesForFindings)))"}
}

/// <p>Contains information about an Amazon Inspector assessment template. This data type is
///          used as the response element in the <a>DescribeAssessmentTemplates</a>
///          action.</p>
public struct AssessmentTemplate: Equatable {
    /// <p>The ARN of the assessment template.</p>
    public let arn: String?
    /// <p>The number of existing assessment runs associated with this assessment template. This
    ///          value can be zero or a positive integer.</p>
    public let assessmentRunCount: Int?
    /// <p>The ARN of the assessment target that corresponds to this assessment
    ///          template.</p>
    public let assessmentTargetArn: String?
    /// <p>The time at which the assessment template is created.</p>
    public let createdAt: Date?
    /// <p>The duration in seconds specified for this assessment template. The default value is
    ///          3600 seconds (one hour). The maximum value is 86400 seconds (one day).</p>
    public let durationInSeconds: Int
    /// <p>The Amazon Resource Name (ARN) of the most recent assessment run associated with this
    ///          assessment template. This value exists only when the value of assessmentRunCount is
    ///          greaterpa than zero.</p>
    public let lastAssessmentRunArn: String?
    /// <p>The name of the assessment template.</p>
    public let name: String?
    /// <p>The rules packages that are specified for this assessment template.</p>
    public let rulesPackageArns: [String]?
    /// <p>The user-defined attributes that are assigned to every generated finding from the
    ///          assessment run that uses this assessment template.</p>
    public let userAttributesForFindings: [Attribute]?

    public init (
        arn: String? = nil,
        assessmentRunCount: Int? = nil,
        assessmentTargetArn: String? = nil,
        createdAt: Date? = nil,
        durationInSeconds: Int = 0,
        lastAssessmentRunArn: String? = nil,
        name: String? = nil,
        rulesPackageArns: [String]? = nil,
        userAttributesForFindings: [Attribute]? = nil
    )
    {
        self.arn = arn
        self.assessmentRunCount = assessmentRunCount
        self.assessmentTargetArn = assessmentTargetArn
        self.createdAt = createdAt
        self.durationInSeconds = durationInSeconds
        self.lastAssessmentRunArn = lastAssessmentRunArn
        self.name = name
        self.rulesPackageArns = rulesPackageArns
        self.userAttributesForFindings = userAttributesForFindings
    }
}

extension AssessmentTemplateFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case durationRange
        case namePattern
        case rulesPackageArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationRange = durationRange {
            try encodeContainer.encode(durationRange, forKey: .durationRange)
        }
        if let namePattern = namePattern {
            try encodeContainer.encode(namePattern, forKey: .namePattern)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for filterrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(filterrulespackagearnlist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namePatternDecoded = try containerValues.decodeIfPresent(String.self, forKey: .namePattern)
        namePattern = namePatternDecoded
        let durationRangeDecoded = try containerValues.decodeIfPresent(DurationRange.self, forKey: .durationRange)
        durationRange = durationRangeDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
    }
}

extension AssessmentTemplateFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssessmentTemplateFilter(durationRange: \(String(describing: durationRange)), namePattern: \(String(describing: namePattern)), rulesPackageArns: \(String(describing: rulesPackageArns)))"}
}

/// <p>Used as the request parameter in the <a>ListAssessmentTemplates</a>
///          action.</p>
public struct AssessmentTemplateFilter: Equatable {
    /// <p>For a record to match a filter, the value specified for this data type property must
    ///          inclusively match any value between the specified minimum and maximum values of the
    ///             <b>durationInSeconds</b> property of the <a>AssessmentTemplate</a> data type.</p>
    public let durationRange: DurationRange?
    /// <p>For a record to match a filter, an explicit value or a string that contains a
    ///          wildcard that is specified for this data type property must match the value of the
    ///             <b>assessmentTemplateName</b> property of the <a>AssessmentTemplate</a> data type.</p>
    public let namePattern: String?
    /// <p>For a record to match a filter, the values that are specified for this data type
    ///          property must be contained in the list of values of the <b>rulesPackageArns</b> property of the <a>AssessmentTemplate</a> data
    ///          type.</p>
    public let rulesPackageArns: [String]?

    public init (
        durationRange: DurationRange? = nil,
        namePattern: String? = nil,
        rulesPackageArns: [String]? = nil
    )
    {
        self.durationRange = durationRange
        self.namePattern = namePattern
        self.rulesPackageArns = rulesPackageArns
    }
}

extension AssetAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentId
        case amiId
        case autoScalingGroup
        case hostname
        case ipv4Addresses
        case networkInterfaces
        case schemaVersion
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentId = agentId {
            try encodeContainer.encode(agentId, forKey: .agentId)
        }
        if let amiId = amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let autoScalingGroup = autoScalingGroup {
            try encodeContainer.encode(autoScalingGroup, forKey: .autoScalingGroup)
        }
        if let hostname = hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let ipv4Addresses = ipv4Addresses {
            var ipv4AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv4Addresses)
            for ipv4addresslist0 in ipv4Addresses {
                try ipv4AddressesContainer.encode(ipv4addresslist0)
            }
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterfaces0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterfaces0)
            }
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tags0 in tags {
                try tagsContainer.encode(tags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decode(Int.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let agentIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .agentId)
        agentId = agentIdDecoded
        let autoScalingGroupDecoded = try containerValues.decodeIfPresent(String.self, forKey: .autoScalingGroup)
        autoScalingGroup = autoScalingGroupDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let ipv4AddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipv4Addresses)
        var ipv4AddressesDecoded0:[String]? = nil
        if let ipv4AddressesContainer = ipv4AddressesContainer {
            ipv4AddressesDecoded0 = [String]()
            for string0 in ipv4AddressesContainer {
                if let string0 = string0 {
                    ipv4AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv4Addresses = ipv4AddressesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let networkInterfacesContainer = try containerValues.decodeIfPresent([NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
    }
}

extension AssetAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AssetAttributes(agentId: \(String(describing: agentId)), amiId: \(String(describing: amiId)), autoScalingGroup: \(String(describing: autoScalingGroup)), hostname: \(String(describing: hostname)), ipv4Addresses: \(String(describing: ipv4Addresses)), networkInterfaces: \(String(describing: networkInterfaces)), schemaVersion: \(String(describing: schemaVersion)), tags: \(String(describing: tags)))"}
}

/// <p>A collection of attributes of the host from which the finding is generated.</p>
public struct AssetAttributes: Equatable {
    /// <p>The ID of the agent that is installed on the EC2 instance where the finding is
    ///          generated.</p>
    public let agentId: String?
    /// <p>The ID of the Amazon Machine Image (AMI) that is installed on the EC2 instance where
    ///          the finding is generated.</p>
    public let amiId: String?
    /// <p>The Auto Scaling group of the EC2 instance where the finding is generated.</p>
    public let autoScalingGroup: String?
    /// <p>The hostname of the EC2 instance where the finding is generated.</p>
    public let hostname: String?
    /// <p>The list of IP v4 addresses of the EC2 instance where the finding is
    ///          generated.</p>
    public let ipv4Addresses: [String]?
    /// <p>An array of the network interfaces interacting with the EC2 instance where the
    ///          finding is generated.</p>
    public let networkInterfaces: [NetworkInterface]?
    /// <p>The schema version of this data type.</p>
    public let schemaVersion: Int
    /// <p>The tags related to the EC2 instance where the finding is generated.</p>
    public let tags: [Tag]?

    public init (
        agentId: String? = nil,
        amiId: String? = nil,
        autoScalingGroup: String? = nil,
        hostname: String? = nil,
        ipv4Addresses: [String]? = nil,
        networkInterfaces: [NetworkInterface]? = nil,
        schemaVersion: Int = 0,
        tags: [Tag]? = nil
    )
    {
        self.agentId = agentId
        self.amiId = amiId
        self.autoScalingGroup = autoScalingGroup
        self.hostname = hostname
        self.ipv4Addresses = ipv4Addresses
        self.networkInterfaces = networkInterfaces
        self.schemaVersion = schemaVersion
        self.tags = tags
    }
}

public enum AssetType {
    case ec2Instance
    case sdkUnknown(String)
}

extension AssetType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [AssetType] {
        return [
            .ec2Instance,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .ec2Instance: return "ec2-instance"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = AssetType(rawValue: rawValue) ?? AssetType.sdkUnknown(rawValue)
    }
}

extension Attribute: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Attribute: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Attribute(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>This data type is used as a request parameter in the <a>AddAttributesToFindings</a> and <a>CreateAssessmentTemplate</a>
///          actions.</p>
public struct Attribute: Equatable {
    /// <p>The attribute key.</p>
    public let key: String?
    /// <p>The value assigned to the attribute key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public struct CreateAssessmentTargetInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssessmentTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentTargetInput>
    public typealias MOutput = OperationOutput<CreateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentTargetOutputError>
}

extension CreateAssessmentTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentTargetInput(assessmentTargetName: \(String(describing: assessmentTargetName)), resourceGroupArn: \(String(describing: resourceGroupArn)))"}
}

extension CreateAssessmentTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetName
        case resourceGroupArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetName = assessmentTargetName {
            try encodeContainer.encode(assessmentTargetName, forKey: .assessmentTargetName)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
    }
}

public struct CreateAssessmentTargetInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssessmentTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentTargetInput>
    public typealias MOutput = OperationOutput<CreateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentTargetOutputError>
}

public struct CreateAssessmentTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssessmentTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentTargetInput>
    public typealias MOutput = OperationOutput<CreateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentTargetOutputError>
}

public struct CreateAssessmentTargetInput: Equatable {
    /// <p>The user-defined name that identifies the assessment target that you want to create.
    ///          The name must be unique within the AWS account.</p>
    public let assessmentTargetName: String?
    /// <p>The ARN that specifies the resource group that is used to create the assessment
    ///          target. If resourceGroupArn is not specified, all EC2 instances in the current AWS account
    ///          and region are included in the assessment target.</p>
    public let resourceGroupArn: String?

    public init (
        assessmentTargetName: String? = nil,
        resourceGroupArn: String? = nil
    )
    {
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

struct CreateAssessmentTargetInputBody: Equatable {
    public let assessmentTargetName: String?
    public let resourceGroupArn: String?
}

extension CreateAssessmentTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetName
        case resourceGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetName)
        assessmentTargetName = assessmentTargetNameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

extension CreateAssessmentTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssessmentTargetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentTargetOutputResponse(assessmentTargetArn: \(String(describing: assessmentTargetArn)))"}
}

extension CreateAssessmentTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssessmentTargetOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentTargetArn = output.assessmentTargetArn
        } else {
            self.assessmentTargetArn = nil
        }
    }
}

public struct CreateAssessmentTargetOutputResponse: Equatable {
    /// <p>The ARN that specifies the assessment target that is created.</p>
    public let assessmentTargetArn: String?

    public init (
        assessmentTargetArn: String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

struct CreateAssessmentTargetOutputResponseBody: Equatable {
    public let assessmentTargetArn: String?
}

extension CreateAssessmentTargetOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
    }
}

public struct CreateAssessmentTemplateInputBodyMiddleware: Middleware {
    public let id: String = "CreateAssessmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentTemplateInput>
    public typealias MOutput = OperationOutput<CreateAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentTemplateOutputError>
}

extension CreateAssessmentTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentTemplateInput(assessmentTargetArn: \(String(describing: assessmentTargetArn)), assessmentTemplateName: \(String(describing: assessmentTemplateName)), durationInSeconds: \(String(describing: durationInSeconds)), rulesPackageArns: \(String(describing: rulesPackageArns)), userAttributesForFindings: \(String(describing: userAttributesForFindings)))"}
}

extension CreateAssessmentTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArn
        case assessmentTemplateName
        case durationInSeconds
        case rulesPackageArns
        case userAttributesForFindings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let assessmentTemplateName = assessmentTemplateName {
            try encodeContainer.encode(assessmentTemplateName, forKey: .assessmentTemplateName)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for assessmenttemplaterulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(assessmenttemplaterulespackagearnlist0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for userattributelist0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(userattributelist0)
            }
        }
    }
}

public struct CreateAssessmentTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAssessmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentTemplateInput>
    public typealias MOutput = OperationOutput<CreateAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentTemplateOutputError>
}

public struct CreateAssessmentTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAssessmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAssessmentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAssessmentTemplateInput>
    public typealias MOutput = OperationOutput<CreateAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAssessmentTemplateOutputError>
}

public struct CreateAssessmentTemplateInput: Equatable {
    /// <p>The ARN that specifies the assessment target for which you want to create the
    ///          assessment template.</p>
    public let assessmentTargetArn: String?
    /// <p>The user-defined name that identifies the assessment template that you want to
    ///          create. You can create several assessment templates for an assessment target. The names of
    ///          the assessment templates that correspond to a particular assessment target must be
    ///          unique.</p>
    public let assessmentTemplateName: String?
    /// <p>The duration of the assessment run in seconds.</p>
    public let durationInSeconds: Int
    /// <p>The ARNs that specify the rules packages that you want to attach to the assessment
    ///          template.</p>
    public let rulesPackageArns: [String]?
    /// <p>The user-defined attributes that are assigned to every finding that is generated by
    ///          the assessment run that uses this assessment template. An attribute is a key and value pair
    ///          (an <a>Attribute</a> object). Within an assessment template, each key must be
    ///          unique.</p>
    public let userAttributesForFindings: [Attribute]?

    public init (
        assessmentTargetArn: String? = nil,
        assessmentTemplateName: String? = nil,
        durationInSeconds: Int = 0,
        rulesPackageArns: [String]? = nil,
        userAttributesForFindings: [Attribute]? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTemplateName = assessmentTemplateName
        self.durationInSeconds = durationInSeconds
        self.rulesPackageArns = rulesPackageArns
        self.userAttributesForFindings = userAttributesForFindings
    }
}

struct CreateAssessmentTemplateInputBody: Equatable {
    public let assessmentTargetArn: String?
    public let assessmentTemplateName: String?
    public let durationInSeconds: Int
    public let rulesPackageArns: [String]?
    public let userAttributesForFindings: [Attribute]?
}

extension CreateAssessmentTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArn
        case assessmentTemplateName
        case durationInSeconds
        case rulesPackageArns
        case userAttributesForFindings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let assessmentTemplateNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateName)
        assessmentTemplateName = assessmentTemplateNameDecoded
        let durationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                if let structure0 = structure0 {
                    userAttributesForFindingsDecoded0?.append(structure0)
                }
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
    }
}

extension CreateAssessmentTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAssessmentTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAssessmentTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAssessmentTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAssessmentTemplateOutputResponse(assessmentTemplateArn: \(String(describing: assessmentTemplateArn)))"}
}

extension CreateAssessmentTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAssessmentTemplateOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentTemplateArn = output.assessmentTemplateArn
        } else {
            self.assessmentTemplateArn = nil
        }
    }
}

public struct CreateAssessmentTemplateOutputResponse: Equatable {
    /// <p>The ARN that specifies the assessment template that is created.</p>
    public let assessmentTemplateArn: String?

    public init (
        assessmentTemplateArn: String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct CreateAssessmentTemplateOutputResponseBody: Equatable {
    public let assessmentTemplateArn: String?
}

extension CreateAssessmentTemplateOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

public struct CreateExclusionsPreviewInputBodyMiddleware: Middleware {
    public let id: String = "CreateExclusionsPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExclusionsPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExclusionsPreviewInput>
    public typealias MOutput = OperationOutput<CreateExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExclusionsPreviewOutputError>
}

extension CreateExclusionsPreviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExclusionsPreviewInput(assessmentTemplateArn: \(String(describing: assessmentTemplateArn)))"}
}

extension CreateExclusionsPreviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

public struct CreateExclusionsPreviewInputHeadersMiddleware: Middleware {
    public let id: String = "CreateExclusionsPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExclusionsPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExclusionsPreviewInput>
    public typealias MOutput = OperationOutput<CreateExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExclusionsPreviewOutputError>
}

public struct CreateExclusionsPreviewInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateExclusionsPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateExclusionsPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateExclusionsPreviewInput>
    public typealias MOutput = OperationOutput<CreateExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateExclusionsPreviewOutputError>
}

public struct CreateExclusionsPreviewInput: Equatable {
    /// <p>The ARN that specifies the assessment template for which you want to create an
    ///          exclusions preview.</p>
    public let assessmentTemplateArn: String?

    public init (
        assessmentTemplateArn: String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct CreateExclusionsPreviewInputBody: Equatable {
    public let assessmentTemplateArn: String?
}

extension CreateExclusionsPreviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

extension CreateExclusionsPreviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateExclusionsPreviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreviewGenerationInProgressException" : self = .previewGenerationInProgressException(try PreviewGenerationInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateExclusionsPreviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case previewGenerationInProgressException(PreviewGenerationInProgressException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateExclusionsPreviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateExclusionsPreviewOutputResponse(previewToken: \(String(describing: previewToken)))"}
}

extension CreateExclusionsPreviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateExclusionsPreviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.previewToken = output.previewToken
        } else {
            self.previewToken = nil
        }
    }
}

public struct CreateExclusionsPreviewOutputResponse: Equatable {
    /// <p>Specifies the unique identifier of the requested exclusions preview. You can use the
    ///          unique identifier to retrieve the exclusions preview when running the GetExclusionsPreview
    ///          API.</p>
    public let previewToken: String?

    public init (
        previewToken: String? = nil
    )
    {
        self.previewToken = previewToken
    }
}

struct CreateExclusionsPreviewOutputResponseBody: Equatable {
    public let previewToken: String?
}

extension CreateExclusionsPreviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case previewToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previewToken)
        previewToken = previewTokenDecoded
    }
}

public struct CreateResourceGroupInputBodyMiddleware: Middleware {
    public let id: String = "CreateResourceGroupInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceGroupInput>
    public typealias MOutput = OperationOutput<CreateResourceGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceGroupOutputError>
}

extension CreateResourceGroupInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceGroupInput(resourceGroupTags: \(String(describing: resourceGroupTags)))"}
}

extension CreateResourceGroupInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceGroupTags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupTags = resourceGroupTags {
            var resourceGroupTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupTags)
            for resourcegrouptags0 in resourceGroupTags {
                try resourceGroupTagsContainer.encode(resourcegrouptags0)
            }
        }
    }
}

public struct CreateResourceGroupInputHeadersMiddleware: Middleware {
    public let id: String = "CreateResourceGroupInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceGroupInput>
    public typealias MOutput = OperationOutput<CreateResourceGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceGroupOutputError>
}

public struct CreateResourceGroupInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateResourceGroupInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateResourceGroupInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateResourceGroupOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateResourceGroupInput>
    public typealias MOutput = OperationOutput<CreateResourceGroupOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateResourceGroupOutputError>
}

public struct CreateResourceGroupInput: Equatable {
    /// <p>A collection of keys and an array of possible values,
    ///          '[{"key":"key1","values":["Value1","Value2"]},{"key":"Key2","values":["Value3"]}]'.</p>
    ///          <p>For example,'[{"key":"Name","values":["TestEC2Instance"]}]'.</p>
    public let resourceGroupTags: [ResourceGroupTag]?

    public init (
        resourceGroupTags: [ResourceGroupTag]? = nil
    )
    {
        self.resourceGroupTags = resourceGroupTags
    }
}

struct CreateResourceGroupInputBody: Equatable {
    public let resourceGroupTags: [ResourceGroupTag]?
}

extension CreateResourceGroupInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceGroupTags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupTagsContainer = try containerValues.decodeIfPresent([ResourceGroupTag?].self, forKey: .resourceGroupTags)
        var resourceGroupTagsDecoded0:[ResourceGroupTag]? = nil
        if let resourceGroupTagsContainer = resourceGroupTagsContainer {
            resourceGroupTagsDecoded0 = [ResourceGroupTag]()
            for structure0 in resourceGroupTagsContainer {
                if let structure0 = structure0 {
                    resourceGroupTagsDecoded0?.append(structure0)
                }
            }
        }
        resourceGroupTags = resourceGroupTagsDecoded0
    }
}

extension CreateResourceGroupOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateResourceGroupOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateResourceGroupOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateResourceGroupOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateResourceGroupOutputResponse(resourceGroupArn: \(String(describing: resourceGroupArn)))"}
}

extension CreateResourceGroupOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateResourceGroupOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.resourceGroupArn = output.resourceGroupArn
        } else {
            self.resourceGroupArn = nil
        }
    }
}

public struct CreateResourceGroupOutputResponse: Equatable {
    /// <p>The ARN that specifies the resource group that is created.</p>
    public let resourceGroupArn: String?

    public init (
        resourceGroupArn: String? = nil
    )
    {
        self.resourceGroupArn = resourceGroupArn
    }
}

struct CreateResourceGroupOutputResponseBody: Equatable {
    public let resourceGroupArn: String?
}

extension CreateResourceGroupOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

public struct DeleteAssessmentRunInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentRunInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentRunOutputError>
}

extension DeleteAssessmentRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentRunInput(assessmentRunArn: \(String(describing: assessmentRunArn)))"}
}

extension DeleteAssessmentRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }
}

public struct DeleteAssessmentRunInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentRunInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentRunOutputError>
}

public struct DeleteAssessmentRunInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentRunInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentRunOutputError>
}

public struct DeleteAssessmentRunInput: Equatable {
    /// <p>The ARN that specifies the assessment run that you want to delete.</p>
    public let assessmentRunArn: String?

    public init (
        assessmentRunArn: String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct DeleteAssessmentRunInputBody: Equatable {
    public let assessmentRunArn: String?
}

extension DeleteAssessmentRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension DeleteAssessmentRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentRunOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentRunOutputResponse()"}
}

extension DeleteAssessmentRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentRunOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssessmentRunOutputResponseBody: Equatable {
}

extension DeleteAssessmentRunOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAssessmentTargetInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAssessmentTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentTargetInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentTargetOutputError>
}

extension DeleteAssessmentTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentTargetInput(assessmentTargetArn: \(String(describing: assessmentTargetArn)))"}
}

extension DeleteAssessmentTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
    }
}

public struct DeleteAssessmentTargetInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssessmentTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentTargetInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentTargetOutputError>
}

public struct DeleteAssessmentTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssessmentTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentTargetInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentTargetOutputError>
}

public struct DeleteAssessmentTargetInput: Equatable {
    /// <p>The ARN that specifies the assessment target that you want to delete.</p>
    public let assessmentTargetArn: String?

    public init (
        assessmentTargetArn: String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
    }
}

struct DeleteAssessmentTargetInputBody: Equatable {
    public let assessmentTargetArn: String?
}

extension DeleteAssessmentTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
    }
}

extension DeleteAssessmentTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentTargetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentTargetOutputResponse()"}
}

extension DeleteAssessmentTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentTargetOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssessmentTargetOutputResponseBody: Equatable {
}

extension DeleteAssessmentTargetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DeleteAssessmentTemplateInputBodyMiddleware: Middleware {
    public let id: String = "DeleteAssessmentTemplateInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentTemplateInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentTemplateOutputError>
}

extension DeleteAssessmentTemplateInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentTemplateInput(assessmentTemplateArn: \(String(describing: assessmentTemplateArn)))"}
}

extension DeleteAssessmentTemplateInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

public struct DeleteAssessmentTemplateInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAssessmentTemplateInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentTemplateInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentTemplateOutputError>
}

public struct DeleteAssessmentTemplateInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAssessmentTemplateInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAssessmentTemplateInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAssessmentTemplateOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAssessmentTemplateInput>
    public typealias MOutput = OperationOutput<DeleteAssessmentTemplateOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAssessmentTemplateOutputError>
}

public struct DeleteAssessmentTemplateInput: Equatable {
    /// <p>The ARN that specifies the assessment template that you want to delete.</p>
    public let assessmentTemplateArn: String?

    public init (
        assessmentTemplateArn: String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct DeleteAssessmentTemplateInputBody: Equatable {
    public let assessmentTemplateArn: String?
}

extension DeleteAssessmentTemplateInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
    }
}

extension DeleteAssessmentTemplateOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAssessmentTemplateOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAssessmentTemplateOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAssessmentTemplateOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAssessmentTemplateOutputResponse()"}
}

extension DeleteAssessmentTemplateOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAssessmentTemplateOutputResponse: Equatable {

    public init() {}
}

struct DeleteAssessmentTemplateOutputResponseBody: Equatable {
}

extension DeleteAssessmentTemplateOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct DescribeAssessmentRunsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAssessmentRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentRunsInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentRunsOutputError>
}

extension DescribeAssessmentRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssessmentRunsInput(assessmentRunArns: \(String(describing: assessmentRunArns)))"}
}

extension DescribeAssessmentRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArns = assessmentRunArns {
            var assessmentRunArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentRunArns)
            for batchdescribearnlist0 in assessmentRunArns {
                try assessmentRunArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeAssessmentRunsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssessmentRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentRunsInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentRunsOutputError>
}

public struct DescribeAssessmentRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssessmentRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentRunsInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentRunsOutputError>
}

public struct DescribeAssessmentRunsInput: Equatable {
    /// <p>The ARN that specifies the assessment run that you want to describe.</p>
    public let assessmentRunArns: [String]?

    public init (
        assessmentRunArns: [String]? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
    }
}

struct DescribeAssessmentRunsInputBody: Equatable {
    public let assessmentRunArns: [String]?
}

extension DescribeAssessmentRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
    }
}

extension DescribeAssessmentRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssessmentRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssessmentRunsOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssessmentRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssessmentRunsOutputResponse(assessmentRuns: \(String(describing: assessmentRuns)), failedItems: \(String(describing: failedItems)))"}
}

extension DescribeAssessmentRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssessmentRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentRuns = output.assessmentRuns
            self.failedItems = output.failedItems
        } else {
            self.assessmentRuns = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentRunsOutputResponse: Equatable {
    /// <p>Information about the assessment run.</p>
    public let assessmentRuns: [AssessmentRun]?
    /// <p>Assessment run details that cannot be described. An error code is provided for each
    ///          failed item.</p>
    public let failedItems: [String:FailedItemDetails]?

    public init (
        assessmentRuns: [AssessmentRun]? = nil,
        failedItems: [String:FailedItemDetails]? = nil
    )
    {
        self.assessmentRuns = assessmentRuns
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentRunsOutputResponseBody: Equatable {
    public let assessmentRuns: [AssessmentRun]?
    public let failedItems: [String:FailedItemDetails]?
}

extension DescribeAssessmentRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRuns
        case failedItems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunsContainer = try containerValues.decodeIfPresent([AssessmentRun?].self, forKey: .assessmentRuns)
        var assessmentRunsDecoded0:[AssessmentRun]? = nil
        if let assessmentRunsContainer = assessmentRunsContainer {
            assessmentRunsDecoded0 = [AssessmentRun]()
            for structure0 in assessmentRunsContainer {
                if let structure0 = structure0 {
                    assessmentRunsDecoded0?.append(structure0)
                }
            }
        }
        assessmentRuns = assessmentRunsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeAssessmentTargetsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAssessmentTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentTargetsInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentTargetsOutputError>
}

extension DescribeAssessmentTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssessmentTargetsInput(assessmentTargetArns: \(String(describing: assessmentTargetArns)))"}
}

extension DescribeAssessmentTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArns = assessmentTargetArns {
            var assessmentTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTargetArns)
            for batchdescribearnlist0 in assessmentTargetArns {
                try assessmentTargetArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeAssessmentTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssessmentTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentTargetsInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentTargetsOutputError>
}

public struct DescribeAssessmentTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssessmentTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentTargetsInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentTargetsOutputError>
}

public struct DescribeAssessmentTargetsInput: Equatable {
    /// <p>The ARNs that specifies the assessment targets that you want to describe.</p>
    public let assessmentTargetArns: [String]?

    public init (
        assessmentTargetArns: [String]? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
    }
}

struct DescribeAssessmentTargetsInputBody: Equatable {
    public let assessmentTargetArns: [String]?
}

extension DescribeAssessmentTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
    }
}

extension DescribeAssessmentTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssessmentTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssessmentTargetsOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssessmentTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssessmentTargetsOutputResponse(assessmentTargets: \(String(describing: assessmentTargets)), failedItems: \(String(describing: failedItems)))"}
}

extension DescribeAssessmentTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssessmentTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentTargets = output.assessmentTargets
            self.failedItems = output.failedItems
        } else {
            self.assessmentTargets = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentTargetsOutputResponse: Equatable {
    /// <p>Information about the assessment targets.</p>
    public let assessmentTargets: [AssessmentTarget]?
    /// <p>Assessment target details that cannot be described. An error code is provided for
    ///          each failed item.</p>
    public let failedItems: [String:FailedItemDetails]?

    public init (
        assessmentTargets: [AssessmentTarget]? = nil,
        failedItems: [String:FailedItemDetails]? = nil
    )
    {
        self.assessmentTargets = assessmentTargets
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentTargetsOutputResponseBody: Equatable {
    public let assessmentTargets: [AssessmentTarget]?
    public let failedItems: [String:FailedItemDetails]?
}

extension DescribeAssessmentTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargets
        case failedItems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetsContainer = try containerValues.decodeIfPresent([AssessmentTarget?].self, forKey: .assessmentTargets)
        var assessmentTargetsDecoded0:[AssessmentTarget]? = nil
        if let assessmentTargetsContainer = assessmentTargetsContainer {
            assessmentTargetsDecoded0 = [AssessmentTarget]()
            for structure0 in assessmentTargetsContainer {
                if let structure0 = structure0 {
                    assessmentTargetsDecoded0?.append(structure0)
                }
            }
        }
        assessmentTargets = assessmentTargetsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeAssessmentTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeAssessmentTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentTemplatesInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentTemplatesOutputError>
}

extension DescribeAssessmentTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssessmentTemplatesInput(assessmentTemplateArns: \(String(describing: assessmentTemplateArns)))"}
}

extension DescribeAssessmentTemplatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArns = assessmentTemplateArns {
            var assessmentTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTemplateArns)
            for batchdescribearnlist0 in assessmentTemplateArns {
                try assessmentTemplateArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeAssessmentTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeAssessmentTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentTemplatesInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentTemplatesOutputError>
}

public struct DescribeAssessmentTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeAssessmentTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeAssessmentTemplatesInput>
    public typealias MOutput = OperationOutput<DescribeAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeAssessmentTemplatesOutputError>
}

public struct DescribeAssessmentTemplatesInput: Equatable {
    public let assessmentTemplateArns: [String]?

    public init (
        assessmentTemplateArns: [String]? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
    }
}

struct DescribeAssessmentTemplatesInputBody: Equatable {
    public let assessmentTemplateArns: [String]?
}

extension DescribeAssessmentTemplatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
    }
}

extension DescribeAssessmentTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAssessmentTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeAssessmentTemplatesOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAssessmentTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeAssessmentTemplatesOutputResponse(assessmentTemplates: \(String(describing: assessmentTemplates)), failedItems: \(String(describing: failedItems)))"}
}

extension DescribeAssessmentTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeAssessmentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentTemplates = output.assessmentTemplates
            self.failedItems = output.failedItems
        } else {
            self.assessmentTemplates = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeAssessmentTemplatesOutputResponse: Equatable {
    /// <p>Information about the assessment templates.</p>
    public let assessmentTemplates: [AssessmentTemplate]?
    /// <p>Assessment template details that cannot be described. An error code is provided for
    ///          each failed item.</p>
    public let failedItems: [String:FailedItemDetails]?

    public init (
        assessmentTemplates: [AssessmentTemplate]? = nil,
        failedItems: [String:FailedItemDetails]? = nil
    )
    {
        self.assessmentTemplates = assessmentTemplates
        self.failedItems = failedItems
    }
}

struct DescribeAssessmentTemplatesOutputResponseBody: Equatable {
    public let assessmentTemplates: [AssessmentTemplate]?
    public let failedItems: [String:FailedItemDetails]?
}

extension DescribeAssessmentTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplates
        case failedItems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplatesContainer = try containerValues.decodeIfPresent([AssessmentTemplate?].self, forKey: .assessmentTemplates)
        var assessmentTemplatesDecoded0:[AssessmentTemplate]? = nil
        if let assessmentTemplatesContainer = assessmentTemplatesContainer {
            assessmentTemplatesDecoded0 = [AssessmentTemplate]()
            for structure0 in assessmentTemplatesContainer {
                if let structure0 = structure0 {
                    assessmentTemplatesDecoded0?.append(structure0)
                }
            }
        }
        assessmentTemplates = assessmentTemplatesDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension DescribeCrossAccountAccessRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCrossAccountAccessRoleInput()"}
}

extension DescribeCrossAccountAccessRoleInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DescribeCrossAccountAccessRoleInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeCrossAccountAccessRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCrossAccountAccessRoleInput>
    public typealias MOutput = OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCrossAccountAccessRoleOutputError>
}

public struct DescribeCrossAccountAccessRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeCrossAccountAccessRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeCrossAccountAccessRoleInput>
    public typealias MOutput = OperationOutput<DescribeCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeCrossAccountAccessRoleOutputError>
}

public struct DescribeCrossAccountAccessRoleInput: Equatable {

    public init() {}
}

struct DescribeCrossAccountAccessRoleInputBody: Equatable {
}

extension DescribeCrossAccountAccessRoleInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DescribeCrossAccountAccessRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeCrossAccountAccessRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeCrossAccountAccessRoleOutputError: Equatable {
    case internalException(InternalException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeCrossAccountAccessRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeCrossAccountAccessRoleOutputResponse(registeredAt: \(String(describing: registeredAt)), roleArn: \(String(describing: roleArn)), valid: \(String(describing: valid)))"}
}

extension DescribeCrossAccountAccessRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeCrossAccountAccessRoleOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.registeredAt = output.registeredAt
            self.roleArn = output.roleArn
            self.valid = output.valid
        } else {
            self.registeredAt = nil
            self.roleArn = nil
            self.valid = nil
        }
    }
}

public struct DescribeCrossAccountAccessRoleOutputResponse: Equatable {
    /// <p>The date when the cross-account access role was registered.</p>
    public let registeredAt: Date?
    /// <p>The ARN that specifies the IAM role that Amazon Inspector uses to access your AWS
    ///          account.</p>
    public let roleArn: String?
    /// <p>A Boolean value that specifies whether the IAM role has the necessary policies
    ///          attached to enable Amazon Inspector to access your AWS account.</p>
    public let valid: Bool?

    public init (
        registeredAt: Date? = nil,
        roleArn: String? = nil,
        valid: Bool? = nil
    )
    {
        self.registeredAt = registeredAt
        self.roleArn = roleArn
        self.valid = valid
    }
}

struct DescribeCrossAccountAccessRoleOutputResponseBody: Equatable {
    public let roleArn: String?
    public let valid: Bool?
    public let registeredAt: Date?
}

extension DescribeCrossAccountAccessRoleOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case registeredAt
        case roleArn
        case valid
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let validDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .valid)
        valid = validDecoded
        let registeredAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .registeredAt)
        registeredAt = registeredAtDecoded
    }
}

public struct DescribeExclusionsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeExclusionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExclusionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExclusionsInput>
    public typealias MOutput = OperationOutput<DescribeExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExclusionsOutputError>
}

extension DescribeExclusionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExclusionsInput(exclusionArns: \(String(describing: exclusionArns)), locale: \(String(describing: locale)))"}
}

extension DescribeExclusionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case exclusionArns
        case locale
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusionArns = exclusionArns {
            var exclusionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .exclusionArns)
            for batchdescribeexclusionsarnlist0 in exclusionArns {
                try exclusionArnsContainer.encode(batchdescribeexclusionsarnlist0)
            }
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
    }
}

public struct DescribeExclusionsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeExclusionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExclusionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExclusionsInput>
    public typealias MOutput = OperationOutput<DescribeExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExclusionsOutputError>
}

public struct DescribeExclusionsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeExclusionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeExclusionsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeExclusionsInput>
    public typealias MOutput = OperationOutput<DescribeExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeExclusionsOutputError>
}

public struct DescribeExclusionsInput: Equatable {
    /// <p>The list of ARNs that specify the exclusions that you want to describe.</p>
    public let exclusionArns: [String]?
    /// <p>The locale into which you want to translate the exclusion's title, description, and
    ///          recommendation.</p>
    public let locale: Locale?

    public init (
        exclusionArns: [String]? = nil,
        locale: Locale? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.locale = locale
    }
}

struct DescribeExclusionsInputBody: Equatable {
    public let exclusionArns: [String]?
    public let locale: Locale?
}

extension DescribeExclusionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusionArns
        case locale
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusionArns)
        var exclusionArnsDecoded0:[String]? = nil
        if let exclusionArnsContainer = exclusionArnsContainer {
            exclusionArnsDecoded0 = [String]()
            for string0 in exclusionArnsContainer {
                if let string0 = string0 {
                    exclusionArnsDecoded0?.append(string0)
                }
            }
        }
        exclusionArns = exclusionArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeExclusionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeExclusionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeExclusionsOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeExclusionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeExclusionsOutputResponse(exclusions: \(String(describing: exclusions)), failedItems: \(String(describing: failedItems)))"}
}

extension DescribeExclusionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeExclusionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exclusions = output.exclusions
            self.failedItems = output.failedItems
        } else {
            self.exclusions = nil
            self.failedItems = nil
        }
    }
}

public struct DescribeExclusionsOutputResponse: Equatable {
    /// <p>Information about the exclusions.</p>
    public let exclusions: [String:Exclusion]?
    /// <p>Exclusion details that cannot be described. An error code is provided for each failed
    ///          item.</p>
    public let failedItems: [String:FailedItemDetails]?

    public init (
        exclusions: [String:Exclusion]? = nil,
        failedItems: [String:FailedItemDetails]? = nil
    )
    {
        self.exclusions = exclusions
        self.failedItems = failedItems
    }
}

struct DescribeExclusionsOutputResponseBody: Equatable {
    public let exclusions: [String:Exclusion]?
    public let failedItems: [String:FailedItemDetails]?
}

extension DescribeExclusionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusions
        case failedItems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionsContainer = try containerValues.decodeIfPresent([String: Exclusion?].self, forKey: .exclusions)
        var exclusionsDecoded0: [String:Exclusion]? = nil
        if let exclusionsContainer = exclusionsContainer {
            exclusionsDecoded0 = [String:Exclusion]()
            for (key0, exclusion0) in exclusionsContainer {
                if let exclusion0 = exclusion0 {
                    exclusionsDecoded0?[key0] = exclusion0
                }
            }
        }
        exclusions = exclusionsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeFindingsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFindingsInput>
    public typealias MOutput = OperationOutput<DescribeFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFindingsOutputError>
}

extension DescribeFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFindingsInput(findingArns: \(String(describing: findingArns)), locale: \(String(describing: locale)))"}
}

extension DescribeFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case findingArns
        case locale
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for batchdescribearnlist0 in findingArns {
                try findingArnsContainer.encode(batchdescribearnlist0)
            }
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
    }
}

public struct DescribeFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFindingsInput>
    public typealias MOutput = OperationOutput<DescribeFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFindingsOutputError>
}

public struct DescribeFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeFindingsInput>
    public typealias MOutput = OperationOutput<DescribeFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeFindingsOutputError>
}

public struct DescribeFindingsInput: Equatable {
    /// <p>The ARN that specifies the finding that you want to describe.</p>
    public let findingArns: [String]?
    /// <p>The locale into which you want to translate a finding description, recommendation,
    ///          and the short description that identifies the finding.</p>
    public let locale: Locale?

    public init (
        findingArns: [String]? = nil,
        locale: Locale? = nil
    )
    {
        self.findingArns = findingArns
        self.locale = locale
    }
}

struct DescribeFindingsInputBody: Equatable {
    public let findingArns: [String]?
    public let locale: Locale?
}

extension DescribeFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingArns
        case locale
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeFindingsOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeFindingsOutputResponse(failedItems: \(String(describing: failedItems)), findings: \(String(describing: findings)))"}
}

extension DescribeFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedItems = output.failedItems
            self.findings = output.findings
        } else {
            self.failedItems = nil
            self.findings = nil
        }
    }
}

public struct DescribeFindingsOutputResponse: Equatable {
    /// <p>Finding details that cannot be described. An error code is provided for each failed
    ///          item.</p>
    public let failedItems: [String:FailedItemDetails]?
    /// <p>Information about the finding.</p>
    public let findings: [Finding]?

    public init (
        failedItems: [String:FailedItemDetails]? = nil,
        findings: [Finding]? = nil
    )
    {
        self.failedItems = failedItems
        self.findings = findings
    }
}

struct DescribeFindingsOutputResponseBody: Equatable {
    public let findings: [Finding]?
    public let failedItems: [String:FailedItemDetails]?
}

extension DescribeFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedItems
        case findings
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([Finding?].self, forKey: .findings)
        var findingsDecoded0:[Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeResourceGroupsInputBodyMiddleware: Middleware {
    public let id: String = "DescribeResourceGroupsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceGroupsInput>
    public typealias MOutput = OperationOutput<DescribeResourceGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceGroupsOutputError>
}

extension DescribeResourceGroupsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceGroupsInput(resourceGroupArns: \(String(describing: resourceGroupArns)))"}
}

extension DescribeResourceGroupsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceGroupArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceGroupArns = resourceGroupArns {
            var resourceGroupArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceGroupArns)
            for batchdescribearnlist0 in resourceGroupArns {
                try resourceGroupArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeResourceGroupsInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeResourceGroupsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceGroupsInput>
    public typealias MOutput = OperationOutput<DescribeResourceGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceGroupsOutputError>
}

public struct DescribeResourceGroupsInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeResourceGroupsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeResourceGroupsInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeResourceGroupsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeResourceGroupsInput>
    public typealias MOutput = OperationOutput<DescribeResourceGroupsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeResourceGroupsOutputError>
}

public struct DescribeResourceGroupsInput: Equatable {
    /// <p>The ARN that specifies the resource group that you want to describe.</p>
    public let resourceGroupArns: [String]?

    public init (
        resourceGroupArns: [String]? = nil
    )
    {
        self.resourceGroupArns = resourceGroupArns
    }
}

struct DescribeResourceGroupsInputBody: Equatable {
    public let resourceGroupArns: [String]?
}

extension DescribeResourceGroupsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceGroupArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .resourceGroupArns)
        var resourceGroupArnsDecoded0:[String]? = nil
        if let resourceGroupArnsContainer = resourceGroupArnsContainer {
            resourceGroupArnsDecoded0 = [String]()
            for string0 in resourceGroupArnsContainer {
                if let string0 = string0 {
                    resourceGroupArnsDecoded0?.append(string0)
                }
            }
        }
        resourceGroupArns = resourceGroupArnsDecoded0
    }
}

extension DescribeResourceGroupsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeResourceGroupsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeResourceGroupsOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeResourceGroupsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeResourceGroupsOutputResponse(failedItems: \(String(describing: failedItems)), resourceGroups: \(String(describing: resourceGroups)))"}
}

extension DescribeResourceGroupsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeResourceGroupsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedItems = output.failedItems
            self.resourceGroups = output.resourceGroups
        } else {
            self.failedItems = nil
            self.resourceGroups = nil
        }
    }
}

public struct DescribeResourceGroupsOutputResponse: Equatable {
    /// <p>Resource group details that cannot be described. An error code is provided for each
    ///          failed item.</p>
    public let failedItems: [String:FailedItemDetails]?
    /// <p>Information about a resource group.</p>
    public let resourceGroups: [ResourceGroup]?

    public init (
        failedItems: [String:FailedItemDetails]? = nil,
        resourceGroups: [ResourceGroup]? = nil
    )
    {
        self.failedItems = failedItems
        self.resourceGroups = resourceGroups
    }
}

struct DescribeResourceGroupsOutputResponseBody: Equatable {
    public let resourceGroups: [ResourceGroup]?
    public let failedItems: [String:FailedItemDetails]?
}

extension DescribeResourceGroupsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedItems
        case resourceGroups
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceGroupsContainer = try containerValues.decodeIfPresent([ResourceGroup?].self, forKey: .resourceGroups)
        var resourceGroupsDecoded0:[ResourceGroup]? = nil
        if let resourceGroupsContainer = resourceGroupsContainer {
            resourceGroupsDecoded0 = [ResourceGroup]()
            for structure0 in resourceGroupsContainer {
                if let structure0 = structure0 {
                    resourceGroupsDecoded0?.append(structure0)
                }
            }
        }
        resourceGroups = resourceGroupsDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public struct DescribeRulesPackagesInputBodyMiddleware: Middleware {
    public let id: String = "DescribeRulesPackagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRulesPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRulesPackagesInput>
    public typealias MOutput = OperationOutput<DescribeRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRulesPackagesOutputError>
}

extension DescribeRulesPackagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRulesPackagesInput(locale: \(String(describing: locale)), rulesPackageArns: \(String(describing: rulesPackageArns)))"}
}

extension DescribeRulesPackagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case locale
        case rulesPackageArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for batchdescribearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(batchdescribearnlist0)
            }
        }
    }
}

public struct DescribeRulesPackagesInputHeadersMiddleware: Middleware {
    public let id: String = "DescribeRulesPackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRulesPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRulesPackagesInput>
    public typealias MOutput = OperationOutput<DescribeRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRulesPackagesOutputError>
}

public struct DescribeRulesPackagesInputQueryItemMiddleware: Middleware {
    public let id: String = "DescribeRulesPackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DescribeRulesPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<DescribeRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DescribeRulesPackagesInput>
    public typealias MOutput = OperationOutput<DescribeRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DescribeRulesPackagesOutputError>
}

public struct DescribeRulesPackagesInput: Equatable {
    /// <p>The locale that you want to translate a rules package description into.</p>
    public let locale: Locale?
    /// <p>The ARN that specifies the rules package that you want to describe.</p>
    public let rulesPackageArns: [String]?

    public init (
        locale: Locale? = nil,
        rulesPackageArns: [String]? = nil
    )
    {
        self.locale = locale
        self.rulesPackageArns = rulesPackageArns
    }
}

struct DescribeRulesPackagesInputBody: Equatable {
    public let rulesPackageArns: [String]?
    public let locale: Locale?
}

extension DescribeRulesPackagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case locale
        case rulesPackageArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeRulesPackagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeRulesPackagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DescribeRulesPackagesOutputError: Equatable {
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeRulesPackagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DescribeRulesPackagesOutputResponse(failedItems: \(String(describing: failedItems)), rulesPackages: \(String(describing: rulesPackages)))"}
}

extension DescribeRulesPackagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DescribeRulesPackagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedItems = output.failedItems
            self.rulesPackages = output.rulesPackages
        } else {
            self.failedItems = nil
            self.rulesPackages = nil
        }
    }
}

public struct DescribeRulesPackagesOutputResponse: Equatable {
    /// <p>Rules package details that cannot be described. An error code is provided for each
    ///          failed item.</p>
    public let failedItems: [String:FailedItemDetails]?
    /// <p>Information about the rules package.</p>
    public let rulesPackages: [RulesPackage]?

    public init (
        failedItems: [String:FailedItemDetails]? = nil,
        rulesPackages: [RulesPackage]? = nil
    )
    {
        self.failedItems = failedItems
        self.rulesPackages = rulesPackages
    }
}

struct DescribeRulesPackagesOutputResponseBody: Equatable {
    public let rulesPackages: [RulesPackage]?
    public let failedItems: [String:FailedItemDetails]?
}

extension DescribeRulesPackagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedItems
        case rulesPackages
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackagesContainer = try containerValues.decodeIfPresent([RulesPackage?].self, forKey: .rulesPackages)
        var rulesPackagesDecoded0:[RulesPackage]? = nil
        if let rulesPackagesContainer = rulesPackagesContainer {
            rulesPackagesDecoded0 = [RulesPackage]()
            for structure0 in rulesPackagesContainer {
                if let structure0 = structure0 {
                    rulesPackagesDecoded0?.append(structure0)
                }
            }
        }
        rulesPackages = rulesPackagesDecoded0
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

extension DurationRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxSeconds
        case minSeconds
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxSeconds != 0 {
            try encodeContainer.encode(maxSeconds, forKey: .maxSeconds)
        }
        if minSeconds != 0 {
            try encodeContainer.encode(minSeconds, forKey: .minSeconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let minSecondsDecoded = try containerValues.decode(Int.self, forKey: .minSeconds)
        minSeconds = minSecondsDecoded
        let maxSecondsDecoded = try containerValues.decode(Int.self, forKey: .maxSeconds)
        maxSeconds = maxSecondsDecoded
    }
}

extension DurationRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DurationRange(maxSeconds: \(String(describing: maxSeconds)), minSeconds: \(String(describing: minSeconds)))"}
}

/// <p>This data type is used in the <a>AssessmentTemplateFilter</a> data
///          type.</p>
public struct DurationRange: Equatable {
    /// <p>The maximum value of the duration range. Must be less than or equal to 604800 seconds
    ///          (1 week).</p>
    public let maxSeconds: Int
    /// <p>The minimum value of the duration range. Must be greater than zero.</p>
    public let minSeconds: Int

    public init (
        maxSeconds: Int = 0,
        minSeconds: Int = 0
    )
    {
        self.maxSeconds = maxSeconds
        self.minSeconds = minSeconds
    }
}

extension EventSubscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event
        case subscribedAt
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let subscribedAt = subscribedAt {
            try encodeContainer.encode(subscribedAt.timeIntervalSince1970, forKey: .subscribedAt)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let subscribedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .subscribedAt)
        subscribedAt = subscribedAtDecoded
    }
}

extension EventSubscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSubscription(event: \(String(describing: event)), subscribedAt: \(String(describing: subscribedAt)))"}
}

/// <p>This data type is used in the <a>Subscription</a> data type.</p>
public struct EventSubscription: Equatable {
    /// <p>The event for which Amazon Simple Notification Service (SNS) notifications are
    ///          sent.</p>
    public let event: InspectorEvent?
    /// <p>The time at which <a>SubscribeToEvent</a> is called.</p>
    public let subscribedAt: Date?

    public init (
        event: InspectorEvent? = nil,
        subscribedAt: Date? = nil
    )
    {
        self.event = event
        self.subscribedAt = subscribedAt
    }
}

extension Exclusion: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case attributes
        case description
        case recommendation
        case scopes
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scopelist0 in scopes {
                try scopesContainer.encode(scopelist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let scopesContainer = try containerValues.decodeIfPresent([Scope?].self, forKey: .scopes)
        var scopesDecoded0:[Scope]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [Scope]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension Exclusion: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Exclusion(arn: \(String(describing: arn)), attributes: \(String(describing: attributes)), description: \(String(describing: description)), recommendation: \(String(describing: recommendation)), scopes: \(String(describing: scopes)), title: \(String(describing: title)))"}
}

/// <p>Contains information about what was excluded from an assessment run.</p>
public struct Exclusion: Equatable {
    /// <p>The ARN that specifies the exclusion.</p>
    public let arn: String?
    /// <p>The system-defined attributes for the exclusion.</p>
    public let attributes: [Attribute]?
    /// <p>The description of the exclusion.</p>
    public let description: String?
    /// <p>The recommendation for the exclusion.</p>
    public let recommendation: String?
    /// <p>The AWS resources for which the exclusion pertains.</p>
    public let scopes: [Scope]?
    /// <p>The name of the exclusion.</p>
    public let title: String?

    public init (
        arn: String? = nil,
        attributes: [Attribute]? = nil,
        description: String? = nil,
        recommendation: String? = nil,
        scopes: [Scope]? = nil,
        title: String? = nil
    )
    {
        self.arn = arn
        self.attributes = attributes
        self.description = description
        self.recommendation = recommendation
        self.scopes = scopes
        self.title = title
    }
}

extension ExclusionPreview: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributes
        case description
        case recommendation
        case scopes
        case title
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scopes)
            for scopelist0 in scopes {
                try scopesContainer.encode(scopelist0)
            }
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let scopesContainer = try containerValues.decodeIfPresent([Scope?].self, forKey: .scopes)
        var scopesDecoded0:[Scope]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [Scope]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ExclusionPreview: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ExclusionPreview(attributes: \(String(describing: attributes)), description: \(String(describing: description)), recommendation: \(String(describing: recommendation)), scopes: \(String(describing: scopes)), title: \(String(describing: title)))"}
}

/// <p>Contains information about what is excluded from an assessment run given the current
///          state of the assessment template.</p>
public struct ExclusionPreview: Equatable {
    /// <p>The system-defined attributes for the exclusion preview.</p>
    public let attributes: [Attribute]?
    /// <p>The description of the exclusion preview.</p>
    public let description: String?
    /// <p>The recommendation for the exclusion preview.</p>
    public let recommendation: String?
    /// <p>The AWS resources for which the exclusion preview pertains.</p>
    public let scopes: [Scope]?
    /// <p>The name of the exclusion preview.</p>
    public let title: String?

    public init (
        attributes: [Attribute]? = nil,
        description: String? = nil,
        recommendation: String? = nil,
        scopes: [Scope]? = nil,
        title: String? = nil
    )
    {
        self.attributes = attributes
        self.description = description
        self.recommendation = recommendation
        self.scopes = scopes
        self.title = title
    }
}

extension FailedItemDetails: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case failureCode
        case retryable
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let retryable = retryable {
            try encodeContainer.encode(retryable, forKey: .retryable)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failureCodeDecoded = try containerValues.decodeIfPresent(FailedItemErrorCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let retryableDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .retryable)
        retryable = retryableDecoded
    }
}

extension FailedItemDetails: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FailedItemDetails(failureCode: \(String(describing: failureCode)), retryable: \(String(describing: retryable)))"}
}

/// <p>Includes details about the failed items.</p>
public struct FailedItemDetails: Equatable {
    /// <p>The status code of a failed item.</p>
    public let failureCode: FailedItemErrorCode?
    /// <p>Indicates whether you can immediately retry a request for this item for a specified
    ///          resource.</p>
    public let retryable: Bool?

    public init (
        failureCode: FailedItemErrorCode? = nil,
        retryable: Bool? = nil
    )
    {
        self.failureCode = failureCode
        self.retryable = retryable
    }
}

public enum FailedItemErrorCode {
    case accessDenied
    case duplicateArn
    case internalError
    case invalidArn
    case itemDoesNotExist
    case limitExceeded
    case sdkUnknown(String)
}

extension FailedItemErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FailedItemErrorCode] {
        return [
            .accessDenied,
            .duplicateArn,
            .internalError,
            .invalidArn,
            .itemDoesNotExist,
            .limitExceeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .accessDenied: return "ACCESS_DENIED"
        case .duplicateArn: return "DUPLICATE_ARN"
        case .internalError: return "INTERNAL_ERROR"
        case .invalidArn: return "INVALID_ARN"
        case .itemDoesNotExist: return "ITEM_DOES_NOT_EXIST"
        case .limitExceeded: return "LIMIT_EXCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FailedItemErrorCode(rawValue: rawValue) ?? FailedItemErrorCode.sdkUnknown(rawValue)
    }
}

extension Finding: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case assetAttributes
        case assetType
        case attributes
        case confidence
        case createdAt
        case description
        case id
        case indicatorOfCompromise
        case numericSeverity
        case recommendation
        case schemaVersion
        case service
        case serviceAttributes
        case severity
        case title
        case updatedAt
        case userAttributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetAttributes = assetAttributes {
            try encodeContainer.encode(assetAttributes, forKey: .assetAttributes)
        }
        if let assetType = assetType {
            try encodeContainer.encode(assetType.rawValue, forKey: .assetType)
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if confidence != 0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let indicatorOfCompromise = indicatorOfCompromise {
            try encodeContainer.encode(indicatorOfCompromise, forKey: .indicatorOfCompromise)
        }
        if numericSeverity != 0.0 {
            try encodeContainer.encode(numericSeverity, forKey: .numericSeverity)
        }
        if let recommendation = recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let service = service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let serviceAttributes = serviceAttributes {
            try encodeContainer.encode(serviceAttributes, forKey: .serviceAttributes)
        }
        if let severity = severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let title = title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let updatedAt = updatedAt {
            try encodeContainer.encode(updatedAt.timeIntervalSince1970, forKey: .updatedAt)
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for userattributelist0 in userAttributes {
                try userAttributesContainer.encode(userattributelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let schemaVersionDecoded = try containerValues.decode(Int.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(String.self, forKey: .service)
        service = serviceDecoded
        let serviceAttributesDecoded = try containerValues.decodeIfPresent(InspectorServiceAttributes.self, forKey: .serviceAttributes)
        serviceAttributes = serviceAttributesDecoded
        let assetTypeDecoded = try containerValues.decodeIfPresent(AssetType.self, forKey: .assetType)
        assetType = assetTypeDecoded
        let assetAttributesDecoded = try containerValues.decodeIfPresent(AssetAttributes.self, forKey: .assetAttributes)
        assetAttributes = assetAttributesDecoded
        let idDecoded = try containerValues.decodeIfPresent(String.self, forKey: .id)
        id = idDecoded
        let titleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .title)
        title = titleDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let recommendationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Severity.self, forKey: .severity)
        severity = severityDecoded
        let numericSeverityDecoded = try containerValues.decode(Double.self, forKey: .numericSeverity)
        numericSeverity = numericSeverityDecoded
        let confidenceDecoded = try containerValues.decode(Int.self, forKey: .confidence)
        confidence = confidenceDecoded
        let indicatorOfCompromiseDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .indicatorOfCompromise)
        indicatorOfCompromise = indicatorOfCompromiseDecoded
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let userAttributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[Attribute]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [Attribute]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension Finding: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Finding(arn: \(String(describing: arn)), assetAttributes: \(String(describing: assetAttributes)), assetType: \(String(describing: assetType)), attributes: \(String(describing: attributes)), confidence: \(String(describing: confidence)), createdAt: \(String(describing: createdAt)), description: \(String(describing: description)), id: \(String(describing: id)), indicatorOfCompromise: \(String(describing: indicatorOfCompromise)), numericSeverity: \(String(describing: numericSeverity)), recommendation: \(String(describing: recommendation)), schemaVersion: \(String(describing: schemaVersion)), service: \(String(describing: service)), serviceAttributes: \(String(describing: serviceAttributes)), severity: \(String(describing: severity)), title: \(String(describing: title)), updatedAt: \(String(describing: updatedAt)), userAttributes: \(String(describing: userAttributes)))"}
}

/// <p>Contains information about an Amazon Inspector finding. This data type is used as the
///          response element in the <a>DescribeFindings</a> action.</p>
public struct Finding: Equatable {
    /// <p>The ARN that specifies the finding.</p>
    public let arn: String?
    /// <p>A collection of attributes of the host from which the finding is generated.</p>
    public let assetAttributes: AssetAttributes?
    /// <p>The type of the host from which the finding is generated.</p>
    public let assetType: AssetType?
    /// <p>The system-defined attributes for the finding.</p>
    public let attributes: [Attribute]?
    /// <p>This data element is currently not used.</p>
    public let confidence: Int
    /// <p>The time when the finding was generated.</p>
    public let createdAt: Date?
    /// <p>The description of the finding.</p>
    public let description: String?
    /// <p>The ID of the finding.</p>
    public let id: String?
    /// <p>This data element is currently not used.</p>
    public let indicatorOfCompromise: Bool?
    /// <p>The numeric value of the finding severity.</p>
    public let numericSeverity: Double
    /// <p>The recommendation for the finding.</p>
    public let recommendation: String?
    /// <p>The schema version of this data type.</p>
    public let schemaVersion: Int
    /// <p>The data element is set to "Inspector".</p>
    public let service: String?
    /// <p>This data type is used in the <a>Finding</a> data type.</p>
    public let serviceAttributes: InspectorServiceAttributes?
    /// <p>The finding severity. Values can be set to High, Medium, Low, and
    ///          Informational.</p>
    public let severity: Severity?
    /// <p>The name of the finding.</p>
    public let title: String?
    /// <p>The time when <a>AddAttributesToFindings</a> is called.</p>
    public let updatedAt: Date?
    /// <p>The user-defined attributes that are assigned to the finding.</p>
    public let userAttributes: [Attribute]?

    public init (
        arn: String? = nil,
        assetAttributes: AssetAttributes? = nil,
        assetType: AssetType? = nil,
        attributes: [Attribute]? = nil,
        confidence: Int = 0,
        createdAt: Date? = nil,
        description: String? = nil,
        id: String? = nil,
        indicatorOfCompromise: Bool? = nil,
        numericSeverity: Double = 0.0,
        recommendation: String? = nil,
        schemaVersion: Int = 0,
        service: String? = nil,
        serviceAttributes: InspectorServiceAttributes? = nil,
        severity: Severity? = nil,
        title: String? = nil,
        updatedAt: Date? = nil,
        userAttributes: [Attribute]? = nil
    )
    {
        self.arn = arn
        self.assetAttributes = assetAttributes
        self.assetType = assetType
        self.attributes = attributes
        self.confidence = confidence
        self.createdAt = createdAt
        self.description = description
        self.id = id
        self.indicatorOfCompromise = indicatorOfCompromise
        self.numericSeverity = numericSeverity
        self.recommendation = recommendation
        self.schemaVersion = schemaVersion
        self.service = service
        self.serviceAttributes = serviceAttributes
        self.severity = severity
        self.title = title
        self.updatedAt = updatedAt
        self.userAttributes = userAttributes
    }
}

extension FindingFilter: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case agentIds
        case attributes
        case autoScalingGroups
        case creationTimeRange
        case ruleNames
        case rulesPackageArns
        case severities
        case userAttributes
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentIds = agentIds {
            var agentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .agentIds)
            for agentidlist0 in agentIds {
                try agentIdsContainer.encode(agentidlist0)
            }
        }
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attributelist0 in attributes {
                try attributesContainer.encode(attributelist0)
            }
        }
        if let autoScalingGroups = autoScalingGroups {
            var autoScalingGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .autoScalingGroups)
            for autoscalinggrouplist0 in autoScalingGroups {
                try autoScalingGroupsContainer.encode(autoscalinggrouplist0)
            }
        }
        if let creationTimeRange = creationTimeRange {
            try encodeContainer.encode(creationTimeRange, forKey: .creationTimeRange)
        }
        if let ruleNames = ruleNames {
            var ruleNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ruleNames)
            for rulenamelist0 in ruleNames {
                try ruleNamesContainer.encode(rulenamelist0)
            }
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for filterrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(filterrulespackagearnlist0)
            }
        }
        if let severities = severities {
            var severitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .severities)
            for severitylist0 in severities {
                try severitiesContainer.encode(severitylist0.rawValue)
            }
        }
        if let userAttributes = userAttributes {
            var userAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributes)
            for attributelist0 in userAttributes {
                try userAttributesContainer.encode(attributelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .agentIds)
        var agentIdsDecoded0:[String]? = nil
        if let agentIdsContainer = agentIdsContainer {
            agentIdsDecoded0 = [String]()
            for string0 in agentIdsContainer {
                if let string0 = string0 {
                    agentIdsDecoded0?.append(string0)
                }
            }
        }
        agentIds = agentIdsDecoded0
        let autoScalingGroupsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .autoScalingGroups)
        var autoScalingGroupsDecoded0:[String]? = nil
        if let autoScalingGroupsContainer = autoScalingGroupsContainer {
            autoScalingGroupsDecoded0 = [String]()
            for string0 in autoScalingGroupsContainer {
                if let string0 = string0 {
                    autoScalingGroupsDecoded0?.append(string0)
                }
            }
        }
        autoScalingGroups = autoScalingGroupsDecoded0
        let ruleNamesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ruleNames)
        var ruleNamesDecoded0:[String]? = nil
        if let ruleNamesContainer = ruleNamesContainer {
            ruleNamesDecoded0 = [String]()
            for string0 in ruleNamesContainer {
                if let string0 = string0 {
                    ruleNamesDecoded0?.append(string0)
                }
            }
        }
        ruleNames = ruleNamesDecoded0
        let severitiesContainer = try containerValues.decodeIfPresent([Severity?].self, forKey: .severities)
        var severitiesDecoded0:[Severity]? = nil
        if let severitiesContainer = severitiesContainer {
            severitiesDecoded0 = [Severity]()
            for string0 in severitiesContainer {
                if let string0 = string0 {
                    severitiesDecoded0?.append(string0)
                }
            }
        }
        severities = severitiesDecoded0
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let attributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
        let userAttributesContainer = try containerValues.decodeIfPresent([Attribute?].self, forKey: .userAttributes)
        var userAttributesDecoded0:[Attribute]? = nil
        if let userAttributesContainer = userAttributesContainer {
            userAttributesDecoded0 = [Attribute]()
            for structure0 in userAttributesContainer {
                if let structure0 = structure0 {
                    userAttributesDecoded0?.append(structure0)
                }
            }
        }
        userAttributes = userAttributesDecoded0
        let creationTimeRangeDecoded = try containerValues.decodeIfPresent(TimestampRange.self, forKey: .creationTimeRange)
        creationTimeRange = creationTimeRangeDecoded
    }
}

extension FindingFilter: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FindingFilter(agentIds: \(String(describing: agentIds)), attributes: \(String(describing: attributes)), autoScalingGroups: \(String(describing: autoScalingGroups)), creationTimeRange: \(String(describing: creationTimeRange)), ruleNames: \(String(describing: ruleNames)), rulesPackageArns: \(String(describing: rulesPackageArns)), severities: \(String(describing: severities)), userAttributes: \(String(describing: userAttributes)))"}
}

/// <p>This data type is used as a request parameter in the <a>ListFindings</a>
///          action.</p>
public struct FindingFilter: Equatable {
    /// <p>For a record to match a filter, one of the values that is specified for this data
    ///          type property must be the exact match of the value of the <b>agentId</b> property of the <a>Finding</a> data type.</p>
    public let agentIds: [String]?
    /// <p>For a record to match a filter, the list of values that are specified for this data
    ///          type property must be contained in the list of values of the <b>attributes</b> property of the <a>Finding</a> data type.</p>
    public let attributes: [Attribute]?
    /// <p>For a record to match a filter, one of the values that is specified for this data
    ///          type property must be the exact match of the value of the <b>autoScalingGroup</b> property of the <a>Finding</a> data
    ///          type.</p>
    public let autoScalingGroups: [String]?
    /// <p>The time range during which the finding is generated.</p>
    public let creationTimeRange: TimestampRange?
    /// <p>For a record to match a filter, one of the values that is specified for this data
    ///          type property must be the exact match of the value of the <b>ruleName</b> property of the <a>Finding</a> data type.</p>
    public let ruleNames: [String]?
    /// <p>For a record to match a filter, one of the values that is specified for this data
    ///          type property must be the exact match of the value of the <b>rulesPackageArn</b> property of the <a>Finding</a> data
    ///          type.</p>
    public let rulesPackageArns: [String]?
    /// <p>For a record to match a filter, one of the values that is specified for this data
    ///          type property must be the exact match of the value of the <b>severity</b> property of the <a>Finding</a> data type.</p>
    public let severities: [Severity]?
    /// <p>For a record to match a filter, the value that is specified for this data type
    ///          property must be contained in the list of values of the <b>userAttributes</b> property of the <a>Finding</a> data
    ///          type.</p>
    public let userAttributes: [Attribute]?

    public init (
        agentIds: [String]? = nil,
        attributes: [Attribute]? = nil,
        autoScalingGroups: [String]? = nil,
        creationTimeRange: TimestampRange? = nil,
        ruleNames: [String]? = nil,
        rulesPackageArns: [String]? = nil,
        severities: [Severity]? = nil,
        userAttributes: [Attribute]? = nil
    )
    {
        self.agentIds = agentIds
        self.attributes = attributes
        self.autoScalingGroups = autoScalingGroups
        self.creationTimeRange = creationTimeRange
        self.ruleNames = ruleNames
        self.rulesPackageArns = rulesPackageArns
        self.severities = severities
        self.userAttributes = userAttributes
    }
}

public struct GetAssessmentReportInputBodyMiddleware: Middleware {
    public let id: String = "GetAssessmentReportInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentReportInput>
    public typealias MOutput = OperationOutput<GetAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentReportOutputError>
}

extension GetAssessmentReportInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentReportInput(assessmentRunArn: \(String(describing: assessmentRunArn)), reportFileFormat: \(String(describing: reportFileFormat)), reportType: \(String(describing: reportType)))"}
}

extension GetAssessmentReportInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case reportFileFormat
        case reportType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let reportFileFormat = reportFileFormat {
            try encodeContainer.encode(reportFileFormat.rawValue, forKey: .reportFileFormat)
        }
        if let reportType = reportType {
            try encodeContainer.encode(reportType.rawValue, forKey: .reportType)
        }
    }
}

public struct GetAssessmentReportInputHeadersMiddleware: Middleware {
    public let id: String = "GetAssessmentReportInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentReportInput>
    public typealias MOutput = OperationOutput<GetAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentReportOutputError>
}

public struct GetAssessmentReportInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAssessmentReportInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAssessmentReportInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAssessmentReportOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAssessmentReportInput>
    public typealias MOutput = OperationOutput<GetAssessmentReportOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAssessmentReportOutputError>
}

public struct GetAssessmentReportInput: Equatable {
    /// <p>The ARN that specifies the assessment run for which you want to generate a
    ///          report.</p>
    public let assessmentRunArn: String?
    /// <p>Specifies the file format (html or pdf) of the assessment report that you want to
    ///          generate.</p>
    public let reportFileFormat: ReportFileFormat?
    /// <p>Specifies the type of the assessment report that you want to generate. There are two
    ///          types of assessment reports: a finding report and a full report. For more information, see
    ///             <a href="https://docs.aws.amazon.com/inspector/latest/userguide/inspector_reports.html">Assessment Reports</a>. </p>
    public let reportType: ReportType?

    public init (
        assessmentRunArn: String? = nil,
        reportFileFormat: ReportFileFormat? = nil,
        reportType: ReportType? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.reportFileFormat = reportFileFormat
        self.reportType = reportType
    }
}

struct GetAssessmentReportInputBody: Equatable {
    public let assessmentRunArn: String?
    public let reportFileFormat: ReportFileFormat?
    public let reportType: ReportType?
}

extension GetAssessmentReportInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case reportFileFormat
        case reportType
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let reportFileFormatDecoded = try containerValues.decodeIfPresent(ReportFileFormat.self, forKey: .reportFileFormat)
        reportFileFormat = reportFileFormatDecoded
        let reportTypeDecoded = try containerValues.decodeIfPresent(ReportType.self, forKey: .reportType)
        reportType = reportTypeDecoded
    }
}

extension GetAssessmentReportOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAssessmentReportOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AssessmentRunInProgressException" : self = .assessmentRunInProgressException(try AssessmentRunInProgressException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedFeatureException" : self = .unsupportedFeatureException(try UnsupportedFeatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAssessmentReportOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case assessmentRunInProgressException(AssessmentRunInProgressException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unsupportedFeatureException(UnsupportedFeatureException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAssessmentReportOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAssessmentReportOutputResponse(status: \(String(describing: status)), url: \(String(describing: url)))"}
}

extension GetAssessmentReportOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAssessmentReportOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.status = output.status
            self.url = output.url
        } else {
            self.status = nil
            self.url = nil
        }
    }
}

public struct GetAssessmentReportOutputResponse: Equatable {
    /// <p>Specifies the status of the request to generate an assessment report. </p>
    public let status: ReportStatus?
    /// <p>Specifies the URL where you can find the generated assessment report. This parameter
    ///          is only returned if the report is successfully generated.</p>
    public let url: String?

    public init (
        status: ReportStatus? = nil,
        url: String? = nil
    )
    {
        self.status = status
        self.url = url
    }
}

struct GetAssessmentReportOutputResponseBody: Equatable {
    public let status: ReportStatus?
    public let url: String?
}

extension GetAssessmentReportOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status
        case url
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ReportStatus.self, forKey: .status)
        status = statusDecoded
        let urlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .url)
        url = urlDecoded
    }
}

public struct GetExclusionsPreviewInputBodyMiddleware: Middleware {
    public let id: String = "GetExclusionsPreviewInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExclusionsPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExclusionsPreviewInput>
    public typealias MOutput = OperationOutput<GetExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExclusionsPreviewOutputError>
}

extension GetExclusionsPreviewInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExclusionsPreviewInput(assessmentTemplateArn: \(String(describing: assessmentTemplateArn)), locale: \(String(describing: locale)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), previewToken: \(String(describing: previewToken)))"}
}

extension GetExclusionsPreviewInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArn
        case locale
        case maxResults
        case nextToken
        case previewToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
        if let locale = locale {
            try encodeContainer.encode(locale.rawValue, forKey: .locale)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let previewToken = previewToken {
            try encodeContainer.encode(previewToken, forKey: .previewToken)
        }
    }
}

public struct GetExclusionsPreviewInputHeadersMiddleware: Middleware {
    public let id: String = "GetExclusionsPreviewInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExclusionsPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExclusionsPreviewInput>
    public typealias MOutput = OperationOutput<GetExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExclusionsPreviewOutputError>
}

public struct GetExclusionsPreviewInputQueryItemMiddleware: Middleware {
    public let id: String = "GetExclusionsPreviewInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetExclusionsPreviewInput>,
                  next: H) -> Swift.Result<OperationOutput<GetExclusionsPreviewOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetExclusionsPreviewInput>
    public typealias MOutput = OperationOutput<GetExclusionsPreviewOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetExclusionsPreviewOutputError>
}

public struct GetExclusionsPreviewInput: Equatable {
    /// <p>The ARN that specifies the assessment template for which the exclusions preview was
    ///          requested.</p>
    public let assessmentTemplateArn: String?
    /// <p>The locale into which you want to translate the exclusion's title, description, and
    ///          recommendation.</p>
    public let locale: Locale?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 100. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the GetExclusionsPreviewRequest action. Subsequent calls to
    ///          the action fill nextToken in the request with the value of nextToken from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?
    /// <p>The unique identifier associated of the exclusions preview.</p>
    public let previewToken: String?

    public init (
        assessmentTemplateArn: String? = nil,
        locale: Locale? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil,
        previewToken: String? = nil
    )
    {
        self.assessmentTemplateArn = assessmentTemplateArn
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewToken = previewToken
    }
}

struct GetExclusionsPreviewInputBody: Equatable {
    public let assessmentTemplateArn: String?
    public let previewToken: String?
    public let nextToken: String?
    public let maxResults: Int?
    public let locale: Locale?
}

extension GetExclusionsPreviewInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArn
        case locale
        case maxResults
        case nextToken
        case previewToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let previewTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previewToken)
        previewToken = previewTokenDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Locale.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension GetExclusionsPreviewOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExclusionsPreviewOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetExclusionsPreviewOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExclusionsPreviewOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetExclusionsPreviewOutputResponse(exclusionPreviews: \(String(describing: exclusionPreviews)), nextToken: \(String(describing: nextToken)), previewStatus: \(String(describing: previewStatus)))"}
}

extension GetExclusionsPreviewOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetExclusionsPreviewOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exclusionPreviews = output.exclusionPreviews
            self.nextToken = output.nextToken
            self.previewStatus = output.previewStatus
        } else {
            self.exclusionPreviews = nil
            self.nextToken = nil
            self.previewStatus = nil
        }
    }
}

public struct GetExclusionsPreviewOutputResponse: Equatable {
    /// <p>Information about the exclusions included in the preview.</p>
    public let exclusionPreviews: [ExclusionPreview]?
    /// <p>When a response is generated, if there is more data to be listed, this parameters is
    ///          present in the response and contains the value to use for the nextToken parameter in a
    ///          subsequent pagination request. If there is no more data to be listed, this parameter is set
    ///          to null.</p>
    public let nextToken: String?
    /// <p>Specifies the status of the request to generate an exclusions preview.</p>
    public let previewStatus: PreviewStatus?

    public init (
        exclusionPreviews: [ExclusionPreview]? = nil,
        nextToken: String? = nil,
        previewStatus: PreviewStatus? = nil
    )
    {
        self.exclusionPreviews = exclusionPreviews
        self.nextToken = nextToken
        self.previewStatus = previewStatus
    }
}

struct GetExclusionsPreviewOutputResponseBody: Equatable {
    public let previewStatus: PreviewStatus?
    public let exclusionPreviews: [ExclusionPreview]?
    public let nextToken: String?
}

extension GetExclusionsPreviewOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusionPreviews
        case nextToken
        case previewStatus
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewStatusDecoded = try containerValues.decodeIfPresent(PreviewStatus.self, forKey: .previewStatus)
        previewStatus = previewStatusDecoded
        let exclusionPreviewsContainer = try containerValues.decodeIfPresent([ExclusionPreview?].self, forKey: .exclusionPreviews)
        var exclusionPreviewsDecoded0:[ExclusionPreview]? = nil
        if let exclusionPreviewsContainer = exclusionPreviewsContainer {
            exclusionPreviewsDecoded0 = [ExclusionPreview]()
            for structure0 in exclusionPreviewsContainer {
                if let structure0 = structure0 {
                    exclusionPreviewsDecoded0?.append(structure0)
                }
            }
        }
        exclusionPreviews = exclusionPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct GetTelemetryMetadataInputBodyMiddleware: Middleware {
    public let id: String = "GetTelemetryMetadataInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTelemetryMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTelemetryMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTelemetryMetadataInput>
    public typealias MOutput = OperationOutput<GetTelemetryMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTelemetryMetadataOutputError>
}

extension GetTelemetryMetadataInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTelemetryMetadataInput(assessmentRunArn: \(String(describing: assessmentRunArn)))"}
}

extension GetTelemetryMetadataInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
    }
}

public struct GetTelemetryMetadataInputHeadersMiddleware: Middleware {
    public let id: String = "GetTelemetryMetadataInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTelemetryMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTelemetryMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTelemetryMetadataInput>
    public typealias MOutput = OperationOutput<GetTelemetryMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTelemetryMetadataOutputError>
}

public struct GetTelemetryMetadataInputQueryItemMiddleware: Middleware {
    public let id: String = "GetTelemetryMetadataInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetTelemetryMetadataInput>,
                  next: H) -> Swift.Result<OperationOutput<GetTelemetryMetadataOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetTelemetryMetadataInput>
    public typealias MOutput = OperationOutput<GetTelemetryMetadataOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetTelemetryMetadataOutputError>
}

public struct GetTelemetryMetadataInput: Equatable {
    /// <p>The ARN that specifies the assessment run that has the telemetry data that you want
    ///          to obtain.</p>
    public let assessmentRunArn: String?

    public init (
        assessmentRunArn: String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct GetTelemetryMetadataInputBody: Equatable {
    public let assessmentRunArn: String?
}

extension GetTelemetryMetadataInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

extension GetTelemetryMetadataOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTelemetryMetadataOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetTelemetryMetadataOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTelemetryMetadataOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetTelemetryMetadataOutputResponse(telemetryMetadata: \(String(describing: telemetryMetadata)))"}
}

extension GetTelemetryMetadataOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetTelemetryMetadataOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.telemetryMetadata = output.telemetryMetadata
        } else {
            self.telemetryMetadata = nil
        }
    }
}

public struct GetTelemetryMetadataOutputResponse: Equatable {
    /// <p>Telemetry details.</p>
    public let telemetryMetadata: [TelemetryMetadata]?

    public init (
        telemetryMetadata: [TelemetryMetadata]? = nil
    )
    {
        self.telemetryMetadata = telemetryMetadata
    }
}

struct GetTelemetryMetadataOutputResponseBody: Equatable {
    public let telemetryMetadata: [TelemetryMetadata]?
}

extension GetTelemetryMetadataOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case telemetryMetadata
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryMetadataContainer = try containerValues.decodeIfPresent([TelemetryMetadata?].self, forKey: .telemetryMetadata)
        var telemetryMetadataDecoded0:[TelemetryMetadata]? = nil
        if let telemetryMetadataContainer = telemetryMetadataContainer {
            telemetryMetadataDecoded0 = [TelemetryMetadata]()
            for structure0 in telemetryMetadataContainer {
                if let structure0 = structure0 {
                    telemetryMetadataDecoded0?.append(structure0)
                }
            }
        }
        telemetryMetadata = telemetryMetadataDecoded0
    }
}

public enum InspectorEvent {
    case assessmentRunCompleted
    case assessmentRunStarted
    case assessmentRunStateChanged
    case findingReported
    case other
    case sdkUnknown(String)
}

extension InspectorEvent : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InspectorEvent] {
        return [
            .assessmentRunCompleted,
            .assessmentRunStarted,
            .assessmentRunStateChanged,
            .findingReported,
            .other,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assessmentRunCompleted: return "ASSESSMENT_RUN_COMPLETED"
        case .assessmentRunStarted: return "ASSESSMENT_RUN_STARTED"
        case .assessmentRunStateChanged: return "ASSESSMENT_RUN_STATE_CHANGED"
        case .findingReported: return "FINDING_REPORTED"
        case .other: return "OTHER"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InspectorEvent(rawValue: rawValue) ?? InspectorEvent.sdkUnknown(rawValue)
    }
}

extension InspectorServiceAttributes: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case rulesPackageArn
        case schemaVersion
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let rulesPackageArn = rulesPackageArn {
            try encodeContainer.encode(rulesPackageArn, forKey: .rulesPackageArn)
        }
        if schemaVersion != 0 {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaVersionDecoded = try containerValues.decode(Int.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let rulesPackageArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .rulesPackageArn)
        rulesPackageArn = rulesPackageArnDecoded
    }
}

extension InspectorServiceAttributes: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InspectorServiceAttributes(assessmentRunArn: \(String(describing: assessmentRunArn)), rulesPackageArn: \(String(describing: rulesPackageArn)), schemaVersion: \(String(describing: schemaVersion)))"}
}

/// <p>This data type is used in the <a>Finding</a> data type.</p>
public struct InspectorServiceAttributes: Equatable {
    /// <p>The ARN of the assessment run during which the finding is generated.</p>
    public let assessmentRunArn: String?
    /// <p>The ARN of the rules package that is used to generate the finding.</p>
    public let rulesPackageArn: String?
    /// <p>The schema version of this data type.</p>
    public let schemaVersion: Int

    public init (
        assessmentRunArn: String? = nil,
        rulesPackageArn: String? = nil,
        schemaVersion: Int = 0
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.rulesPackageArn = rulesPackageArn
        self.schemaVersion = schemaVersion
    }
}

extension InternalException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InternalException(canRetry: \(String(describing: canRetry)), message: \(String(describing: message)))"}
}

extension InternalException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InternalExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Internal server error.</p>
public struct InternalException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.message = message
    }
}

struct InternalExceptionBody: Equatable {
    public let message: String?
    public let canRetry: Bool?
}

extension InternalExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public enum InvalidCrossAccountRoleErrorCode {
    case roleDoesNotExistOrInvalidTrustRelationship
    case roleDoesNotHaveCorrectPolicy
    case sdkUnknown(String)
}

extension InvalidCrossAccountRoleErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InvalidCrossAccountRoleErrorCode] {
        return [
            .roleDoesNotExistOrInvalidTrustRelationship,
            .roleDoesNotHaveCorrectPolicy,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .roleDoesNotExistOrInvalidTrustRelationship: return "ROLE_DOES_NOT_EXIST_OR_INVALID_TRUST_RELATIONSHIP"
        case .roleDoesNotHaveCorrectPolicy: return "ROLE_DOES_NOT_HAVE_CORRECT_POLICY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InvalidCrossAccountRoleErrorCode(rawValue: rawValue) ?? InvalidCrossAccountRoleErrorCode.sdkUnknown(rawValue)
    }
}

extension InvalidCrossAccountRoleException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCrossAccountRoleException(canRetry: \(String(describing: canRetry)), errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InvalidCrossAccountRoleException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCrossAccountRoleExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Amazon Inspector cannot assume the cross-account role that it needs to list your EC2
///          instances during the assessment run.</p>
public struct InvalidCrossAccountRoleException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Code that indicates the type of error that is generated.</p>
    public var errorCode: InvalidCrossAccountRoleErrorCode?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        errorCode: InvalidCrossAccountRoleErrorCode? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct InvalidCrossAccountRoleExceptionBody: Equatable {
    public let message: String?
    public let errorCode: InvalidCrossAccountRoleErrorCode?
    public let canRetry: Bool?
}

extension InvalidCrossAccountRoleExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InvalidCrossAccountRoleErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public enum InvalidInputErrorCode {
    case assessmentTargetNameAlreadyTaken
    case assessmentTemplateNameAlreadyTaken
    case invalidAgentId
    case invalidAssessmentRunArn
    case invalidAssessmentRunCompletionTimeRange
    case invalidAssessmentRunDurationRange
    case invalidAssessmentRunStartTimeRange
    case invalidAssessmentRunState
    case invalidAssessmentRunStateChangeTimeRange
    case invalidAssessmentTargetArn
    case invalidAssessmentTargetName
    case invalidAssessmentTargetNamePattern
    case invalidAssessmentTemplateArn
    case invalidAssessmentTemplateDuration
    case invalidAssessmentTemplateDurationRange
    case invalidAssessmentTemplateName
    case invalidAssessmentTemplateNamePattern
    case invalidAttribute
    case invalidAutoScalingGroup
    case invalidEvent
    case invalidFindingArn
    case invalidIamRoleArn
    case invalidLocale
    case invalidMaxResults
    case invalidNumberOfAgentIds
    case invalidNumberOfAssessmentRunArns
    case invalidNumberOfAssessmentRunStates
    case invalidNumberOfAssessmentTargetArns
    case invalidNumberOfAssessmentTemplateArns
    case invalidNumberOfAttributes
    case invalidNumberOfAutoScalingGroups
    case invalidNumberOfFindingArns
    case invalidNumberOfResourceGroupArns
    case invalidNumberOfResourceGroupTags
    case invalidNumberOfRulesPackageArns
    case invalidNumberOfRuleNames
    case invalidNumberOfSeverities
    case invalidNumberOfTags
    case invalidNumberOfUserAttributes
    case invalidPaginationToken
    case invalidResourceArn
    case invalidResourceGroupArn
    case invalidResourceGroupTagKey
    case invalidResourceGroupTagValue
    case invalidRulesPackageArn
    case invalidRuleName
    case invalidSeverity
    case invalidSnsTopicArn
    case invalidTag
    case invalidTagKey
    case invalidTagValue
    case invalidUserAttribute
    case invalidUserAttributeKey
    case invalidUserAttributeValue
    case sdkUnknown(String)
}

extension InvalidInputErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InvalidInputErrorCode] {
        return [
            .assessmentTargetNameAlreadyTaken,
            .assessmentTemplateNameAlreadyTaken,
            .invalidAgentId,
            .invalidAssessmentRunArn,
            .invalidAssessmentRunCompletionTimeRange,
            .invalidAssessmentRunDurationRange,
            .invalidAssessmentRunStartTimeRange,
            .invalidAssessmentRunState,
            .invalidAssessmentRunStateChangeTimeRange,
            .invalidAssessmentTargetArn,
            .invalidAssessmentTargetName,
            .invalidAssessmentTargetNamePattern,
            .invalidAssessmentTemplateArn,
            .invalidAssessmentTemplateDuration,
            .invalidAssessmentTemplateDurationRange,
            .invalidAssessmentTemplateName,
            .invalidAssessmentTemplateNamePattern,
            .invalidAttribute,
            .invalidAutoScalingGroup,
            .invalidEvent,
            .invalidFindingArn,
            .invalidIamRoleArn,
            .invalidLocale,
            .invalidMaxResults,
            .invalidNumberOfAgentIds,
            .invalidNumberOfAssessmentRunArns,
            .invalidNumberOfAssessmentRunStates,
            .invalidNumberOfAssessmentTargetArns,
            .invalidNumberOfAssessmentTemplateArns,
            .invalidNumberOfAttributes,
            .invalidNumberOfAutoScalingGroups,
            .invalidNumberOfFindingArns,
            .invalidNumberOfResourceGroupArns,
            .invalidNumberOfResourceGroupTags,
            .invalidNumberOfRulesPackageArns,
            .invalidNumberOfRuleNames,
            .invalidNumberOfSeverities,
            .invalidNumberOfTags,
            .invalidNumberOfUserAttributes,
            .invalidPaginationToken,
            .invalidResourceArn,
            .invalidResourceGroupArn,
            .invalidResourceGroupTagKey,
            .invalidResourceGroupTagValue,
            .invalidRulesPackageArn,
            .invalidRuleName,
            .invalidSeverity,
            .invalidSnsTopicArn,
            .invalidTag,
            .invalidTagKey,
            .invalidTagValue,
            .invalidUserAttribute,
            .invalidUserAttributeKey,
            .invalidUserAttributeValue,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assessmentTargetNameAlreadyTaken: return "ASSESSMENT_TARGET_NAME_ALREADY_TAKEN"
        case .assessmentTemplateNameAlreadyTaken: return "ASSESSMENT_TEMPLATE_NAME_ALREADY_TAKEN"
        case .invalidAgentId: return "INVALID_AGENT_ID"
        case .invalidAssessmentRunArn: return "INVALID_ASSESSMENT_RUN_ARN"
        case .invalidAssessmentRunCompletionTimeRange: return "INVALID_ASSESSMENT_RUN_COMPLETION_TIME_RANGE"
        case .invalidAssessmentRunDurationRange: return "INVALID_ASSESSMENT_RUN_DURATION_RANGE"
        case .invalidAssessmentRunStartTimeRange: return "INVALID_ASSESSMENT_RUN_START_TIME_RANGE"
        case .invalidAssessmentRunState: return "INVALID_ASSESSMENT_RUN_STATE"
        case .invalidAssessmentRunStateChangeTimeRange: return "INVALID_ASSESSMENT_RUN_STATE_CHANGE_TIME_RANGE"
        case .invalidAssessmentTargetArn: return "INVALID_ASSESSMENT_TARGET_ARN"
        case .invalidAssessmentTargetName: return "INVALID_ASSESSMENT_TARGET_NAME"
        case .invalidAssessmentTargetNamePattern: return "INVALID_ASSESSMENT_TARGET_NAME_PATTERN"
        case .invalidAssessmentTemplateArn: return "INVALID_ASSESSMENT_TEMPLATE_ARN"
        case .invalidAssessmentTemplateDuration: return "INVALID_ASSESSMENT_TEMPLATE_DURATION"
        case .invalidAssessmentTemplateDurationRange: return "INVALID_ASSESSMENT_TEMPLATE_DURATION_RANGE"
        case .invalidAssessmentTemplateName: return "INVALID_ASSESSMENT_TEMPLATE_NAME"
        case .invalidAssessmentTemplateNamePattern: return "INVALID_ASSESSMENT_TEMPLATE_NAME_PATTERN"
        case .invalidAttribute: return "INVALID_ATTRIBUTE"
        case .invalidAutoScalingGroup: return "INVALID_AUTO_SCALING_GROUP"
        case .invalidEvent: return "INVALID_EVENT"
        case .invalidFindingArn: return "INVALID_FINDING_ARN"
        case .invalidIamRoleArn: return "INVALID_IAM_ROLE_ARN"
        case .invalidLocale: return "INVALID_LOCALE"
        case .invalidMaxResults: return "INVALID_MAX_RESULTS"
        case .invalidNumberOfAgentIds: return "INVALID_NUMBER_OF_AGENT_IDS"
        case .invalidNumberOfAssessmentRunArns: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_ARNS"
        case .invalidNumberOfAssessmentRunStates: return "INVALID_NUMBER_OF_ASSESSMENT_RUN_STATES"
        case .invalidNumberOfAssessmentTargetArns: return "INVALID_NUMBER_OF_ASSESSMENT_TARGET_ARNS"
        case .invalidNumberOfAssessmentTemplateArns: return "INVALID_NUMBER_OF_ASSESSMENT_TEMPLATE_ARNS"
        case .invalidNumberOfAttributes: return "INVALID_NUMBER_OF_ATTRIBUTES"
        case .invalidNumberOfAutoScalingGroups: return "INVALID_NUMBER_OF_AUTO_SCALING_GROUPS"
        case .invalidNumberOfFindingArns: return "INVALID_NUMBER_OF_FINDING_ARNS"
        case .invalidNumberOfResourceGroupArns: return "INVALID_NUMBER_OF_RESOURCE_GROUP_ARNS"
        case .invalidNumberOfResourceGroupTags: return "INVALID_NUMBER_OF_RESOURCE_GROUP_TAGS"
        case .invalidNumberOfRulesPackageArns: return "INVALID_NUMBER_OF_RULES_PACKAGE_ARNS"
        case .invalidNumberOfRuleNames: return "INVALID_NUMBER_OF_RULE_NAMES"
        case .invalidNumberOfSeverities: return "INVALID_NUMBER_OF_SEVERITIES"
        case .invalidNumberOfTags: return "INVALID_NUMBER_OF_TAGS"
        case .invalidNumberOfUserAttributes: return "INVALID_NUMBER_OF_USER_ATTRIBUTES"
        case .invalidPaginationToken: return "INVALID_PAGINATION_TOKEN"
        case .invalidResourceArn: return "INVALID_RESOURCE_ARN"
        case .invalidResourceGroupArn: return "INVALID_RESOURCE_GROUP_ARN"
        case .invalidResourceGroupTagKey: return "INVALID_RESOURCE_GROUP_TAG_KEY"
        case .invalidResourceGroupTagValue: return "INVALID_RESOURCE_GROUP_TAG_VALUE"
        case .invalidRulesPackageArn: return "INVALID_RULES_PACKAGE_ARN"
        case .invalidRuleName: return "INVALID_RULE_NAME"
        case .invalidSeverity: return "INVALID_SEVERITY"
        case .invalidSnsTopicArn: return "INVALID_SNS_TOPIC_ARN"
        case .invalidTag: return "INVALID_TAG"
        case .invalidTagKey: return "INVALID_TAG_KEY"
        case .invalidTagValue: return "INVALID_TAG_VALUE"
        case .invalidUserAttribute: return "INVALID_USER_ATTRIBUTE"
        case .invalidUserAttributeKey: return "INVALID_USER_ATTRIBUTE_KEY"
        case .invalidUserAttributeValue: return "INVALID_USER_ATTRIBUTE_VALUE"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InvalidInputErrorCode(rawValue: rawValue) ?? InvalidInputErrorCode.sdkUnknown(rawValue)
    }
}

extension InvalidInputException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidInputException(canRetry: \(String(describing: canRetry)), errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension InvalidInputException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidInputExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because an invalid or out-of-range value was supplied for an
///          input parameter.</p>
public struct InvalidInputException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Code that indicates the type of error that is generated.</p>
    public var errorCode: InvalidInputErrorCode?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        errorCode: InvalidInputErrorCode? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct InvalidInputExceptionBody: Equatable {
    public let message: String?
    public let errorCode: InvalidInputErrorCode?
    public let canRetry: Bool?
}

extension InvalidInputExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(InvalidInputErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public enum LimitExceededErrorCode {
    case assessmentRunLimitExceeded
    case assessmentTargetLimitExceeded
    case assessmentTemplateLimitExceeded
    case eventSubscriptionLimitExceeded
    case resourceGroupLimitExceeded
    case sdkUnknown(String)
}

extension LimitExceededErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LimitExceededErrorCode] {
        return [
            .assessmentRunLimitExceeded,
            .assessmentTargetLimitExceeded,
            .assessmentTemplateLimitExceeded,
            .eventSubscriptionLimitExceeded,
            .resourceGroupLimitExceeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assessmentRunLimitExceeded: return "ASSESSMENT_RUN_LIMIT_EXCEEDED"
        case .assessmentTargetLimitExceeded: return "ASSESSMENT_TARGET_LIMIT_EXCEEDED"
        case .assessmentTemplateLimitExceeded: return "ASSESSMENT_TEMPLATE_LIMIT_EXCEEDED"
        case .eventSubscriptionLimitExceeded: return "EVENT_SUBSCRIPTION_LIMIT_EXCEEDED"
        case .resourceGroupLimitExceeded: return "RESOURCE_GROUP_LIMIT_EXCEEDED"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LimitExceededErrorCode(rawValue: rawValue) ?? LimitExceededErrorCode.sdkUnknown(rawValue)
    }
}

extension LimitExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LimitExceededException(canRetry: \(String(describing: canRetry)), errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension LimitExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it attempted to create resources beyond the current
///          AWS account limits. The error code describes the limit exceeded.</p>
public struct LimitExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Code that indicates the type of error that is generated.</p>
    public var errorCode: LimitExceededErrorCode?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        errorCode: LimitExceededErrorCode? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct LimitExceededExceptionBody: Equatable {
    public let message: String?
    public let errorCode: LimitExceededErrorCode?
    public let canRetry: Bool?
}

extension LimitExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(LimitExceededErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct ListAssessmentRunAgentsInputBodyMiddleware: Middleware {
    public let id: String = "ListAssessmentRunAgentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentRunAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentRunAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentRunAgentsInput>
    public typealias MOutput = OperationOutput<ListAssessmentRunAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentRunAgentsOutputError>
}

extension ListAssessmentRunAgentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentRunAgentsInput(assessmentRunArn: \(String(describing: assessmentRunArn)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentRunAgentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentRunAgentsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssessmentRunAgentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentRunAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentRunAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentRunAgentsInput>
    public typealias MOutput = OperationOutput<ListAssessmentRunAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentRunAgentsOutputError>
}

public struct ListAssessmentRunAgentsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssessmentRunAgentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentRunAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentRunAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentRunAgentsInput>
    public typealias MOutput = OperationOutput<ListAssessmentRunAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentRunAgentsOutputError>
}

public struct ListAssessmentRunAgentsInput: Equatable {
    /// <p>The ARN that specifies the assessment run whose agents you want to list.</p>
    public let assessmentRunArn: String?
    /// <p>You can use this parameter to specify a subset of data to be included in the action's
    ///          response.</p>
    ///          <p>For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.</p>
    public let filter: AgentFilter?
    /// <p>You can use this parameter to indicate the maximum number of items that you want in
    ///          the response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>ListAssessmentRunAgents</b>
    ///          action. Subsequent calls to the action fill <b>nextToken</b> in
    ///          the request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?

    public init (
        assessmentRunArn: String? = nil,
        filter: AgentFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunAgentsInputBody: Equatable {
    public let assessmentRunArn: String?
    public let filter: AgentFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAssessmentRunAgentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let filterDecoded = try containerValues.decodeIfPresent(AgentFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentRunAgentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentRunAgentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentRunAgentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentRunAgentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentRunAgentsOutputResponse(assessmentRunAgents: \(String(describing: assessmentRunAgents)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentRunAgentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssessmentRunAgentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentRunAgents = output.assessmentRunAgents
            self.nextToken = output.nextToken
        } else {
            self.assessmentRunAgents = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentRunAgentsOutputResponse: Equatable {
    /// <p>A list of ARNs that specifies the agents returned by the action.</p>
    public let assessmentRunAgents: [AssessmentRunAgent]?
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?

    public init (
        assessmentRunAgents: [AssessmentRunAgent]? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentRunAgents = assessmentRunAgents
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunAgentsOutputResponseBody: Equatable {
    public let assessmentRunAgents: [AssessmentRunAgent]?
    public let nextToken: String?
}

extension ListAssessmentRunAgentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunAgents
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunAgentsContainer = try containerValues.decodeIfPresent([AssessmentRunAgent?].self, forKey: .assessmentRunAgents)
        var assessmentRunAgentsDecoded0:[AssessmentRunAgent]? = nil
        if let assessmentRunAgentsContainer = assessmentRunAgentsContainer {
            assessmentRunAgentsDecoded0 = [AssessmentRunAgent]()
            for structure0 in assessmentRunAgentsContainer {
                if let structure0 = structure0 {
                    assessmentRunAgentsDecoded0?.append(structure0)
                }
            }
        }
        assessmentRunAgents = assessmentRunAgentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssessmentRunsInputBodyMiddleware: Middleware {
    public let id: String = "ListAssessmentRunsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentRunsInput>
    public typealias MOutput = OperationOutput<ListAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentRunsOutputError>
}

extension ListAssessmentRunsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentRunsInput(assessmentTemplateArns: \(String(describing: assessmentTemplateArns)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentRunsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTemplateArns = assessmentTemplateArns {
            var assessmentTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTemplateArns)
            for listparentarnlist0 in assessmentTemplateArns {
                try assessmentTemplateArnsContainer.encode(listparentarnlist0)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentRunsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssessmentRunsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentRunsInput>
    public typealias MOutput = OperationOutput<ListAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentRunsOutputError>
}

public struct ListAssessmentRunsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssessmentRunsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentRunsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentRunsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentRunsInput>
    public typealias MOutput = OperationOutput<ListAssessmentRunsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentRunsOutputError>
}

public struct ListAssessmentRunsInput: Equatable {
    /// <p>The ARNs that specify the assessment templates whose assessment runs you want to
    ///          list.</p>
    public let assessmentTemplateArns: [String]?
    /// <p>You can use this parameter to specify a subset of data to be included in the action's
    ///          response.</p>
    ///          <p>For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.</p>
    public let filter: AssessmentRunFilter?
    /// <p>You can use this parameter to indicate the maximum number of items that you want in
    ///          the response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>ListAssessmentRuns</b>
    ///          action. Subsequent calls to the action fill <b>nextToken</b> in
    ///          the request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?

    public init (
        assessmentTemplateArns: [String]? = nil,
        filter: AssessmentRunFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunsInputBody: Equatable {
    public let assessmentTemplateArns: [String]?
    public let filter: AssessmentRunFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAssessmentRunsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArns
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(AssessmentRunFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentRunsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentRunsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentRunsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentRunsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentRunsOutputResponse(assessmentRunArns: \(String(describing: assessmentRunArns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentRunsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssessmentRunsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentRunArns = output.assessmentRunArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentRunArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentRunsOutputResponse: Equatable {
    /// <p>A list of ARNs that specifies the assessment runs that are returned by the
    ///          action.</p>
    public let assessmentRunArns: [String]?
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?

    public init (
        assessmentRunArns: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentRunsOutputResponseBody: Equatable {
    public let assessmentRunArns: [String]?
    public let nextToken: String?
}

extension ListAssessmentRunsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArns
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssessmentTargetsInputBodyMiddleware: Middleware {
    public let id: String = "ListAssessmentTargetsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentTargetsInput>
    public typealias MOutput = OperationOutput<ListAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentTargetsOutputError>
}

extension ListAssessmentTargetsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentTargetsInput(filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentTargetsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentTargetsInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssessmentTargetsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentTargetsInput>
    public typealias MOutput = OperationOutput<ListAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentTargetsOutputError>
}

public struct ListAssessmentTargetsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssessmentTargetsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentTargetsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentTargetsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentTargetsInput>
    public typealias MOutput = OperationOutput<ListAssessmentTargetsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentTargetsOutputError>
}

public struct ListAssessmentTargetsInput: Equatable {
    /// <p>You can use this parameter to specify a subset of data to be included in the action's
    ///          response.</p>
    ///          <p>For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.</p>
    public let filter: AssessmentTargetFilter?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>ListAssessmentTargets</b>
    ///          action. Subsequent calls to the action fill <b>nextToken</b> in
    ///          the request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?

    public init (
        filter: AssessmentTargetFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentTargetsInputBody: Equatable {
    public let filter: AssessmentTargetFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAssessmentTargetsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(AssessmentTargetFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentTargetsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentTargetsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentTargetsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentTargetsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentTargetsOutputResponse(assessmentTargetArns: \(String(describing: assessmentTargetArns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentTargetsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssessmentTargetsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentTargetArns = output.assessmentTargetArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentTargetArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentTargetsOutputResponse: Equatable {
    /// <p>A list of ARNs that specifies the assessment targets that are returned by the
    ///          action.</p>
    public let assessmentTargetArns: [String]?
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?

    public init (
        assessmentTargetArns: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentTargetsOutputResponseBody: Equatable {
    public let assessmentTargetArns: [String]?
    public let nextToken: String?
}

extension ListAssessmentTargetsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArns
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListAssessmentTemplatesInputBodyMiddleware: Middleware {
    public let id: String = "ListAssessmentTemplatesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentTemplatesInput>
    public typealias MOutput = OperationOutput<ListAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentTemplatesOutputError>
}

extension ListAssessmentTemplatesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentTemplatesInput(assessmentTargetArns: \(String(describing: assessmentTargetArns)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentTemplatesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArns = assessmentTargetArns {
            var assessmentTargetArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTargetArns)
            for listparentarnlist0 in assessmentTargetArns {
                try assessmentTargetArnsContainer.encode(listparentarnlist0)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListAssessmentTemplatesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAssessmentTemplatesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentTemplatesInput>
    public typealias MOutput = OperationOutput<ListAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentTemplatesOutputError>
}

public struct ListAssessmentTemplatesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAssessmentTemplatesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAssessmentTemplatesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAssessmentTemplatesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAssessmentTemplatesInput>
    public typealias MOutput = OperationOutput<ListAssessmentTemplatesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAssessmentTemplatesOutputError>
}

public struct ListAssessmentTemplatesInput: Equatable {
    /// <p>A list of ARNs that specifies the assessment targets whose assessment templates you
    ///          want to list.</p>
    public let assessmentTargetArns: [String]?
    /// <p>You can use this parameter to specify a subset of data to be included in the action's
    ///          response.</p>
    ///          <p>For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.</p>
    public let filter: AssessmentTemplateFilter?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>ListAssessmentTemplates</b>
    ///          action. Subsequent calls to the action fill <b>nextToken</b> in
    ///          the request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?

    public init (
        assessmentTargetArns: [String]? = nil,
        filter: AssessmentTemplateFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentTargetArns = assessmentTargetArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssessmentTemplatesInputBody: Equatable {
    public let assessmentTargetArns: [String]?
    public let filter: AssessmentTemplateFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListAssessmentTemplatesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArns
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentTargetArns)
        var assessmentTargetArnsDecoded0:[String]? = nil
        if let assessmentTargetArnsContainer = assessmentTargetArnsContainer {
            assessmentTargetArnsDecoded0 = [String]()
            for string0 in assessmentTargetArnsContainer {
                if let string0 = string0 {
                    assessmentTargetArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTargetArns = assessmentTargetArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(AssessmentTemplateFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAssessmentTemplatesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAssessmentTemplatesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAssessmentTemplatesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAssessmentTemplatesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAssessmentTemplatesOutputResponse(assessmentTemplateArns: \(String(describing: assessmentTemplateArns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListAssessmentTemplatesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAssessmentTemplatesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentTemplateArns = output.assessmentTemplateArns
            self.nextToken = output.nextToken
        } else {
            self.assessmentTemplateArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssessmentTemplatesOutputResponse: Equatable {
    /// <p>A list of ARNs that specifies the assessment templates returned by the
    ///          action.</p>
    public let assessmentTemplateArns: [String]?
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?

    public init (
        assessmentTemplateArns: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentTemplateArns = assessmentTemplateArns
        self.nextToken = nextToken
    }
}

struct ListAssessmentTemplatesOutputResponseBody: Equatable {
    public let assessmentTemplateArns: [String]?
    public let nextToken: String?
}

extension ListAssessmentTemplatesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTemplateArns
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentTemplateArns)
        var assessmentTemplateArnsDecoded0:[String]? = nil
        if let assessmentTemplateArnsContainer = assessmentTemplateArnsContainer {
            assessmentTemplateArnsDecoded0 = [String]()
            for string0 in assessmentTemplateArnsContainer {
                if let string0 = string0 {
                    assessmentTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentTemplateArns = assessmentTemplateArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListEventSubscriptionsInputBodyMiddleware: Middleware {
    public let id: String = "ListEventSubscriptionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSubscriptionsOutputError>
}

extension ListEventSubscriptionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventSubscriptionsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), resourceArn: \(String(describing: resourceArn)))"}
}

extension ListEventSubscriptionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListEventSubscriptionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventSubscriptionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSubscriptionsOutputError>
}

public struct ListEventSubscriptionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventSubscriptionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSubscriptionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSubscriptionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSubscriptionsInput>
    public typealias MOutput = OperationOutput<ListEventSubscriptionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSubscriptionsOutputError>
}

public struct ListEventSubscriptionsInput: Equatable {
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>ListEventSubscriptions</b>
    ///          action. Subsequent calls to the action fill <b>nextToken</b> in
    ///          the request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?
    /// <p>The ARN of the assessment template for which you want to list the existing event
    ///          subscriptions.</p>
    public let resourceArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        resourceArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListEventSubscriptionsInputBody: Equatable {
    public let resourceArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListEventSubscriptionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEventSubscriptionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSubscriptionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventSubscriptionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSubscriptionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventSubscriptionsOutputResponse(nextToken: \(String(describing: nextToken)), subscriptions: \(String(describing: subscriptions)))"}
}

extension ListEventSubscriptionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventSubscriptionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.subscriptions = output.subscriptions
        } else {
            self.nextToken = nil
            self.subscriptions = nil
        }
    }
}

public struct ListEventSubscriptionsOutputResponse: Equatable {
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?
    /// <p>Details of the returned event subscriptions.</p>
    public let subscriptions: [Subscription]?

    public init (
        nextToken: String? = nil,
        subscriptions: [Subscription]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptions = subscriptions
    }
}

struct ListEventSubscriptionsOutputResponseBody: Equatable {
    public let subscriptions: [Subscription]?
    public let nextToken: String?
}

extension ListEventSubscriptionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case subscriptions
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListExclusionsInputBodyMiddleware: Middleware {
    public let id: String = "ListExclusionsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExclusionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExclusionsInput>
    public typealias MOutput = OperationOutput<ListExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExclusionsOutputError>
}

extension ListExclusionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExclusionsInput(assessmentRunArn: \(String(describing: assessmentRunArn)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExclusionsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListExclusionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListExclusionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExclusionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExclusionsInput>
    public typealias MOutput = OperationOutput<ListExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExclusionsOutputError>
}

public struct ListExclusionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListExclusionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListExclusionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListExclusionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListExclusionsInput>
    public typealias MOutput = OperationOutput<ListExclusionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListExclusionsOutputError>
}

public struct ListExclusionsInput: Equatable {
    /// <p>The ARN of the assessment run that generated the exclusions that you want to
    ///          list.</p>
    public let assessmentRunArn: String?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 100. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the ListExclusionsRequest action. Subsequent calls to the
    ///          action fill nextToken in the request with the value of nextToken from the previous response
    ///          to continue listing data.</p>
    public let nextToken: String?

    public init (
        assessmentRunArn: String? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListExclusionsInputBody: Equatable {
    public let assessmentRunArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListExclusionsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListExclusionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListExclusionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListExclusionsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListExclusionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListExclusionsOutputResponse(exclusionArns: \(String(describing: exclusionArns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListExclusionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListExclusionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.exclusionArns = output.exclusionArns
            self.nextToken = output.nextToken
        } else {
            self.exclusionArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListExclusionsOutputResponse: Equatable {
    /// <p>A list of exclusions' ARNs returned by the action.</p>
    public let exclusionArns: [String]?
    /// <p>When a response is generated, if there is more data to be listed, this parameters is
    ///          present in the response and contains the value to use for the nextToken parameter in a
    ///          subsequent pagination request. If there is no more data to be listed, this parameter is set
    ///          to null.</p>
    public let nextToken: String?

    public init (
        exclusionArns: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.exclusionArns = exclusionArns
        self.nextToken = nextToken
    }
}

struct ListExclusionsOutputResponseBody: Equatable {
    public let exclusionArns: [String]?
    public let nextToken: String?
}

extension ListExclusionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case exclusionArns
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exclusionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .exclusionArns)
        var exclusionArnsDecoded0:[String]? = nil
        if let exclusionArnsContainer = exclusionArnsContainer {
            exclusionArnsDecoded0 = [String]()
            for string0 in exclusionArnsContainer {
                if let string0 = string0 {
                    exclusionArnsDecoded0?.append(string0)
                }
            }
        }
        exclusionArns = exclusionArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListFindingsInputBodyMiddleware: Middleware {
    public let id: String = "ListFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

extension ListFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsInput(assessmentRunArns: \(String(describing: assessmentRunArns)), filter: \(String(describing: filter)), maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArns
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArns = assessmentRunArns {
            var assessmentRunArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentRunArns)
            for listparentarnlist0 in assessmentRunArns {
                try assessmentRunArnsContainer.encode(listparentarnlist0)
            }
        }
        if let filter = filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

public struct ListFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFindingsInput>
    public typealias MOutput = OperationOutput<ListFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFindingsOutputError>
}

public struct ListFindingsInput: Equatable {
    /// <p>The ARNs of the assessment runs that generate the findings that you want to
    ///          list.</p>
    public let assessmentRunArns: [String]?
    /// <p>You can use this parameter to specify a subset of data to be included in the action's
    ///          response.</p>
    ///          <p>For a record to match a filter, all specified filter attributes must match. When
    ///          multiple values are specified for a filter attribute, any of the values can
    ///          match.</p>
    public let filter: FindingFilter?
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>ListFindings</b> action.
    ///          Subsequent calls to the action fill <b>nextToken</b> in the
    ///          request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?

    public init (
        assessmentRunArns: [String]? = nil,
        filter: FindingFilter? = nil,
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.assessmentRunArns = assessmentRunArns
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFindingsInputBody: Equatable {
    public let assessmentRunArns: [String]?
    public let filter: FindingFilter?
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArns
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .assessmentRunArns)
        var assessmentRunArnsDecoded0:[String]? = nil
        if let assessmentRunArnsContainer = assessmentRunArnsContainer {
            assessmentRunArnsDecoded0 = [String]()
            for string0 in assessmentRunArnsContainer {
                if let string0 = string0 {
                    assessmentRunArnsDecoded0?.append(string0)
                }
            }
        }
        assessmentRunArns = assessmentRunArnsDecoded0
        let filterDecoded = try containerValues.decodeIfPresent(FindingFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFindingsOutputResponse(findingArns: \(String(describing: findingArns)), nextToken: \(String(describing: nextToken)))"}
}

extension ListFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.findingArns = output.findingArns
            self.nextToken = output.nextToken
        } else {
            self.findingArns = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutputResponse: Equatable {
    /// <p>A list of ARNs that specifies the findings returned by the action.</p>
    public let findingArns: [String]?
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?

    public init (
        findingArns: [String]? = nil,
        nextToken: String? = nil
    )
    {
        self.findingArns = findingArns
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Equatable {
    public let findingArns: [String]?
    public let nextToken: String?
}

extension ListFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case findingArns
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListRulesPackagesInputBodyMiddleware: Middleware {
    public let id: String = "ListRulesPackagesInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesPackagesInput>
    public typealias MOutput = OperationOutput<ListRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesPackagesOutputError>
}

extension ListRulesPackagesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRulesPackagesInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)))"}
}

extension ListRulesPackagesInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

public struct ListRulesPackagesInputHeadersMiddleware: Middleware {
    public let id: String = "ListRulesPackagesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesPackagesInput>
    public typealias MOutput = OperationOutput<ListRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesPackagesOutputError>
}

public struct ListRulesPackagesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListRulesPackagesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListRulesPackagesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListRulesPackagesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListRulesPackagesInput>
    public typealias MOutput = OperationOutput<ListRulesPackagesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListRulesPackagesOutputError>
}

public struct ListRulesPackagesInput: Equatable {
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>ListRulesPackages</b>
    ///          action. Subsequent calls to the action fill <b>nextToken</b> in
    ///          the request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRulesPackagesInputBody: Equatable {
    public let nextToken: String?
    public let maxResults: Int?
}

extension ListRulesPackagesInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRulesPackagesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRulesPackagesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListRulesPackagesOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRulesPackagesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListRulesPackagesOutputResponse(nextToken: \(String(describing: nextToken)), rulesPackageArns: \(String(describing: rulesPackageArns)))"}
}

extension ListRulesPackagesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListRulesPackagesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextToken = output.nextToken
            self.rulesPackageArns = output.rulesPackageArns
        } else {
            self.nextToken = nil
            self.rulesPackageArns = nil
        }
    }
}

public struct ListRulesPackagesOutputResponse: Equatable {
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?
    /// <p>The list of ARNs that specifies the rules packages returned by the action.</p>
    public let rulesPackageArns: [String]?

    public init (
        nextToken: String? = nil,
        rulesPackageArns: [String]? = nil
    )
    {
        self.nextToken = nextToken
        self.rulesPackageArns = rulesPackageArns
    }
}

struct ListRulesPackagesOutputResponseBody: Equatable {
    public let rulesPackageArns: [String]?
    public let nextToken: String?
}

extension ListRulesPackagesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextToken
        case rulesPackageArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                if let string0 = string0 {
                    rulesPackageArnsDecoded0?.append(string0)
                }
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

public struct ListTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

extension ListTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceInput(resourceArn: \(String(describing: resourceArn)))"}
}

extension ListTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

public struct ListTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsForResourceInput>
    public typealias MOutput = OperationOutput<ListTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsForResourceOutputError>
}

public struct ListTagsForResourceInput: Equatable {
    /// <p>The ARN that specifies the assessment template whose tags you want to list.</p>
    public let resourceArn: String?

    public init (
        resourceArn: String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
}

extension ListTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsForResourceOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Equatable {
    /// <p>A collection of key and value pairs.</p>
    public let tags: [Tag]?

    public init (
        tags: [Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Equatable {
    public let tags: [Tag]?
}

extension ListTagsForResourceOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

public enum Locale {
    case enUs
    case sdkUnknown(String)
}

extension Locale : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Locale] {
        return [
            .enUs,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enUs: return "EN_US"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Locale(rawValue: rawValue) ?? Locale.sdkUnknown(rawValue)
    }
}

extension NetworkInterface: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case ipv6Addresses
        case networkInterfaceId
        case privateDnsName
        case privateIpAddress
        case privateIpAddresses
        case publicDnsName
        case publicIp
        case securityGroups
        case subnetId
        case vpcId
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for ipv6addresses0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(ipv6addresses0)
            }
        }
        if let networkInterfaceId = networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for privateipaddresses0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(privateipaddresses0)
            }
        }
        if let publicDnsName = publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroups0 in securityGroups {
                try securityGroupsContainer.encode(securitygroups0)
            }
        }
        if let subnetId = subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([PrivateIp?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[PrivateIp]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [PrivateIp]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[String]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [String]()
            for string0 in ipv6AddressesContainer {
                if let string0 = string0 {
                    ipv6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let securityGroupsContainer = try containerValues.decodeIfPresent([SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension NetworkInterface: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NetworkInterface(ipv6Addresses: \(String(describing: ipv6Addresses)), networkInterfaceId: \(String(describing: networkInterfaceId)), privateDnsName: \(String(describing: privateDnsName)), privateIpAddress: \(String(describing: privateIpAddress)), privateIpAddresses: \(String(describing: privateIpAddresses)), publicDnsName: \(String(describing: publicDnsName)), publicIp: \(String(describing: publicIp)), securityGroups: \(String(describing: securityGroups)), subnetId: \(String(describing: subnetId)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>Contains information about the network interfaces interacting with an EC2 instance.
///          This data type is used as one of the elements of the <a>AssetAttributes</a> data
///          type.</p>
public struct NetworkInterface: Equatable {
    /// <p>The IP addresses associated with the network interface.</p>
    public let ipv6Addresses: [String]?
    /// <p>The ID of the network interface.</p>
    public let networkInterfaceId: String?
    /// <p>The name of a private DNS associated with the network interface.</p>
    public let privateDnsName: String?
    /// <p>The private IP address associated with the network interface.</p>
    public let privateIpAddress: String?
    /// <p>A list of the private IP addresses associated with the network interface. Includes
    ///          the privateDnsName and privateIpAddress.</p>
    public let privateIpAddresses: [PrivateIp]?
    /// <p>The name of a public DNS associated with the network interface.</p>
    public let publicDnsName: String?
    /// <p>The public IP address from which the network interface is reachable.</p>
    public let publicIp: String?
    /// <p>A list of the security groups associated with the network interface. Includes the
    ///          groupId and groupName.</p>
    public let securityGroups: [SecurityGroup]?
    /// <p>The ID of a subnet associated with the network interface.</p>
    public let subnetId: String?
    /// <p>The ID of a VPC associated with the network interface.</p>
    public let vpcId: String?

    public init (
        ipv6Addresses: [String]? = nil,
        networkInterfaceId: String? = nil,
        privateDnsName: String? = nil,
        privateIpAddress: String? = nil,
        privateIpAddresses: [PrivateIp]? = nil,
        publicDnsName: String? = nil,
        publicIp: String? = nil,
        securityGroups: [SecurityGroup]? = nil,
        subnetId: String? = nil,
        vpcId: String? = nil
    )
    {
        self.ipv6Addresses = ipv6Addresses
        self.networkInterfaceId = networkInterfaceId
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
        self.privateIpAddresses = privateIpAddresses
        self.publicDnsName = publicDnsName
        self.publicIp = publicIp
        self.securityGroups = securityGroups
        self.subnetId = subnetId
        self.vpcId = vpcId
    }
}

public enum NoSuchEntityErrorCode {
    case assessmentRunDoesNotExist
    case assessmentTargetDoesNotExist
    case assessmentTemplateDoesNotExist
    case findingDoesNotExist
    case iamRoleDoesNotExist
    case resourceGroupDoesNotExist
    case rulesPackageDoesNotExist
    case snsTopicDoesNotExist
    case sdkUnknown(String)
}

extension NoSuchEntityErrorCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [NoSuchEntityErrorCode] {
        return [
            .assessmentRunDoesNotExist,
            .assessmentTargetDoesNotExist,
            .assessmentTemplateDoesNotExist,
            .findingDoesNotExist,
            .iamRoleDoesNotExist,
            .resourceGroupDoesNotExist,
            .rulesPackageDoesNotExist,
            .snsTopicDoesNotExist,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .assessmentRunDoesNotExist: return "ASSESSMENT_RUN_DOES_NOT_EXIST"
        case .assessmentTargetDoesNotExist: return "ASSESSMENT_TARGET_DOES_NOT_EXIST"
        case .assessmentTemplateDoesNotExist: return "ASSESSMENT_TEMPLATE_DOES_NOT_EXIST"
        case .findingDoesNotExist: return "FINDING_DOES_NOT_EXIST"
        case .iamRoleDoesNotExist: return "IAM_ROLE_DOES_NOT_EXIST"
        case .resourceGroupDoesNotExist: return "RESOURCE_GROUP_DOES_NOT_EXIST"
        case .rulesPackageDoesNotExist: return "RULES_PACKAGE_DOES_NOT_EXIST"
        case .snsTopicDoesNotExist: return "SNS_TOPIC_DOES_NOT_EXIST"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = NoSuchEntityErrorCode(rawValue: rawValue) ?? NoSuchEntityErrorCode.sdkUnknown(rawValue)
    }
}

extension NoSuchEntityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "NoSuchEntityException(canRetry: \(String(describing: canRetry)), errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

extension NoSuchEntityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: NoSuchEntityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.errorCode = output.errorCode
            self.message = output.message
        } else {
            self.canRetry = nil
            self.errorCode = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request was rejected because it referenced an entity that does not exist. The
///          error code describes the entity.</p>
public struct NoSuchEntityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>You can immediately retry your request.</p>
    public var canRetry: Bool?
    /// <p>Code that indicates the type of error that is generated.</p>
    public var errorCode: NoSuchEntityErrorCode?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        errorCode: NoSuchEntityErrorCode? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.errorCode = errorCode
        self.message = message
    }
}

struct NoSuchEntityExceptionBody: Equatable {
    public let message: String?
    public let errorCode: NoSuchEntityErrorCode?
    public let canRetry: Bool?
}

extension NoSuchEntityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case errorCode
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(NoSuchEntityErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct PreviewAgentsInputBodyMiddleware: Middleware {
    public let id: String = "PreviewAgentsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PreviewAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<PreviewAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PreviewAgentsInput>
    public typealias MOutput = OperationOutput<PreviewAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PreviewAgentsOutputError>
}

extension PreviewAgentsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreviewAgentsInput(maxResults: \(String(describing: maxResults)), nextToken: \(String(describing: nextToken)), previewAgentsArn: \(String(describing: previewAgentsArn)))"}
}

extension PreviewAgentsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case previewAgentsArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let previewAgentsArn = previewAgentsArn {
            try encodeContainer.encode(previewAgentsArn, forKey: .previewAgentsArn)
        }
    }
}

public struct PreviewAgentsInputHeadersMiddleware: Middleware {
    public let id: String = "PreviewAgentsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PreviewAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<PreviewAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PreviewAgentsInput>
    public typealias MOutput = OperationOutput<PreviewAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PreviewAgentsOutputError>
}

public struct PreviewAgentsInputQueryItemMiddleware: Middleware {
    public let id: String = "PreviewAgentsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PreviewAgentsInput>,
                  next: H) -> Swift.Result<OperationOutput<PreviewAgentsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PreviewAgentsInput>
    public typealias MOutput = OperationOutput<PreviewAgentsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PreviewAgentsOutputError>
}

public struct PreviewAgentsInput: Equatable {
    /// <p>You can use this parameter to indicate the maximum number of items you want in the
    ///          response. The default value is 10. The maximum value is 500.</p>
    public let maxResults: Int?
    /// <p>You can use this parameter when paginating results. Set the value of this parameter
    ///          to null on your first call to the <b>PreviewAgents</b> action.
    ///          Subsequent calls to the action fill <b>nextToken</b> in the
    ///          request with the value of <b>NextToken</b> from the previous
    ///          response to continue listing data.</p>
    public let nextToken: String?
    /// <p>The ARN of the assessment target whose agents you want to preview.</p>
    public let previewAgentsArn: String?

    public init (
        maxResults: Int? = nil,
        nextToken: String? = nil,
        previewAgentsArn: String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.previewAgentsArn = previewAgentsArn
    }
}

struct PreviewAgentsInputBody: Equatable {
    public let previewAgentsArn: String?
    public let nextToken: String?
    public let maxResults: Int?
}

extension PreviewAgentsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case maxResults
        case nextToken
        case previewAgentsArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let previewAgentsArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .previewAgentsArn)
        previewAgentsArn = previewAgentsArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension PreviewAgentsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PreviewAgentsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PreviewAgentsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PreviewAgentsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreviewAgentsOutputResponse(agentPreviews: \(String(describing: agentPreviews)), nextToken: \(String(describing: nextToken)))"}
}

extension PreviewAgentsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PreviewAgentsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.agentPreviews = output.agentPreviews
            self.nextToken = output.nextToken
        } else {
            self.agentPreviews = nil
            self.nextToken = nil
        }
    }
}

public struct PreviewAgentsOutputResponse: Equatable {
    /// <p>The resulting list of agents.</p>
    public let agentPreviews: [AgentPreview]?
    /// <p> When a response is generated, if there is more data to be listed, this parameter is
    ///          present in the response and contains the value to use for the <b>nextToken</b> parameter in a subsequent pagination request. If there is no more
    ///          data to be listed, this parameter is set to null.</p>
    public let nextToken: String?

    public init (
        agentPreviews: [AgentPreview]? = nil,
        nextToken: String? = nil
    )
    {
        self.agentPreviews = agentPreviews
        self.nextToken = nextToken
    }
}

struct PreviewAgentsOutputResponseBody: Equatable {
    public let agentPreviews: [AgentPreview]?
    public let nextToken: String?
}

extension PreviewAgentsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case agentPreviews
        case nextToken
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let agentPreviewsContainer = try containerValues.decodeIfPresent([AgentPreview?].self, forKey: .agentPreviews)
        var agentPreviewsDecoded0:[AgentPreview]? = nil
        if let agentPreviewsContainer = agentPreviewsContainer {
            agentPreviewsDecoded0 = [AgentPreview]()
            for structure0 in agentPreviewsContainer {
                if let structure0 = structure0 {
                    agentPreviewsDecoded0?.append(structure0)
                }
            }
        }
        agentPreviews = agentPreviewsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension PreviewGenerationInProgressException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreviewGenerationInProgressException(message: \(String(describing: message)))"}
}

extension PreviewGenerationInProgressException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PreviewGenerationInProgressExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request is rejected. The specified assessment template is currently generating an
///          exclusions preview.</p>
public struct PreviewGenerationInProgressException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?

    public init (
        message: String? = nil
    )
    {
        self.message = message
    }
}

struct PreviewGenerationInProgressExceptionBody: Equatable {
    public let message: String?
}

extension PreviewGenerationInProgressExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum PreviewStatus {
    case completed
    case workInProgress
    case sdkUnknown(String)
}

extension PreviewStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PreviewStatus] {
        return [
            .completed,
            .workInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .workInProgress: return "WORK_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PreviewStatus(rawValue: rawValue) ?? PreviewStatus.sdkUnknown(rawValue)
    }
}

extension PrivateIp: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case privateDnsName
        case privateIpAddress
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension PrivateIp: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PrivateIp(privateDnsName: \(String(describing: privateDnsName)), privateIpAddress: \(String(describing: privateIpAddress)))"}
}

/// <p>Contains information about a private IP address associated with a network interface. This
///          data type is used as a response element in the <a>DescribeFindings</a>
///          action.</p>
public struct PrivateIp: Equatable {
    /// <p>The DNS name of the private IP address.</p>
    public let privateDnsName: String?
    /// <p>The full IP address of the network inteface.</p>
    public let privateIpAddress: String?

    public init (
        privateDnsName: String? = nil,
        privateIpAddress: String? = nil
    )
    {
        self.privateDnsName = privateDnsName
        self.privateIpAddress = privateIpAddress
    }
}

public struct RegisterCrossAccountAccessRoleInputBodyMiddleware: Middleware {
    public let id: String = "RegisterCrossAccountAccessRoleInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCrossAccountAccessRoleInput>
    public typealias MOutput = OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCrossAccountAccessRoleOutputError>
}

extension RegisterCrossAccountAccessRoleInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCrossAccountAccessRoleInput(roleArn: \(String(describing: roleArn)))"}
}

extension RegisterCrossAccountAccessRoleInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case roleArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

public struct RegisterCrossAccountAccessRoleInputHeadersMiddleware: Middleware {
    public let id: String = "RegisterCrossAccountAccessRoleInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCrossAccountAccessRoleInput>
    public typealias MOutput = OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCrossAccountAccessRoleOutputError>
}

public struct RegisterCrossAccountAccessRoleInputQueryItemMiddleware: Middleware {
    public let id: String = "RegisterCrossAccountAccessRoleInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RegisterCrossAccountAccessRoleInput>,
                  next: H) -> Swift.Result<OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RegisterCrossAccountAccessRoleInput>
    public typealias MOutput = OperationOutput<RegisterCrossAccountAccessRoleOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RegisterCrossAccountAccessRoleOutputError>
}

public struct RegisterCrossAccountAccessRoleInput: Equatable {
    /// <p>The ARN of the IAM role that grants Amazon Inspector access to AWS Services needed to
    ///          perform security assessments. </p>
    public let roleArn: String?

    public init (
        roleArn: String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct RegisterCrossAccountAccessRoleInputBody: Equatable {
    public let roleArn: String?
}

extension RegisterCrossAccountAccessRoleInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case roleArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension RegisterCrossAccountAccessRoleOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterCrossAccountAccessRoleOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RegisterCrossAccountAccessRoleOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterCrossAccountAccessRoleOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RegisterCrossAccountAccessRoleOutputResponse()"}
}

extension RegisterCrossAccountAccessRoleOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RegisterCrossAccountAccessRoleOutputResponse: Equatable {

    public init() {}
}

struct RegisterCrossAccountAccessRoleOutputResponseBody: Equatable {
}

extension RegisterCrossAccountAccessRoleOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct RemoveAttributesFromFindingsInputBodyMiddleware: Middleware {
    public let id: String = "RemoveAttributesFromFindingsInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAttributesFromFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAttributesFromFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAttributesFromFindingsInput>
    public typealias MOutput = OperationOutput<RemoveAttributesFromFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAttributesFromFindingsOutputError>
}

extension RemoveAttributesFromFindingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAttributesFromFindingsInput(attributeKeys: \(String(describing: attributeKeys)), findingArns: \(String(describing: findingArns)))"}
}

extension RemoveAttributesFromFindingsInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case attributeKeys
        case findingArns
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeKeys = attributeKeys {
            var attributeKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributeKeys)
            for userattributekeylist0 in attributeKeys {
                try attributeKeysContainer.encode(userattributekeylist0)
            }
        }
        if let findingArns = findingArns {
            var findingArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingArns)
            for addremoveattributesfindingarnlist0 in findingArns {
                try findingArnsContainer.encode(addremoveattributesfindingarnlist0)
            }
        }
    }
}

public struct RemoveAttributesFromFindingsInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveAttributesFromFindingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAttributesFromFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAttributesFromFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAttributesFromFindingsInput>
    public typealias MOutput = OperationOutput<RemoveAttributesFromFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAttributesFromFindingsOutputError>
}

public struct RemoveAttributesFromFindingsInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveAttributesFromFindingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveAttributesFromFindingsInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveAttributesFromFindingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveAttributesFromFindingsInput>
    public typealias MOutput = OperationOutput<RemoveAttributesFromFindingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveAttributesFromFindingsOutputError>
}

public struct RemoveAttributesFromFindingsInput: Equatable {
    /// <p>The array of attribute keys that you want to remove from specified
    ///          findings.</p>
    public let attributeKeys: [String]?
    /// <p>The ARNs that specify the findings that you want to remove attributes from.</p>
    public let findingArns: [String]?

    public init (
        attributeKeys: [String]? = nil,
        findingArns: [String]? = nil
    )
    {
        self.attributeKeys = attributeKeys
        self.findingArns = findingArns
    }
}

struct RemoveAttributesFromFindingsInputBody: Equatable {
    public let findingArns: [String]?
    public let attributeKeys: [String]?
}

extension RemoveAttributesFromFindingsInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case attributeKeys
        case findingArns
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .findingArns)
        var findingArnsDecoded0:[String]? = nil
        if let findingArnsContainer = findingArnsContainer {
            findingArnsDecoded0 = [String]()
            for string0 in findingArnsContainer {
                if let string0 = string0 {
                    findingArnsDecoded0?.append(string0)
                }
            }
        }
        findingArns = findingArnsDecoded0
        let attributeKeysContainer = try containerValues.decodeIfPresent([String?].self, forKey: .attributeKeys)
        var attributeKeysDecoded0:[String]? = nil
        if let attributeKeysContainer = attributeKeysContainer {
            attributeKeysDecoded0 = [String]()
            for string0 in attributeKeysContainer {
                if let string0 = string0 {
                    attributeKeysDecoded0?.append(string0)
                }
            }
        }
        attributeKeys = attributeKeysDecoded0
    }
}

extension RemoveAttributesFromFindingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveAttributesFromFindingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveAttributesFromFindingsOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveAttributesFromFindingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveAttributesFromFindingsOutputResponse(failedItems: \(String(describing: failedItems)))"}
}

extension RemoveAttributesFromFindingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RemoveAttributesFromFindingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.failedItems = output.failedItems
        } else {
            self.failedItems = nil
        }
    }
}

public struct RemoveAttributesFromFindingsOutputResponse: Equatable {
    /// <p>Attributes details that cannot be described. An error code is provided for each
    ///          failed item.</p>
    public let failedItems: [String:FailedItemDetails]?

    public init (
        failedItems: [String:FailedItemDetails]? = nil
    )
    {
        self.failedItems = failedItems
    }
}

struct RemoveAttributesFromFindingsOutputResponseBody: Equatable {
    public let failedItems: [String:FailedItemDetails]?
}

extension RemoveAttributesFromFindingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case failedItems
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failedItemsContainer = try containerValues.decodeIfPresent([String: FailedItemDetails?].self, forKey: .failedItems)
        var failedItemsDecoded0: [String:FailedItemDetails]? = nil
        if let failedItemsContainer = failedItemsContainer {
            failedItemsDecoded0 = [String:FailedItemDetails]()
            for (key0, faileditemdetails0) in failedItemsContainer {
                if let faileditemdetails0 = faileditemdetails0 {
                    failedItemsDecoded0?[key0] = faileditemdetails0
                }
            }
        }
        failedItems = failedItemsDecoded0
    }
}

public enum ReportFileFormat {
    case html
    case pdf
    case sdkUnknown(String)
}

extension ReportFileFormat : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportFileFormat] {
        return [
            .html,
            .pdf,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .html: return "HTML"
        case .pdf: return "PDF"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportFileFormat(rawValue: rawValue) ?? ReportFileFormat.sdkUnknown(rawValue)
    }
}

public enum ReportStatus {
    case completed
    case failed
    case workInProgress
    case sdkUnknown(String)
}

extension ReportStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportStatus] {
        return [
            .completed,
            .failed,
            .workInProgress,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .completed: return "COMPLETED"
        case .failed: return "FAILED"
        case .workInProgress: return "WORK_IN_PROGRESS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportStatus(rawValue: rawValue) ?? ReportStatus.sdkUnknown(rawValue)
    }
}

public enum ReportType {
    case finding
    case full
    case sdkUnknown(String)
}

extension ReportType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ReportType] {
        return [
            .finding,
            .full,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .finding: return "FINDING"
        case .full: return "FULL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ReportType(rawValue: rawValue) ?? ReportType.sdkUnknown(rawValue)
    }
}

extension ResourceGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case createdAt
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for resourcegrouptags0 in tags {
                try tagsContainer.encode(resourcegrouptags0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ResourceGroupTag?].self, forKey: .tags)
        var tagsDecoded0:[ResourceGroupTag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ResourceGroupTag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension ResourceGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceGroup(arn: \(String(describing: arn)), createdAt: \(String(describing: createdAt)), tags: \(String(describing: tags)))"}
}

/// <p>Contains information about a resource group. The resource group defines a set of tags
///          that, when queried, identify the AWS resources that make up the assessment target. This
///          data type is used as the response element in the <a>DescribeResourceGroups</a>
///          action.</p>
public struct ResourceGroup: Equatable {
    /// <p>The ARN of the resource group.</p>
    public let arn: String?
    /// <p>The time at which resource group is created.</p>
    public let createdAt: Date?
    /// <p>The tags (key and value pairs) of the resource group. This data type property is used
    ///          in the <a>CreateResourceGroup</a> action.</p>
    public let tags: [ResourceGroupTag]?

    public init (
        arn: String? = nil,
        createdAt: Date? = nil,
        tags: [ResourceGroupTag]? = nil
    )
    {
        self.arn = arn
        self.createdAt = createdAt
        self.tags = tags
    }
}

extension ResourceGroupTag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ResourceGroupTag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceGroupTag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>This data type is used as one of the elements of the <a>ResourceGroup</a>
///          data type.</p>
public struct ResourceGroupTag: Equatable {
    /// <p>A tag key.</p>
    public let key: String?
    /// <p>The value assigned to a tag key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension RulesPackage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case description
        case name
        case provider
        case version
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let provider = provider {
            try encodeContainer.encode(provider, forKey: .provider)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let providerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .provider)
        provider = providerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension RulesPackage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RulesPackage(arn: \(String(describing: arn)), description: \(String(describing: description)), name: \(String(describing: name)), provider: \(String(describing: provider)), version: \(String(describing: version)))"}
}

/// <p>Contains information about an Amazon Inspector rules package. This data type is used
///          as the response element in the <a>DescribeRulesPackages</a> action.</p>
public struct RulesPackage: Equatable {
    /// <p>The ARN of the rules package.</p>
    public let arn: String?
    /// <p>The description of the rules package.</p>
    public let description: String?
    /// <p>The name of the rules package.</p>
    public let name: String?
    /// <p>The provider of the rules package.</p>
    public let provider: String?
    /// <p>The version ID of the rules package.</p>
    public let version: String?

    public init (
        arn: String? = nil,
        description: String? = nil,
        name: String? = nil,
        provider: String? = nil,
        version: String? = nil
    )
    {
        self.arn = arn
        self.description = description
        self.name = name
        self.provider = provider
        self.version = version
    }
}

extension Scope: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key.rawValue, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(ScopeType.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Scope: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Scope(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>This data type contains key-value pairs that identify various Amazon
///          resources.</p>
public struct Scope: Equatable {
    /// <p>The type of the scope.</p>
    public let key: ScopeType?
    /// <p>The resource identifier for the specified scope type.</p>
    public let value: String?

    public init (
        key: ScopeType? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

public enum ScopeType {
    case instanceId
    case rulesPackageArn
    case sdkUnknown(String)
}

extension ScopeType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ScopeType] {
        return [
            .instanceId,
            .rulesPackageArn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .instanceId: return "INSTANCE_ID"
        case .rulesPackageArn: return "RULES_PACKAGE_ARN"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ScopeType(rawValue: rawValue) ?? ScopeType.sdkUnknown(rawValue)
    }
}

extension SecurityGroup: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case groupId
        case groupName
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

extension SecurityGroup: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SecurityGroup(groupId: \(String(describing: groupId)), groupName: \(String(describing: groupName)))"}
}

/// <p>Contains information about a security group associated with a network interface. This
///          data type is used as one of the elements of the <a>NetworkInterface</a> data
///          type.</p>
public struct SecurityGroup: Equatable {
    /// <p>The ID of the security group.</p>
    public let groupId: String?
    /// <p>The name of the security group.</p>
    public let groupName: String?

    public init (
        groupId: String? = nil,
        groupName: String? = nil
    )
    {
        self.groupId = groupId
        self.groupName = groupName
    }
}

extension ServiceTemporarilyUnavailableException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceTemporarilyUnavailableException(canRetry: \(String(describing: canRetry)), message: \(String(describing: message)))"}
}

extension ServiceTemporarilyUnavailableException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceTemporarilyUnavailableExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The serice is temporary unavailable.</p>
public struct ServiceTemporarilyUnavailableException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>You can wait and then retry your request.</p>
    public var canRetry: Bool?
    /// <p>Details of the exception error.</p>
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.message = message
    }
}

struct ServiceTemporarilyUnavailableExceptionBody: Equatable {
    public let message: String?
    public let canRetry: Bool?
}

extension ServiceTemporarilyUnavailableExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct SetTagsForResourceInputBodyMiddleware: Middleware {
    public let id: String = "SetTagsForResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTagsForResourceInput>
    public typealias MOutput = OperationOutput<SetTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTagsForResourceOutputError>
}

extension SetTagsForResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTagsForResourceInput(resourceArn: \(String(describing: resourceArn)), tags: \(String(describing: tags)))"}
}

extension SetTagsForResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for taglist0 in tags {
                try tagsContainer.encode(taglist0)
            }
        }
    }
}

public struct SetTagsForResourceInputHeadersMiddleware: Middleware {
    public let id: String = "SetTagsForResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTagsForResourceInput>
    public typealias MOutput = OperationOutput<SetTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTagsForResourceOutputError>
}

public struct SetTagsForResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "SetTagsForResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SetTagsForResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<SetTagsForResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SetTagsForResourceInput>
    public typealias MOutput = OperationOutput<SetTagsForResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SetTagsForResourceOutputError>
}

public struct SetTagsForResourceInput: Equatable {
    /// <p>The ARN of the assessment template that you want to set tags to.</p>
    public let resourceArn: String?
    /// <p>A collection of key and value pairs that you want to set to the assessment
    ///          template.</p>
    public let tags: [Tag]?

    public init (
        resourceArn: String? = nil,
        tags: [Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct SetTagsForResourceInputBody: Equatable {
    public let resourceArn: String?
    public let tags: [Tag]?
}

extension SetTagsForResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Tag?].self, forKey: .tags)
        var tagsDecoded0:[Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SetTagsForResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SetTagsForResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SetTagsForResourceOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SetTagsForResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SetTagsForResourceOutputResponse()"}
}

extension SetTagsForResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SetTagsForResourceOutputResponse: Equatable {

    public init() {}
}

struct SetTagsForResourceOutputResponseBody: Equatable {
}

extension SetTagsForResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum Severity {
    case high
    case informational
    case low
    case medium
    case undefined
    case sdkUnknown(String)
}

extension Severity : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Severity] {
        return [
            .high,
            .informational,
            .low,
            .medium,
            .undefined,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .high: return "High"
        case .informational: return "Informational"
        case .low: return "Low"
        case .medium: return "Medium"
        case .undefined: return "Undefined"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
    }
}

public struct StartAssessmentRunInputBodyMiddleware: Middleware {
    public let id: String = "StartAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAssessmentRunInput>
    public typealias MOutput = OperationOutput<StartAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAssessmentRunOutputError>
}

extension StartAssessmentRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAssessmentRunInput(assessmentRunName: \(String(describing: assessmentRunName)), assessmentTemplateArn: \(String(describing: assessmentTemplateArn)))"}
}

extension StartAssessmentRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunName
        case assessmentTemplateArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunName = assessmentRunName {
            try encodeContainer.encode(assessmentRunName, forKey: .assessmentRunName)
        }
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
    }
}

public struct StartAssessmentRunInputHeadersMiddleware: Middleware {
    public let id: String = "StartAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAssessmentRunInput>
    public typealias MOutput = OperationOutput<StartAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAssessmentRunOutputError>
}

public struct StartAssessmentRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StartAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StartAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StartAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StartAssessmentRunInput>
    public typealias MOutput = OperationOutput<StartAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StartAssessmentRunOutputError>
}

public struct StartAssessmentRunInput: Equatable {
    /// <p>You can specify the name for the assessment run. The name must be unique for the
    ///          assessment template whose ARN is used to start the assessment run.</p>
    public let assessmentRunName: String?
    /// <p>The ARN of the assessment template of the assessment run that you want to
    ///          start.</p>
    public let assessmentTemplateArn: String?

    public init (
        assessmentRunName: String? = nil,
        assessmentTemplateArn: String? = nil
    )
    {
        self.assessmentRunName = assessmentRunName
        self.assessmentTemplateArn = assessmentTemplateArn
    }
}

struct StartAssessmentRunInputBody: Equatable {
    public let assessmentTemplateArn: String?
    public let assessmentRunName: String?
}

extension StartAssessmentRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunName
        case assessmentTemplateArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let assessmentRunNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunName)
        assessmentRunName = assessmentRunNameDecoded
    }
}

extension StartAssessmentRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAssessmentRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AgentsAlreadyRunningAssessmentException" : self = .agentsAlreadyRunningAssessmentException(try AgentsAlreadyRunningAssessmentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCrossAccountRoleException" : self = .invalidCrossAccountRoleException(try InvalidCrossAccountRoleException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StartAssessmentRunOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case agentsAlreadyRunningAssessmentException(AgentsAlreadyRunningAssessmentException)
    case internalException(InternalException)
    case invalidCrossAccountRoleException(InvalidCrossAccountRoleException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAssessmentRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StartAssessmentRunOutputResponse(assessmentRunArn: \(String(describing: assessmentRunArn)))"}
}

extension StartAssessmentRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: StartAssessmentRunOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.assessmentRunArn = output.assessmentRunArn
        } else {
            self.assessmentRunArn = nil
        }
    }
}

public struct StartAssessmentRunOutputResponse: Equatable {
    /// <p>The ARN of the assessment run that has been started.</p>
    public let assessmentRunArn: String?

    public init (
        assessmentRunArn: String? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
    }
}

struct StartAssessmentRunOutputResponseBody: Equatable {
    public let assessmentRunArn: String?
}

extension StartAssessmentRunOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
    }
}

public enum StopAction {
    case skipEvaluation
    case startEvaluation
    case sdkUnknown(String)
}

extension StopAction : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StopAction] {
        return [
            .skipEvaluation,
            .startEvaluation,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .skipEvaluation: return "SKIP_EVALUATION"
        case .startEvaluation: return "START_EVALUATION"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StopAction(rawValue: rawValue) ?? StopAction.sdkUnknown(rawValue)
    }
}

public struct StopAssessmentRunInputBodyMiddleware: Middleware {
    public let id: String = "StopAssessmentRunInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAssessmentRunInput>
    public typealias MOutput = OperationOutput<StopAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAssessmentRunOutputError>
}

extension StopAssessmentRunInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAssessmentRunInput(assessmentRunArn: \(String(describing: assessmentRunArn)), stopAction: \(String(describing: stopAction)))"}
}

extension StopAssessmentRunInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case stopAction
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentRunArn = assessmentRunArn {
            try encodeContainer.encode(assessmentRunArn, forKey: .assessmentRunArn)
        }
        if let stopAction = stopAction {
            try encodeContainer.encode(stopAction.rawValue, forKey: .stopAction)
        }
    }
}

public struct StopAssessmentRunInputHeadersMiddleware: Middleware {
    public let id: String = "StopAssessmentRunInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAssessmentRunInput>
    public typealias MOutput = OperationOutput<StopAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAssessmentRunOutputError>
}

public struct StopAssessmentRunInputQueryItemMiddleware: Middleware {
    public let id: String = "StopAssessmentRunInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<StopAssessmentRunInput>,
                  next: H) -> Swift.Result<OperationOutput<StopAssessmentRunOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<StopAssessmentRunInput>
    public typealias MOutput = OperationOutput<StopAssessmentRunOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<StopAssessmentRunOutputError>
}

public struct StopAssessmentRunInput: Equatable {
    /// <p>The ARN of the assessment run that you want to stop.</p>
    public let assessmentRunArn: String?
    /// <p>An input option that can be set to either START_EVALUATION or SKIP_EVALUATION.
    ///          START_EVALUATION (the default value), stops the AWS agent from collecting data and begins
    ///          the results evaluation and the findings generation process. SKIP_EVALUATION cancels the
    ///          assessment run immediately, after which no findings are generated.</p>
    public let stopAction: StopAction?

    public init (
        assessmentRunArn: String? = nil,
        stopAction: StopAction? = nil
    )
    {
        self.assessmentRunArn = assessmentRunArn
        self.stopAction = stopAction
    }
}

struct StopAssessmentRunInputBody: Equatable {
    public let assessmentRunArn: String?
    public let stopAction: StopAction?
}

extension StopAssessmentRunInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentRunArn
        case stopAction
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentRunArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentRunArn)
        assessmentRunArn = assessmentRunArnDecoded
        let stopActionDecoded = try containerValues.decodeIfPresent(StopAction.self, forKey: .stopAction)
        stopAction = stopActionDecoded
    }
}

extension StopAssessmentRunOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopAssessmentRunOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum StopAssessmentRunOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopAssessmentRunOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "StopAssessmentRunOutputResponse()"}
}

extension StopAssessmentRunOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct StopAssessmentRunOutputResponse: Equatable {

    public init() {}
}

struct StopAssessmentRunOutputResponseBody: Equatable {
}

extension StopAssessmentRunOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct SubscribeToEventInputBodyMiddleware: Middleware {
    public let id: String = "SubscribeToEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToEventInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToEventInput>
    public typealias MOutput = OperationOutput<SubscribeToEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToEventOutputError>
}

extension SubscribeToEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeToEventInput(event: \(String(describing: event)), resourceArn: \(String(describing: resourceArn)), topicArn: \(String(describing: topicArn)))"}
}

extension SubscribeToEventInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }
}

public struct SubscribeToEventInputHeadersMiddleware: Middleware {
    public let id: String = "SubscribeToEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToEventInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToEventInput>
    public typealias MOutput = OperationOutput<SubscribeToEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToEventOutputError>
}

public struct SubscribeToEventInputQueryItemMiddleware: Middleware {
    public let id: String = "SubscribeToEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<SubscribeToEventInput>,
                  next: H) -> Swift.Result<OperationOutput<SubscribeToEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<SubscribeToEventInput>
    public typealias MOutput = OperationOutput<SubscribeToEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<SubscribeToEventOutputError>
}

public struct SubscribeToEventInput: Equatable {
    /// <p>The event for which you want to receive SNS notifications.</p>
    public let event: InspectorEvent?
    /// <p>The ARN of the assessment template that is used during the event for which you want
    ///          to receive SNS notifications.</p>
    public let resourceArn: String?
    /// <p>The ARN of the SNS topic to which the SNS notifications are sent.</p>
    public let topicArn: String?

    public init (
        event: InspectorEvent? = nil,
        resourceArn: String? = nil,
        topicArn: String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

struct SubscribeToEventInputBody: Equatable {
    public let resourceArn: String?
    public let event: InspectorEvent?
    public let topicArn: String?
}

extension SubscribeToEventInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension SubscribeToEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SubscribeToEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum SubscribeToEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case limitExceededException(LimitExceededException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SubscribeToEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubscribeToEventOutputResponse()"}
}

extension SubscribeToEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct SubscribeToEventOutputResponse: Equatable {

    public init() {}
}

struct SubscribeToEventOutputResponseBody: Equatable {
}

extension SubscribeToEventOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension Subscription: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case eventSubscriptions
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventSubscriptions = eventSubscriptions {
            var eventSubscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventSubscriptions)
            for eventsubscriptionlist0 in eventSubscriptions {
                try eventSubscriptionsContainer.encode(eventsubscriptionlist0)
            }
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
        let eventSubscriptionsContainer = try containerValues.decodeIfPresent([EventSubscription?].self, forKey: .eventSubscriptions)
        var eventSubscriptionsDecoded0:[EventSubscription]? = nil
        if let eventSubscriptionsContainer = eventSubscriptionsContainer {
            eventSubscriptionsDecoded0 = [EventSubscription]()
            for structure0 in eventSubscriptionsContainer {
                if let structure0 = structure0 {
                    eventSubscriptionsDecoded0?.append(structure0)
                }
            }
        }
        eventSubscriptions = eventSubscriptionsDecoded0
    }
}

extension Subscription: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Subscription(eventSubscriptions: \(String(describing: eventSubscriptions)), resourceArn: \(String(describing: resourceArn)), topicArn: \(String(describing: topicArn)))"}
}

/// <p>This data type is used as a response element in the <a>ListEventSubscriptions</a> action.</p>
public struct Subscription: Equatable {
    /// <p>The list of existing event subscriptions.</p>
    public let eventSubscriptions: [EventSubscription]?
    /// <p>The ARN of the assessment template that is used during the event for which the SNS
    ///          notification is sent.</p>
    public let resourceArn: String?
    /// <p>The ARN of the Amazon Simple Notification Service (SNS) topic to which the SNS
    ///          notifications are sent.</p>
    public let topicArn: String?

    public init (
        eventSubscriptions: [EventSubscription]? = nil,
        resourceArn: String? = nil,
        topicArn: String? = nil
    )
    {
        self.eventSubscriptions = eventSubscriptions
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

extension Tag: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Tag: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Tag(key: \(String(describing: key)), value: \(String(describing: value)))"}
}

/// <p>A key and value pair. This data type is used as a request parameter in the <a>SetTagsForResource</a> action and a response element in the <a>ListTagsForResource</a> action.</p>
public struct Tag: Equatable {
    /// <p>A tag key.</p>
    public let key: String?
    /// <p>A value assigned to a tag key.</p>
    public let value: String?

    public init (
        key: String? = nil,
        value: String? = nil
    )
    {
        self.key = key
        self.value = value
    }
}

extension TelemetryMetadata: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case count
        case dataSize
        case messageType
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let dataSize = dataSize {
            try encodeContainer.encode(dataSize, forKey: .dataSize)
        }
        if let messageType = messageType {
            try encodeContainer.encode(messageType, forKey: .messageType)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .messageType)
        messageType = messageTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .count)
        count = countDecoded
        let dataSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .dataSize)
        dataSize = dataSizeDecoded
    }
}

extension TelemetryMetadata: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TelemetryMetadata(count: \(String(describing: count)), dataSize: \(String(describing: dataSize)), messageType: \(String(describing: messageType)))"}
}

/// <p>The metadata about the Amazon Inspector application data metrics collected by the
///          agent. This data type is used as the response element in the <a>GetTelemetryMetadata</a> action.</p>
public struct TelemetryMetadata: Equatable {
    /// <p>The count of messages that the agent sends to the Amazon Inspector service.</p>
    public let count: Int?
    /// <p>The data size of messages that the agent sends to the Amazon Inspector
    ///          service.</p>
    public let dataSize: Int?
    /// <p>A specific type of behavioral data that is collected by the agent.</p>
    public let messageType: String?

    public init (
        count: Int? = nil,
        dataSize: Int? = nil,
        messageType: String? = nil
    )
    {
        self.count = count
        self.dataSize = dataSize
        self.messageType = messageType
    }
}

extension TimestampRange: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case beginDate
        case endDate
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let beginDate = beginDate {
            try encodeContainer.encode(beginDate.timeIntervalSince1970, forKey: .beginDate)
        }
        if let endDate = endDate {
            try encodeContainer.encode(endDate.timeIntervalSince1970, forKey: .endDate)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let beginDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .beginDate)
        beginDate = beginDateDecoded
        let endDateDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .endDate)
        endDate = endDateDecoded
    }
}

extension TimestampRange: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TimestampRange(beginDate: \(String(describing: beginDate)), endDate: \(String(describing: endDate)))"}
}

/// <p>This data type is used in the <a>AssessmentRunFilter</a> data
///          type.</p>
public struct TimestampRange: Equatable {
    /// <p>The minimum value of the timestamp range.</p>
    public let beginDate: Date?
    /// <p>The maximum value of the timestamp range.</p>
    public let endDate: Date?

    public init (
        beginDate: Date? = nil,
        endDate: Date? = nil
    )
    {
        self.beginDate = beginDate
        self.endDate = endDate
    }
}

public struct UnsubscribeFromEventInputBodyMiddleware: Middleware {
    public let id: String = "UnsubscribeFromEventInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeFromEventInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeFromEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeFromEventInput>
    public typealias MOutput = OperationOutput<UnsubscribeFromEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeFromEventOutputError>
}

extension UnsubscribeFromEventInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeFromEventInput(event: \(String(describing: event)), resourceArn: \(String(describing: resourceArn)), topicArn: \(String(describing: topicArn)))"}
}

extension UnsubscribeFromEventInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let resourceArn = resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let topicArn = topicArn {
            try encodeContainer.encode(topicArn, forKey: .topicArn)
        }
    }
}

public struct UnsubscribeFromEventInputHeadersMiddleware: Middleware {
    public let id: String = "UnsubscribeFromEventInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeFromEventInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeFromEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeFromEventInput>
    public typealias MOutput = OperationOutput<UnsubscribeFromEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeFromEventOutputError>
}

public struct UnsubscribeFromEventInputQueryItemMiddleware: Middleware {
    public let id: String = "UnsubscribeFromEventInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UnsubscribeFromEventInput>,
                  next: H) -> Swift.Result<OperationOutput<UnsubscribeFromEventOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UnsubscribeFromEventInput>
    public typealias MOutput = OperationOutput<UnsubscribeFromEventOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UnsubscribeFromEventOutputError>
}

public struct UnsubscribeFromEventInput: Equatable {
    /// <p>The event for which you want to stop receiving SNS notifications.</p>
    public let event: InspectorEvent?
    /// <p>The ARN of the assessment template that is used during the event for which you want
    ///          to stop receiving SNS notifications.</p>
    public let resourceArn: String?
    /// <p>The ARN of the SNS topic to which SNS notifications are sent.</p>
    public let topicArn: String?

    public init (
        event: InspectorEvent? = nil,
        resourceArn: String? = nil,
        topicArn: String? = nil
    )
    {
        self.event = event
        self.resourceArn = resourceArn
        self.topicArn = topicArn
    }
}

struct UnsubscribeFromEventInputBody: Equatable {
    public let resourceArn: String?
    public let event: InspectorEvent?
    public let topicArn: String?
}

extension UnsubscribeFromEventInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case event
        case resourceArn
        case topicArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let eventDecoded = try containerValues.decodeIfPresent(InspectorEvent.self, forKey: .event)
        event = eventDecoded
        let topicArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .topicArn)
        topicArn = topicArnDecoded
    }
}

extension UnsubscribeFromEventOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnsubscribeFromEventOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UnsubscribeFromEventOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnsubscribeFromEventOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsubscribeFromEventOutputResponse()"}
}

extension UnsubscribeFromEventOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UnsubscribeFromEventOutputResponse: Equatable {

    public init() {}
}

struct UnsubscribeFromEventOutputResponseBody: Equatable {
}

extension UnsubscribeFromEventOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UnsupportedFeatureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedFeatureException(canRetry: \(String(describing: canRetry)), message: \(String(describing: message)))"}
}

extension UnsupportedFeatureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedFeatureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.canRetry = output.canRetry
            self.message = output.message
        } else {
            self.canRetry = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Used by the <a>GetAssessmentReport</a> API. The request was rejected
///          because you tried to generate a report for an assessment run that existed before reporting
///          was supported in Amazon Inspector. You can only generate reports for assessment runs that
///          took place or will take place after generating reports in Amazon Inspector became
///          available.</p>
public struct UnsupportedFeatureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var canRetry: Bool?
    public var message: String?

    public init (
        canRetry: Bool? = nil,
        message: String? = nil
    )
    {
        self.canRetry = canRetry
        self.message = message
    }
}

struct UnsupportedFeatureExceptionBody: Equatable {
    public let message: String?
    public let canRetry: Bool?
}

extension UnsupportedFeatureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case canRetry
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let canRetryDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .canRetry)
        canRetry = canRetryDecoded
    }
}

public struct UpdateAssessmentTargetInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAssessmentTargetInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentTargetInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentTargetOutputError>
}

extension UpdateAssessmentTargetInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentTargetInput(assessmentTargetArn: \(String(describing: assessmentTargetArn)), assessmentTargetName: \(String(describing: assessmentTargetName)), resourceGroupArn: \(String(describing: resourceGroupArn)))"}
}

extension UpdateAssessmentTargetInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArn
        case assessmentTargetName
        case resourceGroupArn
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargetArn = assessmentTargetArn {
            try encodeContainer.encode(assessmentTargetArn, forKey: .assessmentTargetArn)
        }
        if let assessmentTargetName = assessmentTargetName {
            try encodeContainer.encode(assessmentTargetName, forKey: .assessmentTargetName)
        }
        if let resourceGroupArn = resourceGroupArn {
            try encodeContainer.encode(resourceGroupArn, forKey: .resourceGroupArn)
        }
    }
}

public struct UpdateAssessmentTargetInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAssessmentTargetInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentTargetInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentTargetOutputError>
}

public struct UpdateAssessmentTargetInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAssessmentTargetInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAssessmentTargetInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAssessmentTargetOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAssessmentTargetInput>
    public typealias MOutput = OperationOutput<UpdateAssessmentTargetOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAssessmentTargetOutputError>
}

public struct UpdateAssessmentTargetInput: Equatable {
    /// <p>The ARN of the assessment target that you want to update.</p>
    public let assessmentTargetArn: String?
    /// <p>The name of the assessment target that you want to update.</p>
    public let assessmentTargetName: String?
    /// <p>The ARN of the resource group that is used to specify the new resource group to
    ///          associate with the assessment target.</p>
    public let resourceGroupArn: String?

    public init (
        assessmentTargetArn: String? = nil,
        assessmentTargetName: String? = nil,
        resourceGroupArn: String? = nil
    )
    {
        self.assessmentTargetArn = assessmentTargetArn
        self.assessmentTargetName = assessmentTargetName
        self.resourceGroupArn = resourceGroupArn
    }
}

struct UpdateAssessmentTargetInputBody: Equatable {
    public let assessmentTargetArn: String?
    public let assessmentTargetName: String?
    public let resourceGroupArn: String?
}

extension UpdateAssessmentTargetInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case assessmentTargetArn
        case assessmentTargetName
        case resourceGroupArn
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentTargetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetArn)
        assessmentTargetArn = assessmentTargetArnDecoded
        let assessmentTargetNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTargetName)
        assessmentTargetName = assessmentTargetNameDecoded
        let resourceGroupArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resourceGroupArn)
        resourceGroupArn = resourceGroupArnDecoded
    }
}

extension UpdateAssessmentTargetOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAssessmentTargetOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalException" : self = .internalException(try InternalException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidInputException" : self = .invalidInputException(try InvalidInputException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoSuchEntityException" : self = .noSuchEntityException(try NoSuchEntityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceTemporarilyUnavailableException" : self = .serviceTemporarilyUnavailableException(try ServiceTemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAssessmentTargetOutputError: Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalException(InternalException)
    case invalidInputException(InvalidInputException)
    case noSuchEntityException(NoSuchEntityException)
    case serviceTemporarilyUnavailableException(ServiceTemporarilyUnavailableException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAssessmentTargetOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAssessmentTargetOutputResponse()"}
}

extension UpdateAssessmentTargetOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UpdateAssessmentTargetOutputResponse: Equatable {

    public init() {}
}

struct UpdateAssessmentTargetOutputResponseBody: Equatable {
}

extension UpdateAssessmentTargetOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}
