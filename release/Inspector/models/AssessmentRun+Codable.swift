// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AssessmentRun: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn
        case assessmentTemplateArn
        case completedAt
        case createdAt
        case dataCollected
        case durationInSeconds
        case findingCounts
        case name
        case notifications
        case rulesPackageArns
        case startedAt
        case state
        case stateChangedAt
        case stateChanges
        case userAttributesForFindings
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assessmentTemplateArn = assessmentTemplateArn {
            try encodeContainer.encode(assessmentTemplateArn, forKey: .assessmentTemplateArn)
        }
        if let completedAt = completedAt {
            try encodeContainer.encode(completedAt.timeIntervalSince1970, forKey: .completedAt)
        }
        if let createdAt = createdAt {
            try encodeContainer.encode(createdAt.timeIntervalSince1970, forKey: .createdAt)
        }
        if let dataCollected = dataCollected {
            try encodeContainer.encode(dataCollected, forKey: .dataCollected)
        }
        if durationInSeconds != 0 {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let findingCounts = findingCounts {
            var findingCountsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .findingCounts)
            for (dictKey0, assessmentrunfindingcounts0) in findingCounts {
                try findingCountsContainer.encode(assessmentrunfindingcounts0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for assessmentrunnotificationlist0 in notifications {
                try notificationsContainer.encode(assessmentrunnotificationlist0)
            }
        }
        if let rulesPackageArns = rulesPackageArns {
            var rulesPackageArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rulesPackageArns)
            for assessmentrulespackagearnlist0 in rulesPackageArns {
                try rulesPackageArnsContainer.encode(assessmentrulespackagearnlist0)
            }
        }
        if let startedAt = startedAt {
            try encodeContainer.encode(startedAt.timeIntervalSince1970, forKey: .startedAt)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateChangedAt = stateChangedAt {
            try encodeContainer.encode(stateChangedAt.timeIntervalSince1970, forKey: .stateChangedAt)
        }
        if let stateChanges = stateChanges {
            var stateChangesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stateChanges)
            for assessmentrunstatechangelist0 in stateChanges {
                try stateChangesContainer.encode(assessmentrunstatechangelist0)
            }
        }
        if let userAttributesForFindings = userAttributesForFindings {
            var userAttributesForFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .userAttributesForFindings)
            for userattributelist0 in userAttributesForFindings {
                try userAttributesForFindingsContainer.encode(userattributelist0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let assessmentTemplateArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .assessmentTemplateArn)
        assessmentTemplateArn = assessmentTemplateArnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(AssessmentRunState.self, forKey: .state)
        state = stateDecoded
        let durationInSecondsDecoded = try containerValues.decode(Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
        let rulesPackageArnsContainer = try containerValues.decodeIfPresent([String].self, forKey: .rulesPackageArns)
        var rulesPackageArnsDecoded0:[String]? = nil
        if let rulesPackageArnsContainer = rulesPackageArnsContainer {
            rulesPackageArnsDecoded0 = [String]()
            for string0 in rulesPackageArnsContainer {
                rulesPackageArnsDecoded0?.append(string0)
            }
        }
        rulesPackageArns = rulesPackageArnsDecoded0
        let userAttributesForFindingsContainer = try containerValues.decodeIfPresent([Attribute].self, forKey: .userAttributesForFindings)
        var userAttributesForFindingsDecoded0:[Attribute]? = nil
        if let userAttributesForFindingsContainer = userAttributesForFindingsContainer {
            userAttributesForFindingsDecoded0 = [Attribute]()
            for structure0 in userAttributesForFindingsContainer {
                userAttributesForFindingsDecoded0?.append(structure0)
            }
        }
        userAttributesForFindings = userAttributesForFindingsDecoded0
        let createdAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startedAt)
        startedAt = startedAtDecoded
        let completedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .completedAt)
        completedAt = completedAtDecoded
        let stateChangedAtDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .stateChangedAt)
        stateChangedAt = stateChangedAtDecoded
        let dataCollectedDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .dataCollected)
        dataCollected = dataCollectedDecoded
        let stateChangesContainer = try containerValues.decodeIfPresent([AssessmentRunStateChange].self, forKey: .stateChanges)
        var stateChangesDecoded0:[AssessmentRunStateChange]? = nil
        if let stateChangesContainer = stateChangesContainer {
            stateChangesDecoded0 = [AssessmentRunStateChange]()
            for structure0 in stateChangesContainer {
                stateChangesDecoded0?.append(structure0)
            }
        }
        stateChanges = stateChangesDecoded0
        let notificationsContainer = try containerValues.decodeIfPresent([AssessmentRunNotification].self, forKey: .notifications)
        var notificationsDecoded0:[AssessmentRunNotification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [AssessmentRunNotification]()
            for structure0 in notificationsContainer {
                notificationsDecoded0?.append(structure0)
            }
        }
        notifications = notificationsDecoded0
        let findingCountsContainer = try containerValues.decodeIfPresent([String:Int].self, forKey: .findingCounts)
        var findingCountsDecoded0: [String:Int]? = nil
        if let findingCountsContainer = findingCountsContainer {
            findingCountsDecoded0 = [String:Int]()
            for (key0, findingcount0) in findingCountsContainer {
                findingCountsDecoded0?[key0] = findingcount0
            }
        }
        findingCounts = findingCountsDecoded0
    }
}
