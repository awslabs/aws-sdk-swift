// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AudioCodecSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aacSettings = "aacSettings"
        case ac3Settings = "ac3Settings"
        case aiffSettings = "aiffSettings"
        case codec = "codec"
        case eac3AtmosSettings = "eac3AtmosSettings"
        case eac3Settings = "eac3Settings"
        case mp2Settings = "mp2Settings"
        case mp3Settings = "mp3Settings"
        case opusSettings = "opusSettings"
        case vorbisSettings = "vorbisSettings"
        case wavSettings = "wavSettings"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aacSettings = aacSettings {
            try encodeContainer.encode(aacSettings, forKey: .aacSettings)
        }
        if let ac3Settings = ac3Settings {
            try encodeContainer.encode(ac3Settings, forKey: .ac3Settings)
        }
        if let aiffSettings = aiffSettings {
            try encodeContainer.encode(aiffSettings, forKey: .aiffSettings)
        }
        if let codec = codec {
            try encodeContainer.encode(codec.rawValue, forKey: .codec)
        }
        if let eac3AtmosSettings = eac3AtmosSettings {
            try encodeContainer.encode(eac3AtmosSettings, forKey: .eac3AtmosSettings)
        }
        if let eac3Settings = eac3Settings {
            try encodeContainer.encode(eac3Settings, forKey: .eac3Settings)
        }
        if let mp2Settings = mp2Settings {
            try encodeContainer.encode(mp2Settings, forKey: .mp2Settings)
        }
        if let mp3Settings = mp3Settings {
            try encodeContainer.encode(mp3Settings, forKey: .mp3Settings)
        }
        if let opusSettings = opusSettings {
            try encodeContainer.encode(opusSettings, forKey: .opusSettings)
        }
        if let vorbisSettings = vorbisSettings {
            try encodeContainer.encode(vorbisSettings, forKey: .vorbisSettings)
        }
        if let wavSettings = wavSettings {
            try encodeContainer.encode(wavSettings, forKey: .wavSettings)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aacSettingsDecoded = try containerValues.decodeIfPresent(AacSettings.self, forKey: .aacSettings)
        aacSettings = aacSettingsDecoded
        let ac3SettingsDecoded = try containerValues.decodeIfPresent(Ac3Settings.self, forKey: .ac3Settings)
        ac3Settings = ac3SettingsDecoded
        let aiffSettingsDecoded = try containerValues.decodeIfPresent(AiffSettings.self, forKey: .aiffSettings)
        aiffSettings = aiffSettingsDecoded
        let codecDecoded = try containerValues.decodeIfPresent(AudioCodec.self, forKey: .codec)
        codec = codecDecoded
        let eac3AtmosSettingsDecoded = try containerValues.decodeIfPresent(Eac3AtmosSettings.self, forKey: .eac3AtmosSettings)
        eac3AtmosSettings = eac3AtmosSettingsDecoded
        let eac3SettingsDecoded = try containerValues.decodeIfPresent(Eac3Settings.self, forKey: .eac3Settings)
        eac3Settings = eac3SettingsDecoded
        let mp2SettingsDecoded = try containerValues.decodeIfPresent(Mp2Settings.self, forKey: .mp2Settings)
        mp2Settings = mp2SettingsDecoded
        let mp3SettingsDecoded = try containerValues.decodeIfPresent(Mp3Settings.self, forKey: .mp3Settings)
        mp3Settings = mp3SettingsDecoded
        let opusSettingsDecoded = try containerValues.decodeIfPresent(OpusSettings.self, forKey: .opusSettings)
        opusSettings = opusSettingsDecoded
        let vorbisSettingsDecoded = try containerValues.decodeIfPresent(VorbisSettings.self, forKey: .vorbisSettings)
        vorbisSettings = vorbisSettingsDecoded
        let wavSettingsDecoded = try containerValues.decodeIfPresent(WavSettings.self, forKey: .wavSettings)
        wavSettings = wavSettingsDecoded
    }
}
