// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension JobSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adAvailOffset = "adAvailOffset"
        case availBlanking = "availBlanking"
        case esam = "esam"
        case inputs = "inputs"
        case kantarWatermark = "kantarWatermark"
        case motionImageInserter = "motionImageInserter"
        case nielsenConfiguration = "nielsenConfiguration"
        case nielsenNonLinearWatermark = "nielsenNonLinearWatermark"
        case outputGroups = "outputGroups"
        case timecodeConfig = "timecodeConfig"
        case timedMetadataInsertion = "timedMetadataInsertion"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if adAvailOffset != 0 {
            try encodeContainer.encode(adAvailOffset, forKey: .adAvailOffset)
        }
        if let availBlanking = availBlanking {
            try encodeContainer.encode(availBlanking, forKey: .availBlanking)
        }
        if let esam = esam {
            try encodeContainer.encode(esam, forKey: .esam)
        }
        if let inputs = inputs {
            var inputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .inputs)
            for __listofinput0 in inputs {
                try inputsContainer.encode(__listofinput0)
            }
        }
        if let kantarWatermark = kantarWatermark {
            try encodeContainer.encode(kantarWatermark, forKey: .kantarWatermark)
        }
        if let motionImageInserter = motionImageInserter {
            try encodeContainer.encode(motionImageInserter, forKey: .motionImageInserter)
        }
        if let nielsenConfiguration = nielsenConfiguration {
            try encodeContainer.encode(nielsenConfiguration, forKey: .nielsenConfiguration)
        }
        if let nielsenNonLinearWatermark = nielsenNonLinearWatermark {
            try encodeContainer.encode(nielsenNonLinearWatermark, forKey: .nielsenNonLinearWatermark)
        }
        if let outputGroups = outputGroups {
            var outputGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputGroups)
            for __listofoutputgroup0 in outputGroups {
                try outputGroupsContainer.encode(__listofoutputgroup0)
            }
        }
        if let timecodeConfig = timecodeConfig {
            try encodeContainer.encode(timecodeConfig, forKey: .timecodeConfig)
        }
        if let timedMetadataInsertion = timedMetadataInsertion {
            try encodeContainer.encode(timedMetadataInsertion, forKey: .timedMetadataInsertion)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adAvailOffsetDecoded = try containerValues.decode(Int.self, forKey: .adAvailOffset)
        adAvailOffset = adAvailOffsetDecoded
        let availBlankingDecoded = try containerValues.decodeIfPresent(AvailBlanking.self, forKey: .availBlanking)
        availBlanking = availBlankingDecoded
        let esamDecoded = try containerValues.decodeIfPresent(EsamSettings.self, forKey: .esam)
        esam = esamDecoded
        let inputsContainer = try containerValues.decodeIfPresent([Input].self, forKey: .inputs)
        var inputsDecoded0:[Input]? = nil
        if let inputsContainer = inputsContainer {
            inputsDecoded0 = [Input]()
            for structure0 in inputsContainer {
                inputsDecoded0?.append(structure0)
            }
        }
        inputs = inputsDecoded0
        let kantarWatermarkDecoded = try containerValues.decodeIfPresent(KantarWatermarkSettings.self, forKey: .kantarWatermark)
        kantarWatermark = kantarWatermarkDecoded
        let motionImageInserterDecoded = try containerValues.decodeIfPresent(MotionImageInserter.self, forKey: .motionImageInserter)
        motionImageInserter = motionImageInserterDecoded
        let nielsenConfigurationDecoded = try containerValues.decodeIfPresent(NielsenConfiguration.self, forKey: .nielsenConfiguration)
        nielsenConfiguration = nielsenConfigurationDecoded
        let nielsenNonLinearWatermarkDecoded = try containerValues.decodeIfPresent(NielsenNonLinearWatermarkSettings.self, forKey: .nielsenNonLinearWatermark)
        nielsenNonLinearWatermark = nielsenNonLinearWatermarkDecoded
        let outputGroupsContainer = try containerValues.decodeIfPresent([OutputGroup].self, forKey: .outputGroups)
        var outputGroupsDecoded0:[OutputGroup]? = nil
        if let outputGroupsContainer = outputGroupsContainer {
            outputGroupsDecoded0 = [OutputGroup]()
            for structure0 in outputGroupsContainer {
                outputGroupsDecoded0?.append(structure0)
            }
        }
        outputGroups = outputGroupsDecoded0
        let timecodeConfigDecoded = try containerValues.decodeIfPresent(TimecodeConfig.self, forKey: .timecodeConfig)
        timecodeConfig = timecodeConfigDecoded
        let timedMetadataInsertionDecoded = try containerValues.decodeIfPresent(TimedMetadataInsertion.self, forKey: .timedMetadataInsertion)
        timedMetadataInsertion = timedMetadataInsertionDecoded
    }
}
