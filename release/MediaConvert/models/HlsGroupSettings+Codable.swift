// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension HlsGroupSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case adMarkers = "adMarkers"
        case additionalManifests = "additionalManifests"
        case audioOnlyHeader = "audioOnlyHeader"
        case baseUrl = "baseUrl"
        case captionLanguageMappings = "captionLanguageMappings"
        case captionLanguageSetting = "captionLanguageSetting"
        case clientCache = "clientCache"
        case codecSpecification = "codecSpecification"
        case destination = "destination"
        case destinationSettings = "destinationSettings"
        case directoryStructure = "directoryStructure"
        case encryption = "encryption"
        case manifestCompression = "manifestCompression"
        case manifestDurationFormat = "manifestDurationFormat"
        case minFinalSegmentLength = "minFinalSegmentLength"
        case minSegmentLength = "minSegmentLength"
        case outputSelection = "outputSelection"
        case programDateTime = "programDateTime"
        case programDateTimePeriod = "programDateTimePeriod"
        case segmentControl = "segmentControl"
        case segmentLength = "segmentLength"
        case segmentsPerSubdirectory = "segmentsPerSubdirectory"
        case streamInfResolution = "streamInfResolution"
        case timedMetadataId3Frame = "timedMetadataId3Frame"
        case timedMetadataId3Period = "timedMetadataId3Period"
        case timestampDeltaMilliseconds = "timestampDeltaMilliseconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adMarkers = adMarkers {
            var adMarkersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adMarkers)
            for __listofhlsadmarkers0 in adMarkers {
                try adMarkersContainer.encode(__listofhlsadmarkers0.rawValue)
            }
        }
        if let additionalManifests = additionalManifests {
            var additionalManifestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalManifests)
            for __listofhlsadditionalmanifest0 in additionalManifests {
                try additionalManifestsContainer.encode(__listofhlsadditionalmanifest0)
            }
        }
        if let audioOnlyHeader = audioOnlyHeader {
            try encodeContainer.encode(audioOnlyHeader.rawValue, forKey: .audioOnlyHeader)
        }
        if let baseUrl = baseUrl {
            try encodeContainer.encode(baseUrl, forKey: .baseUrl)
        }
        if let captionLanguageMappings = captionLanguageMappings {
            var captionLanguageMappingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .captionLanguageMappings)
            for __listofhlscaptionlanguagemapping0 in captionLanguageMappings {
                try captionLanguageMappingsContainer.encode(__listofhlscaptionlanguagemapping0)
            }
        }
        if let captionLanguageSetting = captionLanguageSetting {
            try encodeContainer.encode(captionLanguageSetting.rawValue, forKey: .captionLanguageSetting)
        }
        if let clientCache = clientCache {
            try encodeContainer.encode(clientCache.rawValue, forKey: .clientCache)
        }
        if let codecSpecification = codecSpecification {
            try encodeContainer.encode(codecSpecification.rawValue, forKey: .codecSpecification)
        }
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
        if let destinationSettings = destinationSettings {
            try encodeContainer.encode(destinationSettings, forKey: .destinationSettings)
        }
        if let directoryStructure = directoryStructure {
            try encodeContainer.encode(directoryStructure.rawValue, forKey: .directoryStructure)
        }
        if let encryption = encryption {
            try encodeContainer.encode(encryption, forKey: .encryption)
        }
        if let manifestCompression = manifestCompression {
            try encodeContainer.encode(manifestCompression.rawValue, forKey: .manifestCompression)
        }
        if let manifestDurationFormat = manifestDurationFormat {
            try encodeContainer.encode(manifestDurationFormat.rawValue, forKey: .manifestDurationFormat)
        }
        if minFinalSegmentLength != 0.0 {
            try encodeContainer.encode(minFinalSegmentLength, forKey: .minFinalSegmentLength)
        }
        if minSegmentLength != 0 {
            try encodeContainer.encode(minSegmentLength, forKey: .minSegmentLength)
        }
        if let outputSelection = outputSelection {
            try encodeContainer.encode(outputSelection.rawValue, forKey: .outputSelection)
        }
        if let programDateTime = programDateTime {
            try encodeContainer.encode(programDateTime.rawValue, forKey: .programDateTime)
        }
        if programDateTimePeriod != 0 {
            try encodeContainer.encode(programDateTimePeriod, forKey: .programDateTimePeriod)
        }
        if let segmentControl = segmentControl {
            try encodeContainer.encode(segmentControl.rawValue, forKey: .segmentControl)
        }
        if segmentLength != 0 {
            try encodeContainer.encode(segmentLength, forKey: .segmentLength)
        }
        if segmentsPerSubdirectory != 0 {
            try encodeContainer.encode(segmentsPerSubdirectory, forKey: .segmentsPerSubdirectory)
        }
        if let streamInfResolution = streamInfResolution {
            try encodeContainer.encode(streamInfResolution.rawValue, forKey: .streamInfResolution)
        }
        if let timedMetadataId3Frame = timedMetadataId3Frame {
            try encodeContainer.encode(timedMetadataId3Frame.rawValue, forKey: .timedMetadataId3Frame)
        }
        if timedMetadataId3Period != 0 {
            try encodeContainer.encode(timedMetadataId3Period, forKey: .timedMetadataId3Period)
        }
        if timestampDeltaMilliseconds != 0 {
            try encodeContainer.encode(timestampDeltaMilliseconds, forKey: .timestampDeltaMilliseconds)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adMarkersContainer = try containerValues.decodeIfPresent([HlsAdMarkers].self, forKey: .adMarkers)
        var adMarkersDecoded0:[HlsAdMarkers]? = nil
        if let adMarkersContainer = adMarkersContainer {
            adMarkersDecoded0 = [HlsAdMarkers]()
            for string0 in adMarkersContainer {
                adMarkersDecoded0?.append(string0)
            }
        }
        adMarkers = adMarkersDecoded0
        let additionalManifestsContainer = try containerValues.decodeIfPresent([HlsAdditionalManifest].self, forKey: .additionalManifests)
        var additionalManifestsDecoded0:[HlsAdditionalManifest]? = nil
        if let additionalManifestsContainer = additionalManifestsContainer {
            additionalManifestsDecoded0 = [HlsAdditionalManifest]()
            for structure0 in additionalManifestsContainer {
                additionalManifestsDecoded0?.append(structure0)
            }
        }
        additionalManifests = additionalManifestsDecoded0
        let audioOnlyHeaderDecoded = try containerValues.decodeIfPresent(HlsAudioOnlyHeader.self, forKey: .audioOnlyHeader)
        audioOnlyHeader = audioOnlyHeaderDecoded
        let baseUrlDecoded = try containerValues.decodeIfPresent(String.self, forKey: .baseUrl)
        baseUrl = baseUrlDecoded
        let captionLanguageMappingsContainer = try containerValues.decodeIfPresent([HlsCaptionLanguageMapping].self, forKey: .captionLanguageMappings)
        var captionLanguageMappingsDecoded0:[HlsCaptionLanguageMapping]? = nil
        if let captionLanguageMappingsContainer = captionLanguageMappingsContainer {
            captionLanguageMappingsDecoded0 = [HlsCaptionLanguageMapping]()
            for structure0 in captionLanguageMappingsContainer {
                captionLanguageMappingsDecoded0?.append(structure0)
            }
        }
        captionLanguageMappings = captionLanguageMappingsDecoded0
        let captionLanguageSettingDecoded = try containerValues.decodeIfPresent(HlsCaptionLanguageSetting.self, forKey: .captionLanguageSetting)
        captionLanguageSetting = captionLanguageSettingDecoded
        let clientCacheDecoded = try containerValues.decodeIfPresent(HlsClientCache.self, forKey: .clientCache)
        clientCache = clientCacheDecoded
        let codecSpecificationDecoded = try containerValues.decodeIfPresent(HlsCodecSpecification.self, forKey: .codecSpecification)
        codecSpecification = codecSpecificationDecoded
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
        let destinationSettingsDecoded = try containerValues.decodeIfPresent(DestinationSettings.self, forKey: .destinationSettings)
        destinationSettings = destinationSettingsDecoded
        let directoryStructureDecoded = try containerValues.decodeIfPresent(HlsDirectoryStructure.self, forKey: .directoryStructure)
        directoryStructure = directoryStructureDecoded
        let encryptionDecoded = try containerValues.decodeIfPresent(HlsEncryptionSettings.self, forKey: .encryption)
        encryption = encryptionDecoded
        let manifestCompressionDecoded = try containerValues.decodeIfPresent(HlsManifestCompression.self, forKey: .manifestCompression)
        manifestCompression = manifestCompressionDecoded
        let manifestDurationFormatDecoded = try containerValues.decodeIfPresent(HlsManifestDurationFormat.self, forKey: .manifestDurationFormat)
        manifestDurationFormat = manifestDurationFormatDecoded
        let minFinalSegmentLengthDecoded = try containerValues.decode(Double.self, forKey: .minFinalSegmentLength)
        minFinalSegmentLength = minFinalSegmentLengthDecoded
        let minSegmentLengthDecoded = try containerValues.decode(Int.self, forKey: .minSegmentLength)
        minSegmentLength = minSegmentLengthDecoded
        let outputSelectionDecoded = try containerValues.decodeIfPresent(HlsOutputSelection.self, forKey: .outputSelection)
        outputSelection = outputSelectionDecoded
        let programDateTimeDecoded = try containerValues.decodeIfPresent(HlsProgramDateTime.self, forKey: .programDateTime)
        programDateTime = programDateTimeDecoded
        let programDateTimePeriodDecoded = try containerValues.decode(Int.self, forKey: .programDateTimePeriod)
        programDateTimePeriod = programDateTimePeriodDecoded
        let segmentControlDecoded = try containerValues.decodeIfPresent(HlsSegmentControl.self, forKey: .segmentControl)
        segmentControl = segmentControlDecoded
        let segmentLengthDecoded = try containerValues.decode(Int.self, forKey: .segmentLength)
        segmentLength = segmentLengthDecoded
        let segmentsPerSubdirectoryDecoded = try containerValues.decode(Int.self, forKey: .segmentsPerSubdirectory)
        segmentsPerSubdirectory = segmentsPerSubdirectoryDecoded
        let streamInfResolutionDecoded = try containerValues.decodeIfPresent(HlsStreamInfResolution.self, forKey: .streamInfResolution)
        streamInfResolution = streamInfResolutionDecoded
        let timedMetadataId3FrameDecoded = try containerValues.decodeIfPresent(HlsTimedMetadataId3Frame.self, forKey: .timedMetadataId3Frame)
        timedMetadataId3Frame = timedMetadataId3FrameDecoded
        let timedMetadataId3PeriodDecoded = try containerValues.decode(Int.self, forKey: .timedMetadataId3Period)
        timedMetadataId3Period = timedMetadataId3PeriodDecoded
        let timestampDeltaMillisecondsDecoded = try containerValues.decode(Int.self, forKey: .timestampDeltaMilliseconds)
        timestampDeltaMilliseconds = timestampDeltaMillisecondsDecoded
    }
}
