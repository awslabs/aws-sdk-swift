// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension DvbSubDestinationSettings: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case alignment = "alignment"
        case backgroundColor = "backgroundColor"
        case backgroundOpacity = "backgroundOpacity"
        case ddsHandling = "ddsHandling"
        case ddsXCoordinate = "ddsXCoordinate"
        case ddsYCoordinate = "ddsYCoordinate"
        case fontColor = "fontColor"
        case fontOpacity = "fontOpacity"
        case fontResolution = "fontResolution"
        case fontScript = "fontScript"
        case fontSize = "fontSize"
        case height = "height"
        case outlineColor = "outlineColor"
        case outlineSize = "outlineSize"
        case shadowColor = "shadowColor"
        case shadowOpacity = "shadowOpacity"
        case shadowXOffset = "shadowXOffset"
        case shadowYOffset = "shadowYOffset"
        case subtitlingType = "subtitlingType"
        case teletextSpacing = "teletextSpacing"
        case width = "width"
        case xPosition = "xPosition"
        case yPosition = "yPosition"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alignment = alignment {
            try encodeContainer.encode(alignment.rawValue, forKey: .alignment)
        }
        if let backgroundColor = backgroundColor {
            try encodeContainer.encode(backgroundColor.rawValue, forKey: .backgroundColor)
        }
        if backgroundOpacity != 0 {
            try encodeContainer.encode(backgroundOpacity, forKey: .backgroundOpacity)
        }
        if let ddsHandling = ddsHandling {
            try encodeContainer.encode(ddsHandling.rawValue, forKey: .ddsHandling)
        }
        if ddsXCoordinate != 0 {
            try encodeContainer.encode(ddsXCoordinate, forKey: .ddsXCoordinate)
        }
        if ddsYCoordinate != 0 {
            try encodeContainer.encode(ddsYCoordinate, forKey: .ddsYCoordinate)
        }
        if let fontColor = fontColor {
            try encodeContainer.encode(fontColor.rawValue, forKey: .fontColor)
        }
        if fontOpacity != 0 {
            try encodeContainer.encode(fontOpacity, forKey: .fontOpacity)
        }
        if fontResolution != 0 {
            try encodeContainer.encode(fontResolution, forKey: .fontResolution)
        }
        if let fontScript = fontScript {
            try encodeContainer.encode(fontScript.rawValue, forKey: .fontScript)
        }
        if fontSize != 0 {
            try encodeContainer.encode(fontSize, forKey: .fontSize)
        }
        if height != 0 {
            try encodeContainer.encode(height, forKey: .height)
        }
        if let outlineColor = outlineColor {
            try encodeContainer.encode(outlineColor.rawValue, forKey: .outlineColor)
        }
        if outlineSize != 0 {
            try encodeContainer.encode(outlineSize, forKey: .outlineSize)
        }
        if let shadowColor = shadowColor {
            try encodeContainer.encode(shadowColor.rawValue, forKey: .shadowColor)
        }
        if shadowOpacity != 0 {
            try encodeContainer.encode(shadowOpacity, forKey: .shadowOpacity)
        }
        if shadowXOffset != 0 {
            try encodeContainer.encode(shadowXOffset, forKey: .shadowXOffset)
        }
        if shadowYOffset != 0 {
            try encodeContainer.encode(shadowYOffset, forKey: .shadowYOffset)
        }
        if let subtitlingType = subtitlingType {
            try encodeContainer.encode(subtitlingType.rawValue, forKey: .subtitlingType)
        }
        if let teletextSpacing = teletextSpacing {
            try encodeContainer.encode(teletextSpacing.rawValue, forKey: .teletextSpacing)
        }
        if width != 0 {
            try encodeContainer.encode(width, forKey: .width)
        }
        if xPosition != 0 {
            try encodeContainer.encode(xPosition, forKey: .xPosition)
        }
        if yPosition != 0 {
            try encodeContainer.encode(yPosition, forKey: .yPosition)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alignmentDecoded = try containerValues.decodeIfPresent(DvbSubtitleAlignment.self, forKey: .alignment)
        alignment = alignmentDecoded
        let backgroundColorDecoded = try containerValues.decodeIfPresent(DvbSubtitleBackgroundColor.self, forKey: .backgroundColor)
        backgroundColor = backgroundColorDecoded
        let backgroundOpacityDecoded = try containerValues.decode(Int.self, forKey: .backgroundOpacity)
        backgroundOpacity = backgroundOpacityDecoded
        let ddsHandlingDecoded = try containerValues.decodeIfPresent(DvbddsHandling.self, forKey: .ddsHandling)
        ddsHandling = ddsHandlingDecoded
        let ddsXCoordinateDecoded = try containerValues.decode(Int.self, forKey: .ddsXCoordinate)
        ddsXCoordinate = ddsXCoordinateDecoded
        let ddsYCoordinateDecoded = try containerValues.decode(Int.self, forKey: .ddsYCoordinate)
        ddsYCoordinate = ddsYCoordinateDecoded
        let fontColorDecoded = try containerValues.decodeIfPresent(DvbSubtitleFontColor.self, forKey: .fontColor)
        fontColor = fontColorDecoded
        let fontOpacityDecoded = try containerValues.decode(Int.self, forKey: .fontOpacity)
        fontOpacity = fontOpacityDecoded
        let fontResolutionDecoded = try containerValues.decode(Int.self, forKey: .fontResolution)
        fontResolution = fontResolutionDecoded
        let fontScriptDecoded = try containerValues.decodeIfPresent(FontScript.self, forKey: .fontScript)
        fontScript = fontScriptDecoded
        let fontSizeDecoded = try containerValues.decode(Int.self, forKey: .fontSize)
        fontSize = fontSizeDecoded
        let heightDecoded = try containerValues.decode(Int.self, forKey: .height)
        height = heightDecoded
        let outlineColorDecoded = try containerValues.decodeIfPresent(DvbSubtitleOutlineColor.self, forKey: .outlineColor)
        outlineColor = outlineColorDecoded
        let outlineSizeDecoded = try containerValues.decode(Int.self, forKey: .outlineSize)
        outlineSize = outlineSizeDecoded
        let shadowColorDecoded = try containerValues.decodeIfPresent(DvbSubtitleShadowColor.self, forKey: .shadowColor)
        shadowColor = shadowColorDecoded
        let shadowOpacityDecoded = try containerValues.decode(Int.self, forKey: .shadowOpacity)
        shadowOpacity = shadowOpacityDecoded
        let shadowXOffsetDecoded = try containerValues.decode(Int.self, forKey: .shadowXOffset)
        shadowXOffset = shadowXOffsetDecoded
        let shadowYOffsetDecoded = try containerValues.decode(Int.self, forKey: .shadowYOffset)
        shadowYOffset = shadowYOffsetDecoded
        let subtitlingTypeDecoded = try containerValues.decodeIfPresent(DvbSubtitlingType.self, forKey: .subtitlingType)
        subtitlingType = subtitlingTypeDecoded
        let teletextSpacingDecoded = try containerValues.decodeIfPresent(DvbSubtitleTeletextSpacing.self, forKey: .teletextSpacing)
        teletextSpacing = teletextSpacingDecoded
        let widthDecoded = try containerValues.decode(Int.self, forKey: .width)
        width = widthDecoded
        let xPositionDecoded = try containerValues.decode(Int.self, forKey: .xPosition)
        xPosition = xPositionDecoded
        let yPositionDecoded = try containerValues.decode(Int.self, forKey: .yPosition)
        yPosition = yPositionDecoded
    }
}
