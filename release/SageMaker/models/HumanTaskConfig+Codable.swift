// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension HumanTaskConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case annotationConsolidationConfig = "AnnotationConsolidationConfig"
        case maxConcurrentTaskCount = "MaxConcurrentTaskCount"
        case numberOfHumanWorkersPerDataObject = "NumberOfHumanWorkersPerDataObject"
        case preHumanTaskLambdaArn = "PreHumanTaskLambdaArn"
        case publicWorkforceTaskPrice = "PublicWorkforceTaskPrice"
        case taskAvailabilityLifetimeInSeconds = "TaskAvailabilityLifetimeInSeconds"
        case taskDescription = "TaskDescription"
        case taskKeywords = "TaskKeywords"
        case taskTimeLimitInSeconds = "TaskTimeLimitInSeconds"
        case taskTitle = "TaskTitle"
        case uiConfig = "UiConfig"
        case workteamArn = "WorkteamArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let annotationConsolidationConfig = annotationConsolidationConfig {
            try encodeContainer.encode(annotationConsolidationConfig, forKey: .annotationConsolidationConfig)
        }
        if let maxConcurrentTaskCount = maxConcurrentTaskCount {
            try encodeContainer.encode(maxConcurrentTaskCount, forKey: .maxConcurrentTaskCount)
        }
        if let numberOfHumanWorkersPerDataObject = numberOfHumanWorkersPerDataObject {
            try encodeContainer.encode(numberOfHumanWorkersPerDataObject, forKey: .numberOfHumanWorkersPerDataObject)
        }
        if let preHumanTaskLambdaArn = preHumanTaskLambdaArn {
            try encodeContainer.encode(preHumanTaskLambdaArn, forKey: .preHumanTaskLambdaArn)
        }
        if let publicWorkforceTaskPrice = publicWorkforceTaskPrice {
            try encodeContainer.encode(publicWorkforceTaskPrice, forKey: .publicWorkforceTaskPrice)
        }
        if let taskAvailabilityLifetimeInSeconds = taskAvailabilityLifetimeInSeconds {
            try encodeContainer.encode(taskAvailabilityLifetimeInSeconds, forKey: .taskAvailabilityLifetimeInSeconds)
        }
        if let taskDescription = taskDescription {
            try encodeContainer.encode(taskDescription, forKey: .taskDescription)
        }
        if let taskKeywords = taskKeywords {
            var taskKeywordsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .taskKeywords)
            for taskkeywords0 in taskKeywords {
                try taskKeywordsContainer.encode(taskkeywords0)
            }
        }
        if let taskTimeLimitInSeconds = taskTimeLimitInSeconds {
            try encodeContainer.encode(taskTimeLimitInSeconds, forKey: .taskTimeLimitInSeconds)
        }
        if let taskTitle = taskTitle {
            try encodeContainer.encode(taskTitle, forKey: .taskTitle)
        }
        if let uiConfig = uiConfig {
            try encodeContainer.encode(uiConfig, forKey: .uiConfig)
        }
        if let workteamArn = workteamArn {
            try encodeContainer.encode(workteamArn, forKey: .workteamArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workteamArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workteamArn)
        workteamArn = workteamArnDecoded
        let uiConfigDecoded = try containerValues.decodeIfPresent(UiConfig.self, forKey: .uiConfig)
        uiConfig = uiConfigDecoded
        let preHumanTaskLambdaArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .preHumanTaskLambdaArn)
        preHumanTaskLambdaArn = preHumanTaskLambdaArnDecoded
        let taskKeywordsContainer = try containerValues.decodeIfPresent([String].self, forKey: .taskKeywords)
        var taskKeywordsDecoded0:[String]? = nil
        if let taskKeywordsContainer = taskKeywordsContainer {
            taskKeywordsDecoded0 = [String]()
            for string0 in taskKeywordsContainer {
                taskKeywordsDecoded0?.append(string0)
            }
        }
        taskKeywords = taskKeywordsDecoded0
        let taskTitleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskTitle)
        taskTitle = taskTitleDecoded
        let taskDescriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .taskDescription)
        taskDescription = taskDescriptionDecoded
        let numberOfHumanWorkersPerDataObjectDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .numberOfHumanWorkersPerDataObject)
        numberOfHumanWorkersPerDataObject = numberOfHumanWorkersPerDataObjectDecoded
        let taskTimeLimitInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .taskTimeLimitInSeconds)
        taskTimeLimitInSeconds = taskTimeLimitInSecondsDecoded
        let taskAvailabilityLifetimeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .taskAvailabilityLifetimeInSeconds)
        taskAvailabilityLifetimeInSeconds = taskAvailabilityLifetimeInSecondsDecoded
        let maxConcurrentTaskCountDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maxConcurrentTaskCount)
        maxConcurrentTaskCount = maxConcurrentTaskCountDecoded
        let annotationConsolidationConfigDecoded = try containerValues.decodeIfPresent(AnnotationConsolidationConfig.self, forKey: .annotationConsolidationConfig)
        annotationConsolidationConfig = annotationConsolidationConfigDecoded
        let publicWorkforceTaskPriceDecoded = try containerValues.decodeIfPresent(PublicWorkforceTaskPrice.self, forKey: .publicWorkforceTaskPrice)
        publicWorkforceTaskPrice = publicWorkforceTaskPriceDecoded
    }
}
