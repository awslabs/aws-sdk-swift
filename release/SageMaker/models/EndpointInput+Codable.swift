// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension EndpointInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endTimeOffset = "EndTimeOffset"
        case endpointName = "EndpointName"
        case featuresAttribute = "FeaturesAttribute"
        case inferenceAttribute = "InferenceAttribute"
        case localPath = "LocalPath"
        case probabilityAttribute = "ProbabilityAttribute"
        case probabilityThresholdAttribute = "ProbabilityThresholdAttribute"
        case s3DataDistributionType = "S3DataDistributionType"
        case s3InputMode = "S3InputMode"
        case startTimeOffset = "StartTimeOffset"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTimeOffset = endTimeOffset {
            try encodeContainer.encode(endTimeOffset, forKey: .endTimeOffset)
        }
        if let endpointName = endpointName {
            try encodeContainer.encode(endpointName, forKey: .endpointName)
        }
        if let featuresAttribute = featuresAttribute {
            try encodeContainer.encode(featuresAttribute, forKey: .featuresAttribute)
        }
        if let inferenceAttribute = inferenceAttribute {
            try encodeContainer.encode(inferenceAttribute, forKey: .inferenceAttribute)
        }
        if let localPath = localPath {
            try encodeContainer.encode(localPath, forKey: .localPath)
        }
        if let probabilityAttribute = probabilityAttribute {
            try encodeContainer.encode(probabilityAttribute, forKey: .probabilityAttribute)
        }
        if let probabilityThresholdAttribute = probabilityThresholdAttribute {
            try encodeContainer.encode(probabilityThresholdAttribute, forKey: .probabilityThresholdAttribute)
        }
        if let s3DataDistributionType = s3DataDistributionType {
            try encodeContainer.encode(s3DataDistributionType.rawValue, forKey: .s3DataDistributionType)
        }
        if let s3InputMode = s3InputMode {
            try encodeContainer.encode(s3InputMode.rawValue, forKey: .s3InputMode)
        }
        if let startTimeOffset = startTimeOffset {
            try encodeContainer.encode(startTimeOffset, forKey: .startTimeOffset)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endpointName)
        endpointName = endpointNameDecoded
        let localPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localPath)
        localPath = localPathDecoded
        let s3InputModeDecoded = try containerValues.decodeIfPresent(ProcessingS3InputMode.self, forKey: .s3InputMode)
        s3InputMode = s3InputModeDecoded
        let s3DataDistributionTypeDecoded = try containerValues.decodeIfPresent(ProcessingS3DataDistributionType.self, forKey: .s3DataDistributionType)
        s3DataDistributionType = s3DataDistributionTypeDecoded
        let featuresAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .featuresAttribute)
        featuresAttribute = featuresAttributeDecoded
        let inferenceAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .inferenceAttribute)
        inferenceAttribute = inferenceAttributeDecoded
        let probabilityAttributeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .probabilityAttribute)
        probabilityAttribute = probabilityAttributeDecoded
        let probabilityThresholdAttributeDecoded = try containerValues.decodeIfPresent(Double.self, forKey: .probabilityThresholdAttribute)
        probabilityThresholdAttribute = probabilityThresholdAttributeDecoded
        let startTimeOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .startTimeOffset)
        startTimeOffset = startTimeOffsetDecoded
        let endTimeOffsetDecoded = try containerValues.decodeIfPresent(String.self, forKey: .endTimeOffset)
        endTimeOffset = endTimeOffsetDecoded
    }
}
