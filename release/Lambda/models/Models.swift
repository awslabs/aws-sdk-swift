// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccountLimit: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeSizeUnzipped = "CodeSizeUnzipped"
        case codeSizeZipped = "CodeSizeZipped"
        case concurrentExecutions = "ConcurrentExecutions"
        case totalCodeSize = "TotalCodeSize"
        case unreservedConcurrentExecutions = "UnreservedConcurrentExecutions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if codeSizeUnzipped != 0 {
            try encodeContainer.encode(codeSizeUnzipped, forKey: .codeSizeUnzipped)
        }
        if codeSizeZipped != 0 {
            try encodeContainer.encode(codeSizeZipped, forKey: .codeSizeZipped)
        }
        if concurrentExecutions != 0 {
            try encodeContainer.encode(concurrentExecutions, forKey: .concurrentExecutions)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
        if let unreservedConcurrentExecutions = unreservedConcurrentExecutions {
            try encodeContainer.encode(unreservedConcurrentExecutions, forKey: .unreservedConcurrentExecutions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decode(Int.self, forKey: .totalCodeSize)
        totalCodeSize = totalCodeSizeDecoded
        let codeSizeUnzippedDecoded = try containerValues.decode(Int.self, forKey: .codeSizeUnzipped)
        codeSizeUnzipped = codeSizeUnzippedDecoded
        let codeSizeZippedDecoded = try containerValues.decode(Int.self, forKey: .codeSizeZipped)
        codeSizeZipped = codeSizeZippedDecoded
        let concurrentExecutionsDecoded = try containerValues.decode(Int.self, forKey: .concurrentExecutions)
        concurrentExecutions = concurrentExecutionsDecoded
        let unreservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .unreservedConcurrentExecutions)
        unreservedConcurrentExecutions = unreservedConcurrentExecutionsDecoded
    }
}

extension AccountLimit: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountLimit(codeSizeUnzipped: \(String(describing: codeSizeUnzipped)), codeSizeZipped: \(String(describing: codeSizeZipped)), concurrentExecutions: \(String(describing: concurrentExecutions)), totalCodeSize: \(String(describing: totalCodeSize)), unreservedConcurrentExecutions: \(String(describing: unreservedConcurrentExecutions)))"}
}

/// <p>Limits that are related to concurrency and storage. All file and storage sizes are in bytes.</p>
public struct AccountLimit: Equatable {
    /// <p>The maximum size of a function's deployment package and layers when they're extracted.</p>
    public let codeSizeUnzipped: Int
    /// <p>The maximum size of a deployment package when it's uploaded directly to AWS Lambda. Use Amazon S3 for larger
    ///       files.</p>
    public let codeSizeZipped: Int
    /// <p>The maximum number of simultaneous function executions.</p>
    public let concurrentExecutions: Int
    /// <p>The amount of storage space that you can use for all deployment packages and layer archives.</p>
    public let totalCodeSize: Int
    /// <p>The maximum number of simultaneous function executions, minus the capacity that's reserved for individual
    ///       functions with <a>PutFunctionConcurrency</a>.</p>
    public let unreservedConcurrentExecutions: Int?

    public init (
        codeSizeUnzipped: Int = 0,
        codeSizeZipped: Int = 0,
        concurrentExecutions: Int = 0,
        totalCodeSize: Int = 0,
        unreservedConcurrentExecutions: Int? = nil
    )
    {
        self.codeSizeUnzipped = codeSizeUnzipped
        self.codeSizeZipped = codeSizeZipped
        self.concurrentExecutions = concurrentExecutions
        self.totalCodeSize = totalCodeSize
        self.unreservedConcurrentExecutions = unreservedConcurrentExecutions
    }
}

extension AccountUsage: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case functionCount = "FunctionCount"
        case totalCodeSize = "TotalCodeSize"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if functionCount != 0 {
            try encodeContainer.encode(functionCount, forKey: .functionCount)
        }
        if totalCodeSize != 0 {
            try encodeContainer.encode(totalCodeSize, forKey: .totalCodeSize)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalCodeSizeDecoded = try containerValues.decode(Int.self, forKey: .totalCodeSize)
        totalCodeSize = totalCodeSizeDecoded
        let functionCountDecoded = try containerValues.decode(Int.self, forKey: .functionCount)
        functionCount = functionCountDecoded
    }
}

extension AccountUsage: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AccountUsage(functionCount: \(String(describing: functionCount)), totalCodeSize: \(String(describing: totalCodeSize)))"}
}

/// <p>The number of functions and amount of storage in use.</p>
public struct AccountUsage: Equatable {
    /// <p>The number of Lambda functions.</p>
    public let functionCount: Int
    /// <p>The amount of storage space, in bytes, that's being used by deployment packages and layer archives.</p>
    public let totalCodeSize: Int

    public init (
        functionCount: Int = 0,
        totalCodeSize: Int = 0
    )
    {
        self.functionCount = functionCount
        self.totalCodeSize = totalCodeSize
    }
}

public struct AddLayerVersionPermissionInputBodyMiddleware: Middleware {
    public let id: String = "AddLayerVersionPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddLayerVersionPermissionInput>
    public typealias MOutput = OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddLayerVersionPermissionOutputError>
}

extension AddLayerVersionPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddLayerVersionPermissionInput(action: \(String(describing: action)), layerName: \(String(describing: layerName)), organizationId: \(String(describing: organizationId)), principal: \(String(describing: principal)), revisionId: \(String(describing: revisionId)), statementId: \(String(describing: statementId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension AddLayerVersionPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let organizationId = organizationId {
            try encodeContainer.encode(organizationId, forKey: .organizationId)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct AddLayerVersionPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "AddLayerVersionPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddLayerVersionPermissionInput>
    public typealias MOutput = OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddLayerVersionPermissionOutputError>
}

public struct AddLayerVersionPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddLayerVersionPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddLayerVersionPermissionInput>
    public typealias MOutput = OperationOutput<AddLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddLayerVersionPermissionOutputError>
}

public struct AddLayerVersionPermissionInput: Equatable {
    /// <p>The API action that grants access to the layer. For example, <code>lambda:GetLayerVersion</code>.</p>
    public let action: String?
    /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
    public let layerName: String?
    /// <p>With the principal set to <code>*</code>, grant permission to all accounts in the specified
    ///       organization.</p>
    public let organizationId: String?
    /// <p>An account ID, or <code>*</code> to grant permission to all AWS accounts.</p>
    public let principal: String?
    /// <p>Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.</p>
    public let revisionId: String?
    /// <p>An identifier that distinguishes the policy from others on the same layer version.</p>
    public let statementId: String?
    /// <p>The version number.</p>
    public let versionNumber: Int

    public init (
        action: String? = nil,
        layerName: String? = nil,
        organizationId: String? = nil,
        principal: String? = nil,
        revisionId: String? = nil,
        statementId: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.action = action
        self.layerName = layerName
        self.organizationId = organizationId
        self.principal = principal
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct AddLayerVersionPermissionInputBody: Equatable {
    public let statementId: String?
    public let action: String?
    public let principal: String?
    public let organizationId: String?
}

extension AddLayerVersionPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case organizationId = "OrganizationId"
        case principal = "Principal"
        case statementId = "StatementId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let organizationIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .organizationId)
        organizationId = organizationIdDecoded
    }
}

extension AddLayerVersionPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddLayerVersionPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddLayerVersionPermissionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddLayerVersionPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddLayerVersionPermissionOutputResponse(revisionId: \(String(describing: revisionId)), statement: \(String(describing: statement)))"}
}

extension AddLayerVersionPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddLayerVersionPermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.revisionId = output.revisionId
            self.statement = output.statement
        } else {
            self.revisionId = nil
            self.statement = nil
        }
    }
}

public struct AddLayerVersionPermissionOutputResponse: Equatable {
    /// <p>A unique identifier for the current revision of the policy.</p>
    public let revisionId: String?
    /// <p>The permission statement.</p>
    public let statement: String?

    public init (
        revisionId: String? = nil,
        statement: String? = nil
    )
    {
        self.revisionId = revisionId
        self.statement = statement
    }
}

struct AddLayerVersionPermissionOutputResponseBody: Equatable {
    public let statement: String?
    public let revisionId: String?
}

extension AddLayerVersionPermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case revisionId = "RevisionId"
        case statement = "Statement"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statement)
        statement = statementDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct AddPermissionInputBodyMiddleware: Middleware {
    public let id: String = "AddPermissionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPermissionInput>
    public typealias MOutput = OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPermissionOutputError>
}

extension AddPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddPermissionInput(action: \(String(describing: action)), eventSourceToken: \(String(describing: eventSourceToken)), functionName: \(String(describing: functionName)), principal: \(String(describing: principal)), qualifier: \(String(describing: qualifier)), revisionId: \(String(describing: revisionId)), sourceAccount: \(String(describing: sourceAccount)), sourceArn: \(String(describing: sourceArn)), statementId: \(String(describing: statementId)))"}
}

extension AddPermissionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case principal = "Principal"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let eventSourceToken = eventSourceToken {
            try encodeContainer.encode(eventSourceToken, forKey: .eventSourceToken)
        }
        if let principal = principal {
            try encodeContainer.encode(principal, forKey: .principal)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let sourceAccount = sourceAccount {
            try encodeContainer.encode(sourceAccount, forKey: .sourceAccount)
        }
        if let sourceArn = sourceArn {
            try encodeContainer.encode(sourceArn, forKey: .sourceArn)
        }
        if let statementId = statementId {
            try encodeContainer.encode(statementId, forKey: .statementId)
        }
    }
}

public struct AddPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "AddPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPermissionInput>
    public typealias MOutput = OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPermissionOutputError>
}

public struct AddPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "AddPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<AddPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<AddPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<AddPermissionInput>
    public typealias MOutput = OperationOutput<AddPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<AddPermissionOutputError>
}

public struct AddPermissionInput: Equatable {
    /// <p>The action that the principal can use on the function. For example, <code>lambda:InvokeFunction</code> or
    ///         <code>lambda:GetFunction</code>.</p>
    public let action: String?
    /// <p>For Alexa Smart Home functions, a token that must be supplied by the invoker.</p>
    public let eventSourceToken: String?
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>The AWS service or account that invokes the function. If you specify a service, use <code>SourceArn</code> or
    ///         <code>SourceAccount</code> to limit who can invoke the function through that service.</p>
    public let principal: String?
    /// <p>Specify a version or alias to add permissions to a published version of the function.</p>
    public let qualifier: String?
    /// <p>Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.</p>
    public let revisionId: String?
    /// <p>For Amazon S3, the ID of the account that owns the resource. Use this together with <code>SourceArn</code> to
    ///       ensure that the resource is owned by the specified account. It is possible for an Amazon S3 bucket to be deleted
    ///       by its owner and recreated by another account.</p>
    public let sourceAccount: String?
    /// <p>For AWS services, the ARN of the AWS resource that invokes the function. For example, an Amazon S3 bucket or
    ///       Amazon SNS topic.</p>
    public let sourceArn: String?
    /// <p>A statement identifier that differentiates the statement from others in the same policy.</p>
    public let statementId: String?

    public init (
        action: String? = nil,
        eventSourceToken: String? = nil,
        functionName: String? = nil,
        principal: String? = nil,
        qualifier: String? = nil,
        revisionId: String? = nil,
        sourceAccount: String? = nil,
        sourceArn: String? = nil,
        statementId: String? = nil
    )
    {
        self.action = action
        self.eventSourceToken = eventSourceToken
        self.functionName = functionName
        self.principal = principal
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.sourceAccount = sourceAccount
        self.sourceArn = sourceArn
        self.statementId = statementId
    }
}

struct AddPermissionInputBody: Equatable {
    public let statementId: String?
    public let action: String?
    public let principal: String?
    public let sourceArn: String?
    public let sourceAccount: String?
    public let eventSourceToken: String?
    public let revisionId: String?
}

extension AddPermissionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case action = "Action"
        case eventSourceToken = "EventSourceToken"
        case principal = "Principal"
        case revisionId = "RevisionId"
        case sourceAccount = "SourceAccount"
        case sourceArn = "SourceArn"
        case statementId = "StatementId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statementId)
        statementId = statementIdDecoded
        let actionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .action)
        action = actionDecoded
        let principalDecoded = try containerValues.decodeIfPresent(String.self, forKey: .principal)
        principal = principalDecoded
        let sourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceArn)
        sourceArn = sourceArnDecoded
        let sourceAccountDecoded = try containerValues.decodeIfPresent(String.self, forKey: .sourceAccount)
        sourceAccount = sourceAccountDecoded
        let eventSourceTokenDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceToken)
        eventSourceToken = eventSourceTokenDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension AddPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AddPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PolicyLengthExceededException" : self = .policyLengthExceededException(try PolicyLengthExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum AddPermissionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case policyLengthExceededException(PolicyLengthExceededException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AddPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AddPermissionOutputResponse(statement: \(String(describing: statement)))"}
}

extension AddPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: AddPermissionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.statement = output.statement
        } else {
            self.statement = nil
        }
    }
}

public struct AddPermissionOutputResponse: Equatable {
    /// <p>The permission statement that's added to the function policy.</p>
    public let statement: String?

    public init (
        statement: String? = nil
    )
    {
        self.statement = statement
    }
}

struct AddPermissionOutputResponseBody: Equatable {
    public let statement: String?
}

extension AddPermissionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case statement = "Statement"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statementDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statement)
        statement = statementDecoded
    }
}

extension AliasConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasArn = aliasArn {
            try encodeContainer.encode(aliasArn, forKey: .aliasArn)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension AliasConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AliasConfiguration(aliasArn: \(String(describing: aliasArn)), description: \(String(describing: description)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), routingConfig: \(String(describing: routingConfig)))"}
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
public struct AliasConfiguration: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    public let aliasArn: String?
    /// <p>A description of the alias.</p>
    public let description: String?
    /// <p>The function version that the alias invokes.</p>
    public let functionVersion: String?
    /// <p>The name of the alias.</p>
    public let name: String?
    /// <p>A unique identifier that changes when you update the alias.</p>
    public let revisionId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    ///         configuration</a> of the alias.</p>
    public let routingConfig: AliasRoutingConfiguration?

    public init (
        aliasArn: String? = nil,
        description: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        routingConfig: AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

extension AliasRoutingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case additionalVersionWeights = "AdditionalVersionWeights"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalVersionWeights = additionalVersionWeights {
            var additionalVersionWeightsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .additionalVersionWeights)
            for (dictKey0, additionalversionweights0) in additionalVersionWeights {
                try additionalVersionWeightsContainer.encode(additionalversionweights0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let additionalVersionWeightsContainer = try containerValues.decodeIfPresent([String: Double?].self, forKey: .additionalVersionWeights)
        var additionalVersionWeightsDecoded0: [String:Double]? = nil
        if let additionalVersionWeightsContainer = additionalVersionWeightsContainer {
            additionalVersionWeightsDecoded0 = [String:Double]()
            for (key0, weight0) in additionalVersionWeightsContainer {
                if let weight0 = weight0 {
                    additionalVersionWeightsDecoded0?[key0] = weight0
                }
            }
        }
        additionalVersionWeights = additionalVersionWeightsDecoded0
    }
}

extension AliasRoutingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AliasRoutingConfiguration(additionalVersionWeights: \(String(describing: additionalVersionWeights)))"}
}

/// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">traffic-shifting</a> configuration of a Lambda function alias.</p>
public struct AliasRoutingConfiguration: Equatable {
    /// <p>The second version, and the percentage of traffic that's routed to it.</p>
    public let additionalVersionWeights: [String:Double]?

    public init (
        additionalVersionWeights: [String:Double]? = nil
    )
    {
        self.additionalVersionWeights = additionalVersionWeights
    }
}

extension AllowedPublishers: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case signingProfileVersionArns = "SigningProfileVersionArns"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signingProfileVersionArns = signingProfileVersionArns {
            var signingProfileVersionArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .signingProfileVersionArns)
            for signingprofileversionarns0 in signingProfileVersionArns {
                try signingProfileVersionArnsContainer.encode(signingprofileversionarns0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signingProfileVersionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .signingProfileVersionArns)
        var signingProfileVersionArnsDecoded0:[String]? = nil
        if let signingProfileVersionArnsContainer = signingProfileVersionArnsContainer {
            signingProfileVersionArnsDecoded0 = [String]()
            for string0 in signingProfileVersionArnsContainer {
                if let string0 = string0 {
                    signingProfileVersionArnsDecoded0?.append(string0)
                }
            }
        }
        signingProfileVersionArns = signingProfileVersionArnsDecoded0
    }
}

extension AllowedPublishers: CustomDebugStringConvertible {
    public var debugDescription: String {
        "AllowedPublishers(signingProfileVersionArns: \(String(describing: signingProfileVersionArns)))"}
}

/// <p>List of signing profiles that can sign a code package. </p>
public struct AllowedPublishers: Equatable {
    /// <p>The Amazon Resource Name (ARN) for each of the signing profiles. A signing profile defines a trusted user
    ///       who can sign a code package. </p>
    public let signingProfileVersionArns: [String]?

    public init (
        signingProfileVersionArns: [String]? = nil
    )
    {
        self.signingProfileVersionArns = signingProfileVersionArns
    }
}

extension CodeSigningConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case codeSigningConfigId = "CodeSigningConfigId"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
        case lastModified = "LastModified"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let codeSigningConfigId = codeSigningConfigId {
            try encodeContainer.encode(codeSigningConfigId, forKey: .codeSigningConfigId)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSigningConfigId)
        codeSigningConfigId = codeSigningConfigIdDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension CodeSigningConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeSigningConfig(allowedPublishers: \(String(describing: allowedPublishers)), codeSigningConfigArn: \(String(describing: codeSigningConfigArn)), codeSigningConfigId: \(String(describing: codeSigningConfigId)), codeSigningPolicies: \(String(describing: codeSigningPolicies)), description: \(String(describing: description)), lastModified: \(String(describing: lastModified)))"}
}

/// <p>Details about a Code signing configuration. </p>
public struct CodeSigningConfig: Equatable {
    /// <p>List of allowed publishers.</p>
    public let allowedPublishers: AllowedPublishers?
    /// <p>The Amazon Resource Name (ARN) of the Code signing configuration.</p>
    public let codeSigningConfigArn: String?
    /// <p>Unique identifer for the Code signing configuration.</p>
    public let codeSigningConfigId: String?
    /// <p>The code signing policy controls the validation failure action for signature mismatch or expiry.</p>
    public let codeSigningPolicies: CodeSigningPolicies?
    /// <p>Code signing configuration description.</p>
    public let description: String?
    /// <p>The date and time that the Code signing configuration was last modified, in ISO-8601 format (YYYY-MM-DDThh:mm:ss.sTZD). </p>
    public let lastModified: String?

    public init (
        allowedPublishers: AllowedPublishers? = nil,
        codeSigningConfigArn: String? = nil,
        codeSigningConfigId: String? = nil,
        codeSigningPolicies: CodeSigningPolicies? = nil,
        description: String? = nil,
        lastModified: String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningConfigArn = codeSigningConfigArn
        self.codeSigningConfigId = codeSigningConfigId
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
        self.lastModified = lastModified
    }
}

extension CodeSigningConfigNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeSigningConfigNotFoundException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension CodeSigningConfigNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CodeSigningConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified code signing configuration does not exist.</p>
public struct CodeSigningConfigNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeSigningConfigNotFoundExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension CodeSigningConfigNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeSigningPolicies: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case untrustedArtifactOnDeployment = "UntrustedArtifactOnDeployment"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let untrustedArtifactOnDeployment = untrustedArtifactOnDeployment {
            try encodeContainer.encode(untrustedArtifactOnDeployment.rawValue, forKey: .untrustedArtifactOnDeployment)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let untrustedArtifactOnDeploymentDecoded = try containerValues.decodeIfPresent(CodeSigningPolicy.self, forKey: .untrustedArtifactOnDeployment)
        untrustedArtifactOnDeployment = untrustedArtifactOnDeploymentDecoded
    }
}

extension CodeSigningPolicies: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeSigningPolicies(untrustedArtifactOnDeployment: \(String(describing: untrustedArtifactOnDeployment)))"}
}

/// <p>Code signing configuration policies specifies the validation failure action for signature mismatch or
///        expiry.</p>
public struct CodeSigningPolicies: Equatable {
    /// <p>Code signing configuration policy for deployment validation failure. If you set the policy to
    ///       <code>Enforce</code>, Lambda blocks the deployment request if signature validation checks fail. If you set the
    ///       policy to <code>Warn</code>, Lambda allows the deployment and creates a CloudWatch log. </p>
    ///          <p>Default value: <code>Warn</code>
    ///          </p>
    public let untrustedArtifactOnDeployment: CodeSigningPolicy?

    public init (
        untrustedArtifactOnDeployment: CodeSigningPolicy? = nil
    )
    {
        self.untrustedArtifactOnDeployment = untrustedArtifactOnDeployment
    }
}

public enum CodeSigningPolicy {
    case enforce
    case warn
    case sdkUnknown(String)
}

extension CodeSigningPolicy : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [CodeSigningPolicy] {
        return [
            .enforce,
            .warn,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enforce: return "Enforce"
        case .warn: return "Warn"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = CodeSigningPolicy(rawValue: rawValue) ?? CodeSigningPolicy.sdkUnknown(rawValue)
    }
}

extension CodeStorageExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeStorageExceededException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension CodeStorageExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CodeStorageExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>You have exceeded your maximum total code size per account. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more</a>
///          </p>
public struct CodeStorageExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    /// <p>The exception type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeStorageExceededExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension CodeStorageExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CodeVerificationFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CodeVerificationFailedException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension CodeVerificationFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CodeVerificationFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The code signature failed one or more of the validation checks for signature mismatch or expiry, and the code signing policy
///       is set to ENFORCE. Lambda blocks the deployment. </p>
public struct CodeVerificationFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct CodeVerificationFailedExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension CodeVerificationFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension Concurrency: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension Concurrency: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Concurrency(reservedConcurrentExecutions: \(String(describing: reservedConcurrentExecutions)))"}
}

public struct Concurrency: Equatable {
    /// <p>The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">Managing Concurrency</a>.</p>
    public let reservedConcurrentExecutions: Int?

    public init (
        reservedConcurrentExecutions: Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

public struct CreateAliasInputBodyMiddleware: Middleware {
    public let id: String = "CreateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

extension CreateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasInput(description: \(String(describing: description)), functionName: \(String(describing: functionName)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), routingConfig: \(String(describing: routingConfig)))"}
}

extension CreateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let name = name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

public struct CreateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "CreateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

public struct CreateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateAliasInput>
    public typealias MOutput = OperationOutput<CreateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateAliasOutputError>
}

public struct CreateAliasInput: Equatable {
    /// <p>A description of the alias.</p>
    public let description: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The function version that the alias invokes.</p>
    public let functionVersion: String?
    /// <p>The name of the alias.</p>
    public let name: String?
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
    ///         configuration</a> of the alias.</p>
    public let routingConfig: AliasRoutingConfiguration?

    public init (
        description: String? = nil,
        functionName: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        routingConfig: AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.routingConfig = routingConfig
    }
}

struct CreateAliasInputBody: Equatable {
    public let name: String?
    public let functionVersion: String?
    public let description: String?
    public let routingConfig: AliasRoutingConfiguration?
}

extension CreateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
    }
}

extension CreateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateAliasOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateAliasOutputResponse(aliasArn: \(String(describing: aliasArn)), description: \(String(describing: description)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), routingConfig: \(String(describing: routingConfig)))"}
}

extension CreateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
public struct CreateAliasOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    public let aliasArn: String?
    /// <p>A description of the alias.</p>
    public let description: String?
    /// <p>The function version that the alias invokes.</p>
    public let functionVersion: String?
    /// <p>The name of the alias.</p>
    public let name: String?
    /// <p>A unique identifier that changes when you update the alias.</p>
    public let revisionId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    ///         configuration</a> of the alias.</p>
    public let routingConfig: AliasRoutingConfiguration?

    public init (
        aliasArn: String? = nil,
        description: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        routingConfig: AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct CreateAliasOutputResponseBody: Equatable {
    public let aliasArn: String?
    public let name: String?
    public let functionVersion: String?
    public let description: String?
    public let routingConfig: AliasRoutingConfiguration?
    public let revisionId: String?
}

extension CreateAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct CreateCodeSigningConfigInputBodyMiddleware: Middleware {
    public let id: String = "CreateCodeSigningConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCodeSigningConfigOutputError>
}

extension CreateCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCodeSigningConfigInput(allowedPublishers: \(String(describing: allowedPublishers)), codeSigningPolicies: \(String(describing: codeSigningPolicies)), description: \(String(describing: description)))"}
}

extension CreateCodeSigningConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct CreateCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "CreateCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCodeSigningConfigOutputError>
}

public struct CreateCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<CreateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateCodeSigningConfigOutputError>
}

public struct CreateCodeSigningConfigInput: Equatable {
    /// <p>Signing profiles for this code signing configuration.</p>
    public let allowedPublishers: AllowedPublishers?
    /// <p>The code signing policies define the actions to take if the validation checks fail. </p>
    public let codeSigningPolicies: CodeSigningPolicies?
    /// <p>Descriptive name for this code signing configuration.</p>
    public let description: String?

    public init (
        allowedPublishers: AllowedPublishers? = nil,
        codeSigningPolicies: CodeSigningPolicies? = nil,
        description: String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct CreateCodeSigningConfigInputBody: Equatable {
    public let description: String?
    public let allowedPublishers: AllowedPublishers?
    public let codeSigningPolicies: CodeSigningPolicies?
}

extension CreateCodeSigningConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension CreateCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateCodeSigningConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateCodeSigningConfigOutputResponse(codeSigningConfig: \(String(describing: codeSigningConfig)))"}
}

extension CreateCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct CreateCodeSigningConfigOutputResponse: Equatable {
    /// <p>The code signing configuration.</p>
    public let codeSigningConfig: CodeSigningConfig?

    public init (
        codeSigningConfig: CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct CreateCodeSigningConfigOutputResponseBody: Equatable {
    public let codeSigningConfig: CodeSigningConfig?
}

extension CreateCodeSigningConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

public struct CreateEventSourceMappingInputBodyMiddleware: Middleware {
    public let id: String = "CreateEventSourceMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSourceMappingInput>
    public typealias MOutput = OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSourceMappingOutputError>
}

extension CreateEventSourceMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSourceMappingInput(batchSize: \(String(describing: batchSize)), bisectBatchOnFunctionError: \(String(describing: bisectBatchOnFunctionError)), destinationConfig: \(String(describing: destinationConfig)), enabled: \(String(describing: enabled)), eventSourceArn: \(String(describing: eventSourceArn)), functionName: \(String(describing: functionName)), functionResponseTypes: \(String(describing: functionResponseTypes)), maximumBatchingWindowInSeconds: \(String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), parallelizationFactor: \(String(describing: parallelizationFactor)), queues: \(String(describing: queues)), selfManagedEventSource: \(String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(String(describing: sourceAccessConfigurations)), startingPosition: \(String(describing: startingPosition)), startingPositionTimestamp: \(String(describing: startingPositionTimestamp)), topics: \(String(describing: topics)), tumblingWindowInSeconds: \(String(describing: tumblingWindowInSeconds)))"}
}

extension CreateEventSourceMappingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
        if let selfManagedEventSource = selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = startingPositionTimestamp {
            try encodeContainer.encode(startingPositionTimestamp.timeIntervalSince1970, forKey: .startingPositionTimestamp)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

public struct CreateEventSourceMappingInputHeadersMiddleware: Middleware {
    public let id: String = "CreateEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSourceMappingInput>
    public typealias MOutput = OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSourceMappingOutputError>
}

public struct CreateEventSourceMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateEventSourceMappingInput>
    public typealias MOutput = OperationOutput<CreateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateEventSourceMappingOutputError>
}

public struct CreateEventSourceMappingInput: Equatable {
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Kinesis</b> - Default 100. Max 10,000.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon DynamoDB Streams</b> - Default 100. Max 1,000.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Simple Queue Service</b> - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Managed Streaming for Apache Kafka</b> - Default 100. Max 10,000.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Self-Managed Apache Kafka</b> - Default 100. Max 10,000.</p>
    ///             </li>
    ///          </ul>
    public let batchSize: Int?
    /// <p>(Streams) If the function returns an error, split the batch in two and retry.</p>
    public let bisectBatchOnFunctionError: Bool?
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>If true, the event source mapping is active. Set to false to pause polling and invocation.</p>
    public let enabled: Bool?
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Kinesis</b> - The ARN of the data stream or a stream consumer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon DynamoDB Streams</b> - The ARN of the stream.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Simple Queue Service</b> - The ARN of the queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Managed Streaming for Apache Kafka</b> - The ARN of the cluster.</p>
    ///             </li>
    ///          </ul>
    public let eventSourceArn: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    public let functionResponseTypes: [FunctionResponseType]?
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.</p>
    public let maximumBatchingWindowInSeconds: Int?
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1).</p>
    public let maximumRecordAgeInSeconds: Int?
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.</p>
    public let maximumRetryAttempts: Int?
    /// <p>(Streams) The number of batches to process from each shard concurrently.</p>
    public let parallelizationFactor: Int?
    /// <p>
    ///       (MQ) The name of the Amazon MQ broker destination queue to consume.
    ///     </p>
    public let queues: [String]?
    /// <p>The Self-Managed Apache Kafka cluster to send records.</p>
    public let selfManagedEventSource: SelfManagedEventSource?
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    ///       sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    public let startingPosition: EventSourcePosition?
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    ///       reading.</p>
    public let startingPositionTimestamp: Date?
    /// <p>The name of the Kafka topic.</p>
    public let topics: [String]?
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    public let tumblingWindowInSeconds: Int?

    public init (
        batchSize: Int? = nil,
        bisectBatchOnFunctionError: Bool? = nil,
        destinationConfig: DestinationConfig? = nil,
        enabled: Bool? = nil,
        eventSourceArn: String? = nil,
        functionName: String? = nil,
        functionResponseTypes: [FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Int? = nil,
        maximumRecordAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        parallelizationFactor: Int? = nil,
        queues: [String]? = nil,
        selfManagedEventSource: SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [SourceAccessConfiguration]? = nil,
        startingPosition: EventSourcePosition? = nil,
        startingPositionTimestamp: Date? = nil,
        topics: [String]? = nil,
        tumblingWindowInSeconds: Int? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.enabled = enabled
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
    }
}

struct CreateEventSourceMappingInputBody: Equatable {
    public let eventSourceArn: String?
    public let functionName: String?
    public let enabled: Bool?
    public let batchSize: Int?
    public let maximumBatchingWindowInSeconds: Int?
    public let parallelizationFactor: Int?
    public let startingPosition: EventSourcePosition?
    public let startingPositionTimestamp: Date?
    public let destinationConfig: DestinationConfig?
    public let maximumRecordAgeInSeconds: Int?
    public let bisectBatchOnFunctionError: Bool?
    public let maximumRetryAttempts: Int?
    public let tumblingWindowInSeconds: Int?
    public let topics: [String]?
    public let queues: [String]?
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    public let selfManagedEventSource: SelfManagedEventSource?
    public let functionResponseTypes: [FunctionResponseType]?
}

extension CreateEventSourceMappingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case eventSourceArn = "EventSourceArn"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let topicsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topics)
        var topicsDecoded0:[String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queues)
        var queuesDecoded0:[String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension CreateEventSourceMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateEventSourceMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateEventSourceMappingOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateEventSourceMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateEventSourceMappingOutputResponse(batchSize: \(String(describing: batchSize)), bisectBatchOnFunctionError: \(String(describing: bisectBatchOnFunctionError)), destinationConfig: \(String(describing: destinationConfig)), eventSourceArn: \(String(describing: eventSourceArn)), functionArn: \(String(describing: functionArn)), functionResponseTypes: \(String(describing: functionResponseTypes)), lastModified: \(String(describing: lastModified)), lastProcessingResult: \(String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), parallelizationFactor: \(String(describing: parallelizationFactor)), queues: \(String(describing: queues)), selfManagedEventSource: \(String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(String(describing: sourceAccessConfigurations)), startingPosition: \(String(describing: startingPosition)), startingPositionTimestamp: \(String(describing: startingPositionTimestamp)), state: \(String(describing: state)), stateTransitionReason: \(String(describing: stateTransitionReason)), topics: \(String(describing: topics)), tumblingWindowInSeconds: \(String(describing: tumblingWindowInSeconds)), uUID: \(String(describing: uUID)))"}
}

extension CreateEventSourceMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
public struct CreateEventSourceMappingOutputResponse: Equatable {
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    public let batchSize: Int?
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    public let bisectBatchOnFunctionError: Bool?
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    public let eventSourceArn: String?
    /// <p>The ARN of the Lambda function.</p>
    public let functionArn: String?
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    public let functionResponseTypes: [FunctionResponseType]?
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    public let lastModified: Date?
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    public let lastProcessingResult: String?
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    public let maximumBatchingWindowInSeconds: Int?
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRecordAgeInSeconds: Int?
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRetryAttempts: Int?
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    public let parallelizationFactor: Int?
    /// <p>
    ///       (MQ) The name of the Amazon MQ broker destination queue to consume.
    ///     </p>
    public let queues: [String]?
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    public let selfManagedEventSource: SelfManagedEventSource?
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    ///       sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    public let startingPosition: EventSourcePosition?
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    ///       reading.</p>
    public let startingPositionTimestamp: Date?
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    ///       <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    ///       <code>Updating</code>, or <code>Deleting</code>.</p>
    public let state: String?
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    ///       service.</p>
    public let stateTransitionReason: String?
    /// <p>The name of the Kafka topic.</p>
    public let topics: [String]?
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    public let tumblingWindowInSeconds: Int?
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        batchSize: Int? = nil,
        bisectBatchOnFunctionError: Bool? = nil,
        destinationConfig: DestinationConfig? = nil,
        eventSourceArn: String? = nil,
        functionArn: String? = nil,
        functionResponseTypes: [FunctionResponseType]? = nil,
        lastModified: Date? = nil,
        lastProcessingResult: String? = nil,
        maximumBatchingWindowInSeconds: Int? = nil,
        maximumRecordAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        parallelizationFactor: Int? = nil,
        queues: [String]? = nil,
        selfManagedEventSource: SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [SourceAccessConfiguration]? = nil,
        startingPosition: EventSourcePosition? = nil,
        startingPositionTimestamp: Date? = nil,
        state: String? = nil,
        stateTransitionReason: String? = nil,
        topics: [String]? = nil,
        tumblingWindowInSeconds: Int? = nil,
        uUID: String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct CreateEventSourceMappingOutputResponseBody: Equatable {
    public let uUID: String?
    public let startingPosition: EventSourcePosition?
    public let startingPositionTimestamp: Date?
    public let batchSize: Int?
    public let maximumBatchingWindowInSeconds: Int?
    public let parallelizationFactor: Int?
    public let eventSourceArn: String?
    public let functionArn: String?
    public let lastModified: Date?
    public let lastProcessingResult: String?
    public let state: String?
    public let stateTransitionReason: String?
    public let destinationConfig: DestinationConfig?
    public let topics: [String]?
    public let queues: [String]?
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    public let selfManagedEventSource: SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Int?
    public let bisectBatchOnFunctionError: Bool?
    public let maximumRetryAttempts: Int?
    public let tumblingWindowInSeconds: Int?
    public let functionResponseTypes: [FunctionResponseType]?
}

extension CreateEventSourceMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topics)
        var topicsDecoded0:[String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queues)
        var queuesDecoded0:[String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

public struct CreateFunctionInputBodyMiddleware: Middleware {
    public let id: String = "CreateFunctionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

extension CreateFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionInput(code: \(String(describing: code)), codeSigningConfigArn: \(String(describing: codeSigningConfigArn)), deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfig: \(String(describing: imageConfig)), kMSKeyArn: \(String(describing: kMSKeyArn)), layers: \(String(describing: layers)), memorySize: \(String(describing: memorySize)), packageType: \(String(describing: packageType)), publish: \(String(describing: publish)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), tags: \(String(describing: tags)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateFunctionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerlist0 in layers {
                try layersContainer.encode(layerlist0)
            }
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if publish != false {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct CreateFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "CreateFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "CreateFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<CreateFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<CreateFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<CreateFunctionInput>
    public typealias MOutput = OperationOutput<CreateFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<CreateFunctionOutputError>
}

public struct CreateFunctionInput: Equatable {
    /// <p>The code for the function.</p>
    public let code: FunctionCode?
    /// <p>To enable code signing for this function, specify the ARN of a code-signing configuration. A code-signing configuration
    /// includes a set of signing profiles, which define the trusted publishers for this function.</p>
    public let codeSigningConfigArn: String?
    /// <p>A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
    ///       when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues</a>.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>A description of the function.</p>
    public let description: String?
    /// <p>Environment variables that are accessible from function code during execution.</p>
    public let environment: Environment?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The name of the method within your code that Lambda calls to execute your function. The format includes the
    ///       file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
    ///       see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model</a>.</p>
    public let handler: String?
    /// <p>
    ///             <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html">Container image configuration
    ///       values</a> that override the values in the container image Dockerfile.</p>
    public let imageConfig: ImageConfig?
    /// <p>The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment
    ///       variables. If it's not provided, AWS Lambda uses a default service key.</p>
    public let kMSKeyArn: String?
    /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a>
    ///       to add to the function's execution environment. Specify each layer by its ARN, including the version.</p>
    public let layers: [String]?
    /// <p>The amount of memory available to the function at runtime. Increasing the function's memory also increases its CPU
    ///       allocation. The default value is 128 MB. The value can be any multiple of 1 MB.</p>
    public let memorySize: Int?
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for ZIP archive.</p>
    public let packageType: PackageType?
    /// <p>Set to true to publish the first version of the function during creation.</p>
    public let publish: Bool
    /// <p>The Amazon Resource Name (ARN) of the function's execution role.</p>
    public let role: String?
    /// <p>The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>.</p>
    public let runtime: Runtime?
    /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a> to apply to the
    ///       function.</p>
    public let tags: [String:String]?
    /// <p>The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
    ///       maximum allowed value is 900 seconds.</p>
    public let timeout: Int?
    /// <p>Set <code>Mode</code> to <code>Active</code> to sample and trace a subset of incoming requests with AWS
    ///       X-Ray.</p>
    public let tracingConfig: TracingConfig?
    /// <p>For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
    ///       When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
    ///       information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings</a>.</p>
    public let vpcConfig: VpcConfig?

    public init (
        code: FunctionCode? = nil,
        codeSigningConfigArn: String? = nil,
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: Environment? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfig: ImageConfig? = nil,
        kMSKeyArn: String? = nil,
        layers: [String]? = nil,
        memorySize: Int? = nil,
        packageType: PackageType? = nil,
        publish: Bool = false,
        role: String? = nil,
        runtime: Runtime? = nil,
        tags: [String:String]? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfig? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.code = code
        self.codeSigningConfigArn = codeSigningConfigArn
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kMSKeyArn = kMSKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.packageType = packageType
        self.publish = publish
        self.role = role
        self.runtime = runtime
        self.tags = tags
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionInputBody: Equatable {
    public let functionName: String?
    public let runtime: Runtime?
    public let role: String?
    public let handler: String?
    public let code: FunctionCode?
    public let description: String?
    public let timeout: Int?
    public let memorySize: Int?
    public let publish: Bool
    public let vpcConfig: VpcConfig?
    public let packageType: PackageType?
    public let deadLetterConfig: DeadLetterConfig?
    public let environment: Environment?
    public let kMSKeyArn: String?
    public let tracingConfig: TracingConfig?
    public let tags: [String:String]?
    public let layers: [String]?
    public let fileSystemConfigs: [FileSystemConfig]?
    public let imageConfig: ImageConfig?
    public let codeSigningConfigArn: String?
}

extension CreateFunctionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case publish = "Publish"
        case role = "Role"
        case runtime = "Runtime"
        case tags = "Tags"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let codeDecoded = try containerValues.decodeIfPresent(FunctionCode.self, forKey: .code)
        code = codeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let publishDecoded = try containerValues.decode(Bool.self, forKey: .publish)
        publish = publishDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let packageTypeDecoded = try containerValues.decodeIfPresent(PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(Environment.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let layersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layers)
        var layersDecoded0:[String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
    }
}

extension CreateFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum CreateFunctionOutputError: Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeStorageExceededException(CodeStorageExceededException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "CreateFunctionOutputResponse(codeSha256: \(String(describing: codeSha256)), codeSize: \(String(describing: codeSize)), deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionArn: \(String(describing: functionArn)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfigResponse: \(String(describing: imageConfigResponse)), kMSKeyArn: \(String(describing: kMSKeyArn)), lastModified: \(String(describing: lastModified)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(String(describing: lastUpdateStatusReasonCode)), layers: \(String(describing: layers)), masterArn: \(String(describing: masterArn)), memorySize: \(String(describing: memorySize)), packageType: \(String(describing: packageType)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), version: \(String(describing: version)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension CreateFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: CreateFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// <p>Details about a function's configuration.</p>
public struct CreateFunctionOutputResponse: Equatable {
    /// <p>The SHA256 hash of the function's deployment package.</p>
    public let codeSha256: String?
    /// <p>The size of the function's deployment package, in bytes.</p>
    public let codeSize: Int
    /// <p>The function's dead letter queue.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>The function's description.</p>
    public let description: String?
    /// <p>The function's environment variables.</p>
    public let environment: EnvironmentResponse?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let functionArn: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The function that Lambda calls to begin executing your function.</p>
    public let handler: String?
    /// <p>The function's image configuration values.</p>
    public let imageConfigResponse: ImageConfigResponse?
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.</p>
    public let kMSKeyArn: String?
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let lastModified: String?
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    ///       after function creation completes.</p>
    public let lastUpdateStatus: LastUpdateStatus?
    /// <p>The reason for the last update that was performed on the function.</p>
    public let lastUpdateStatusReason: String?
    /// <p>The reason code for the last update that was performed on the function.</p>
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers</a>.</p>
    public let layers: [Layer]?
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    public let masterArn: String?
    /// <p>The amount of memory available to the function at runtime. </p>
    public let memorySize: Int?
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    public let packageType: PackageType?
    /// <p>The latest updated revision of the function or alias.</p>
    public let revisionId: String?
    /// <p>The function's execution role.</p>
    public let role: String?
    /// <p>The runtime environment for the Lambda function.</p>
    public let runtime: Runtime?
    /// <p>The ARN of the signing job.</p>
    public let signingJobArn: String?
    /// <p>The ARN of the signing profile version.</p>
    public let signingProfileVersionArn: String?
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    ///       invoking it.</p>
    public let state: State?
    /// <p>The reason for the function's current state.</p>
    public let stateReason: String?
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    ///       modify the function.</p>
    public let stateReasonCode: StateReasonCode?
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    public let timeout: Int?
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    public let tracingConfig: TracingConfigResponse?
    /// <p>The version of the Lambda function.</p>
    public let version: String?
    /// <p>The function's networking configuration.</p>
    public let vpcConfig: VpcConfigResponse?

    public init (
        codeSha256: String? = nil,
        codeSize: Int = 0,
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: EnvironmentResponse? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionArn: String? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfigResponse: ImageConfigResponse? = nil,
        kMSKeyArn: String? = nil,
        lastModified: String? = nil,
        lastUpdateStatus: LastUpdateStatus? = nil,
        lastUpdateStatusReason: String? = nil,
        lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil,
        layers: [Layer]? = nil,
        masterArn: String? = nil,
        memorySize: Int? = nil,
        packageType: PackageType? = nil,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: Runtime? = nil,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil,
        state: State? = nil,
        stateReason: String? = nil,
        stateReasonCode: StateReasonCode? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfigResponse? = nil,
        version: String? = nil,
        vpcConfig: VpcConfigResponse? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct CreateFunctionOutputResponseBody: Equatable {
    public let functionName: String?
    public let functionArn: String?
    public let runtime: Runtime?
    public let role: String?
    public let handler: String?
    public let codeSize: Int
    public let description: String?
    public let timeout: Int?
    public let memorySize: Int?
    public let lastModified: String?
    public let codeSha256: String?
    public let version: String?
    public let vpcConfig: VpcConfigResponse?
    public let deadLetterConfig: DeadLetterConfig?
    public let environment: EnvironmentResponse?
    public let kMSKeyArn: String?
    public let tracingConfig: TracingConfigResponse?
    public let masterArn: String?
    public let revisionId: String?
    public let layers: [Layer]?
    public let state: State?
    public let stateReason: String?
    public let stateReasonCode: StateReasonCode?
    public let lastUpdateStatus: LastUpdateStatus?
    public let lastUpdateStatusReason: String?
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [FileSystemConfig]?
    public let packageType: PackageType?
    public let imageConfigResponse: ImageConfigResponse?
    public let signingProfileVersionArn: String?
    public let signingJobArn: String?
}

extension CreateFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension DeadLetterConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case targetArn = "TargetArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetArn = targetArn {
            try encodeContainer.encode(targetArn, forKey: .targetArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .targetArn)
        targetArn = targetArnDecoded
    }
}

extension DeadLetterConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeadLetterConfig(targetArn: \(String(describing: targetArn)))"}
}

/// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">dead-letter queue</a> for
///       failed asynchronous invocations.</p>
public struct DeadLetterConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of an Amazon SQS queue or Amazon SNS topic.</p>
    public let targetArn: String?

    public init (
        targetArn: String? = nil
    )
    {
        self.targetArn = targetArn
    }
}

extension DeleteAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAliasInput(functionName: \(String(describing: functionName)), name: \(String(describing: name)))"}
}

extension DeleteAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteAliasInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteAliasInput>
    public typealias MOutput = OperationOutput<DeleteAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteAliasOutputError>
}

public struct DeleteAliasInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The name of the alias.</p>
    public let name: String?

    public init (
        functionName: String? = nil,
        name: String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct DeleteAliasInputBody: Equatable {
}

extension DeleteAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteAliasOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteAliasOutputResponse()"}
}

extension DeleteAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAliasOutputResponse: Equatable {

    public init() {}
}

struct DeleteAliasOutputResponseBody: Equatable {
}

extension DeleteAliasOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCodeSigningConfigInput(codeSigningConfigArn: \(String(describing: codeSigningConfigArn)))"}
}

extension DeleteCodeSigningConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<DeleteCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCodeSigningConfigOutputError>
}

public struct DeleteCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<DeleteCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteCodeSigningConfigOutputError>
}

public struct DeleteCodeSigningConfigInput: Equatable {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    public let codeSigningConfigArn: String?

    public init (
        codeSigningConfigArn: String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct DeleteCodeSigningConfigInputBody: Equatable {
}

extension DeleteCodeSigningConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteCodeSigningConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteCodeSigningConfigOutputResponse()"}
}

extension DeleteCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteCodeSigningConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteCodeSigningConfigOutputResponseBody: Equatable {
}

extension DeleteCodeSigningConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEventSourceMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSourceMappingInput(uUID: \(String(describing: uUID)))"}
}

extension DeleteEventSourceMappingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteEventSourceMappingInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSourceMappingInput>
    public typealias MOutput = OperationOutput<DeleteEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSourceMappingOutputError>
}

public struct DeleteEventSourceMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteEventSourceMappingInput>
    public typealias MOutput = OperationOutput<DeleteEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteEventSourceMappingOutputError>
}

public struct DeleteEventSourceMappingInput: Equatable {
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        uUID: String? = nil
    )
    {
        self.uUID = uUID
    }
}

struct DeleteEventSourceMappingInputBody: Equatable {
}

extension DeleteEventSourceMappingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteEventSourceMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteEventSourceMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteEventSourceMappingOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteEventSourceMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteEventSourceMappingOutputResponse(batchSize: \(String(describing: batchSize)), bisectBatchOnFunctionError: \(String(describing: bisectBatchOnFunctionError)), destinationConfig: \(String(describing: destinationConfig)), eventSourceArn: \(String(describing: eventSourceArn)), functionArn: \(String(describing: functionArn)), functionResponseTypes: \(String(describing: functionResponseTypes)), lastModified: \(String(describing: lastModified)), lastProcessingResult: \(String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), parallelizationFactor: \(String(describing: parallelizationFactor)), queues: \(String(describing: queues)), selfManagedEventSource: \(String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(String(describing: sourceAccessConfigurations)), startingPosition: \(String(describing: startingPosition)), startingPositionTimestamp: \(String(describing: startingPositionTimestamp)), state: \(String(describing: state)), stateTransitionReason: \(String(describing: stateTransitionReason)), topics: \(String(describing: topics)), tumblingWindowInSeconds: \(String(describing: tumblingWindowInSeconds)), uUID: \(String(describing: uUID)))"}
}

extension DeleteEventSourceMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: DeleteEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
public struct DeleteEventSourceMappingOutputResponse: Equatable {
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    public let batchSize: Int?
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    public let bisectBatchOnFunctionError: Bool?
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    public let eventSourceArn: String?
    /// <p>The ARN of the Lambda function.</p>
    public let functionArn: String?
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    public let functionResponseTypes: [FunctionResponseType]?
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    public let lastModified: Date?
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    public let lastProcessingResult: String?
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    public let maximumBatchingWindowInSeconds: Int?
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRecordAgeInSeconds: Int?
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRetryAttempts: Int?
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    public let parallelizationFactor: Int?
    /// <p>
    ///       (MQ) The name of the Amazon MQ broker destination queue to consume.
    ///     </p>
    public let queues: [String]?
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    public let selfManagedEventSource: SelfManagedEventSource?
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    ///       sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    public let startingPosition: EventSourcePosition?
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    ///       reading.</p>
    public let startingPositionTimestamp: Date?
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    ///       <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    ///       <code>Updating</code>, or <code>Deleting</code>.</p>
    public let state: String?
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    ///       service.</p>
    public let stateTransitionReason: String?
    /// <p>The name of the Kafka topic.</p>
    public let topics: [String]?
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    public let tumblingWindowInSeconds: Int?
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        batchSize: Int? = nil,
        bisectBatchOnFunctionError: Bool? = nil,
        destinationConfig: DestinationConfig? = nil,
        eventSourceArn: String? = nil,
        functionArn: String? = nil,
        functionResponseTypes: [FunctionResponseType]? = nil,
        lastModified: Date? = nil,
        lastProcessingResult: String? = nil,
        maximumBatchingWindowInSeconds: Int? = nil,
        maximumRecordAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        parallelizationFactor: Int? = nil,
        queues: [String]? = nil,
        selfManagedEventSource: SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [SourceAccessConfiguration]? = nil,
        startingPosition: EventSourcePosition? = nil,
        startingPositionTimestamp: Date? = nil,
        state: String? = nil,
        stateTransitionReason: String? = nil,
        topics: [String]? = nil,
        tumblingWindowInSeconds: Int? = nil,
        uUID: String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct DeleteEventSourceMappingOutputResponseBody: Equatable {
    public let uUID: String?
    public let startingPosition: EventSourcePosition?
    public let startingPositionTimestamp: Date?
    public let batchSize: Int?
    public let maximumBatchingWindowInSeconds: Int?
    public let parallelizationFactor: Int?
    public let eventSourceArn: String?
    public let functionArn: String?
    public let lastModified: Date?
    public let lastProcessingResult: String?
    public let state: String?
    public let stateTransitionReason: String?
    public let destinationConfig: DestinationConfig?
    public let topics: [String]?
    public let queues: [String]?
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    public let selfManagedEventSource: SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Int?
    public let bisectBatchOnFunctionError: Bool?
    public let maximumRetryAttempts: Int?
    public let tumblingWindowInSeconds: Int?
    public let functionResponseTypes: [FunctionResponseType]?
}

extension DeleteEventSourceMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topics)
        var topicsDecoded0:[String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queues)
        var queuesDecoded0:[String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension DeleteFunctionCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionCodeSigningConfigInput(functionName: \(String(describing: functionName)))"}
}

extension DeleteFunctionCodeSigningConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFunctionCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFunctionCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionCodeSigningConfigOutputError>
}

public struct DeleteFunctionCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFunctionCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<DeleteFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionCodeSigningConfigOutputError>
}

public struct DeleteFunctionCodeSigningConfigInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?

    public init (
        functionName: String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionCodeSigningConfigInputBody: Equatable {
}

extension DeleteFunctionCodeSigningConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionCodeSigningConfigOutputError: Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionCodeSigningConfigOutputResponse()"}
}

extension DeleteFunctionCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionCodeSigningConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteFunctionCodeSigningConfigOutputResponseBody: Equatable {
}

extension DeleteFunctionCodeSigningConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionConcurrencyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionConcurrencyInput(functionName: \(String(describing: functionName)))"}
}

extension DeleteFunctionConcurrencyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFunctionConcurrencyInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFunctionConcurrencyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionConcurrencyInput>
    public typealias MOutput = OperationOutput<DeleteFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionConcurrencyOutputError>
}

public struct DeleteFunctionConcurrencyInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFunctionConcurrencyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionConcurrencyInput>
    public typealias MOutput = OperationOutput<DeleteFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionConcurrencyOutputError>
}

public struct DeleteFunctionConcurrencyInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?

    public init (
        functionName: String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct DeleteFunctionConcurrencyInputBody: Equatable {
}

extension DeleteFunctionConcurrencyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionConcurrencyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionConcurrencyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionConcurrencyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionConcurrencyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionConcurrencyOutputResponse()"}
}

extension DeleteFunctionConcurrencyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionConcurrencyOutputResponse: Equatable {

    public init() {}
}

struct DeleteFunctionConcurrencyOutputResponseBody: Equatable {
}

extension DeleteFunctionConcurrencyOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionEventInvokeConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionEventInvokeConfigInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension DeleteFunctionEventInvokeConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFunctionEventInvokeConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionEventInvokeConfigOutputError>
}

public struct DeleteFunctionEventInvokeConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<DeleteFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionEventInvokeConfigOutputError>
}

public struct DeleteFunctionEventInvokeConfigInput: Equatable {
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>A version number or alias name.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionEventInvokeConfigInputBody: Equatable {
}

extension DeleteFunctionEventInvokeConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionEventInvokeConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionEventInvokeConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionEventInvokeConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionEventInvokeConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionEventInvokeConfigOutputResponse()"}
}

extension DeleteFunctionEventInvokeConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionEventInvokeConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteFunctionEventInvokeConfigOutputResponseBody: Equatable {
}

extension DeleteFunctionEventInvokeConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension DeleteFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteFunctionInput>
    public typealias MOutput = OperationOutput<DeleteFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteFunctionOutputError>
}

public struct DeleteFunctionInput: Equatable {
    /// <p>The name of the Lambda function or version.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:1</code> (with version).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>Specify a version to delete. You can't delete a version that's referenced by an alias.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteFunctionInputBody: Equatable {
}

extension DeleteFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteFunctionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteFunctionOutputResponse()"}
}

extension DeleteFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFunctionOutputResponse: Equatable {

    public init() {}
}

struct DeleteFunctionOutputResponseBody: Equatable {
}

extension DeleteFunctionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLayerVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLayerVersionInput(layerName: \(String(describing: layerName)), versionNumber: \(String(describing: versionNumber)))"}
}

extension DeleteLayerVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteLayerVersionInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteLayerVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLayerVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLayerVersionInput>
    public typealias MOutput = OperationOutput<DeleteLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLayerVersionOutputError>
}

public struct DeleteLayerVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteLayerVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteLayerVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteLayerVersionInput>
    public typealias MOutput = OperationOutput<DeleteLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteLayerVersionOutputError>
}

public struct DeleteLayerVersionInput: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
    public let layerName: String?
    /// <p>The version number.</p>
    public let versionNumber: Int

    public init (
        layerName: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct DeleteLayerVersionInputBody: Equatable {
}

extension DeleteLayerVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteLayerVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteLayerVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteLayerVersionOutputError: Equatable {
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteLayerVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteLayerVersionOutputResponse()"}
}

extension DeleteLayerVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteLayerVersionOutputResponse: Equatable {

    public init() {}
}

struct DeleteLayerVersionOutputResponseBody: Equatable {
}

extension DeleteLayerVersionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProvisionedConcurrencyConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisionedConcurrencyConfigInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension DeleteProvisionedConcurrencyConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct DeleteProvisionedConcurrencyConfigInputHeadersMiddleware: Middleware {
    public let id: String = "DeleteProvisionedConcurrencyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>
    public typealias MOutput = OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisionedConcurrencyConfigOutputError>
}

public struct DeleteProvisionedConcurrencyConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "DeleteProvisionedConcurrencyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<DeleteProvisionedConcurrencyConfigInput>
    public typealias MOutput = OperationOutput<DeleteProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<DeleteProvisionedConcurrencyConfigOutputError>
}

public struct DeleteProvisionedConcurrencyConfigInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The version number or alias name.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct DeleteProvisionedConcurrencyConfigInputBody: Equatable {
}

extension DeleteProvisionedConcurrencyConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DeleteProvisionedConcurrencyConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteProvisionedConcurrencyConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum DeleteProvisionedConcurrencyConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteProvisionedConcurrencyConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DeleteProvisionedConcurrencyConfigOutputResponse()"}
}

extension DeleteProvisionedConcurrencyConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct DeleteProvisionedConcurrencyConfigOutputResponse: Equatable {

    public init() {}
}

struct DeleteProvisionedConcurrencyConfigOutputResponseBody: Equatable {
}

extension DeleteProvisionedConcurrencyConfigOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension DestinationConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case onFailure = "OnFailure"
        case onSuccess = "OnSuccess"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let onFailure = onFailure {
            try encodeContainer.encode(onFailure, forKey: .onFailure)
        }
        if let onSuccess = onSuccess {
            try encodeContainer.encode(onSuccess, forKey: .onSuccess)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let onSuccessDecoded = try containerValues.decodeIfPresent(OnSuccess.self, forKey: .onSuccess)
        onSuccess = onSuccessDecoded
        let onFailureDecoded = try containerValues.decodeIfPresent(OnFailure.self, forKey: .onFailure)
        onFailure = onFailureDecoded
    }
}

extension DestinationConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "DestinationConfig(onFailure: \(String(describing: onFailure)), onSuccess: \(String(describing: onSuccess)))"}
}

/// <p>A configuration object that specifies the destination of an event after Lambda processes it.</p>
public struct DestinationConfig: Equatable {
    /// <p>The destination configuration for failed invocations.</p>
    public let onFailure: OnFailure?
    /// <p>The destination configuration for successful invocations.</p>
    public let onSuccess: OnSuccess?

    public init (
        onFailure: OnFailure? = nil,
        onSuccess: OnSuccess? = nil
    )
    {
        self.onFailure = onFailure
        self.onSuccess = onSuccess
    }
}

extension EC2AccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2AccessDeniedException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension EC2AccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EC2AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Need additional permissions to configure VPC settings.</p>
public struct EC2AccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EC2AccessDeniedExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension EC2AccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2ThrottledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2ThrottledException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension EC2ThrottledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EC2ThrottledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Lambda was throttled by Amazon EC2 during Lambda function initialization using the execution role provided
///       for the Lambda function.</p>
public struct EC2ThrottledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EC2ThrottledExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension EC2ThrottledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EC2UnexpectedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EC2UnexpectedException(eC2ErrorCode: \(String(describing: eC2ErrorCode)), message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension EC2UnexpectedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EC2UnexpectedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eC2ErrorCode = output.eC2ErrorCode
            self.message = output.message
            self.type = output.type
        } else {
            self.eC2ErrorCode = nil
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Lambda received an unexpected EC2 client exception while setting up for the Lambda function.</p>
public struct EC2UnexpectedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var eC2ErrorCode: String?
    public var message: String?
    public var type: String?

    public init (
        eC2ErrorCode: String? = nil,
        message: String? = nil,
        type: String? = nil
    )
    {
        self.eC2ErrorCode = eC2ErrorCode
        self.message = message
        self.type = type
    }
}

struct EC2UnexpectedExceptionBody: Equatable {
    public let type: String?
    public let message: String?
    public let eC2ErrorCode: String?
}

extension EC2UnexpectedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eC2ErrorCode = "EC2ErrorCode"
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let eC2ErrorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eC2ErrorCode)
        eC2ErrorCode = eC2ErrorCodeDecoded
    }
}

extension EFSIOException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EFSIOException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension EFSIOException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EFSIOExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>An error occured when reading from or writing to a connected file system.</p>
public struct EFSIOException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSIOExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension EFSIOExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountConnectivityException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EFSMountConnectivityException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension EFSMountConnectivityException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EFSMountConnectivityExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function couldn't make a network connection to the configured file system.</p>
public struct EFSMountConnectivityException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountConnectivityExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension EFSMountConnectivityExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountFailureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EFSMountFailureException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension EFSMountFailureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EFSMountFailureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function couldn't mount the configured file system due to a permission or configuration issue.</p>
public struct EFSMountFailureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountFailureExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension EFSMountFailureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EFSMountTimeoutException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EFSMountTimeoutException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension EFSMountTimeoutException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: EFSMountTimeoutExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function was able to make a network connection to the configured file system, but the mount operation
///       timed out.</p>
public struct EFSMountTimeoutException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct EFSMountTimeoutExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension EFSMountTimeoutExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ENILimitReachedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ENILimitReachedException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ENILimitReachedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ENILimitReachedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Lambda was not able to create an elastic network interface in the VPC, specified as part of Lambda
///       function configuration, because the limit for network interfaces has been reached.</p>
public struct ENILimitReachedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ENILimitReachedExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension ENILimitReachedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum EndPointType {
    case kafkaBootstrapServers
    case sdkUnknown(String)
}

extension EndPointType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EndPointType] {
        return [
            .kafkaBootstrapServers,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .kafkaBootstrapServers: return "KAFKA_BOOTSTRAP_SERVERS"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EndPointType(rawValue: rawValue) ?? EndPointType.sdkUnknown(rawValue)
    }
}

extension Environment: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case variables = "Variables"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, environmentvariables0) in variables {
                try variablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension Environment: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Environment(variables: \(String(describing: variables)))"}
}

/// <p>A function's environment variable settings.</p>
public struct Environment: Equatable {
    /// <p>Environment variable key-value pairs.</p>
    public let variables: [String:String]?

    public init (
        variables: [String:String]? = nil
    )
    {
        self.variables = variables
    }
}

extension EnvironmentError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension EnvironmentError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentError(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

/// <p>Error messages for environment variables that couldn't be applied.</p>
public struct EnvironmentError: Equatable {
    /// <p>The error code.</p>
    public let errorCode: String?
    /// <p>The error message.</p>
    public let message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

extension EnvironmentResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case variables = "Variables"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .variables)
            for (dictKey0, environmentvariables0) in variables {
                try variablesContainer.encode(environmentvariables0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .variables)
        var variablesDecoded0: [String:String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [String:String]()
            for (key0, environmentvariablevalue0) in variablesContainer {
                if let environmentvariablevalue0 = environmentvariablevalue0 {
                    variablesDecoded0?[key0] = environmentvariablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let errorDecoded = try containerValues.decodeIfPresent(EnvironmentError.self, forKey: .error)
        error = errorDecoded
    }
}

extension EnvironmentResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EnvironmentResponse(error: \(String(describing: error)), variables: \(String(describing: variables)))"}
}

/// <p>The results of an operation to update or read environment variables. If the operation is successful, the
///       response contains the environment variables. If it failed, the response contains details about the error.</p>
public struct EnvironmentResponse: Equatable {
    /// <p>Error messages for environment variables that couldn't be applied.</p>
    public let error: EnvironmentError?
    /// <p>Environment variable key-value pairs.</p>
    public let variables: [String:String]?

    public init (
        error: EnvironmentError? = nil,
        variables: [String:String]? = nil
    )
    {
        self.error = error
        self.variables = variables
    }
}

extension EventSourceMappingConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let eventSourceArn = eventSourceArn {
            try encodeContainer.encode(eventSourceArn, forKey: .eventSourceArn)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let lastProcessingResult = lastProcessingResult {
            try encodeContainer.encode(lastProcessingResult, forKey: .lastProcessingResult)
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let queues = queues {
            var queuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .queues)
            for queues0 in queues {
                try queuesContainer.encode(queues0)
            }
        }
        if let selfManagedEventSource = selfManagedEventSource {
            try encodeContainer.encode(selfManagedEventSource, forKey: .selfManagedEventSource)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let startingPosition = startingPosition {
            try encodeContainer.encode(startingPosition.rawValue, forKey: .startingPosition)
        }
        if let startingPositionTimestamp = startingPositionTimestamp {
            try encodeContainer.encode(startingPositionTimestamp.timeIntervalSince1970, forKey: .startingPositionTimestamp)
        }
        if let state = state {
            try encodeContainer.encode(state, forKey: .state)
        }
        if let stateTransitionReason = stateTransitionReason {
            try encodeContainer.encode(stateTransitionReason, forKey: .stateTransitionReason)
        }
        if let topics = topics {
            var topicsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topics)
            for topics0 in topics {
                try topicsContainer.encode(topics0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
        if let uUID = uUID {
            try encodeContainer.encode(uUID, forKey: .uUID)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topics)
        var topicsDecoded0:[String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queues)
        var queuesDecoded0:[String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension EventSourceMappingConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "EventSourceMappingConfiguration(batchSize: \(String(describing: batchSize)), bisectBatchOnFunctionError: \(String(describing: bisectBatchOnFunctionError)), destinationConfig: \(String(describing: destinationConfig)), eventSourceArn: \(String(describing: eventSourceArn)), functionArn: \(String(describing: functionArn)), functionResponseTypes: \(String(describing: functionResponseTypes)), lastModified: \(String(describing: lastModified)), lastProcessingResult: \(String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), parallelizationFactor: \(String(describing: parallelizationFactor)), queues: \(String(describing: queues)), selfManagedEventSource: \(String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(String(describing: sourceAccessConfigurations)), startingPosition: \(String(describing: startingPosition)), startingPositionTimestamp: \(String(describing: startingPositionTimestamp)), state: \(String(describing: state)), stateTransitionReason: \(String(describing: stateTransitionReason)), topics: \(String(describing: topics)), tumblingWindowInSeconds: \(String(describing: tumblingWindowInSeconds)), uUID: \(String(describing: uUID)))"}
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
public struct EventSourceMappingConfiguration: Equatable {
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    public let batchSize: Int?
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    public let bisectBatchOnFunctionError: Bool?
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    public let eventSourceArn: String?
    /// <p>The ARN of the Lambda function.</p>
    public let functionArn: String?
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    public let functionResponseTypes: [FunctionResponseType]?
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    public let lastModified: Date?
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    public let lastProcessingResult: String?
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    public let maximumBatchingWindowInSeconds: Int?
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRecordAgeInSeconds: Int?
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRetryAttempts: Int?
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    public let parallelizationFactor: Int?
    /// <p>
    ///       (MQ) The name of the Amazon MQ broker destination queue to consume.
    ///     </p>
    public let queues: [String]?
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    public let selfManagedEventSource: SelfManagedEventSource?
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    ///       sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    public let startingPosition: EventSourcePosition?
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    ///       reading.</p>
    public let startingPositionTimestamp: Date?
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    ///       <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    ///       <code>Updating</code>, or <code>Deleting</code>.</p>
    public let state: String?
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    ///       service.</p>
    public let stateTransitionReason: String?
    /// <p>The name of the Kafka topic.</p>
    public let topics: [String]?
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    public let tumblingWindowInSeconds: Int?
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        batchSize: Int? = nil,
        bisectBatchOnFunctionError: Bool? = nil,
        destinationConfig: DestinationConfig? = nil,
        eventSourceArn: String? = nil,
        functionArn: String? = nil,
        functionResponseTypes: [FunctionResponseType]? = nil,
        lastModified: Date? = nil,
        lastProcessingResult: String? = nil,
        maximumBatchingWindowInSeconds: Int? = nil,
        maximumRecordAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        parallelizationFactor: Int? = nil,
        queues: [String]? = nil,
        selfManagedEventSource: SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [SourceAccessConfiguration]? = nil,
        startingPosition: EventSourcePosition? = nil,
        startingPositionTimestamp: Date? = nil,
        state: String? = nil,
        stateTransitionReason: String? = nil,
        topics: [String]? = nil,
        tumblingWindowInSeconds: Int? = nil,
        uUID: String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

public enum EventSourcePosition {
    case atTimestamp
    case latest
    case trimHorizon
    case sdkUnknown(String)
}

extension EventSourcePosition : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [EventSourcePosition] {
        return [
            .atTimestamp,
            .latest,
            .trimHorizon,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .atTimestamp: return "AT_TIMESTAMP"
        case .latest: return "LATEST"
        case .trimHorizon: return "TRIM_HORIZON"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = EventSourcePosition(rawValue: rawValue) ?? EventSourcePosition.sdkUnknown(rawValue)
    }
}

extension FileSystemConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case localMountPath = "LocalMountPath"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let localMountPath = localMountPath {
            try encodeContainer.encode(localMountPath, forKey: .localMountPath)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let localMountPathDecoded = try containerValues.decodeIfPresent(String.self, forKey: .localMountPath)
        localMountPath = localMountPathDecoded
    }
}

extension FileSystemConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FileSystemConfig(arn: \(String(describing: arn)), localMountPath: \(String(describing: localMountPath)))"}
}

/// <p>Details about the connection between a Lambda function and an Amazon EFS file system.</p>
public struct FileSystemConfig: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the Amazon EFS access point that provides access to the file system.</p>
    public let arn: String?
    /// <p>The path where the function can access the file system, starting with <code>/mnt/</code>.</p>
    public let localMountPath: String?

    public init (
        arn: String? = nil,
        localMountPath: String? = nil
    )
    {
        self.arn = arn
        self.localMountPath = localMountPath
    }
}

extension FunctionCode: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageUri = "ImageUri"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
    }
}

extension FunctionCode: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionCode(imageUri: \(String(describing: imageUri)), s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)), s3ObjectVersion: \(String(describing: s3ObjectVersion)), zipFile: \(String(describing: zipFile)))"}
}

/// <p>The code for the Lambda function. You can specify either an object in Amazon S3, upload a .zip file archive deployment
///       package directly, or specify the URI of a container image.</p>
public struct FunctionCode: Equatable {
    /// <p>URI of a container image in the Amazon ECR registry.</p>
    public let imageUri: String?
    /// <p>An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 key of the deployment package.</p>
    public let s3Key: String?
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    public let s3ObjectVersion: String?
    /// <p>The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the encoding for
    ///   you.</p>
    public let zipFile: Data?

    public init (
        imageUri: String? = nil,
        s3Bucket: String? = nil,
        s3Key: String? = nil,
        s3ObjectVersion: String? = nil,
        zipFile: Data? = nil
    )
    {
        self.imageUri = imageUri
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

extension FunctionCodeLocation: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case imageUri = "ImageUri"
        case location = "Location"
        case repositoryType = "RepositoryType"
        case resolvedImageUri = "ResolvedImageUri"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let repositoryType = repositoryType {
            try encodeContainer.encode(repositoryType, forKey: .repositoryType)
        }
        if let resolvedImageUri = resolvedImageUri {
            try encodeContainer.encode(resolvedImageUri, forKey: .resolvedImageUri)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryTypeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .repositoryType)
        repositoryType = repositoryTypeDecoded
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let resolvedImageUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .resolvedImageUri)
        resolvedImageUri = resolvedImageUriDecoded
    }
}

extension FunctionCodeLocation: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionCodeLocation(imageUri: \(String(describing: imageUri)), location: \(String(describing: location)), repositoryType: \(String(describing: repositoryType)), resolvedImageUri: \(String(describing: resolvedImageUri)))"}
}

/// <p>Details about a function's deployment package.</p>
public struct FunctionCodeLocation: Equatable {
    /// <p>URI of a container image in the Amazon ECR registry.</p>
    public let imageUri: String?
    /// <p>A presigned URL that you can use to download the deployment package.</p>
    public let location: String?
    /// <p>The service that's hosting the file.</p>
    public let repositoryType: String?
    /// <p>The resolved URI for the image.</p>
    public let resolvedImageUri: String?

    public init (
        imageUri: String? = nil,
        location: String? = nil,
        repositoryType: String? = nil,
        resolvedImageUri: String? = nil
    )
    {
        self.imageUri = imageUri
        self.location = location
        self.repositoryType = repositoryType
        self.resolvedImageUri = resolvedImageUri
    }
}

extension FunctionConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfigResponse = imageConfigResponse {
            try encodeContainer.encode(imageConfigResponse, forKey: .imageConfigResponse)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let lastUpdateStatus = lastUpdateStatus {
            try encodeContainer.encode(lastUpdateStatus.rawValue, forKey: .lastUpdateStatus)
        }
        if let lastUpdateStatusReason = lastUpdateStatusReason {
            try encodeContainer.encode(lastUpdateStatusReason, forKey: .lastUpdateStatusReason)
        }
        if let lastUpdateStatusReasonCode = lastUpdateStatusReasonCode {
            try encodeContainer.encode(lastUpdateStatusReasonCode.rawValue, forKey: .lastUpdateStatusReasonCode)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layersreferencelist0 in layers {
                try layersContainer.encode(layersreferencelist0)
            }
        }
        if let masterArn = masterArn {
            try encodeContainer.encode(masterArn, forKey: .masterArn)
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let packageType = packageType {
            try encodeContainer.encode(packageType.rawValue, forKey: .packageType)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
        if let state = state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let stateReason = stateReason {
            try encodeContainer.encode(stateReason, forKey: .stateReason)
        }
        if let stateReasonCode = stateReasonCode {
            try encodeContainer.encode(stateReasonCode.rawValue, forKey: .stateReasonCode)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let version = version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension FunctionConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionConfiguration(codeSha256: \(String(describing: codeSha256)), codeSize: \(String(describing: codeSize)), deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionArn: \(String(describing: functionArn)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfigResponse: \(String(describing: imageConfigResponse)), kMSKeyArn: \(String(describing: kMSKeyArn)), lastModified: \(String(describing: lastModified)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(String(describing: lastUpdateStatusReasonCode)), layers: \(String(describing: layers)), masterArn: \(String(describing: masterArn)), memorySize: \(String(describing: memorySize)), packageType: \(String(describing: packageType)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), version: \(String(describing: version)), vpcConfig: \(String(describing: vpcConfig)))"}
}

/// <p>Details about a function's configuration.</p>
public struct FunctionConfiguration: Equatable {
    /// <p>The SHA256 hash of the function's deployment package.</p>
    public let codeSha256: String?
    /// <p>The size of the function's deployment package, in bytes.</p>
    public let codeSize: Int
    /// <p>The function's dead letter queue.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>The function's description.</p>
    public let description: String?
    /// <p>The function's environment variables.</p>
    public let environment: EnvironmentResponse?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let functionArn: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The function that Lambda calls to begin executing your function.</p>
    public let handler: String?
    /// <p>The function's image configuration values.</p>
    public let imageConfigResponse: ImageConfigResponse?
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.</p>
    public let kMSKeyArn: String?
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let lastModified: String?
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    ///       after function creation completes.</p>
    public let lastUpdateStatus: LastUpdateStatus?
    /// <p>The reason for the last update that was performed on the function.</p>
    public let lastUpdateStatusReason: String?
    /// <p>The reason code for the last update that was performed on the function.</p>
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers</a>.</p>
    public let layers: [Layer]?
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    public let masterArn: String?
    /// <p>The amount of memory available to the function at runtime. </p>
    public let memorySize: Int?
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    public let packageType: PackageType?
    /// <p>The latest updated revision of the function or alias.</p>
    public let revisionId: String?
    /// <p>The function's execution role.</p>
    public let role: String?
    /// <p>The runtime environment for the Lambda function.</p>
    public let runtime: Runtime?
    /// <p>The ARN of the signing job.</p>
    public let signingJobArn: String?
    /// <p>The ARN of the signing profile version.</p>
    public let signingProfileVersionArn: String?
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    ///       invoking it.</p>
    public let state: State?
    /// <p>The reason for the function's current state.</p>
    public let stateReason: String?
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    ///       modify the function.</p>
    public let stateReasonCode: StateReasonCode?
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    public let timeout: Int?
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    public let tracingConfig: TracingConfigResponse?
    /// <p>The version of the Lambda function.</p>
    public let version: String?
    /// <p>The function's networking configuration.</p>
    public let vpcConfig: VpcConfigResponse?

    public init (
        codeSha256: String? = nil,
        codeSize: Int = 0,
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: EnvironmentResponse? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionArn: String? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfigResponse: ImageConfigResponse? = nil,
        kMSKeyArn: String? = nil,
        lastModified: String? = nil,
        lastUpdateStatus: LastUpdateStatus? = nil,
        lastUpdateStatusReason: String? = nil,
        lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil,
        layers: [Layer]? = nil,
        masterArn: String? = nil,
        memorySize: Int? = nil,
        packageType: PackageType? = nil,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: Runtime? = nil,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil,
        state: State? = nil,
        stateReason: String? = nil,
        stateReasonCode: StateReasonCode? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfigResponse? = nil,
        version: String? = nil,
        vpcConfig: VpcConfigResponse? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

extension FunctionEventInvokeConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified.timeIntervalSince1970, forKey: .lastModified)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension FunctionEventInvokeConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "FunctionEventInvokeConfig(destinationConfig: \(String(describing: destinationConfig)), functionArn: \(String(describing: functionArn)), lastModified: \(String(describing: lastModified)), maximumEventAgeInSeconds: \(String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)))"}
}

public struct FunctionEventInvokeConfig: Equatable {
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    ///          <p class="title">
    ///             <b>Destinations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Queue</b> - The ARN of an SQS queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Topic</b> - The ARN of an SNS topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    ///             </li>
    ///          </ul>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    public let functionArn: String?
    /// <p>The date and time that the configuration was last updated.</p>
    public let lastModified: Date?
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    public let maximumEventAgeInSeconds: Int?
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    public let maximumRetryAttempts: Int?

    public init (
        destinationConfig: DestinationConfig? = nil,
        functionArn: String? = nil,
        lastModified: Date? = nil,
        maximumEventAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

public enum FunctionResponseType {
    case reportbatchitemfailures
    case sdkUnknown(String)
}

extension FunctionResponseType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FunctionResponseType] {
        return [
            .reportbatchitemfailures,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .reportbatchitemfailures: return "ReportBatchItemFailures"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FunctionResponseType(rawValue: rawValue) ?? FunctionResponseType.sdkUnknown(rawValue)
    }
}

public enum FunctionVersion {
    case all
    case sdkUnknown(String)
}

extension FunctionVersion : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [FunctionVersion] {
        return [
            .all,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .all: return "ALL"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = FunctionVersion(rawValue: rawValue) ?? FunctionVersion.sdkUnknown(rawValue)
    }
}

extension GetAccountSettingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSettingsInput()"}
}

extension GetAccountSettingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAccountSettingsInputHeadersMiddleware: Middleware {
    public let id: String = "GetAccountSettingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAccountSettingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAccountSettingsInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAccountSettingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAccountSettingsInput>
    public typealias MOutput = OperationOutput<GetAccountSettingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAccountSettingsOutputError>
}

public struct GetAccountSettingsInput: Equatable {

    public init() {}
}

struct GetAccountSettingsInputBody: Equatable {
}

extension GetAccountSettingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAccountSettingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountSettingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAccountSettingsOutputError: Equatable {
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountSettingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAccountSettingsOutputResponse(accountLimit: \(String(describing: accountLimit)), accountUsage: \(String(describing: accountUsage)))"}
}

extension GetAccountSettingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAccountSettingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.accountLimit = output.accountLimit
            self.accountUsage = output.accountUsage
        } else {
            self.accountLimit = nil
            self.accountUsage = nil
        }
    }
}

public struct GetAccountSettingsOutputResponse: Equatable {
    /// <p>Limits that are related to concurrency and code storage.</p>
    public let accountLimit: AccountLimit?
    /// <p>The number of functions and amount of storage in use.</p>
    public let accountUsage: AccountUsage?

    public init (
        accountLimit: AccountLimit? = nil,
        accountUsage: AccountUsage? = nil
    )
    {
        self.accountLimit = accountLimit
        self.accountUsage = accountUsage
    }
}

struct GetAccountSettingsOutputResponseBody: Equatable {
    public let accountLimit: AccountLimit?
    public let accountUsage: AccountUsage?
}

extension GetAccountSettingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case accountLimit = "AccountLimit"
        case accountUsage = "AccountUsage"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountLimitDecoded = try containerValues.decodeIfPresent(AccountLimit.self, forKey: .accountLimit)
        accountLimit = accountLimitDecoded
        let accountUsageDecoded = try containerValues.decodeIfPresent(AccountUsage.self, forKey: .accountUsage)
        accountUsage = accountUsageDecoded
    }
}

extension GetAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAliasInput(functionName: \(String(describing: functionName)), name: \(String(describing: name)))"}
}

extension GetAliasInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetAliasInputHeadersMiddleware: Middleware {
    public let id: String = "GetAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAliasInput>
    public typealias MOutput = OperationOutput<GetAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAliasOutputError>
}

public struct GetAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "GetAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<GetAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetAliasInput>
    public typealias MOutput = OperationOutput<GetAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetAliasOutputError>
}

public struct GetAliasInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The name of the alias.</p>
    public let name: String?

    public init (
        functionName: String? = nil,
        name: String? = nil
    )
    {
        self.functionName = functionName
        self.name = name
    }
}

struct GetAliasInputBody: Equatable {
}

extension GetAliasInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetAliasOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetAliasOutputResponse(aliasArn: \(String(describing: aliasArn)), description: \(String(describing: description)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), routingConfig: \(String(describing: routingConfig)))"}
}

extension GetAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
public struct GetAliasOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    public let aliasArn: String?
    /// <p>A description of the alias.</p>
    public let description: String?
    /// <p>The function version that the alias invokes.</p>
    public let functionVersion: String?
    /// <p>The name of the alias.</p>
    public let name: String?
    /// <p>A unique identifier that changes when you update the alias.</p>
    public let revisionId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    ///         configuration</a> of the alias.</p>
    public let routingConfig: AliasRoutingConfiguration?

    public init (
        aliasArn: String? = nil,
        description: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        routingConfig: AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct GetAliasOutputResponseBody: Equatable {
    public let aliasArn: String?
    public let name: String?
    public let functionVersion: String?
    public let description: String?
    public let routingConfig: AliasRoutingConfiguration?
    public let revisionId: String?
}

extension GetAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCodeSigningConfigInput(codeSigningConfigArn: \(String(describing: codeSigningConfigArn)))"}
}

extension GetCodeSigningConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<GetCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCodeSigningConfigOutputError>
}

public struct GetCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<GetCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetCodeSigningConfigOutputError>
}

public struct GetCodeSigningConfigInput: Equatable {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration. </p>
    public let codeSigningConfigArn: String?

    public init (
        codeSigningConfigArn: String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
    }
}

struct GetCodeSigningConfigInputBody: Equatable {
}

extension GetCodeSigningConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetCodeSigningConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetCodeSigningConfigOutputResponse(codeSigningConfig: \(String(describing: codeSigningConfig)))"}
}

extension GetCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct GetCodeSigningConfigOutputResponse: Equatable {
    /// <p>The code signing configuration</p>
    public let codeSigningConfig: CodeSigningConfig?

    public init (
        codeSigningConfig: CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct GetCodeSigningConfigOutputResponseBody: Equatable {
    public let codeSigningConfig: CodeSigningConfig?
}

extension GetCodeSigningConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

extension GetEventSourceMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventSourceMappingInput(uUID: \(String(describing: uUID)))"}
}

extension GetEventSourceMappingInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetEventSourceMappingInputHeadersMiddleware: Middleware {
    public let id: String = "GetEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventSourceMappingInput>
    public typealias MOutput = OperationOutput<GetEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventSourceMappingOutputError>
}

public struct GetEventSourceMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "GetEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<GetEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetEventSourceMappingInput>
    public typealias MOutput = OperationOutput<GetEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetEventSourceMappingOutputError>
}

public struct GetEventSourceMappingInput: Equatable {
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        uUID: String? = nil
    )
    {
        self.uUID = uUID
    }
}

struct GetEventSourceMappingInputBody: Equatable {
}

extension GetEventSourceMappingInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetEventSourceMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEventSourceMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetEventSourceMappingOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEventSourceMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetEventSourceMappingOutputResponse(batchSize: \(String(describing: batchSize)), bisectBatchOnFunctionError: \(String(describing: bisectBatchOnFunctionError)), destinationConfig: \(String(describing: destinationConfig)), eventSourceArn: \(String(describing: eventSourceArn)), functionArn: \(String(describing: functionArn)), functionResponseTypes: \(String(describing: functionResponseTypes)), lastModified: \(String(describing: lastModified)), lastProcessingResult: \(String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), parallelizationFactor: \(String(describing: parallelizationFactor)), queues: \(String(describing: queues)), selfManagedEventSource: \(String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(String(describing: sourceAccessConfigurations)), startingPosition: \(String(describing: startingPosition)), startingPositionTimestamp: \(String(describing: startingPositionTimestamp)), state: \(String(describing: state)), stateTransitionReason: \(String(describing: stateTransitionReason)), topics: \(String(describing: topics)), tumblingWindowInSeconds: \(String(describing: tumblingWindowInSeconds)), uUID: \(String(describing: uUID)))"}
}

extension GetEventSourceMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
public struct GetEventSourceMappingOutputResponse: Equatable {
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    public let batchSize: Int?
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    public let bisectBatchOnFunctionError: Bool?
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    public let eventSourceArn: String?
    /// <p>The ARN of the Lambda function.</p>
    public let functionArn: String?
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    public let functionResponseTypes: [FunctionResponseType]?
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    public let lastModified: Date?
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    public let lastProcessingResult: String?
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    public let maximumBatchingWindowInSeconds: Int?
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRecordAgeInSeconds: Int?
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRetryAttempts: Int?
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    public let parallelizationFactor: Int?
    /// <p>
    ///       (MQ) The name of the Amazon MQ broker destination queue to consume.
    ///     </p>
    public let queues: [String]?
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    public let selfManagedEventSource: SelfManagedEventSource?
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    ///       sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    public let startingPosition: EventSourcePosition?
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    ///       reading.</p>
    public let startingPositionTimestamp: Date?
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    ///       <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    ///       <code>Updating</code>, or <code>Deleting</code>.</p>
    public let state: String?
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    ///       service.</p>
    public let stateTransitionReason: String?
    /// <p>The name of the Kafka topic.</p>
    public let topics: [String]?
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    public let tumblingWindowInSeconds: Int?
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        batchSize: Int? = nil,
        bisectBatchOnFunctionError: Bool? = nil,
        destinationConfig: DestinationConfig? = nil,
        eventSourceArn: String? = nil,
        functionArn: String? = nil,
        functionResponseTypes: [FunctionResponseType]? = nil,
        lastModified: Date? = nil,
        lastProcessingResult: String? = nil,
        maximumBatchingWindowInSeconds: Int? = nil,
        maximumRecordAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        parallelizationFactor: Int? = nil,
        queues: [String]? = nil,
        selfManagedEventSource: SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [SourceAccessConfiguration]? = nil,
        startingPosition: EventSourcePosition? = nil,
        startingPositionTimestamp: Date? = nil,
        state: String? = nil,
        stateTransitionReason: String? = nil,
        topics: [String]? = nil,
        tumblingWindowInSeconds: Int? = nil,
        uUID: String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct GetEventSourceMappingOutputResponseBody: Equatable {
    public let uUID: String?
    public let startingPosition: EventSourcePosition?
    public let startingPositionTimestamp: Date?
    public let batchSize: Int?
    public let maximumBatchingWindowInSeconds: Int?
    public let parallelizationFactor: Int?
    public let eventSourceArn: String?
    public let functionArn: String?
    public let lastModified: Date?
    public let lastProcessingResult: String?
    public let state: String?
    public let stateTransitionReason: String?
    public let destinationConfig: DestinationConfig?
    public let topics: [String]?
    public let queues: [String]?
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    public let selfManagedEventSource: SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Int?
    public let bisectBatchOnFunctionError: Bool?
    public let maximumRetryAttempts: Int?
    public let tumblingWindowInSeconds: Int?
    public let functionResponseTypes: [FunctionResponseType]?
}

extension GetEventSourceMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topics)
        var topicsDecoded0:[String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queues)
        var queuesDecoded0:[String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension GetFunctionCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionCodeSigningConfigInput(functionName: \(String(describing: functionName)))"}
}

extension GetFunctionCodeSigningConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<GetFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionCodeSigningConfigOutputError>
}

public struct GetFunctionCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<GetFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionCodeSigningConfigOutputError>
}

public struct GetFunctionCodeSigningConfigInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?

    public init (
        functionName: String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigInputBody: Equatable {
}

extension GetFunctionCodeSigningConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionCodeSigningConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionCodeSigningConfigOutputResponse(codeSigningConfigArn: \(String(describing: codeSigningConfigArn)), functionName: \(String(describing: functionName)))"}
}

extension GetFunctionCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct GetFunctionCodeSigningConfigOutputResponse: Equatable {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    public let codeSigningConfigArn: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?

    public init (
        codeSigningConfigArn: String? = nil,
        functionName: String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct GetFunctionCodeSigningConfigOutputResponseBody: Equatable {
    public let codeSigningConfigArn: String?
    public let functionName: String?
}

extension GetFunctionCodeSigningConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

extension GetFunctionConcurrencyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionConcurrencyInput(functionName: \(String(describing: functionName)))"}
}

extension GetFunctionConcurrencyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionConcurrencyInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionConcurrencyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionConcurrencyInput>
    public typealias MOutput = OperationOutput<GetFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionConcurrencyOutputError>
}

public struct GetFunctionConcurrencyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionConcurrencyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionConcurrencyInput>
    public typealias MOutput = OperationOutput<GetFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionConcurrencyOutputError>
}

public struct GetFunctionConcurrencyInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?

    public init (
        functionName: String? = nil
    )
    {
        self.functionName = functionName
    }
}

struct GetFunctionConcurrencyInputBody: Equatable {
}

extension GetFunctionConcurrencyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionConcurrencyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionConcurrencyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionConcurrencyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionConcurrencyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionConcurrencyOutputResponse(reservedConcurrentExecutions: \(String(describing: reservedConcurrentExecutions)))"}
}

extension GetFunctionConcurrencyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionConcurrencyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct GetFunctionConcurrencyOutputResponse: Equatable {
    /// <p>The number of simultaneous executions that are reserved for the function.</p>
    public let reservedConcurrentExecutions: Int?

    public init (
        reservedConcurrentExecutions: Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct GetFunctionConcurrencyOutputResponseBody: Equatable {
    public let reservedConcurrentExecutions: Int?
}

extension GetFunctionConcurrencyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension GetFunctionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionConfigurationInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension GetFunctionConfigurationInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionConfigurationInput>
    public typealias MOutput = OperationOutput<GetFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionConfigurationOutputError>
}

public struct GetFunctionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionConfigurationInput>
    public typealias MOutput = OperationOutput<GetFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionConfigurationOutputError>
}

public struct GetFunctionConfigurationInput: Equatable {
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>Specify a version or alias to get details about a published version of the function.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionConfigurationInputBody: Equatable {
}

extension GetFunctionConfigurationInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionConfigurationOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionConfigurationOutputResponse(codeSha256: \(String(describing: codeSha256)), codeSize: \(String(describing: codeSize)), deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionArn: \(String(describing: functionArn)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfigResponse: \(String(describing: imageConfigResponse)), kMSKeyArn: \(String(describing: kMSKeyArn)), lastModified: \(String(describing: lastModified)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(String(describing: lastUpdateStatusReasonCode)), layers: \(String(describing: layers)), masterArn: \(String(describing: masterArn)), memorySize: \(String(describing: memorySize)), packageType: \(String(describing: packageType)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), version: \(String(describing: version)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension GetFunctionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// <p>Details about a function's configuration.</p>
public struct GetFunctionConfigurationOutputResponse: Equatable {
    /// <p>The SHA256 hash of the function's deployment package.</p>
    public let codeSha256: String?
    /// <p>The size of the function's deployment package, in bytes.</p>
    public let codeSize: Int
    /// <p>The function's dead letter queue.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>The function's description.</p>
    public let description: String?
    /// <p>The function's environment variables.</p>
    public let environment: EnvironmentResponse?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let functionArn: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The function that Lambda calls to begin executing your function.</p>
    public let handler: String?
    /// <p>The function's image configuration values.</p>
    public let imageConfigResponse: ImageConfigResponse?
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.</p>
    public let kMSKeyArn: String?
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let lastModified: String?
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    ///       after function creation completes.</p>
    public let lastUpdateStatus: LastUpdateStatus?
    /// <p>The reason for the last update that was performed on the function.</p>
    public let lastUpdateStatusReason: String?
    /// <p>The reason code for the last update that was performed on the function.</p>
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers</a>.</p>
    public let layers: [Layer]?
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    public let masterArn: String?
    /// <p>The amount of memory available to the function at runtime. </p>
    public let memorySize: Int?
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    public let packageType: PackageType?
    /// <p>The latest updated revision of the function or alias.</p>
    public let revisionId: String?
    /// <p>The function's execution role.</p>
    public let role: String?
    /// <p>The runtime environment for the Lambda function.</p>
    public let runtime: Runtime?
    /// <p>The ARN of the signing job.</p>
    public let signingJobArn: String?
    /// <p>The ARN of the signing profile version.</p>
    public let signingProfileVersionArn: String?
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    ///       invoking it.</p>
    public let state: State?
    /// <p>The reason for the function's current state.</p>
    public let stateReason: String?
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    ///       modify the function.</p>
    public let stateReasonCode: StateReasonCode?
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    public let timeout: Int?
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    public let tracingConfig: TracingConfigResponse?
    /// <p>The version of the Lambda function.</p>
    public let version: String?
    /// <p>The function's networking configuration.</p>
    public let vpcConfig: VpcConfigResponse?

    public init (
        codeSha256: String? = nil,
        codeSize: Int = 0,
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: EnvironmentResponse? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionArn: String? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfigResponse: ImageConfigResponse? = nil,
        kMSKeyArn: String? = nil,
        lastModified: String? = nil,
        lastUpdateStatus: LastUpdateStatus? = nil,
        lastUpdateStatusReason: String? = nil,
        lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil,
        layers: [Layer]? = nil,
        masterArn: String? = nil,
        memorySize: Int? = nil,
        packageType: PackageType? = nil,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: Runtime? = nil,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil,
        state: State? = nil,
        stateReason: String? = nil,
        stateReasonCode: StateReasonCode? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfigResponse? = nil,
        version: String? = nil,
        vpcConfig: VpcConfigResponse? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct GetFunctionConfigurationOutputResponseBody: Equatable {
    public let functionName: String?
    public let functionArn: String?
    public let runtime: Runtime?
    public let role: String?
    public let handler: String?
    public let codeSize: Int
    public let description: String?
    public let timeout: Int?
    public let memorySize: Int?
    public let lastModified: String?
    public let codeSha256: String?
    public let version: String?
    public let vpcConfig: VpcConfigResponse?
    public let deadLetterConfig: DeadLetterConfig?
    public let environment: EnvironmentResponse?
    public let kMSKeyArn: String?
    public let tracingConfig: TracingConfigResponse?
    public let masterArn: String?
    public let revisionId: String?
    public let layers: [Layer]?
    public let state: State?
    public let stateReason: String?
    public let stateReasonCode: StateReasonCode?
    public let lastUpdateStatus: LastUpdateStatus?
    public let lastUpdateStatusReason: String?
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [FileSystemConfig]?
    public let packageType: PackageType?
    public let imageConfigResponse: ImageConfigResponse?
    public let signingProfileVersionArn: String?
    public let signingJobArn: String?
}

extension GetFunctionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension GetFunctionEventInvokeConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionEventInvokeConfigInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension GetFunctionEventInvokeConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionEventInvokeConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<GetFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionEventInvokeConfigOutputError>
}

public struct GetFunctionEventInvokeConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<GetFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionEventInvokeConfigOutputError>
}

public struct GetFunctionEventInvokeConfigInput: Equatable {
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>A version number or alias name.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionEventInvokeConfigInputBody: Equatable {
}

extension GetFunctionEventInvokeConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionEventInvokeConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionEventInvokeConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionEventInvokeConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionEventInvokeConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionEventInvokeConfigOutputResponse(destinationConfig: \(String(describing: destinationConfig)), functionArn: \(String(describing: functionArn)), lastModified: \(String(describing: lastModified)), maximumEventAgeInSeconds: \(String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)))"}
}

extension GetFunctionEventInvokeConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct GetFunctionEventInvokeConfigOutputResponse: Equatable {
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    ///          <p class="title">
    ///             <b>Destinations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Queue</b> - The ARN of an SQS queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Topic</b> - The ARN of an SNS topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    ///             </li>
    ///          </ul>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    public let functionArn: String?
    /// <p>The date and time that the configuration was last updated.</p>
    public let lastModified: Date?
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    public let maximumEventAgeInSeconds: Int?
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    public let maximumRetryAttempts: Int?

    public init (
        destinationConfig: DestinationConfig? = nil,
        functionArn: String? = nil,
        lastModified: Date? = nil,
        maximumEventAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct GetFunctionEventInvokeConfigOutputResponseBody: Equatable {
    public let lastModified: Date?
    public let functionArn: String?
    public let maximumRetryAttempts: Int?
    public let maximumEventAgeInSeconds: Int?
    public let destinationConfig: DestinationConfig?
}

extension GetFunctionEventInvokeConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension GetFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension GetFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "GetFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionInput>
    public typealias MOutput = OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionOutputError>
}

public struct GetFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetFunctionInput>
    public typealias MOutput = OperationOutput<GetFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetFunctionOutputError>
}

public struct GetFunctionInput: Equatable {
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>Specify a version or alias to get details about a published version of the function.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetFunctionInputBody: Equatable {
}

extension GetFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetFunctionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetFunctionOutputResponse(code: \(String(describing: code)), concurrency: \(String(describing: concurrency)), configuration: \(String(describing: configuration)), tags: \(String(describing: tags)))"}
}

extension GetFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.code = output.code
            self.concurrency = output.concurrency
            self.configuration = output.configuration
            self.tags = output.tags
        } else {
            self.code = nil
            self.concurrency = nil
            self.configuration = nil
            self.tags = nil
        }
    }
}

public struct GetFunctionOutputResponse: Equatable {
    /// <p>The deployment package of the function or version.</p>
    public let code: FunctionCodeLocation?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">reserved
    ///         concurrency</a>.</p>
    public let concurrency: Concurrency?
    /// <p>The configuration of the function or version.</p>
    public let configuration: FunctionConfiguration?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/tagging.html">tags</a>.</p>
    public let tags: [String:String]?

    public init (
        code: FunctionCodeLocation? = nil,
        concurrency: Concurrency? = nil,
        configuration: FunctionConfiguration? = nil,
        tags: [String:String]? = nil
    )
    {
        self.code = code
        self.concurrency = concurrency
        self.configuration = configuration
        self.tags = tags
    }
}

struct GetFunctionOutputResponseBody: Equatable {
    public let configuration: FunctionConfiguration?
    public let code: FunctionCodeLocation?
    public let tags: [String:String]?
    public let concurrency: Concurrency?
}

extension GetFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case code = "Code"
        case concurrency = "Concurrency"
        case configuration = "Configuration"
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(FunctionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let codeDecoded = try containerValues.decodeIfPresent(FunctionCodeLocation.self, forKey: .code)
        code = codeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let concurrencyDecoded = try containerValues.decodeIfPresent(Concurrency.self, forKey: .concurrency)
        concurrency = concurrencyDecoded
    }
}

extension GetLayerVersionByArnInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLayerVersionByArnInput(arn: \(String(describing: arn)))"}
}

extension GetLayerVersionByArnInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLayerVersionByArnInputHeadersMiddleware: Middleware {
    public let id: String = "GetLayerVersionByArnInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLayerVersionByArnInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLayerVersionByArnOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLayerVersionByArnInput>
    public typealias MOutput = OperationOutput<GetLayerVersionByArnOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLayerVersionByArnOutputError>
}

public struct GetLayerVersionByArnInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLayerVersionByArnInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLayerVersionByArnInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLayerVersionByArnOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "find", value: "LayerVersion"))
        if let arn = input.operationInput.arn {
            let arnQueryItem = URLQueryItem(name: "Arn".urlPercentEncoding(), value: String(arn).urlPercentEncoding())
            input.builder.withQueryItem(arnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLayerVersionByArnInput>
    public typealias MOutput = OperationOutput<GetLayerVersionByArnOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLayerVersionByArnOutputError>
}

public struct GetLayerVersionByArnInput: Equatable {
    /// <p>The ARN of the layer version.</p>
    public let arn: String?

    public init (
        arn: String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetLayerVersionByArnInputBody: Equatable {
}

extension GetLayerVersionByArnInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLayerVersionByArnOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionByArnOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionByArnOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionByArnOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLayerVersionByArnOutputResponse(compatibleRuntimes: \(String(describing: compatibleRuntimes)), content: \(String(describing: content)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), layerArn: \(String(describing: layerArn)), layerVersionArn: \(String(describing: layerVersionArn)), licenseInfo: \(String(describing: licenseInfo)), version: \(String(describing: version)))"}
}

extension GetLayerVersionByArnOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLayerVersionByArnOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionByArnOutputResponse: Equatable {
    /// <p>The layer's compatible runtimes.</p>
    public let compatibleRuntimes: [Runtime]?
    /// <p>Details about the layer version.</p>
    public let content: LayerVersionContentOutput?
    /// <p>The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let createdDate: String?
    /// <p>The description of the version.</p>
    public let description: String?
    /// <p>The ARN of the layer.</p>
    public let layerArn: String?
    /// <p>The ARN of the layer version.</p>
    public let layerVersionArn: String?
    /// <p>The layer's software license.</p>
    public let licenseInfo: String?
    /// <p>The version number.</p>
    public let version: Int

    public init (
        compatibleRuntimes: [Runtime]? = nil,
        content: LayerVersionContentOutput? = nil,
        createdDate: String? = nil,
        description: String? = nil,
        layerArn: String? = nil,
        layerVersionArn: String? = nil,
        licenseInfo: String? = nil,
        version: Int = 0
    )
    {
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionByArnOutputResponseBody: Equatable {
    public let content: LayerVersionContentOutput?
    public let layerArn: String?
    public let layerVersionArn: String?
    public let description: String?
    public let createdDate: String?
    public let version: Int
    public let compatibleRuntimes: [Runtime]?
    public let licenseInfo: String?
}

extension GetLayerVersionByArnOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
    }
}

extension GetLayerVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLayerVersionInput(layerName: \(String(describing: layerName)), versionNumber: \(String(describing: versionNumber)))"}
}

extension GetLayerVersionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLayerVersionInputHeadersMiddleware: Middleware {
    public let id: String = "GetLayerVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLayerVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLayerVersionInput>
    public typealias MOutput = OperationOutput<GetLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLayerVersionOutputError>
}

public struct GetLayerVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLayerVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLayerVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLayerVersionInput>
    public typealias MOutput = OperationOutput<GetLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLayerVersionOutputError>
}

public struct GetLayerVersionInput: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
    public let layerName: String?
    /// <p>The version number.</p>
    public let versionNumber: Int

    public init (
        layerName: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionInputBody: Equatable {
}

extension GetLayerVersionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLayerVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLayerVersionOutputResponse(compatibleRuntimes: \(String(describing: compatibleRuntimes)), content: \(String(describing: content)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), layerArn: \(String(describing: layerArn)), layerVersionArn: \(String(describing: layerVersionArn)), licenseInfo: \(String(describing: licenseInfo)), version: \(String(describing: version)))"}
}

extension GetLayerVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLayerVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct GetLayerVersionOutputResponse: Equatable {
    /// <p>The layer's compatible runtimes.</p>
    public let compatibleRuntimes: [Runtime]?
    /// <p>Details about the layer version.</p>
    public let content: LayerVersionContentOutput?
    /// <p>The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let createdDate: String?
    /// <p>The description of the version.</p>
    public let description: String?
    /// <p>The ARN of the layer.</p>
    public let layerArn: String?
    /// <p>The ARN of the layer version.</p>
    public let layerVersionArn: String?
    /// <p>The layer's software license.</p>
    public let licenseInfo: String?
    /// <p>The version number.</p>
    public let version: Int

    public init (
        compatibleRuntimes: [Runtime]? = nil,
        content: LayerVersionContentOutput? = nil,
        createdDate: String? = nil,
        description: String? = nil,
        layerArn: String? = nil,
        layerVersionArn: String? = nil,
        licenseInfo: String? = nil,
        version: Int = 0
    )
    {
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct GetLayerVersionOutputResponseBody: Equatable {
    public let content: LayerVersionContentOutput?
    public let layerArn: String?
    public let layerVersionArn: String?
    public let description: String?
    public let createdDate: String?
    public let version: Int
    public let compatibleRuntimes: [Runtime]?
    public let licenseInfo: String?
}

extension GetLayerVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
    }
}

extension GetLayerVersionPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLayerVersionPolicyInput(layerName: \(String(describing: layerName)), versionNumber: \(String(describing: versionNumber)))"}
}

extension GetLayerVersionPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetLayerVersionPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetLayerVersionPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLayerVersionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLayerVersionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLayerVersionPolicyInput>
    public typealias MOutput = OperationOutput<GetLayerVersionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLayerVersionPolicyOutputError>
}

public struct GetLayerVersionPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetLayerVersionPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetLayerVersionPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetLayerVersionPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetLayerVersionPolicyInput>
    public typealias MOutput = OperationOutput<GetLayerVersionPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetLayerVersionPolicyOutputError>
}

public struct GetLayerVersionPolicyInput: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
    public let layerName: String?
    /// <p>The version number.</p>
    public let versionNumber: Int

    public init (
        layerName: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.layerName = layerName
        self.versionNumber = versionNumber
    }
}

struct GetLayerVersionPolicyInputBody: Equatable {
}

extension GetLayerVersionPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetLayerVersionPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetLayerVersionPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetLayerVersionPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetLayerVersionPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetLayerVersionPolicyOutputResponse(policy: \(String(describing: policy)), revisionId: \(String(describing: revisionId)))"}
}

extension GetLayerVersionPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetLayerVersionPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetLayerVersionPolicyOutputResponse: Equatable {
    /// <p>The policy document.</p>
    public let policy: String?
    /// <p>A unique identifier for the current revision of the policy.</p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetLayerVersionPolicyOutputResponseBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension GetLayerVersionPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetPolicyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension GetPolicyInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetPolicyInputHeadersMiddleware: Middleware {
    public let id: String = "GetPolicyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInputQueryItemMiddleware: Middleware {
    public let id: String = "GetPolicyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetPolicyInput>,
                  next: H) -> Swift.Result<OperationOutput<GetPolicyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetPolicyInput>
    public typealias MOutput = OperationOutput<GetPolicyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetPolicyOutputError>
}

public struct GetPolicyInput: Equatable {
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>Specify a version or alias to get the policy for that resource.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetPolicyInputBody: Equatable {
}

extension GetPolicyInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetPolicyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPolicyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetPolicyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPolicyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetPolicyOutputResponse(policy: \(String(describing: policy)), revisionId: \(String(describing: revisionId)))"}
}

extension GetPolicyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetPolicyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.policy = output.policy
            self.revisionId = output.revisionId
        } else {
            self.policy = nil
            self.revisionId = nil
        }
    }
}

public struct GetPolicyOutputResponse: Equatable {
    /// <p>The resource-based policy.</p>
    public let policy: String?
    /// <p>A unique identifier for the current revision of the policy.</p>
    public let revisionId: String?

    public init (
        policy: String? = nil,
        revisionId: String? = nil
    )
    {
        self.policy = policy
        self.revisionId = revisionId
    }
}

struct GetPolicyOutputResponseBody: Equatable {
    public let policy: String?
    public let revisionId: String?
}

extension GetPolicyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case policy = "Policy"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .policy)
        policy = policyDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension GetProvisionedConcurrencyConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProvisionedConcurrencyConfigInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)))"}
}

extension GetProvisionedConcurrencyConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct GetProvisionedConcurrencyConfigInputHeadersMiddleware: Middleware {
    public let id: String = "GetProvisionedConcurrencyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProvisionedConcurrencyConfigInput>
    public typealias MOutput = OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProvisionedConcurrencyConfigOutputError>
}

public struct GetProvisionedConcurrencyConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "GetProvisionedConcurrencyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<GetProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<GetProvisionedConcurrencyConfigInput>
    public typealias MOutput = OperationOutput<GetProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<GetProvisionedConcurrencyConfigOutputError>
}

public struct GetProvisionedConcurrencyConfigInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The version number or alias name.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
    }
}

struct GetProvisionedConcurrencyConfigInputBody: Equatable {
}

extension GetProvisionedConcurrencyConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension GetProvisionedConcurrencyConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProvisionedConcurrencyConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ProvisionedConcurrencyConfigNotFoundException" : self = .provisionedConcurrencyConfigNotFoundException(try ProvisionedConcurrencyConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum GetProvisionedConcurrencyConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case provisionedConcurrencyConfigNotFoundException(ProvisionedConcurrencyConfigNotFoundException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProvisionedConcurrencyConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "GetProvisionedConcurrencyConfigOutputResponse(allocatedProvisionedConcurrentExecutions: \(String(describing: allocatedProvisionedConcurrentExecutions)), availableProvisionedConcurrentExecutions: \(String(describing: availableProvisionedConcurrentExecutions)), lastModified: \(String(describing: lastModified)), requestedProvisionedConcurrentExecutions: \(String(describing: requestedProvisionedConcurrentExecutions)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

extension GetProvisionedConcurrencyConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: GetProvisionedConcurrencyConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct GetProvisionedConcurrencyConfigOutputResponse: Equatable {
    /// <p>The amount of provisioned concurrency allocated.</p>
    public let allocatedProvisionedConcurrentExecutions: Int?
    /// <p>The amount of provisioned concurrency available.</p>
    public let availableProvisionedConcurrentExecutions: Int?
    /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
    public let lastModified: String?
    /// <p>The amount of provisioned concurrency requested.</p>
    public let requestedProvisionedConcurrentExecutions: Int?
    /// <p>The status of the allocation process.</p>
    public let status: ProvisionedConcurrencyStatusEnum?
    /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
    public let statusReason: String?

    public init (
        allocatedProvisionedConcurrentExecutions: Int? = nil,
        availableProvisionedConcurrentExecutions: Int? = nil,
        lastModified: String? = nil,
        requestedProvisionedConcurrentExecutions: Int? = nil,
        status: ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct GetProvisionedConcurrencyConfigOutputResponseBody: Equatable {
    public let requestedProvisionedConcurrentExecutions: Int?
    public let availableProvisionedConcurrentExecutions: Int?
    public let allocatedProvisionedConcurrentExecutions: Int?
    public let status: ProvisionedConcurrencyStatusEnum?
    public let statusReason: String?
    public let lastModified: String?
}

extension GetProvisionedConcurrencyConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension ImageConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case command = "Command"
        case entryPoint = "EntryPoint"
        case workingDirectory = "WorkingDirectory"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = command {
            var commandContainer = encodeContainer.nestedUnkeyedContainer(forKey: .command)
            for stringlist0 in command {
                try commandContainer.encode(stringlist0)
            }
        }
        if let entryPoint = entryPoint {
            var entryPointContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entryPoint)
            for stringlist0 in entryPoint {
                try entryPointContainer.encode(stringlist0)
            }
        }
        if let workingDirectory = workingDirectory {
            try encodeContainer.encode(workingDirectory, forKey: .workingDirectory)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryPointContainer = try containerValues.decodeIfPresent([String?].self, forKey: .entryPoint)
        var entryPointDecoded0:[String]? = nil
        if let entryPointContainer = entryPointContainer {
            entryPointDecoded0 = [String]()
            for string0 in entryPointContainer {
                if let string0 = string0 {
                    entryPointDecoded0?.append(string0)
                }
            }
        }
        entryPoint = entryPointDecoded0
        let commandContainer = try containerValues.decodeIfPresent([String?].self, forKey: .command)
        var commandDecoded0:[String]? = nil
        if let commandContainer = commandContainer {
            commandDecoded0 = [String]()
            for string0 in commandContainer {
                if let string0 = string0 {
                    commandDecoded0?.append(string0)
                }
            }
        }
        command = commandDecoded0
        let workingDirectoryDecoded = try containerValues.decodeIfPresent(String.self, forKey: .workingDirectory)
        workingDirectory = workingDirectoryDecoded
    }
}

extension ImageConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageConfig(command: \(String(describing: command)), entryPoint: \(String(describing: entryPoint)), workingDirectory: \(String(describing: workingDirectory)))"}
}

/// <p>Configuration values that override the container image Dockerfile settings. See
///       <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-create.html#images-parms">Container settings</a>. </p>
public struct ImageConfig: Equatable {
    /// <p>Specifies parameters that you want to pass in with ENTRYPOINT. </p>
    public let command: [String]?
    /// <p>Specifies the entry point to their application, which is typically the location of the runtime
    ///       executable.</p>
    public let entryPoint: [String]?
    /// <p>Specifies the working directory.</p>
    public let workingDirectory: String?

    public init (
        command: [String]? = nil,
        entryPoint: [String]? = nil,
        workingDirectory: String? = nil
    )
    {
        self.command = command
        self.entryPoint = entryPoint
        self.workingDirectory = workingDirectory
    }
}

extension ImageConfigError: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case errorCode = "ErrorCode"
        case message = "Message"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let message = message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ImageConfigError: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageConfigError(errorCode: \(String(describing: errorCode)), message: \(String(describing: message)))"}
}

/// <p>Error response to GetFunctionConfiguration.</p>
public struct ImageConfigError: Equatable {
    /// <p>Error code.</p>
    public let errorCode: String?
    /// <p>Error message.</p>
    public let message: String?

    public init (
        errorCode: String? = nil,
        message: String? = nil
    )
    {
        self.errorCode = errorCode
        self.message = message
    }
}

extension ImageConfigResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case error = "Error"
        case imageConfig = "ImageConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageConfigDecoded = try containerValues.decodeIfPresent(ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
        let errorDecoded = try containerValues.decodeIfPresent(ImageConfigError.self, forKey: .error)
        error = errorDecoded
    }
}

extension ImageConfigResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ImageConfigResponse(error: \(String(describing: error)), imageConfig: \(String(describing: imageConfig)))"}
}

/// <p>Response to GetFunctionConfiguration request.</p>
public struct ImageConfigResponse: Equatable {
    /// <p>Error response to GetFunctionConfiguration.</p>
    public let error: ImageConfigError?
    /// <p>Configuration values that override the container image Dockerfile.</p>
    public let imageConfig: ImageConfig?

    public init (
        error: ImageConfigError? = nil,
        imageConfig: ImageConfig? = nil
    )
    {
        self.error = error
        self.imageConfig = imageConfig
    }
}

extension InvalidCodeSignatureException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidCodeSignatureException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidCodeSignatureException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidCodeSignatureExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The code signature failed the integrity check. Lambda always blocks deployment if the integrity check
///       fails, even if code signing policy is set to WARN.</p>
public struct InvalidCodeSignatureException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidCodeSignatureExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension InvalidCodeSignatureExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterValueException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidParameterValueException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension InvalidParameterValueException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidParameterValueExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>One of the parameters in the request is invalid.</p>
public struct InvalidParameterValueException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?
    /// <p>The exception type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidParameterValueExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension InvalidParameterValueExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRequestContentException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRequestContentException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension InvalidRequestContentException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRequestContentExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request body could not be parsed as JSON.</p>
public struct InvalidRequestContentException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?
    /// <p>The exception type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidRequestContentExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension InvalidRequestContentExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidRuntimeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidRuntimeException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidRuntimeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidRuntimeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The runtime or runtime version specified is not supported.</p>
public struct InvalidRuntimeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidRuntimeExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension InvalidRuntimeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSecurityGroupIDException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSecurityGroupIDException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidSecurityGroupIDException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSecurityGroupIDExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Security Group ID provided in the Lambda function VPC configuration is invalid.</p>
public struct InvalidSecurityGroupIDException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidSecurityGroupIDExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension InvalidSecurityGroupIDExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidSubnetIDException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidSubnetIDException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidSubnetIDException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidSubnetIDExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The Subnet ID provided in the Lambda function VPC configuration is invalid.</p>
public struct InvalidSubnetIDException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidSubnetIDExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension InvalidSubnetIDExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidZipFileException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvalidZipFileException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension InvalidZipFileException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: InvalidZipFileExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Lambda could not unzip the deployment package.</p>
public struct InvalidZipFileException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InvalidZipFileExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension InvalidZipFileExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum InvocationType {
    case dryrun
    case event
    case requestresponse
    case sdkUnknown(String)
}

extension InvocationType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [InvocationType] {
        return [
            .dryrun,
            .event,
            .requestresponse,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dryrun: return "DryRun"
        case .event: return "Event"
        case .requestresponse: return "RequestResponse"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = InvocationType(rawValue: rawValue) ?? InvocationType.sdkUnknown(rawValue)
    }
}

public struct InvokeAsyncInputBodyMiddleware: Middleware {
    public let id: String = "InvokeAsyncInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeAsyncInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let invokeArgs = input.operationInput.invokeArgs {
            let data = invokeArgs
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeAsyncOutputError>
}

extension InvokeAsyncInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvokeAsyncInput(functionName: \(String(describing: functionName)), invokeArgs: \(String(describing: invokeArgs)))"}
}

extension InvokeAsyncInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invokeArgs = invokeArgs {
            try encodeContainer.encode(invokeArgs.base64EncodedString(), forKey: .invokeArgs)
        }
    }
}

public struct InvokeAsyncInputHeadersMiddleware: Middleware {
    public let id: String = "InvokeAsyncInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeAsyncInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeAsyncOutputError>
}

public struct InvokeAsyncInputQueryItemMiddleware: Middleware {
    public let id: String = "InvokeAsyncInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeAsyncInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeAsyncOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeAsyncInput>
    public typealias MOutput = OperationOutput<InvokeAsyncOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeAsyncOutputError>
}

@available(*, deprecated)
public struct InvokeAsyncInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The JSON that you want to provide to your Lambda function as input.</p>
    public let invokeArgs: Data?

    public init (
        functionName: String? = nil,
        invokeArgs: Data? = nil
    )
    {
        self.functionName = functionName
        self.invokeArgs = invokeArgs
    }
}

struct InvokeAsyncInputBody: Equatable {
    public let invokeArgs: Data?
}

extension InvokeAsyncInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case invokeArgs = "InvokeArgs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invokeArgsDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .invokeArgs)
        invokeArgs = invokeArgsDecoded
    }
}

extension InvokeAsyncOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeAsyncOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidRequestContentException" : self = .invalidRequestContentException(try InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuntimeException" : self = .invalidRuntimeException(try InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeAsyncOutputError: Equatable {
    case invalidRequestContentException(InvalidRequestContentException)
    case invalidRuntimeException(InvalidRuntimeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeAsyncOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvokeAsyncOutputResponse(status: \(String(describing: status)))"}
}

extension InvokeAsyncOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        self.status = httpResponse.statusCode.rawValue
    }
}

/// <p>A success response (<code>202 Accepted</code>) indicates that the request is queued for invocation. </p>
@available(*, deprecated)
public struct InvokeAsyncOutputResponse: Equatable {
    /// <p>The status code.</p>
    public let status: Int

    public init (
        status: Int = 0
    )
    {
        self.status = status
    }
}

struct InvokeAsyncOutputResponseBody: Equatable {
    public let status: Int
}

extension InvokeAsyncOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case status = "Status"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decode(Int.self, forKey: .status)
        status = statusDecoded
    }
}

public struct InvokeInputBodyMiddleware: Middleware {
    public let id: String = "InvokeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let payload = input.operationInput.payload {
            let data = payload
            let body = HttpBody.data(data)
            input.builder.withBody(body)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeInput>
    public typealias MOutput = OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeOutputError>
}

extension InvokeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvokeInput(clientContext: \(String(describing: clientContext)), functionName: \(String(describing: functionName)), invocationType: \(String(describing: invocationType)), logType: \(String(describing: logType)), payload: \(String(describing: payload)), qualifier: \(String(describing: qualifier)))"}
}

extension InvokeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let payload = payload {
            try encodeContainer.encode(payload.base64EncodedString(), forKey: .payload)
        }
    }
}

public struct InvokeInputHeadersMiddleware: Middleware {
    public let id: String = "InvokeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let clientContext = input.operationInput.clientContext {
            input.builder.withHeader(name: "X-Amz-Client-Context", value: String(clientContext))
        }
        if let invocationType = input.operationInput.invocationType {
            input.builder.withHeader(name: "X-Amz-Invocation-Type", value: String(invocationType.rawValue))
        }
        if let logType = input.operationInput.logType {
            input.builder.withHeader(name: "X-Amz-Log-Type", value: String(logType.rawValue))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeInput>
    public typealias MOutput = OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeOutputError>
}

public struct InvokeInputQueryItemMiddleware: Middleware {
    public let id: String = "InvokeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<InvokeInput>,
                  next: H) -> Swift.Result<OperationOutput<InvokeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<InvokeInput>
    public typealias MOutput = OperationOutput<InvokeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<InvokeOutputError>
}

public struct InvokeInput: Equatable {
    /// <p>Up to 3583 bytes of base64-encoded data about the invoking client to pass to the function in the context
    ///       object.</p>
    public let clientContext: String?
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>Choose from the following options.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>RequestResponse</code> (default) - Invoke the function synchronously. Keep the connection open until
    ///           the function returns a response or times out. The API response includes the function response and additional
    ///           data.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>Event</code> - Invoke the function asynchronously. Send events that fail multiple times to the
    ///           function's dead-letter queue (if it's configured). The API response only includes a status code.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>DryRun</code> - Validate parameter values and verify that the user or role has permission to invoke
    ///           the function.</p>
    ///             </li>
    ///          </ul>
    public let invocationType: InvocationType?
    /// <p>Set to <code>Tail</code> to include the execution log in the response.</p>
    public let logType: LogType?
    /// <p>The JSON that you want to provide to your Lambda function as input.</p>
    public let payload: Data?
    /// <p>Specify a version or alias to invoke a published version of the function.</p>
    public let qualifier: String?

    public init (
        clientContext: String? = nil,
        functionName: String? = nil,
        invocationType: InvocationType? = nil,
        logType: LogType? = nil,
        payload: Data? = nil,
        qualifier: String? = nil
    )
    {
        self.clientContext = clientContext
        self.functionName = functionName
        self.invocationType = invocationType
        self.logType = logType
        self.payload = payload
        self.qualifier = qualifier
    }
}

struct InvokeInputBody: Equatable {
    public let payload: Data?
}

extension InvokeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension InvokeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InvokeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "EC2AccessDeniedException" : self = .eC2AccessDeniedException(try EC2AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2ThrottledException" : self = .eC2ThrottledException(try EC2ThrottledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EC2UnexpectedException" : self = .eC2UnexpectedException(try EC2UnexpectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSIOException" : self = .eFSIOException(try EFSIOException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountConnectivityException" : self = .eFSMountConnectivityException(try EFSMountConnectivityException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountFailureException" : self = .eFSMountFailureException(try EFSMountFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "EFSMountTimeoutException" : self = .eFSMountTimeoutException(try EFSMountTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ENILimitReachedException" : self = .eNILimitReachedException(try ENILimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRequestContentException" : self = .invalidRequestContentException(try InvalidRequestContentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidRuntimeException" : self = .invalidRuntimeException(try InvalidRuntimeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSecurityGroupIDException" : self = .invalidSecurityGroupIDException(try InvalidSecurityGroupIDException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidSubnetIDException" : self = .invalidSubnetIDException(try InvalidSubnetIDException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidZipFileException" : self = .invalidZipFileException(try InvalidZipFileException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSAccessDeniedException" : self = .kMSAccessDeniedException(try KMSAccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSDisabledException" : self = .kMSDisabledException(try KMSDisabledException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSInvalidStateException" : self = .kMSInvalidStateException(try KMSInvalidStateException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "KMSNotFoundException" : self = .kMSNotFoundException(try KMSNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTooLargeException" : self = .requestTooLargeException(try RequestTooLargeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotReadyException" : self = .resourceNotReadyException(try ResourceNotReadyException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "SubnetIPAddressLimitReachedException" : self = .subnetIPAddressLimitReachedException(try SubnetIPAddressLimitReachedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedMediaTypeException" : self = .unsupportedMediaTypeException(try UnsupportedMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum InvokeOutputError: Equatable {
    case eC2AccessDeniedException(EC2AccessDeniedException)
    case eC2ThrottledException(EC2ThrottledException)
    case eC2UnexpectedException(EC2UnexpectedException)
    case eFSIOException(EFSIOException)
    case eFSMountConnectivityException(EFSMountConnectivityException)
    case eFSMountFailureException(EFSMountFailureException)
    case eFSMountTimeoutException(EFSMountTimeoutException)
    case eNILimitReachedException(ENILimitReachedException)
    case invalidParameterValueException(InvalidParameterValueException)
    case invalidRequestContentException(InvalidRequestContentException)
    case invalidRuntimeException(InvalidRuntimeException)
    case invalidSecurityGroupIDException(InvalidSecurityGroupIDException)
    case invalidSubnetIDException(InvalidSubnetIDException)
    case invalidZipFileException(InvalidZipFileException)
    case kMSAccessDeniedException(KMSAccessDeniedException)
    case kMSDisabledException(KMSDisabledException)
    case kMSInvalidStateException(KMSInvalidStateException)
    case kMSNotFoundException(KMSNotFoundException)
    case requestTooLargeException(RequestTooLargeException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case resourceNotReadyException(ResourceNotReadyException)
    case serviceException(ServiceException)
    case subnetIPAddressLimitReachedException(SubnetIPAddressLimitReachedException)
    case tooManyRequestsException(TooManyRequestsException)
    case unsupportedMediaTypeException(UnsupportedMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InvokeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "InvokeOutputResponse(executedVersion: \(String(describing: executedVersion)), functionError: \(String(describing: functionError)), logResult: \(String(describing: logResult)), payload: \(String(describing: payload)), statusCode: \(String(describing: statusCode)))"}
}

extension InvokeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if let executedVersionHeaderValue = httpResponse.headers.value(for: "X-Amz-Executed-Version") {
            self.executedVersion = executedVersionHeaderValue
        } else {
            self.executedVersion = nil
        }
        if let functionErrorHeaderValue = httpResponse.headers.value(for: "X-Amz-Function-Error") {
            self.functionError = functionErrorHeaderValue
        } else {
            self.functionError = nil
        }
        if let logResultHeaderValue = httpResponse.headers.value(for: "X-Amz-Log-Result") {
            self.logResult = logResultHeaderValue
        } else {
            self.logResult = nil
        }
        if case .data(let data) = httpResponse.body,
           let unwrappedData = data {
            self.payload = unwrappedData
        } else {
            self.payload = nil
        }
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct InvokeOutputResponse: Equatable {
    /// <p>The version of the function that executed. When you invoke a function with an alias, this indicates which
    ///       version the alias resolved to.</p>
    public let executedVersion: String?
    /// <p>If present, indicates that an error occurred during function execution. Details about the error are included
    ///       in the response payload.</p>
    public let functionError: String?
    /// <p>The last 4 KB of the execution log, which is base64 encoded.</p>
    public let logResult: String?
    /// <p>The response from the function, or an error object.</p>
    public let payload: Data?
    /// <p>The HTTP status code is in the 200 range for a successful request. For the <code>RequestResponse</code>
    ///       invocation type, this status code is 200. For the <code>Event</code> invocation type, this status code is 202. For
    ///       the <code>DryRun</code> invocation type, the status code is 204.</p>
    public let statusCode: Int

    public init (
        executedVersion: String? = nil,
        functionError: String? = nil,
        logResult: String? = nil,
        payload: Data? = nil,
        statusCode: Int = 0
    )
    {
        self.executedVersion = executedVersion
        self.functionError = functionError
        self.logResult = logResult
        self.payload = payload
        self.statusCode = statusCode
    }
}

struct InvokeOutputResponseBody: Equatable {
    public let statusCode: Int
    public let payload: Data?
}

extension InvokeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case payload = "Payload"
        case statusCode = "StatusCode"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decode(Int.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let payloadDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .payload)
        payload = payloadDecoded
    }
}

extension KMSAccessDeniedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSAccessDeniedException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension KMSAccessDeniedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSAccessDeniedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Lambda was unable to decrypt the environment variables because KMS access was denied. Check the Lambda
///       function's KMS permissions.</p>
public struct KMSAccessDeniedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSAccessDeniedExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension KMSAccessDeniedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSDisabledException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSDisabledException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension KMSDisabledException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSDisabledExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key used is disabled. Check the Lambda
///       function's KMS key settings.</p>
public struct KMSDisabledException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSDisabledExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension KMSDisabledExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSInvalidStateException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSInvalidStateException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension KMSInvalidStateException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSInvalidStateExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key used is in an invalid state for
///       Decrypt. Check the function's KMS key settings.</p>
public struct KMSInvalidStateException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSInvalidStateExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension KMSInvalidStateExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KMSNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "KMSNotFoundException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension KMSNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: KMSNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>Lambda was unable to decrypt the environment variables because the KMS key was not found. Check the function's
///       KMS key settings. </p>
public struct KMSNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct KMSNotFoundExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension KMSNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum LastUpdateStatus {
    case failed
    case inprogress
    case successful
    case sdkUnknown(String)
}

extension LastUpdateStatus : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LastUpdateStatus] {
        return [
            .failed,
            .inprogress,
            .successful,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "Failed"
        case .inprogress: return "InProgress"
        case .successful: return "Successful"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LastUpdateStatus(rawValue: rawValue) ?? LastUpdateStatus.sdkUnknown(rawValue)
    }
}

public enum LastUpdateStatusReasonCode {
    case enilimitexceeded
    case imageaccessdenied
    case imagedeleted
    case insufficientrolepermissions
    case internalerror
    case invalidconfiguration
    case invalidimage
    case invalidsecuritygroup
    case invalidsubnet
    case subnetoutofipaddresses
    case sdkUnknown(String)
}

extension LastUpdateStatusReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LastUpdateStatusReasonCode] {
        return [
            .enilimitexceeded,
            .imageaccessdenied,
            .imagedeleted,
            .insufficientrolepermissions,
            .internalerror,
            .invalidconfiguration,
            .invalidimage,
            .invalidsecuritygroup,
            .invalidsubnet,
            .subnetoutofipaddresses,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .enilimitexceeded: return "EniLimitExceeded"
        case .imageaccessdenied: return "ImageAccessDenied"
        case .imagedeleted: return "ImageDeleted"
        case .insufficientrolepermissions: return "InsufficientRolePermissions"
        case .internalerror: return "InternalError"
        case .invalidconfiguration: return "InvalidConfiguration"
        case .invalidimage: return "InvalidImage"
        case .invalidsecuritygroup: return "InvalidSecurityGroup"
        case .invalidsubnet: return "InvalidSubnet"
        case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LastUpdateStatusReasonCode(rawValue: rawValue) ?? LastUpdateStatusReasonCode.sdkUnknown(rawValue)
    }
}

extension Layer: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case arn = "Arn"
        case codeSize = "CodeSize"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .arn)
        arn = arnDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension Layer: CustomDebugStringConvertible {
    public var debugDescription: String {
        "Layer(arn: \(String(describing: arn)), codeSize: \(String(describing: codeSize)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)))"}
}

/// <p>An <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
///         layer</a>.</p>
public struct Layer: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
    public let arn: String?
    /// <p>The size of the layer archive in bytes.</p>
    public let codeSize: Int
    /// <p>The Amazon Resource Name (ARN)  of a signing job.</p>
    public let signingJobArn: String?
    /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
    public let signingProfileVersionArn: String?

    public init (
        arn: String? = nil,
        codeSize: Int = 0,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil
    )
    {
        self.arn = arn
        self.codeSize = codeSize
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
    }
}

extension LayerVersionContentInput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let zipFileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
    }
}

extension LayerVersionContentInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerVersionContentInput(s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)), s3ObjectVersion: \(String(describing: s3ObjectVersion)), zipFile: \(String(describing: zipFile)))"}
}

/// <p>A ZIP archive that contains the contents of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
///         layer</a>. You can specify either an Amazon S3 location,
///       or upload a layer archive directly.</p>
public struct LayerVersionContentInput: Equatable {
    /// <p>The Amazon S3 bucket of the layer archive.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 key of the layer archive.</p>
    public let s3Key: String?
    /// <p>For versioned objects, the version of the layer archive object to use.</p>
    public let s3ObjectVersion: String?
    /// <p>The base64-encoded contents of the layer archive. AWS SDK and AWS CLI clients handle the encoding for
    ///       you.</p>
    public let zipFile: Data?

    public init (
        s3Bucket: String? = nil,
        s3Key: String? = nil,
        s3ObjectVersion: String? = nil,
        zipFile: Data? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

extension LayerVersionContentOutput: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case location = "Location"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if codeSize != 0 {
            try encodeContainer.encode(codeSize, forKey: .codeSize)
        }
        if let location = location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let signingJobArn = signingJobArn {
            try encodeContainer.encode(signingJobArn, forKey: .signingJobArn)
        }
        if let signingProfileVersionArn = signingProfileVersionArn {
            try encodeContainer.encode(signingProfileVersionArn, forKey: .signingProfileVersionArn)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .location)
        location = locationDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

extension LayerVersionContentOutput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerVersionContentOutput(codeSha256: \(String(describing: codeSha256)), codeSize: \(String(describing: codeSize)), location: \(String(describing: location)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)))"}
}

/// <p>Details about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
///         layer</a>.</p>
public struct LayerVersionContentOutput: Equatable {
    /// <p>The SHA-256 hash of the layer archive.</p>
    public let codeSha256: String?
    /// <p>The size of the layer archive in bytes.</p>
    public let codeSize: Int
    /// <p>A link to the layer archive in Amazon S3 that is valid for 10 minutes.</p>
    public let location: String?
    /// <p>The Amazon Resource Name (ARN)  of a signing job.</p>
    public let signingJobArn: String?
    /// <p>The Amazon Resource Name (ARN) for a signing profile version.</p>
    public let signingProfileVersionArn: String?

    public init (
        codeSha256: String? = nil,
        codeSize: Int = 0,
        location: String? = nil,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.location = location
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
    }
}

extension LayerVersionsListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for compatibleruntimes0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(compatibleruntimes0.rawValue)
            }
        }
        if let createdDate = createdDate {
            try encodeContainer.encode(createdDate, forKey: .createdDate)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let layerVersionArn = layerVersionArn {
            try encodeContainer.encode(layerVersionArn, forKey: .layerVersionArn)
        }
        if let licenseInfo = licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
        if version != 0 {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
    }
}

extension LayerVersionsListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayerVersionsListItem(compatibleRuntimes: \(String(describing: compatibleRuntimes)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), layerVersionArn: \(String(describing: layerVersionArn)), licenseInfo: \(String(describing: licenseInfo)), version: \(String(describing: version)))"}
}

/// <p>Details about a version of an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
///         layer</a>.</p>
public struct LayerVersionsListItem: Equatable {
    /// <p>The layer's compatible runtimes.</p>
    public let compatibleRuntimes: [Runtime]?
    /// <p>The date that the version was created, in ISO 8601 format. For example, <code>2018-11-27T15:10:45.123+0000</code>.</p>
    public let createdDate: String?
    /// <p>The description of the version.</p>
    public let description: String?
    /// <p>The ARN of the layer version.</p>
    public let layerVersionArn: String?
    /// <p>The layer's open-source license.</p>
    public let licenseInfo: String?
    /// <p>The version number.</p>
    public let version: Int

    public init (
        compatibleRuntimes: [Runtime]? = nil,
        createdDate: String? = nil,
        description: String? = nil,
        layerVersionArn: String? = nil,
        licenseInfo: String? = nil,
        version: Int = 0
    )
    {
        self.compatibleRuntimes = compatibleRuntimes
        self.createdDate = createdDate
        self.description = description
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

extension LayersListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case latestMatchingVersion = "LatestMatchingVersion"
        case layerArn = "LayerArn"
        case layerName = "LayerName"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestMatchingVersion = latestMatchingVersion {
            try encodeContainer.encode(latestMatchingVersion, forKey: .latestMatchingVersion)
        }
        if let layerArn = layerArn {
            try encodeContainer.encode(layerArn, forKey: .layerArn)
        }
        if let layerName = layerName {
            try encodeContainer.encode(layerName, forKey: .layerName)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerName)
        layerName = layerNameDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let latestMatchingVersionDecoded = try containerValues.decodeIfPresent(LayerVersionsListItem.self, forKey: .latestMatchingVersion)
        latestMatchingVersion = latestMatchingVersionDecoded
    }
}

extension LayersListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "LayersListItem(latestMatchingVersion: \(String(describing: latestMatchingVersion)), layerArn: \(String(describing: layerArn)), layerName: \(String(describing: layerName)))"}
}

/// <p>Details about an <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">AWS Lambda
///         layer</a>.</p>
public struct LayersListItem: Equatable {
    /// <p>The newest version of the layer.</p>
    public let latestMatchingVersion: LayerVersionsListItem?
    /// <p>The Amazon Resource Name (ARN) of the function layer.</p>
    public let layerArn: String?
    /// <p>The name of the layer.</p>
    public let layerName: String?

    public init (
        latestMatchingVersion: LayerVersionsListItem? = nil,
        layerArn: String? = nil,
        layerName: String? = nil
    )
    {
        self.latestMatchingVersion = latestMatchingVersion
        self.layerArn = layerArn
        self.layerName = layerName
    }
}

extension ListAliasesInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAliasesInput(functionName: \(String(describing: functionName)), functionVersion: \(String(describing: functionVersion)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListAliasesInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListAliasesInputHeadersMiddleware: Middleware {
    public let id: String = "ListAliasesInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

public struct ListAliasesInputQueryItemMiddleware: Middleware {
    public let id: String = "ListAliasesInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListAliasesInput>,
                  next: H) -> Swift.Result<OperationOutput<ListAliasesOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let functionVersion = input.operationInput.functionVersion {
            let functionVersionQueryItem = URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: String(functionVersion).urlPercentEncoding())
            input.builder.withQueryItem(functionVersionQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListAliasesInput>
    public typealias MOutput = OperationOutput<ListAliasesOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListAliasesOutputError>
}

public struct ListAliasesInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>Specify a function version to only list aliases that invoke that version.</p>
    public let functionVersion: String?
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let marker: String?
    /// <p>Limit the number of aliases returned.</p>
    public let maxItems: Int?

    public init (
        functionName: String? = nil,
        functionVersion: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListAliasesInputBody: Equatable {
}

extension ListAliasesInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListAliasesOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListAliasesOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListAliasesOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListAliasesOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListAliasesOutputResponse(aliases: \(String(describing: aliases)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListAliasesOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListAliasesOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliases = output.aliases
            self.nextMarker = output.nextMarker
        } else {
            self.aliases = nil
            self.nextMarker = nil
        }
    }
}

public struct ListAliasesOutputResponse: Equatable {
    /// <p>A list of aliases.</p>
    public let aliases: [AliasConfiguration]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextMarker: String?

    public init (
        aliases: [AliasConfiguration]? = nil,
        nextMarker: String? = nil
    )
    {
        self.aliases = aliases
        self.nextMarker = nextMarker
    }
}

struct ListAliasesOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let aliases: [AliasConfiguration]?
}

extension ListAliasesOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliases = "Aliases"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let aliasesContainer = try containerValues.decodeIfPresent([AliasConfiguration?].self, forKey: .aliases)
        var aliasesDecoded0:[AliasConfiguration]? = nil
        if let aliasesContainer = aliasesContainer {
            aliasesDecoded0 = [AliasConfiguration]()
            for structure0 in aliasesContainer {
                if let structure0 = structure0 {
                    aliasesDecoded0?.append(structure0)
                }
            }
        }
        aliases = aliasesDecoded0
    }
}

extension ListCodeSigningConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCodeSigningConfigsInput(marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListCodeSigningConfigsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListCodeSigningConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListCodeSigningConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCodeSigningConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCodeSigningConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCodeSigningConfigsInput>
    public typealias MOutput = OperationOutput<ListCodeSigningConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCodeSigningConfigsOutputError>
}

public struct ListCodeSigningConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListCodeSigningConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListCodeSigningConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListCodeSigningConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListCodeSigningConfigsInput>
    public typealias MOutput = OperationOutput<ListCodeSigningConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListCodeSigningConfigsOutputError>
}

public struct ListCodeSigningConfigsInput: Equatable {
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let marker: String?
    /// <p>Maximum number of items to return.</p>
    public let maxItems: Int?

    public init (
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListCodeSigningConfigsInputBody: Equatable {
}

extension ListCodeSigningConfigsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListCodeSigningConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListCodeSigningConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListCodeSigningConfigsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListCodeSigningConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListCodeSigningConfigsOutputResponse(codeSigningConfigs: \(String(describing: codeSigningConfigs)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListCodeSigningConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListCodeSigningConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSigningConfigs = output.codeSigningConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.codeSigningConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListCodeSigningConfigsOutputResponse: Equatable {
    /// <p>The code signing configurations</p>
    public let codeSigningConfigs: [CodeSigningConfig]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextMarker: String?

    public init (
        codeSigningConfigs: [CodeSigningConfig]? = nil,
        nextMarker: String? = nil
    )
    {
        self.codeSigningConfigs = codeSigningConfigs
        self.nextMarker = nextMarker
    }
}

struct ListCodeSigningConfigsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let codeSigningConfigs: [CodeSigningConfig]?
}

extension ListCodeSigningConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfigs = "CodeSigningConfigs"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let codeSigningConfigsContainer = try containerValues.decodeIfPresent([CodeSigningConfig?].self, forKey: .codeSigningConfigs)
        var codeSigningConfigsDecoded0:[CodeSigningConfig]? = nil
        if let codeSigningConfigsContainer = codeSigningConfigsContainer {
            codeSigningConfigsDecoded0 = [CodeSigningConfig]()
            for structure0 in codeSigningConfigsContainer {
                if let structure0 = structure0 {
                    codeSigningConfigsDecoded0?.append(structure0)
                }
            }
        }
        codeSigningConfigs = codeSigningConfigsDecoded0
    }
}

extension ListEventSourceMappingsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventSourceMappingsInput(eventSourceArn: \(String(describing: eventSourceArn)), functionName: \(String(describing: functionName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListEventSourceMappingsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListEventSourceMappingsInputHeadersMiddleware: Middleware {
    public let id: String = "ListEventSourceMappingsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSourceMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSourceMappingsInput>
    public typealias MOutput = OperationOutput<ListEventSourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSourceMappingsOutputError>
}

public struct ListEventSourceMappingsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListEventSourceMappingsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListEventSourceMappingsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListEventSourceMappingsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let functionName = input.operationInput.functionName {
            let functionNameQueryItem = URLQueryItem(name: "FunctionName".urlPercentEncoding(), value: String(functionName).urlPercentEncoding())
            input.builder.withQueryItem(functionNameQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        if let eventSourceArn = input.operationInput.eventSourceArn {
            let eventSourceArnQueryItem = URLQueryItem(name: "EventSourceArn".urlPercentEncoding(), value: String(eventSourceArn).urlPercentEncoding())
            input.builder.withQueryItem(eventSourceArnQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListEventSourceMappingsInput>
    public typealias MOutput = OperationOutput<ListEventSourceMappingsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListEventSourceMappingsOutputError>
}

public struct ListEventSourceMappingsInput: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Kinesis</b> - The ARN of the data stream or a stream consumer.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon DynamoDB Streams</b> - The ARN of the stream.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Simple Queue Service</b> - The ARN of the queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Managed Streaming for Apache Kafka</b> - The ARN of the cluster.</p>
    ///             </li>
    ///          </ul>
    public let eventSourceArn: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>A pagination token returned by a previous call.</p>
    public let marker: String?
    /// <p>The maximum number of event source mappings to return.</p>
    public let maxItems: Int?

    public init (
        eventSourceArn: String? = nil,
        functionName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.eventSourceArn = eventSourceArn
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListEventSourceMappingsInputBody: Equatable {
}

extension ListEventSourceMappingsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListEventSourceMappingsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListEventSourceMappingsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListEventSourceMappingsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListEventSourceMappingsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListEventSourceMappingsOutputResponse(eventSourceMappings: \(String(describing: eventSourceMappings)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListEventSourceMappingsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListEventSourceMappingsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.eventSourceMappings = output.eventSourceMappings
            self.nextMarker = output.nextMarker
        } else {
            self.eventSourceMappings = nil
            self.nextMarker = nil
        }
    }
}

public struct ListEventSourceMappingsOutputResponse: Equatable {
    /// <p>A list of event source mappings.</p>
    public let eventSourceMappings: [EventSourceMappingConfiguration]?
    /// <p>A pagination token that's returned when the response doesn't contain all event source mappings.</p>
    public let nextMarker: String?

    public init (
        eventSourceMappings: [EventSourceMappingConfiguration]? = nil,
        nextMarker: String? = nil
    )
    {
        self.eventSourceMappings = eventSourceMappings
        self.nextMarker = nextMarker
    }
}

struct ListEventSourceMappingsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let eventSourceMappings: [EventSourceMappingConfiguration]?
}

extension ListEventSourceMappingsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case eventSourceMappings = "EventSourceMappings"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let eventSourceMappingsContainer = try containerValues.decodeIfPresent([EventSourceMappingConfiguration?].self, forKey: .eventSourceMappings)
        var eventSourceMappingsDecoded0:[EventSourceMappingConfiguration]? = nil
        if let eventSourceMappingsContainer = eventSourceMappingsContainer {
            eventSourceMappingsDecoded0 = [EventSourceMappingConfiguration]()
            for structure0 in eventSourceMappingsContainer {
                if let structure0 = structure0 {
                    eventSourceMappingsDecoded0?.append(structure0)
                }
            }
        }
        eventSourceMappings = eventSourceMappingsDecoded0
    }
}

extension ListFunctionEventInvokeConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionEventInvokeConfigsInput(functionName: \(String(describing: functionName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListFunctionEventInvokeConfigsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFunctionEventInvokeConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFunctionEventInvokeConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionEventInvokeConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionEventInvokeConfigsInput>
    public typealias MOutput = OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionEventInvokeConfigsOutputError>
}

public struct ListFunctionEventInvokeConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFunctionEventInvokeConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionEventInvokeConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionEventInvokeConfigsInput>
    public typealias MOutput = OperationOutput<ListFunctionEventInvokeConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionEventInvokeConfigsOutputError>
}

public struct ListFunctionEventInvokeConfigsInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let marker: String?
    /// <p>The maximum number of configurations to return.</p>
    public let maxItems: Int?

    public init (
        functionName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionEventInvokeConfigsInputBody: Equatable {
}

extension ListFunctionEventInvokeConfigsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFunctionEventInvokeConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionEventInvokeConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionEventInvokeConfigsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionEventInvokeConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionEventInvokeConfigsOutputResponse(functionEventInvokeConfigs: \(String(describing: functionEventInvokeConfigs)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListFunctionEventInvokeConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFunctionEventInvokeConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.functionEventInvokeConfigs = output.functionEventInvokeConfigs
            self.nextMarker = output.nextMarker
        } else {
            self.functionEventInvokeConfigs = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionEventInvokeConfigsOutputResponse: Equatable {
    /// <p>A list of configurations.</p>
    public let functionEventInvokeConfigs: [FunctionEventInvokeConfig]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextMarker: String?

    public init (
        functionEventInvokeConfigs: [FunctionEventInvokeConfig]? = nil,
        nextMarker: String? = nil
    )
    {
        self.functionEventInvokeConfigs = functionEventInvokeConfigs
        self.nextMarker = nextMarker
    }
}

struct ListFunctionEventInvokeConfigsOutputResponseBody: Equatable {
    public let functionEventInvokeConfigs: [FunctionEventInvokeConfig]?
    public let nextMarker: String?
}

extension ListFunctionEventInvokeConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionEventInvokeConfigs = "FunctionEventInvokeConfigs"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionEventInvokeConfigsContainer = try containerValues.decodeIfPresent([FunctionEventInvokeConfig?].self, forKey: .functionEventInvokeConfigs)
        var functionEventInvokeConfigsDecoded0:[FunctionEventInvokeConfig]? = nil
        if let functionEventInvokeConfigsContainer = functionEventInvokeConfigsContainer {
            functionEventInvokeConfigsDecoded0 = [FunctionEventInvokeConfig]()
            for structure0 in functionEventInvokeConfigsContainer {
                if let structure0 = structure0 {
                    functionEventInvokeConfigsDecoded0?.append(structure0)
                }
            }
        }
        functionEventInvokeConfigs = functionEventInvokeConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListFunctionsByCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsByCodeSigningConfigInput(codeSigningConfigArn: \(String(describing: codeSigningConfigArn)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListFunctionsByCodeSigningConfigInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFunctionsByCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "ListFunctionsByCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsByCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsByCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsByCodeSigningConfigOutputError>
}

public struct ListFunctionsByCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFunctionsByCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsByCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsByCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<ListFunctionsByCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsByCodeSigningConfigOutputError>
}

public struct ListFunctionsByCodeSigningConfigInput: Equatable {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    public let codeSigningConfigArn: String?
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let marker: String?
    /// <p>Maximum number of items to return.</p>
    public let maxItems: Int?

    public init (
        codeSigningConfigArn: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListFunctionsByCodeSigningConfigInputBody: Equatable {
}

extension ListFunctionsByCodeSigningConfigInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFunctionsByCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsByCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsByCodeSigningConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsByCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsByCodeSigningConfigOutputResponse(functionArns: \(String(describing: functionArns)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListFunctionsByCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFunctionsByCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.functionArns = output.functionArns
            self.nextMarker = output.nextMarker
        } else {
            self.functionArns = nil
            self.nextMarker = nil
        }
    }
}

public struct ListFunctionsByCodeSigningConfigOutputResponse: Equatable {
    /// <p>The function ARNs. </p>
    public let functionArns: [String]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextMarker: String?

    public init (
        functionArns: [String]? = nil,
        nextMarker: String? = nil
    )
    {
        self.functionArns = functionArns
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsByCodeSigningConfigOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let functionArns: [String]?
}

extension ListFunctionsByCodeSigningConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functionArns = "FunctionArns"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionArnsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .functionArns)
        var functionArnsDecoded0:[String]? = nil
        if let functionArnsContainer = functionArnsContainer {
            functionArnsDecoded0 = [String]()
            for string0 in functionArnsContainer {
                if let string0 = string0 {
                    functionArnsDecoded0?.append(string0)
                }
            }
        }
        functionArns = functionArnsDecoded0
    }
}

extension ListFunctionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsInput(functionVersion: \(String(describing: functionVersion)), marker: \(String(describing: marker)), masterRegion: \(String(describing: masterRegion)), maxItems: \(String(describing: maxItems)))"}
}

extension ListFunctionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListFunctionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListFunctionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListFunctionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListFunctionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListFunctionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let masterRegion = input.operationInput.masterRegion {
            let masterRegionQueryItem = URLQueryItem(name: "MasterRegion".urlPercentEncoding(), value: String(masterRegion).urlPercentEncoding())
            input.builder.withQueryItem(masterRegionQueryItem)
        }
        if let functionVersion = input.operationInput.functionVersion {
            let functionVersionQueryItem = URLQueryItem(name: "FunctionVersion".urlPercentEncoding(), value: String(functionVersion.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(functionVersionQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListFunctionsInput>
    public typealias MOutput = OperationOutput<ListFunctionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListFunctionsOutputError>
}

public struct ListFunctionsInput: Equatable {
    /// <p>Set to <code>ALL</code> to include entries for all published versions of each function.</p>
    public let functionVersion: FunctionVersion?
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let marker: String?
    /// <p>For Lambda@Edge functions, the AWS Region of the master function. For example, <code>us-east-1</code> filters
    ///       the list of functions to only include Lambda@Edge functions replicated from a master function in US East (N.
    ///       Virginia). If specified, you must set <code>FunctionVersion</code> to <code>ALL</code>.</p>
    public let masterRegion: String?
    /// <p>The maximum number of functions to return in the response. Note that <code>ListFunctions</code> returns a maximum of 50 items in each response,
    ///       even if you set the number higher.</p>
    public let maxItems: Int?

    public init (
        functionVersion: FunctionVersion? = nil,
        marker: String? = nil,
        masterRegion: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.functionVersion = functionVersion
        self.marker = marker
        self.masterRegion = masterRegion
        self.maxItems = maxItems
    }
}

struct ListFunctionsInputBody: Equatable {
}

extension ListFunctionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListFunctionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFunctionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListFunctionsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFunctionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListFunctionsOutputResponse(functions: \(String(describing: functions)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListFunctionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListFunctionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.functions = output.functions
            self.nextMarker = output.nextMarker
        } else {
            self.functions = nil
            self.nextMarker = nil
        }
    }
}

/// <p>A list of Lambda functions.</p>
public struct ListFunctionsOutputResponse: Equatable {
    /// <p>A list of Lambda functions.</p>
    public let functions: [FunctionConfiguration]?
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextMarker: String?

    public init (
        functions: [FunctionConfiguration]? = nil,
        nextMarker: String? = nil
    )
    {
        self.functions = functions
        self.nextMarker = nextMarker
    }
}

struct ListFunctionsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let functions: [FunctionConfiguration]?
}

extension ListFunctionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case functions = "Functions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let functionsContainer = try containerValues.decodeIfPresent([FunctionConfiguration?].self, forKey: .functions)
        var functionsDecoded0:[FunctionConfiguration]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [FunctionConfiguration]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension ListLayerVersionsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLayerVersionsInput(compatibleRuntime: \(String(describing: compatibleRuntime)), layerName: \(String(describing: layerName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListLayerVersionsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLayerVersionsInputHeadersMiddleware: Middleware {
    public let id: String = "ListLayerVersionsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLayerVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLayerVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLayerVersionsInput>
    public typealias MOutput = OperationOutput<ListLayerVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLayerVersionsOutputError>
}

public struct ListLayerVersionsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLayerVersionsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLayerVersionsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLayerVersionsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let compatibleRuntime = input.operationInput.compatibleRuntime {
            let compatibleRuntimeQueryItem = URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: String(compatibleRuntime.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(compatibleRuntimeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLayerVersionsInput>
    public typealias MOutput = OperationOutput<ListLayerVersionsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLayerVersionsOutputError>
}

public struct ListLayerVersionsInput: Equatable {
    /// <p>A runtime identifier. For example, <code>go1.x</code>.</p>
    public let compatibleRuntime: Runtime?
    /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
    public let layerName: String?
    /// <p>A pagination token returned by a previous call.</p>
    public let marker: String?
    /// <p>The maximum number of versions to return.</p>
    public let maxItems: Int?

    public init (
        compatibleRuntime: Runtime? = nil,
        layerName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.compatibleRuntime = compatibleRuntime
        self.layerName = layerName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayerVersionsInputBody: Equatable {
}

extension ListLayerVersionsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLayerVersionsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLayerVersionsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLayerVersionsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLayerVersionsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLayerVersionsOutputResponse(layerVersions: \(String(describing: layerVersions)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListLayerVersionsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLayerVersionsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.layerVersions = output.layerVersions
            self.nextMarker = output.nextMarker
        } else {
            self.layerVersions = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayerVersionsOutputResponse: Equatable {
    /// <p>A list of versions.</p>
    public let layerVersions: [LayerVersionsListItem]?
    /// <p>A pagination token returned when the response doesn't contain all versions.</p>
    public let nextMarker: String?

    public init (
        layerVersions: [LayerVersionsListItem]? = nil,
        nextMarker: String? = nil
    )
    {
        self.layerVersions = layerVersions
        self.nextMarker = nextMarker
    }
}

struct ListLayerVersionsOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let layerVersions: [LayerVersionsListItem]?
}

extension ListLayerVersionsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layerVersions = "LayerVersions"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layerVersionsContainer = try containerValues.decodeIfPresent([LayerVersionsListItem?].self, forKey: .layerVersions)
        var layerVersionsDecoded0:[LayerVersionsListItem]? = nil
        if let layerVersionsContainer = layerVersionsContainer {
            layerVersionsDecoded0 = [LayerVersionsListItem]()
            for structure0 in layerVersionsContainer {
                if let structure0 = structure0 {
                    layerVersionsDecoded0?.append(structure0)
                }
            }
        }
        layerVersions = layerVersionsDecoded0
    }
}

extension ListLayersInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLayersInput(compatibleRuntime: \(String(describing: compatibleRuntime)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListLayersInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListLayersInputHeadersMiddleware: Middleware {
    public let id: String = "ListLayersInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLayersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLayersInput>
    public typealias MOutput = OperationOutput<ListLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLayersOutputError>
}

public struct ListLayersInputQueryItemMiddleware: Middleware {
    public let id: String = "ListLayersInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListLayersInput>,
                  next: H) -> Swift.Result<OperationOutput<ListLayersOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let compatibleRuntime = input.operationInput.compatibleRuntime {
            let compatibleRuntimeQueryItem = URLQueryItem(name: "CompatibleRuntime".urlPercentEncoding(), value: String(compatibleRuntime.rawValue).urlPercentEncoding())
            input.builder.withQueryItem(compatibleRuntimeQueryItem)
        }
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListLayersInput>
    public typealias MOutput = OperationOutput<ListLayersOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListLayersOutputError>
}

public struct ListLayersInput: Equatable {
    /// <p>A runtime identifier. For example, <code>go1.x</code>.</p>
    public let compatibleRuntime: Runtime?
    /// <p>A pagination token returned by a previous call.</p>
    public let marker: String?
    /// <p>The maximum number of layers to return.</p>
    public let maxItems: Int?

    public init (
        compatibleRuntime: Runtime? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.compatibleRuntime = compatibleRuntime
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListLayersInputBody: Equatable {
}

extension ListLayersInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListLayersOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListLayersOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListLayersOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListLayersOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListLayersOutputResponse(layers: \(String(describing: layers)), nextMarker: \(String(describing: nextMarker)))"}
}

extension ListLayersOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListLayersOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.layers = output.layers
            self.nextMarker = output.nextMarker
        } else {
            self.layers = nil
            self.nextMarker = nil
        }
    }
}

public struct ListLayersOutputResponse: Equatable {
    /// <p>A list of function layers.</p>
    public let layers: [LayersListItem]?
    /// <p>A pagination token returned when the response doesn't contain all layers.</p>
    public let nextMarker: String?

    public init (
        layers: [LayersListItem]? = nil,
        nextMarker: String? = nil
    )
    {
        self.layers = layers
        self.nextMarker = nextMarker
    }
}

struct ListLayersOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let layers: [LayersListItem]?
}

extension ListLayersOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case layers = "Layers"
        case nextMarker = "NextMarker"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let layersContainer = try containerValues.decodeIfPresent([LayersListItem?].self, forKey: .layers)
        var layersDecoded0:[LayersListItem]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [LayersListItem]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
    }
}

extension ListProvisionedConcurrencyConfigsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisionedConcurrencyConfigsInput(functionName: \(String(describing: functionName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListProvisionedConcurrencyConfigsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListProvisionedConcurrencyConfigsInputHeadersMiddleware: Middleware {
    public let id: String = "ListProvisionedConcurrencyConfigsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisionedConcurrencyConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisionedConcurrencyConfigsInput>
    public typealias MOutput = OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisionedConcurrencyConfigsOutputError>
}

public struct ListProvisionedConcurrencyConfigsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListProvisionedConcurrencyConfigsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListProvisionedConcurrencyConfigsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        input.builder.withQueryItem(URLQueryItem(name: "List", value: "ALL"))
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListProvisionedConcurrencyConfigsInput>
    public typealias MOutput = OperationOutput<ListProvisionedConcurrencyConfigsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListProvisionedConcurrencyConfigsOutputError>
}

public struct ListProvisionedConcurrencyConfigsInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let marker: String?
    /// <p>Specify a number to limit the number of configurations returned.</p>
    public let maxItems: Int?

    public init (
        functionName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListProvisionedConcurrencyConfigsInputBody: Equatable {
}

extension ListProvisionedConcurrencyConfigsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListProvisionedConcurrencyConfigsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListProvisionedConcurrencyConfigsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListProvisionedConcurrencyConfigsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListProvisionedConcurrencyConfigsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListProvisionedConcurrencyConfigsOutputResponse(nextMarker: \(String(describing: nextMarker)), provisionedConcurrencyConfigs: \(String(describing: provisionedConcurrencyConfigs)))"}
}

extension ListProvisionedConcurrencyConfigsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListProvisionedConcurrencyConfigsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.provisionedConcurrencyConfigs = output.provisionedConcurrencyConfigs
        } else {
            self.nextMarker = nil
            self.provisionedConcurrencyConfigs = nil
        }
    }
}

public struct ListProvisionedConcurrencyConfigsOutputResponse: Equatable {
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextMarker: String?
    /// <p>A list of provisioned concurrency configurations.</p>
    public let provisionedConcurrencyConfigs: [ProvisionedConcurrencyConfigListItem]?

    public init (
        nextMarker: String? = nil,
        provisionedConcurrencyConfigs: [ProvisionedConcurrencyConfigListItem]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.provisionedConcurrencyConfigs = provisionedConcurrencyConfigs
    }
}

struct ListProvisionedConcurrencyConfigsOutputResponseBody: Equatable {
    public let provisionedConcurrencyConfigs: [ProvisionedConcurrencyConfigListItem]?
    public let nextMarker: String?
}

extension ListProvisionedConcurrencyConfigsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case provisionedConcurrencyConfigs = "ProvisionedConcurrencyConfigs"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrencyConfigsContainer = try containerValues.decodeIfPresent([ProvisionedConcurrencyConfigListItem?].self, forKey: .provisionedConcurrencyConfigs)
        var provisionedConcurrencyConfigsDecoded0:[ProvisionedConcurrencyConfigListItem]? = nil
        if let provisionedConcurrencyConfigsContainer = provisionedConcurrencyConfigsContainer {
            provisionedConcurrencyConfigsDecoded0 = [ProvisionedConcurrencyConfigListItem]()
            for structure0 in provisionedConcurrencyConfigsContainer {
                if let structure0 = structure0 {
                    provisionedConcurrencyConfigsDecoded0?.append(structure0)
                }
            }
        }
        provisionedConcurrencyConfigs = provisionedConcurrencyConfigsDecoded0
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
    }
}

extension ListTagsInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsInput(resource: \(String(describing: resource)))"}
}

extension ListTagsInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListTagsInputHeadersMiddleware: Middleware {
    public let id: String = "ListTagsInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInputQueryItemMiddleware: Middleware {
    public let id: String = "ListTagsInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListTagsInput>,
                  next: H) -> Swift.Result<OperationOutput<ListTagsOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListTagsInput>
    public typealias MOutput = OperationOutput<ListTagsOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListTagsOutputError>
}

public struct ListTagsInput: Equatable {
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let resource: String?

    public init (
        resource: String? = nil
    )
    {
        self.resource = resource
    }
}

struct ListTagsInputBody: Equatable {
}

extension ListTagsInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListTagsOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListTagsOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListTagsOutputResponse(tags: \(String(describing: tags)))"}
}

extension ListTagsOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListTagsOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsOutputResponse: Equatable {
    /// <p>The function's tags.</p>
    public let tags: [String:String]?

    public init (
        tags: [String:String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsOutputResponseBody: Equatable {
    public let tags: [String:String]?
}

extension ListTagsOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListVersionsByFunctionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVersionsByFunctionInput(functionName: \(String(describing: functionName)), marker: \(String(describing: marker)), maxItems: \(String(describing: maxItems)))"}
}

extension ListVersionsByFunctionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct ListVersionsByFunctionInputHeadersMiddleware: Middleware {
    public let id: String = "ListVersionsByFunctionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVersionsByFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVersionsByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVersionsByFunctionInput>
    public typealias MOutput = OperationOutput<ListVersionsByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVersionsByFunctionOutputError>
}

public struct ListVersionsByFunctionInputQueryItemMiddleware: Middleware {
    public let id: String = "ListVersionsByFunctionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<ListVersionsByFunctionInput>,
                  next: H) -> Swift.Result<OperationOutput<ListVersionsByFunctionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let marker = input.operationInput.marker {
            let markerQueryItem = URLQueryItem(name: "Marker".urlPercentEncoding(), value: String(marker).urlPercentEncoding())
            input.builder.withQueryItem(markerQueryItem)
        }
        if let maxItems = input.operationInput.maxItems {
            let maxItemsQueryItem = URLQueryItem(name: "MaxItems".urlPercentEncoding(), value: String(maxItems).urlPercentEncoding())
            input.builder.withQueryItem(maxItemsQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<ListVersionsByFunctionInput>
    public typealias MOutput = OperationOutput<ListVersionsByFunctionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<ListVersionsByFunctionOutputError>
}

public struct ListVersionsByFunctionInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>Specify the pagination token that's returned by a previous request to retrieve the next page of results.</p>
    public let marker: String?
    /// <p>The maximum number of versions to return.</p>
    public let maxItems: Int?

    public init (
        functionName: String? = nil,
        marker: String? = nil,
        maxItems: Int? = nil
    )
    {
        self.functionName = functionName
        self.marker = marker
        self.maxItems = maxItems
    }
}

struct ListVersionsByFunctionInputBody: Equatable {
}

extension ListVersionsByFunctionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension ListVersionsByFunctionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListVersionsByFunctionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum ListVersionsByFunctionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListVersionsByFunctionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ListVersionsByFunctionOutputResponse(nextMarker: \(String(describing: nextMarker)), versions: \(String(describing: versions)))"}
}

extension ListVersionsByFunctionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ListVersionsByFunctionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.nextMarker = output.nextMarker
            self.versions = output.versions
        } else {
            self.nextMarker = nil
            self.versions = nil
        }
    }
}

public struct ListVersionsByFunctionOutputResponse: Equatable {
    /// <p>The pagination token that's included if more results are available.</p>
    public let nextMarker: String?
    /// <p>A list of Lambda function versions.</p>
    public let versions: [FunctionConfiguration]?

    public init (
        nextMarker: String? = nil,
        versions: [FunctionConfiguration]? = nil
    )
    {
        self.nextMarker = nextMarker
        self.versions = versions
    }
}

struct ListVersionsByFunctionOutputResponseBody: Equatable {
    public let nextMarker: String?
    public let versions: [FunctionConfiguration]?
}

extension ListVersionsByFunctionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case nextMarker = "NextMarker"
        case versions = "Versions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextMarkerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .nextMarker)
        nextMarker = nextMarkerDecoded
        let versionsContainer = try containerValues.decodeIfPresent([FunctionConfiguration?].self, forKey: .versions)
        var versionsDecoded0:[FunctionConfiguration]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [FunctionConfiguration]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

public enum LogType {
    case `none`
    case tail
    case sdkUnknown(String)
}

extension LogType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [LogType] {
        return [
            .none,
            .tail,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .none: return "None"
        case .tail: return "Tail"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = LogType(rawValue: rawValue) ?? LogType.sdkUnknown(rawValue)
    }
}

extension OnFailure: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension OnFailure: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OnFailure(destination: \(String(describing: destination)))"}
}

/// <p>A destination for events that failed processing.</p>
public struct OnFailure: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
    public let destination: String?

    public init (
        destination: String? = nil
    )
    {
        self.destination = destination
    }
}

extension OnSuccess: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destination = "Destination"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destination = destination {
            try encodeContainer.encode(destination, forKey: .destination)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationDecoded = try containerValues.decodeIfPresent(String.self, forKey: .destination)
        destination = destinationDecoded
    }
}

extension OnSuccess: CustomDebugStringConvertible {
    public var debugDescription: String {
        "OnSuccess(destination: \(String(describing: destination)))"}
}

/// <p>A destination for events that were processed successfully.</p>
public struct OnSuccess: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the destination resource.</p>
    public let destination: String?

    public init (
        destination: String? = nil
    )
    {
        self.destination = destination
    }
}

public enum PackageType {
    case image
    case zip
    case sdkUnknown(String)
}

extension PackageType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [PackageType] {
        return [
            .image,
            .zip,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .image: return "Image"
        case .zip: return "Zip"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = PackageType(rawValue: rawValue) ?? PackageType.sdkUnknown(rawValue)
    }
}

extension PolicyLengthExceededException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PolicyLengthExceededException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension PolicyLengthExceededException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PolicyLengthExceededExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The permissions policy for the resource is too large. <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Learn more</a>
///          </p>
public struct PolicyLengthExceededException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct PolicyLengthExceededExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension PolicyLengthExceededExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PreconditionFailedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PreconditionFailedException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension PreconditionFailedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PreconditionFailedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The RevisionId provided does not match the latest RevisionId for the Lambda function or alias. Call the
///         <code>GetFunction</code> or the <code>GetAlias</code> API to retrieve the latest RevisionId for your
///       resource.</p>
public struct PreconditionFailedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?
    /// <p>The exception type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct PreconditionFailedExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension PreconditionFailedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ProvisionedConcurrencyConfigListItem: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions {
            try encodeContainer.encode(allocatedProvisionedConcurrentExecutions, forKey: .allocatedProvisionedConcurrentExecutions)
        }
        if let availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions {
            try encodeContainer.encode(availableProvisionedConcurrentExecutions, forKey: .availableProvisionedConcurrentExecutions)
        }
        if let functionArn = functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let lastModified = lastModified {
            try encodeContainer.encode(lastModified, forKey: .lastModified)
        }
        if let requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions {
            try encodeContainer.encode(requestedProvisionedConcurrentExecutions, forKey: .requestedProvisionedConcurrentExecutions)
        }
        if let status = status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = statusReason {
            try encodeContainer.encode(statusReason, forKey: .statusReason)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension ProvisionedConcurrencyConfigListItem: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedConcurrencyConfigListItem(allocatedProvisionedConcurrentExecutions: \(String(describing: allocatedProvisionedConcurrentExecutions)), availableProvisionedConcurrentExecutions: \(String(describing: availableProvisionedConcurrentExecutions)), functionArn: \(String(describing: functionArn)), lastModified: \(String(describing: lastModified)), requestedProvisionedConcurrentExecutions: \(String(describing: requestedProvisionedConcurrentExecutions)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

/// <p>Details about the provisioned concurrency configuration for a function alias or version.</p>
public struct ProvisionedConcurrencyConfigListItem: Equatable {
    /// <p>The amount of provisioned concurrency allocated.</p>
    public let allocatedProvisionedConcurrentExecutions: Int?
    /// <p>The amount of provisioned concurrency available.</p>
    public let availableProvisionedConcurrentExecutions: Int?
    /// <p>The Amazon Resource Name (ARN) of the alias or version.</p>
    public let functionArn: String?
    /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
    public let lastModified: String?
    /// <p>The amount of provisioned concurrency requested.</p>
    public let requestedProvisionedConcurrentExecutions: Int?
    /// <p>The status of the allocation process.</p>
    public let status: ProvisionedConcurrencyStatusEnum?
    /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
    public let statusReason: String?

    public init (
        allocatedProvisionedConcurrentExecutions: Int? = nil,
        availableProvisionedConcurrentExecutions: Int? = nil,
        functionArn: String? = nil,
        lastModified: String? = nil,
        requestedProvisionedConcurrentExecutions: Int? = nil,
        status: ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

extension ProvisionedConcurrencyConfigNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ProvisionedConcurrencyConfigNotFoundException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension ProvisionedConcurrencyConfigNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ProvisionedConcurrencyConfigNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The specified configuration does not exist.</p>
public struct ProvisionedConcurrencyConfigNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ProvisionedConcurrencyConfigNotFoundExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension ProvisionedConcurrencyConfigNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum ProvisionedConcurrencyStatusEnum {
    case failed
    case inProgress
    case ready
    case sdkUnknown(String)
}

extension ProvisionedConcurrencyStatusEnum : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ProvisionedConcurrencyStatusEnum] {
        return [
            .failed,
            .inProgress,
            .ready,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .failed: return "FAILED"
        case .inProgress: return "IN_PROGRESS"
        case .ready: return "READY"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ProvisionedConcurrencyStatusEnum(rawValue: rawValue) ?? ProvisionedConcurrencyStatusEnum.sdkUnknown(rawValue)
    }
}

public struct PublishLayerVersionInputBodyMiddleware: Middleware {
    public let id: String = "PublishLayerVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishLayerVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishLayerVersionInput>
    public typealias MOutput = OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishLayerVersionOutputError>
}

extension PublishLayerVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishLayerVersionInput(compatibleRuntimes: \(String(describing: compatibleRuntimes)), content: \(String(describing: content)), description: \(String(describing: description)), layerName: \(String(describing: layerName)), licenseInfo: \(String(describing: licenseInfo)))"}
}

extension PublishLayerVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compatibleRuntimes = compatibleRuntimes {
            var compatibleRuntimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .compatibleRuntimes)
            for compatibleruntimes0 in compatibleRuntimes {
                try compatibleRuntimesContainer.encode(compatibleruntimes0.rawValue)
            }
        }
        if let content = content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let licenseInfo = licenseInfo {
            try encodeContainer.encode(licenseInfo, forKey: .licenseInfo)
        }
    }
}

public struct PublishLayerVersionInputHeadersMiddleware: Middleware {
    public let id: String = "PublishLayerVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishLayerVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishLayerVersionInput>
    public typealias MOutput = OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishLayerVersionOutputError>
}

public struct PublishLayerVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "PublishLayerVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishLayerVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishLayerVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishLayerVersionInput>
    public typealias MOutput = OperationOutput<PublishLayerVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishLayerVersionOutputError>
}

public struct PublishLayerVersionInput: Equatable {
    /// <p>A list of compatible <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">function
    ///         runtimes</a>. Used for filtering with <a>ListLayers</a> and <a>ListLayerVersions</a>.</p>
    public let compatibleRuntimes: [Runtime]?
    /// <p>The function layer archive.</p>
    public let content: LayerVersionContentInput?
    /// <p>The description of the version.</p>
    public let description: String?
    /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
    public let layerName: String?
    /// <p>The layer's software license. It can be any of the following:</p>
    ///          <ul>
    ///             <li>
    ///                <p>An <a href="https://spdx.org/licenses/">SPDX license identifier</a>. For example,
    ///           <code>MIT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>The URL of a license hosted on the internet. For example,
    ///           <code>https://opensource.org/licenses/MIT</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>The full text of the license.</p>
    ///             </li>
    ///          </ul>
    public let licenseInfo: String?

    public init (
        compatibleRuntimes: [Runtime]? = nil,
        content: LayerVersionContentInput? = nil,
        description: String? = nil,
        layerName: String? = nil,
        licenseInfo: String? = nil
    )
    {
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.description = description
        self.layerName = layerName
        self.licenseInfo = licenseInfo
    }
}

struct PublishLayerVersionInputBody: Equatable {
    public let description: String?
    public let content: LayerVersionContentInput?
    public let compatibleRuntimes: [Runtime]?
    public let licenseInfo: String?
}

extension PublishLayerVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case description = "Description"
        case licenseInfo = "LicenseInfo"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(LayerVersionContentInput.self, forKey: .content)
        content = contentDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
    }
}

extension PublishLayerVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishLayerVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishLayerVersionOutputError: Equatable {
    case codeStorageExceededException(CodeStorageExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishLayerVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishLayerVersionOutputResponse(compatibleRuntimes: \(String(describing: compatibleRuntimes)), content: \(String(describing: content)), createdDate: \(String(describing: createdDate)), description: \(String(describing: description)), layerArn: \(String(describing: layerArn)), layerVersionArn: \(String(describing: layerVersionArn)), licenseInfo: \(String(describing: licenseInfo)), version: \(String(describing: version)))"}
}

extension PublishLayerVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PublishLayerVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.compatibleRuntimes = output.compatibleRuntimes
            self.content = output.content
            self.createdDate = output.createdDate
            self.description = output.description
            self.layerArn = output.layerArn
            self.layerVersionArn = output.layerVersionArn
            self.licenseInfo = output.licenseInfo
            self.version = output.version
        } else {
            self.compatibleRuntimes = nil
            self.content = nil
            self.createdDate = nil
            self.description = nil
            self.layerArn = nil
            self.layerVersionArn = nil
            self.licenseInfo = nil
            self.version = 0
        }
    }
}

public struct PublishLayerVersionOutputResponse: Equatable {
    /// <p>The layer's compatible runtimes.</p>
    public let compatibleRuntimes: [Runtime]?
    /// <p>Details about the layer version.</p>
    public let content: LayerVersionContentOutput?
    /// <p>The date that the layer version was created, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let createdDate: String?
    /// <p>The description of the version.</p>
    public let description: String?
    /// <p>The ARN of the layer.</p>
    public let layerArn: String?
    /// <p>The ARN of the layer version.</p>
    public let layerVersionArn: String?
    /// <p>The layer's software license.</p>
    public let licenseInfo: String?
    /// <p>The version number.</p>
    public let version: Int

    public init (
        compatibleRuntimes: [Runtime]? = nil,
        content: LayerVersionContentOutput? = nil,
        createdDate: String? = nil,
        description: String? = nil,
        layerArn: String? = nil,
        layerVersionArn: String? = nil,
        licenseInfo: String? = nil,
        version: Int = 0
    )
    {
        self.compatibleRuntimes = compatibleRuntimes
        self.content = content
        self.createdDate = createdDate
        self.description = description
        self.layerArn = layerArn
        self.layerVersionArn = layerVersionArn
        self.licenseInfo = licenseInfo
        self.version = version
    }
}

struct PublishLayerVersionOutputResponseBody: Equatable {
    public let content: LayerVersionContentOutput?
    public let layerArn: String?
    public let layerVersionArn: String?
    public let description: String?
    public let createdDate: String?
    public let version: Int
    public let compatibleRuntimes: [Runtime]?
    public let licenseInfo: String?
}

extension PublishLayerVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case compatibleRuntimes = "CompatibleRuntimes"
        case content = "Content"
        case createdDate = "CreatedDate"
        case description = "Description"
        case layerArn = "LayerArn"
        case layerVersionArn = "LayerVersionArn"
        case licenseInfo = "LicenseInfo"
        case version = "Version"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentDecoded = try containerValues.decodeIfPresent(LayerVersionContentOutput.self, forKey: .content)
        content = contentDecoded
        let layerArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerArn)
        layerArn = layerArnDecoded
        let layerVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .layerVersionArn)
        layerVersionArn = layerVersionArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .createdDate)
        createdDate = createdDateDecoded
        let versionDecoded = try containerValues.decode(Int.self, forKey: .version)
        version = versionDecoded
        let compatibleRuntimesContainer = try containerValues.decodeIfPresent([Runtime?].self, forKey: .compatibleRuntimes)
        var compatibleRuntimesDecoded0:[Runtime]? = nil
        if let compatibleRuntimesContainer = compatibleRuntimesContainer {
            compatibleRuntimesDecoded0 = [Runtime]()
            for string0 in compatibleRuntimesContainer {
                if let string0 = string0 {
                    compatibleRuntimesDecoded0?.append(string0)
                }
            }
        }
        compatibleRuntimes = compatibleRuntimesDecoded0
        let licenseInfoDecoded = try containerValues.decodeIfPresent(String.self, forKey: .licenseInfo)
        licenseInfo = licenseInfoDecoded
    }
}

public struct PublishVersionInputBodyMiddleware: Middleware {
    public let id: String = "PublishVersionInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishVersionInput>
    public typealias MOutput = OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishVersionOutputError>
}

extension PublishVersionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishVersionInput(codeSha256: \(String(describing: codeSha256)), description: \(String(describing: description)), functionName: \(String(describing: functionName)), revisionId: \(String(describing: revisionId)))"}
}

extension PublishVersionInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSha256 = codeSha256 {
            try encodeContainer.encode(codeSha256, forKey: .codeSha256)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
    }
}

public struct PublishVersionInputHeadersMiddleware: Middleware {
    public let id: String = "PublishVersionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishVersionInput>
    public typealias MOutput = OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishVersionOutputError>
}

public struct PublishVersionInputQueryItemMiddleware: Middleware {
    public let id: String = "PublishVersionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PublishVersionInput>,
                  next: H) -> Swift.Result<OperationOutput<PublishVersionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PublishVersionInput>
    public typealias MOutput = OperationOutput<PublishVersionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PublishVersionOutputError>
}

public struct PublishVersionInput: Equatable {
    /// <p>Only publish a version if the hash value matches the value that's specified. Use this option to avoid
    ///       publishing a version if the function code has changed since you last updated it. You can get the hash for the
    ///       version that you uploaded from the output of <a>UpdateFunctionCode</a>.</p>
    public let codeSha256: String?
    /// <p>A description for the version to override the description in the function configuration.</p>
    public let description: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid
    ///       publishing a version if the function configuration has changed since you last updated it.</p>
    public let revisionId: String?

    public init (
        codeSha256: String? = nil,
        description: String? = nil,
        functionName: String? = nil,
        revisionId: String? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.description = description
        self.functionName = functionName
        self.revisionId = revisionId
    }
}

struct PublishVersionInputBody: Equatable {
    public let codeSha256: String?
    public let description: String?
    public let revisionId: String?
}

extension PublishVersionInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case description = "Description"
        case revisionId = "RevisionId"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension PublishVersionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PublishVersionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PublishVersionOutputError: Equatable {
    case codeStorageExceededException(CodeStorageExceededException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PublishVersionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PublishVersionOutputResponse(codeSha256: \(String(describing: codeSha256)), codeSize: \(String(describing: codeSize)), deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionArn: \(String(describing: functionArn)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfigResponse: \(String(describing: imageConfigResponse)), kMSKeyArn: \(String(describing: kMSKeyArn)), lastModified: \(String(describing: lastModified)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(String(describing: lastUpdateStatusReasonCode)), layers: \(String(describing: layers)), masterArn: \(String(describing: masterArn)), memorySize: \(String(describing: memorySize)), packageType: \(String(describing: packageType)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), version: \(String(describing: version)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension PublishVersionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PublishVersionOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// <p>Details about a function's configuration.</p>
public struct PublishVersionOutputResponse: Equatable {
    /// <p>The SHA256 hash of the function's deployment package.</p>
    public let codeSha256: String?
    /// <p>The size of the function's deployment package, in bytes.</p>
    public let codeSize: Int
    /// <p>The function's dead letter queue.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>The function's description.</p>
    public let description: String?
    /// <p>The function's environment variables.</p>
    public let environment: EnvironmentResponse?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let functionArn: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The function that Lambda calls to begin executing your function.</p>
    public let handler: String?
    /// <p>The function's image configuration values.</p>
    public let imageConfigResponse: ImageConfigResponse?
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.</p>
    public let kMSKeyArn: String?
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let lastModified: String?
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    ///       after function creation completes.</p>
    public let lastUpdateStatus: LastUpdateStatus?
    /// <p>The reason for the last update that was performed on the function.</p>
    public let lastUpdateStatusReason: String?
    /// <p>The reason code for the last update that was performed on the function.</p>
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers</a>.</p>
    public let layers: [Layer]?
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    public let masterArn: String?
    /// <p>The amount of memory available to the function at runtime. </p>
    public let memorySize: Int?
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    public let packageType: PackageType?
    /// <p>The latest updated revision of the function or alias.</p>
    public let revisionId: String?
    /// <p>The function's execution role.</p>
    public let role: String?
    /// <p>The runtime environment for the Lambda function.</p>
    public let runtime: Runtime?
    /// <p>The ARN of the signing job.</p>
    public let signingJobArn: String?
    /// <p>The ARN of the signing profile version.</p>
    public let signingProfileVersionArn: String?
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    ///       invoking it.</p>
    public let state: State?
    /// <p>The reason for the function's current state.</p>
    public let stateReason: String?
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    ///       modify the function.</p>
    public let stateReasonCode: StateReasonCode?
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    public let timeout: Int?
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    public let tracingConfig: TracingConfigResponse?
    /// <p>The version of the Lambda function.</p>
    public let version: String?
    /// <p>The function's networking configuration.</p>
    public let vpcConfig: VpcConfigResponse?

    public init (
        codeSha256: String? = nil,
        codeSize: Int = 0,
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: EnvironmentResponse? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionArn: String? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfigResponse: ImageConfigResponse? = nil,
        kMSKeyArn: String? = nil,
        lastModified: String? = nil,
        lastUpdateStatus: LastUpdateStatus? = nil,
        lastUpdateStatusReason: String? = nil,
        lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil,
        layers: [Layer]? = nil,
        masterArn: String? = nil,
        memorySize: Int? = nil,
        packageType: PackageType? = nil,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: Runtime? = nil,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil,
        state: State? = nil,
        stateReason: String? = nil,
        stateReasonCode: StateReasonCode? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfigResponse? = nil,
        version: String? = nil,
        vpcConfig: VpcConfigResponse? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct PublishVersionOutputResponseBody: Equatable {
    public let functionName: String?
    public let functionArn: String?
    public let runtime: Runtime?
    public let role: String?
    public let handler: String?
    public let codeSize: Int
    public let description: String?
    public let timeout: Int?
    public let memorySize: Int?
    public let lastModified: String?
    public let codeSha256: String?
    public let version: String?
    public let vpcConfig: VpcConfigResponse?
    public let deadLetterConfig: DeadLetterConfig?
    public let environment: EnvironmentResponse?
    public let kMSKeyArn: String?
    public let tracingConfig: TracingConfigResponse?
    public let masterArn: String?
    public let revisionId: String?
    public let layers: [Layer]?
    public let state: State?
    public let stateReason: String?
    public let stateReasonCode: StateReasonCode?
    public let lastUpdateStatus: LastUpdateStatus?
    public let lastUpdateStatusReason: String?
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [FileSystemConfig]?
    public let packageType: PackageType?
    public let imageConfigResponse: ImageConfigResponse?
    public let signingProfileVersionArn: String?
    public let signingJobArn: String?
}

extension PublishVersionOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

public struct PutFunctionCodeSigningConfigInputBodyMiddleware: Middleware {
    public let id: String = "PutFunctionCodeSigningConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionCodeSigningConfigOutputError>
}

extension PutFunctionCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFunctionCodeSigningConfigInput(codeSigningConfigArn: \(String(describing: codeSigningConfigArn)), functionName: \(String(describing: functionName)))"}
}

extension PutFunctionCodeSigningConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let codeSigningConfigArn = codeSigningConfigArn {
            try encodeContainer.encode(codeSigningConfigArn, forKey: .codeSigningConfigArn)
        }
    }
}

public struct PutFunctionCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "PutFunctionCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionCodeSigningConfigOutputError>
}

public struct PutFunctionCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFunctionCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<PutFunctionCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionCodeSigningConfigOutputError>
}

public struct PutFunctionCodeSigningConfigInput: Equatable {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    public let codeSigningConfigArn: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?

    public init (
        codeSigningConfigArn: String? = nil,
        functionName: String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigInputBody: Equatable {
    public let codeSigningConfigArn: String?
}

extension PutFunctionCodeSigningConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
    }
}

extension PutFunctionCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionCodeSigningConfigOutputError: Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFunctionCodeSigningConfigOutputResponse(codeSigningConfigArn: \(String(describing: codeSigningConfigArn)), functionName: \(String(describing: functionName)))"}
}

extension PutFunctionCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutFunctionCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSigningConfigArn = output.codeSigningConfigArn
            self.functionName = output.functionName
        } else {
            self.codeSigningConfigArn = nil
            self.functionName = nil
        }
    }
}

public struct PutFunctionCodeSigningConfigOutputResponse: Equatable {
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    public let codeSigningConfigArn: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?

    public init (
        codeSigningConfigArn: String? = nil,
        functionName: String? = nil
    )
    {
        self.codeSigningConfigArn = codeSigningConfigArn
        self.functionName = functionName
    }
}

struct PutFunctionCodeSigningConfigOutputResponseBody: Equatable {
    public let codeSigningConfigArn: String?
    public let functionName: String?
}

extension PutFunctionCodeSigningConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfigArn = "CodeSigningConfigArn"
        case functionName = "FunctionName"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSigningConfigArn)
        codeSigningConfigArn = codeSigningConfigArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
    }
}

public struct PutFunctionConcurrencyInputBodyMiddleware: Middleware {
    public let id: String = "PutFunctionConcurrencyInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionConcurrencyInput>
    public typealias MOutput = OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionConcurrencyOutputError>
}

extension PutFunctionConcurrencyInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFunctionConcurrencyInput(functionName: \(String(describing: functionName)), reservedConcurrentExecutions: \(String(describing: reservedConcurrentExecutions)))"}
}

extension PutFunctionConcurrencyInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reservedConcurrentExecutions = reservedConcurrentExecutions {
            try encodeContainer.encode(reservedConcurrentExecutions, forKey: .reservedConcurrentExecutions)
        }
    }
}

public struct PutFunctionConcurrencyInputHeadersMiddleware: Middleware {
    public let id: String = "PutFunctionConcurrencyInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionConcurrencyInput>
    public typealias MOutput = OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionConcurrencyOutputError>
}

public struct PutFunctionConcurrencyInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFunctionConcurrencyInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionConcurrencyInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionConcurrencyOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionConcurrencyInput>
    public typealias MOutput = OperationOutput<PutFunctionConcurrencyOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionConcurrencyOutputError>
}

public struct PutFunctionConcurrencyInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The number of simultaneous executions to reserve for the function.</p>
    public let reservedConcurrentExecutions: Int?

    public init (
        functionName: String? = nil,
        reservedConcurrentExecutions: Int? = nil
    )
    {
        self.functionName = functionName
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyInputBody: Equatable {
    public let reservedConcurrentExecutions: Int?
}

extension PutFunctionConcurrencyInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

extension PutFunctionConcurrencyOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionConcurrencyOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionConcurrencyOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionConcurrencyOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFunctionConcurrencyOutputResponse(reservedConcurrentExecutions: \(String(describing: reservedConcurrentExecutions)))"}
}

extension PutFunctionConcurrencyOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutFunctionConcurrencyOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.reservedConcurrentExecutions = output.reservedConcurrentExecutions
        } else {
            self.reservedConcurrentExecutions = nil
        }
    }
}

public struct PutFunctionConcurrencyOutputResponse: Equatable {
    /// <p>The number of concurrent executions that are reserved for this function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/concurrent-executions.html">Managing Concurrency</a>.</p>
    public let reservedConcurrentExecutions: Int?

    public init (
        reservedConcurrentExecutions: Int? = nil
    )
    {
        self.reservedConcurrentExecutions = reservedConcurrentExecutions
    }
}

struct PutFunctionConcurrencyOutputResponseBody: Equatable {
    public let reservedConcurrentExecutions: Int?
}

extension PutFunctionConcurrencyOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reservedConcurrentExecutions = "ReservedConcurrentExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reservedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .reservedConcurrentExecutions)
        reservedConcurrentExecutions = reservedConcurrentExecutionsDecoded
    }
}

public struct PutFunctionEventInvokeConfigInputBodyMiddleware: Middleware {
    public let id: String = "PutFunctionEventInvokeConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionEventInvokeConfigOutputError>
}

extension PutFunctionEventInvokeConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFunctionEventInvokeConfigInput(destinationConfig: \(String(describing: destinationConfig)), functionName: \(String(describing: functionName)), maximumEventAgeInSeconds: \(String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), qualifier: \(String(describing: qualifier)))"}
}

extension PutFunctionEventInvokeConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

public struct PutFunctionEventInvokeConfigInputHeadersMiddleware: Middleware {
    public let id: String = "PutFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionEventInvokeConfigOutputError>
}

public struct PutFunctionEventInvokeConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "PutFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<PutFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutFunctionEventInvokeConfigOutputError>
}

public struct PutFunctionEventInvokeConfigInput: Equatable {
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    ///          <p class="title">
    ///             <b>Destinations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Queue</b> - The ARN of an SQS queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Topic</b> - The ARN of an SNS topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    ///             </li>
    ///          </ul>
    public let destinationConfig: DestinationConfig?
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    public let maximumEventAgeInSeconds: Int?
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    public let maximumRetryAttempts: Int?
    /// <p>A version number or alias name.</p>
    public let qualifier: String?

    public init (
        destinationConfig: DestinationConfig? = nil,
        functionName: String? = nil,
        maximumEventAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        qualifier: String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct PutFunctionEventInvokeConfigInputBody: Equatable {
    public let maximumRetryAttempts: Int?
    public let maximumEventAgeInSeconds: Int?
    public let destinationConfig: DestinationConfig?
}

extension PutFunctionEventInvokeConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension PutFunctionEventInvokeConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutFunctionEventInvokeConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutFunctionEventInvokeConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutFunctionEventInvokeConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutFunctionEventInvokeConfigOutputResponse(destinationConfig: \(String(describing: destinationConfig)), functionArn: \(String(describing: functionArn)), lastModified: \(String(describing: lastModified)), maximumEventAgeInSeconds: \(String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)))"}
}

extension PutFunctionEventInvokeConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct PutFunctionEventInvokeConfigOutputResponse: Equatable {
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    ///          <p class="title">
    ///             <b>Destinations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Queue</b> - The ARN of an SQS queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Topic</b> - The ARN of an SNS topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    ///             </li>
    ///          </ul>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    public let functionArn: String?
    /// <p>The date and time that the configuration was last updated.</p>
    public let lastModified: Date?
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    public let maximumEventAgeInSeconds: Int?
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    public let maximumRetryAttempts: Int?

    public init (
        destinationConfig: DestinationConfig? = nil,
        functionArn: String? = nil,
        lastModified: Date? = nil,
        maximumEventAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct PutFunctionEventInvokeConfigOutputResponseBody: Equatable {
    public let lastModified: Date?
    public let functionArn: String?
    public let maximumRetryAttempts: Int?
    public let maximumEventAgeInSeconds: Int?
    public let destinationConfig: DestinationConfig?
}

extension PutFunctionEventInvokeConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

public struct PutProvisionedConcurrencyConfigInputBodyMiddleware: Middleware {
    public let id: String = "PutProvisionedConcurrencyConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProvisionedConcurrencyConfigInput>
    public typealias MOutput = OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProvisionedConcurrencyConfigOutputError>
}

extension PutProvisionedConcurrencyConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProvisionedConcurrencyConfigInput(functionName: \(String(describing: functionName)), provisionedConcurrentExecutions: \(String(describing: provisionedConcurrentExecutions)), qualifier: \(String(describing: qualifier)))"}
}

extension PutProvisionedConcurrencyConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let provisionedConcurrentExecutions = provisionedConcurrentExecutions {
            try encodeContainer.encode(provisionedConcurrentExecutions, forKey: .provisionedConcurrentExecutions)
        }
    }
}

public struct PutProvisionedConcurrencyConfigInputHeadersMiddleware: Middleware {
    public let id: String = "PutProvisionedConcurrencyConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProvisionedConcurrencyConfigInput>
    public typealias MOutput = OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProvisionedConcurrencyConfigOutputError>
}

public struct PutProvisionedConcurrencyConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "PutProvisionedConcurrencyConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<PutProvisionedConcurrencyConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<PutProvisionedConcurrencyConfigInput>
    public typealias MOutput = OperationOutput<PutProvisionedConcurrencyConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<PutProvisionedConcurrencyConfigOutputError>
}

public struct PutProvisionedConcurrencyConfigInput: Equatable {
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The amount of provisioned concurrency to allocate for the version or alias.</p>
    public let provisionedConcurrentExecutions: Int?
    /// <p>The version number or alias name.</p>
    public let qualifier: String?

    public init (
        functionName: String? = nil,
        provisionedConcurrentExecutions: Int? = nil,
        qualifier: String? = nil
    )
    {
        self.functionName = functionName
        self.provisionedConcurrentExecutions = provisionedConcurrentExecutions
        self.qualifier = qualifier
    }
}

struct PutProvisionedConcurrencyConfigInputBody: Equatable {
    public let provisionedConcurrentExecutions: Int?
}

extension PutProvisionedConcurrencyConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case provisionedConcurrentExecutions = "ProvisionedConcurrentExecutions"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let provisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .provisionedConcurrentExecutions)
        provisionedConcurrentExecutions = provisionedConcurrentExecutionsDecoded
    }
}

extension PutProvisionedConcurrencyConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutProvisionedConcurrencyConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum PutProvisionedConcurrencyConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutProvisionedConcurrencyConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "PutProvisionedConcurrencyConfigOutputResponse(allocatedProvisionedConcurrentExecutions: \(String(describing: allocatedProvisionedConcurrentExecutions)), availableProvisionedConcurrentExecutions: \(String(describing: availableProvisionedConcurrentExecutions)), lastModified: \(String(describing: lastModified)), requestedProvisionedConcurrentExecutions: \(String(describing: requestedProvisionedConcurrentExecutions)), status: \(String(describing: status)), statusReason: \(String(describing: statusReason)))"}
}

extension PutProvisionedConcurrencyConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: PutProvisionedConcurrencyConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.allocatedProvisionedConcurrentExecutions = output.allocatedProvisionedConcurrentExecutions
            self.availableProvisionedConcurrentExecutions = output.availableProvisionedConcurrentExecutions
            self.lastModified = output.lastModified
            self.requestedProvisionedConcurrentExecutions = output.requestedProvisionedConcurrentExecutions
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.allocatedProvisionedConcurrentExecutions = nil
            self.availableProvisionedConcurrentExecutions = nil
            self.lastModified = nil
            self.requestedProvisionedConcurrentExecutions = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct PutProvisionedConcurrencyConfigOutputResponse: Equatable {
    /// <p>The amount of provisioned concurrency allocated.</p>
    public let allocatedProvisionedConcurrentExecutions: Int?
    /// <p>The amount of provisioned concurrency available.</p>
    public let availableProvisionedConcurrentExecutions: Int?
    /// <p>The date and time that a user last updated the configuration, in <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO 8601 format</a>.</p>
    public let lastModified: String?
    /// <p>The amount of provisioned concurrency requested.</p>
    public let requestedProvisionedConcurrentExecutions: Int?
    /// <p>The status of the allocation process.</p>
    public let status: ProvisionedConcurrencyStatusEnum?
    /// <p>For failed allocations, the reason that provisioned concurrency could not be allocated.</p>
    public let statusReason: String?

    public init (
        allocatedProvisionedConcurrentExecutions: Int? = nil,
        availableProvisionedConcurrentExecutions: Int? = nil,
        lastModified: String? = nil,
        requestedProvisionedConcurrentExecutions: Int? = nil,
        status: ProvisionedConcurrencyStatusEnum? = nil,
        statusReason: String? = nil
    )
    {
        self.allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutions
        self.availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutions
        self.lastModified = lastModified
        self.requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutions
        self.status = status
        self.statusReason = statusReason
    }
}

struct PutProvisionedConcurrencyConfigOutputResponseBody: Equatable {
    public let requestedProvisionedConcurrentExecutions: Int?
    public let availableProvisionedConcurrentExecutions: Int?
    public let allocatedProvisionedConcurrentExecutions: Int?
    public let status: ProvisionedConcurrencyStatusEnum?
    public let statusReason: String?
    public let lastModified: String?
}

extension PutProvisionedConcurrencyConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allocatedProvisionedConcurrentExecutions = "AllocatedProvisionedConcurrentExecutions"
        case availableProvisionedConcurrentExecutions = "AvailableProvisionedConcurrentExecutions"
        case lastModified = "LastModified"
        case requestedProvisionedConcurrentExecutions = "RequestedProvisionedConcurrentExecutions"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .requestedProvisionedConcurrentExecutions)
        requestedProvisionedConcurrentExecutions = requestedProvisionedConcurrentExecutionsDecoded
        let availableProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .availableProvisionedConcurrentExecutions)
        availableProvisionedConcurrentExecutions = availableProvisionedConcurrentExecutionsDecoded
        let allocatedProvisionedConcurrentExecutionsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .allocatedProvisionedConcurrentExecutions)
        allocatedProvisionedConcurrentExecutions = allocatedProvisionedConcurrentExecutionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ProvisionedConcurrencyStatusEnum.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
    }
}

extension RemoveLayerVersionPermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveLayerVersionPermissionInput(layerName: \(String(describing: layerName)), revisionId: \(String(describing: revisionId)), statementId: \(String(describing: statementId)), versionNumber: \(String(describing: versionNumber)))"}
}

extension RemoveLayerVersionPermissionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemoveLayerVersionPermissionInputHeadersMiddleware: Middleware {
    public let id: String = "RemoveLayerVersionPermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveLayerVersionPermissionInput>
    public typealias MOutput = OperationOutput<RemoveLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveLayerVersionPermissionOutputError>
}

public struct RemoveLayerVersionPermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemoveLayerVersionPermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemoveLayerVersionPermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemoveLayerVersionPermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemoveLayerVersionPermissionInput>
    public typealias MOutput = OperationOutput<RemoveLayerVersionPermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemoveLayerVersionPermissionOutputError>
}

public struct RemoveLayerVersionPermissionInput: Equatable {
    /// <p>The name or Amazon Resource Name (ARN) of the layer.</p>
    public let layerName: String?
    /// <p>Only update the policy if the revision ID matches the ID specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.</p>
    public let revisionId: String?
    /// <p>The identifier that was specified when the statement was added.</p>
    public let statementId: String?
    /// <p>The version number.</p>
    public let versionNumber: Int

    public init (
        layerName: String? = nil,
        revisionId: String? = nil,
        statementId: String? = nil,
        versionNumber: Int = 0
    )
    {
        self.layerName = layerName
        self.revisionId = revisionId
        self.statementId = statementId
        self.versionNumber = versionNumber
    }
}

struct RemoveLayerVersionPermissionInputBody: Equatable {
}

extension RemoveLayerVersionPermissionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemoveLayerVersionPermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemoveLayerVersionPermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemoveLayerVersionPermissionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemoveLayerVersionPermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemoveLayerVersionPermissionOutputResponse()"}
}

extension RemoveLayerVersionPermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemoveLayerVersionPermissionOutputResponse: Equatable {

    public init() {}
}

struct RemoveLayerVersionPermissionOutputResponseBody: Equatable {
}

extension RemoveLayerVersionPermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemovePermissionInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionInput(functionName: \(String(describing: functionName)), qualifier: \(String(describing: qualifier)), revisionId: \(String(describing: revisionId)), statementId: \(String(describing: statementId)))"}
}

extension RemovePermissionInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct RemovePermissionInputHeadersMiddleware: Middleware {
    public let id: String = "RemovePermissionInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInputQueryItemMiddleware: Middleware {
    public let id: String = "RemovePermissionInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<RemovePermissionInput>,
                  next: H) -> Swift.Result<OperationOutput<RemovePermissionOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        if let revisionId = input.operationInput.revisionId {
            let revisionIdQueryItem = URLQueryItem(name: "RevisionId".urlPercentEncoding(), value: String(revisionId).urlPercentEncoding())
            input.builder.withQueryItem(revisionIdQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<RemovePermissionInput>
    public typealias MOutput = OperationOutput<RemovePermissionOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<RemovePermissionOutputError>
}

public struct RemovePermissionInput: Equatable {
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>Specify a version or alias to remove permissions from a published version of the function.</p>
    public let qualifier: String?
    /// <p>Only update the policy if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       policy that has changed since you last read it.</p>
    public let revisionId: String?
    /// <p>Statement ID of the permission to remove.</p>
    public let statementId: String?

    public init (
        functionName: String? = nil,
        qualifier: String? = nil,
        revisionId: String? = nil,
        statementId: String? = nil
    )
    {
        self.functionName = functionName
        self.qualifier = qualifier
        self.revisionId = revisionId
        self.statementId = statementId
    }
}

struct RemovePermissionInputBody: Equatable {
}

extension RemovePermissionInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RemovePermissionOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RemovePermissionOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum RemovePermissionOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RemovePermissionOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RemovePermissionOutputResponse()"}
}

extension RemovePermissionOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct RemovePermissionOutputResponse: Equatable {

    public init() {}
}

struct RemovePermissionOutputResponseBody: Equatable {
}

extension RemovePermissionOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension RequestTooLargeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "RequestTooLargeException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension RequestTooLargeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: RequestTooLargeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request payload exceeded the <code>Invoke</code> request body JSON input limit. For more information, see
///         <a href="https://docs.aws.amazon.com/lambda/latest/dg/limits.html">Limits</a>. </p>
public struct RequestTooLargeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct RequestTooLargeExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension RequestTooLargeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceConflictException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceConflictException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension ResourceConflictException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceConflictExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource already exists, or another operation is in progress.</p>
public struct ResourceConflictException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    /// <p>The exception message.</p>
    public var message: String?
    /// <p>The exception type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceConflictExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension ResourceConflictExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceInUseException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceInUseException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ResourceInUseException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The operation conflicts with the resource's availability. For example, you attempted to update an EventSource
///       Mapping in CREATING, or tried to delete a EventSource mapping currently in the UPDATING state.</p>
public struct ResourceInUseException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceInUseExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension ResourceInUseExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotFoundException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ResourceNotFoundException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The resource specified in the request does not exist.</p>
public struct ResourceNotFoundException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceNotFoundExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension ResourceNotFoundExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotReadyException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ResourceNotReadyException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension ResourceNotReadyException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ResourceNotReadyExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The function is inactive and its VPC connection is no longer available. Wait for the VPC connection to
///       reestablish and try again.</p>
public struct ResourceNotReadyException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    /// <p>The exception message.</p>
    public var message: String?
    /// <p>The exception type.</p>
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ResourceNotReadyExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension ResourceNotReadyExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum Runtime {
    case dotnetcore10
    case dotnetcore20
    case dotnetcore21
    case dotnetcore31
    case go1x
    case java11
    case java8
    case java8al2
    case nodejs
    case nodejs10x
    case nodejs12x
    case nodejs14x
    case nodejs43
    case nodejs43edge
    case nodejs610
    case nodejs810
    case provided
    case providedal2
    case python27
    case python36
    case python37
    case python38
    case ruby25
    case ruby27
    case sdkUnknown(String)
}

extension Runtime : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [Runtime] {
        return [
            .dotnetcore10,
            .dotnetcore20,
            .dotnetcore21,
            .dotnetcore31,
            .go1x,
            .java11,
            .java8,
            .java8al2,
            .nodejs,
            .nodejs10x,
            .nodejs12x,
            .nodejs14x,
            .nodejs43,
            .nodejs43edge,
            .nodejs610,
            .nodejs810,
            .provided,
            .providedal2,
            .python27,
            .python36,
            .python37,
            .python38,
            .ruby25,
            .ruby27,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .dotnetcore10: return "dotnetcore1.0"
        case .dotnetcore20: return "dotnetcore2.0"
        case .dotnetcore21: return "dotnetcore2.1"
        case .dotnetcore31: return "dotnetcore3.1"
        case .go1x: return "go1.x"
        case .java11: return "java11"
        case .java8: return "java8"
        case .java8al2: return "java8.al2"
        case .nodejs: return "nodejs"
        case .nodejs10x: return "nodejs10.x"
        case .nodejs12x: return "nodejs12.x"
        case .nodejs14x: return "nodejs14.x"
        case .nodejs43: return "nodejs4.3"
        case .nodejs43edge: return "nodejs4.3-edge"
        case .nodejs610: return "nodejs6.10"
        case .nodejs810: return "nodejs8.10"
        case .provided: return "provided"
        case .providedal2: return "provided.al2"
        case .python27: return "python2.7"
        case .python36: return "python3.6"
        case .python37: return "python3.7"
        case .python38: return "python3.8"
        case .ruby25: return "ruby2.5"
        case .ruby27: return "ruby2.7"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = Runtime(rawValue: rawValue) ?? Runtime.sdkUnknown(rawValue)
    }
}

extension SelfManagedEventSource: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case endpoints = "Endpoints"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endpoints = endpoints {
            var endpointsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .endpoints)
            for (dictKey0, endpoints0) in endpoints {
                try endpointsContainer.encode(endpoints0, forKey: Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointsContainer = try containerValues.decodeIfPresent([String: [String?]?].self, forKey: .endpoints)
        var endpointsDecoded0: [String:[String]]? = nil
        if let endpointsContainer = endpointsContainer {
            endpointsDecoded0 = [String:[String]]()
            for (key0, endpointlists0) in endpointsContainer {
                var endpointlists0Decoded0: [String]? = nil
                if let endpointlists0 = endpointlists0 {
                    endpointlists0Decoded0 = [String]()
                    for string1 in endpointlists0 {
                        if let string1 = string1 {
                            endpointlists0Decoded0?.append(string1)
                        }
                    }
                }
                endpointsDecoded0?[key0] = endpointlists0Decoded0
            }
        }
        endpoints = endpointsDecoded0
    }
}

extension SelfManagedEventSource: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SelfManagedEventSource(endpoints: \(String(describing: endpoints)))"}
}

/// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
public struct SelfManagedEventSource: Equatable {
    /// <p>The list of bootstrap servers for your Kafka brokers in the following format: <code>"KAFKA_BOOTSTRAP_SERVERS": ["abc.xyz.com:xxxx","abc2.xyz.com:xxxx"]</code>.</p>
    public let endpoints: [String:[String]]?

    public init (
        endpoints: [String:[String]]? = nil
    )
    {
        self.endpoints = endpoints
    }
}

extension ServiceException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "ServiceException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension ServiceException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: ServiceExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The AWS Lambda service encountered an internal error.</p>
public struct ServiceException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct ServiceExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension ServiceExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SourceAccessConfiguration: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case uRI = "URI"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let uRI = uRI {
            try encodeContainer.encode(uRI, forKey: .uRI)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(SourceAccessType.self, forKey: .type)
        type = typeDecoded
        let uRIDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uRI)
        uRI = uRIDecoded
    }
}

extension SourceAccessConfiguration: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SourceAccessConfiguration(type: \(String(describing: type)), uRI: \(String(describing: uRI)))"}
}

/// <p>You can specify the authentication protocol, or the VPC components to secure access to your event source.</p>
public struct SourceAccessConfiguration: Equatable {
    /// <p>The type of authentication protocol or the VPC components for your event source. For example: <code>"Type":"SASL_SCRAM_512_AUTH"</code>.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <code>BASIC_AUTH</code> - (MQ) The Secrets Manager secret that stores your broker credentials.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VPC_SUBNET</code> - The subnets associated with your VPC. Lambda connects to these subnets to fetch data from your Self-Managed Apache Kafka cluster.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>VPC_SECURITY_GROUP</code> - The VPC security group used to manage access to your Self-Managed Apache Kafka brokers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SASL_SCRAM_256_AUTH</code> - The Secrets Manager ARN of your secret key used for SASL SCRAM-256 authentication of your Self-Managed Apache Kafka brokers.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <code>SASL_SCRAM_512_AUTH</code> - The Secrets Manager ARN of your secret key used for SASL SCRAM-512 authentication of your Self-Managed Apache Kafka brokers.</p>
    ///             </li>
    ///          </ul>
    public let type: SourceAccessType?
    /// <p>The value for your chosen configuration in <code>Type</code>. For example: <code>"URI": "arn:aws:secretsmanager:us-east-1:01234567890:secret:MyBrokerSecretName"</code>.</p>
    public let uRI: String?

    public init (
        type: SourceAccessType? = nil,
        uRI: String? = nil
    )
    {
        self.type = type
        self.uRI = uRI
    }
}

public enum SourceAccessType {
    case basicAuth
    case saslScram256Auth
    case saslScram512Auth
    case vpcSecurityGroup
    case vpcSubnet
    case sdkUnknown(String)
}

extension SourceAccessType : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [SourceAccessType] {
        return [
            .basicAuth,
            .saslScram256Auth,
            .saslScram512Auth,
            .vpcSecurityGroup,
            .vpcSubnet,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .basicAuth: return "BASIC_AUTH"
        case .saslScram256Auth: return "SASL_SCRAM_256_AUTH"
        case .saslScram512Auth: return "SASL_SCRAM_512_AUTH"
        case .vpcSecurityGroup: return "VPC_SECURITY_GROUP"
        case .vpcSubnet: return "VPC_SUBNET"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = SourceAccessType(rawValue: rawValue) ?? SourceAccessType.sdkUnknown(rawValue)
    }
}

public enum State {
    case active
    case failed
    case inactive
    case pending
    case sdkUnknown(String)
}

extension State : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [State] {
        return [
            .active,
            .failed,
            .inactive,
            .pending,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .failed: return "Failed"
        case .inactive: return "Inactive"
        case .pending: return "Pending"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = State(rawValue: rawValue) ?? State.sdkUnknown(rawValue)
    }
}

public enum StateReasonCode {
    case creating
    case enilimitexceeded
    case idle
    case imageaccessdenied
    case imagedeleted
    case insufficientrolepermissions
    case internalerror
    case invalidconfiguration
    case invalidimage
    case invalidsecuritygroup
    case invalidsubnet
    case restoring
    case subnetoutofipaddresses
    case sdkUnknown(String)
}

extension StateReasonCode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [StateReasonCode] {
        return [
            .creating,
            .enilimitexceeded,
            .idle,
            .imageaccessdenied,
            .imagedeleted,
            .insufficientrolepermissions,
            .internalerror,
            .invalidconfiguration,
            .invalidimage,
            .invalidsecuritygroup,
            .invalidsubnet,
            .restoring,
            .subnetoutofipaddresses,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .creating: return "Creating"
        case .enilimitexceeded: return "EniLimitExceeded"
        case .idle: return "Idle"
        case .imageaccessdenied: return "ImageAccessDenied"
        case .imagedeleted: return "ImageDeleted"
        case .insufficientrolepermissions: return "InsufficientRolePermissions"
        case .internalerror: return "InternalError"
        case .invalidconfiguration: return "InvalidConfiguration"
        case .invalidimage: return "InvalidImage"
        case .invalidsecuritygroup: return "InvalidSecurityGroup"
        case .invalidsubnet: return "InvalidSubnet"
        case .restoring: return "Restoring"
        case .subnetoutofipaddresses: return "SubnetOutOfIPAddresses"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = StateReasonCode(rawValue: rawValue) ?? StateReasonCode.sdkUnknown(rawValue)
    }
}

extension SubnetIPAddressLimitReachedException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "SubnetIPAddressLimitReachedException(message: \(String(describing: message)), type: \(String(describing: type)))"}
}

extension SubnetIPAddressLimitReachedException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: SubnetIPAddressLimitReachedExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>AWS Lambda was not able to set up VPC access for the Lambda function because one or more configured subnets
///       has no available IP addresses.</p>
public struct SubnetIPAddressLimitReachedException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .server
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct SubnetIPAddressLimitReachedExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension SubnetIPAddressLimitReachedExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case message = "Message"
        case type = "Type"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct TagResourceInputBodyMiddleware: Middleware {
    public let id: String = "TagResourceInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

extension TagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceInput(resource: \(String(describing: resource)), tags: \(String(describing: tags)))"}
}

extension TagResourceInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: Key(stringValue: dictKey0))
            }
        }
    }
}

public struct TagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "TagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "TagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<TagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<TagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<TagResourceInput>
    public typealias MOutput = OperationOutput<TagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<TagResourceOutputError>
}

public struct TagResourceInput: Equatable {
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let resource: String?
    /// <p>A list of tags to apply to the function.</p>
    public let tags: [String:String]?

    public init (
        resource: String? = nil,
        tags: [String:String]? = nil
    )
    {
        self.resource = resource
        self.tags = tags
    }
}

struct TagResourceInputBody: Equatable {
    public let tags: [String:String]?
}

extension TagResourceInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case tags = "Tags"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([String: String?].self, forKey: .tags)
        var tagsDecoded0: [String:String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [String:String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum TagResourceOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TagResourceOutputResponse()"}
}

extension TagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Equatable {

    public init() {}
}

struct TagResourceOutputResponseBody: Equatable {
}

extension TagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public enum ThrottleReason {
    case callerratelimitexceeded
    case concurrentinvocationlimitexceeded
    case functioninvocationratelimitexceeded
    case reservedfunctionconcurrentinvocationlimitexceeded
    case reservedfunctioninvocationratelimitexceeded
    case sdkUnknown(String)
}

extension ThrottleReason : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [ThrottleReason] {
        return [
            .callerratelimitexceeded,
            .concurrentinvocationlimitexceeded,
            .functioninvocationratelimitexceeded,
            .reservedfunctionconcurrentinvocationlimitexceeded,
            .reservedfunctioninvocationratelimitexceeded,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .callerratelimitexceeded: return "CallerRateLimitExceeded"
        case .concurrentinvocationlimitexceeded: return "ConcurrentInvocationLimitExceeded"
        case .functioninvocationratelimitexceeded: return "FunctionInvocationRateLimitExceeded"
        case .reservedfunctionconcurrentinvocationlimitexceeded: return "ReservedFunctionConcurrentInvocationLimitExceeded"
        case .reservedfunctioninvocationratelimitexceeded: return "ReservedFunctionInvocationRateLimitExceeded"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = ThrottleReason(rawValue: rawValue) ?? ThrottleReason.sdkUnknown(rawValue)
    }
}

extension TooManyRequestsException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TooManyRequestsException(reason: \(String(describing: reason)), type: \(String(describing: type)), message: \(String(describing: message)), retryAfterSeconds: \(String(describing: retryAfterSeconds)))"}
}

extension TooManyRequestsException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.reason = output.reason
            self.type = output.type
        } else {
            self.reason = nil
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The request throughput limit was exceeded.</p>
public struct TooManyRequestsException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var reason: ThrottleReason?
    /// <p>The number of seconds the caller should wait before retrying.</p>
    public var retryAfterSeconds: String?
    public var type: String?

    public init (
        message: String? = nil,
        reason: ThrottleReason? = nil,
        retryAfterSeconds: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.reason = reason
        self.retryAfterSeconds = retryAfterSeconds
        self.type = type
    }
}

struct TooManyRequestsExceptionBody: Equatable {
    public let type: String?
    public let message: String?
    public let reason: ThrottleReason?
}

extension TooManyRequestsExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case reason = "Reason"
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ThrottleReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension TracingConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension TracingConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TracingConfig(mode: \(String(describing: mode)))"}
}

/// <p>The function's AWS X-Ray tracing configuration. To sample and record incoming requests, set <code>Mode</code>
///       to <code>Active</code>.</p>
public struct TracingConfig: Equatable {
    /// <p>The tracing mode.</p>
    public let mode: TracingMode?

    public init (
        mode: TracingMode? = nil
    )
    {
        self.mode = mode
    }
}

extension TracingConfigResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case mode = "Mode"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mode = mode {
            try encodeContainer.encode(mode.rawValue, forKey: .mode)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modeDecoded = try containerValues.decodeIfPresent(TracingMode.self, forKey: .mode)
        mode = modeDecoded
    }
}

extension TracingConfigResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "TracingConfigResponse(mode: \(String(describing: mode)))"}
}

/// <p>The function's AWS X-Ray tracing configuration.</p>
public struct TracingConfigResponse: Equatable {
    /// <p>The tracing mode.</p>
    public let mode: TracingMode?

    public init (
        mode: TracingMode? = nil
    )
    {
        self.mode = mode
    }
}

public enum TracingMode {
    case active
    case passthrough
    case sdkUnknown(String)
}

extension TracingMode : Equatable, RawRepresentable, Codable, CaseIterable, Hashable {
    public static var allCases: [TracingMode] {
        return [
            .active,
            .passthrough,
            .sdkUnknown("")
        ]
    }
    public init?(rawValue: String) {
        let value = Self.allCases.first(where: { $0.rawValue == rawValue })
        self = value ?? Self.sdkUnknown(rawValue)
    }
    public var rawValue: String {
        switch self {
        case .active: return "Active"
        case .passthrough: return "PassThrough"
        case let .sdkUnknown(s): return s
        }
    }
    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let rawValue = try container.decode(RawValue.self)
        self = TracingMode(rawValue: rawValue) ?? TracingMode.sdkUnknown(rawValue)
    }
}

extension UnsupportedMediaTypeException: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UnsupportedMediaTypeException(type: \(String(describing: type)), message: \(String(describing: message)))"}
}

extension UnsupportedMediaTypeException: AWSHttpServiceError {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UnsupportedMediaTypeExceptionBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.message = output.message
            self.type = output.type
        } else {
            self.type = nil
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// <p>The content type of the <code>Invoke</code> request body is not JSON.</p>
public struct UnsupportedMediaTypeException: ClientRuntime.ServiceError, Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: HttpStatusCode?
    public var _message: String?
    public var _requestID: String?
    public var _retryable: Bool = false
    public var _isThrottling: Bool = false
    public var _type: ErrorType = .client
    public var message: String?
    public var type: String?

    public init (
        message: String? = nil,
        type: String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct UnsupportedMediaTypeExceptionBody: Equatable {
    public let type: String?
    public let message: String?
}

extension UnsupportedMediaTypeExceptionBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case type = "Type"
        case message
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(String.self, forKey: .type)
        type = typeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceInput(resource: \(String(describing: resource)), tagKeys: \(String(describing: tagKeys)))"}
}

extension UntagResourceInput: Encodable, Reflection {

    public func encode(to encoder: Encoder) throws {
    }
}

public struct UntagResourceInputHeadersMiddleware: Middleware {
    public let id: String = "UntagResourceInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInputQueryItemMiddleware: Middleware {
    public let id: String = "UntagResourceInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UntagResourceInput>,
                  next: H) -> Swift.Result<OperationOutput<UntagResourceOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let tagKeys = input.operationInput.tagKeys {
            tagKeys.forEach { queryItemValue in
                let queryItem = URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: String(queryItemValue).urlPercentEncoding())
                input.builder.withQueryItem(queryItem)
            }
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UntagResourceInput>
    public typealias MOutput = OperationOutput<UntagResourceOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UntagResourceOutputError>
}

public struct UntagResourceInput: Equatable {
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let resource: String?
    /// <p>A list of tag keys to remove from the function.</p>
    public let tagKeys: [String]?

    public init (
        resource: String? = nil,
        tagKeys: [String]? = nil
    )
    {
        self.resource = resource
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Equatable {
}

extension UntagResourceInputBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

extension UntagResourceOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UntagResourceOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UntagResourceOutputResponse()"}
}

extension UntagResourceOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Equatable {

    public init() {}
}

struct UntagResourceOutputResponseBody: Equatable {
}

extension UntagResourceOutputResponseBody: Decodable {

    public init (from decoder: Decoder) throws {
    }
}

public struct UpdateAliasInputBodyMiddleware: Middleware {
    public let id: String = "UpdateAliasInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAliasOutputError>
}

extension UpdateAliasInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAliasInput(description: \(String(describing: description)), functionName: \(String(describing: functionName)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), routingConfig: \(String(describing: routingConfig)))"}
}

extension UpdateAliasInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionVersion = functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let routingConfig = routingConfig {
            try encodeContainer.encode(routingConfig, forKey: .routingConfig)
        }
    }
}

public struct UpdateAliasInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateAliasInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateAliasInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateAliasInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateAliasOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateAliasInput>
    public typealias MOutput = OperationOutput<UpdateAliasOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateAliasOutputError>
}

public struct UpdateAliasInput: Equatable {
    /// <p>A description of the alias.</p>
    public let description: String?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The function version that the alias invokes.</p>
    public let functionVersion: String?
    /// <p>The name of the alias.</p>
    public let name: String?
    /// <p>Only update the alias if the revision ID matches the ID that's specified. Use this option to avoid modifying
    ///       an alias that has changed since you last read it.</p>
    public let revisionId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html#configuring-alias-routing">routing
    ///         configuration</a> of the alias.</p>
    public let routingConfig: AliasRoutingConfiguration?

    public init (
        description: String? = nil,
        functionName: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        routingConfig: AliasRoutingConfiguration? = nil
    )
    {
        self.description = description
        self.functionName = functionName
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasInputBody: Equatable {
    public let functionVersion: String?
    public let description: String?
    public let routingConfig: AliasRoutingConfiguration?
    public let revisionId: String?
}

extension UpdateAliasInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension UpdateAliasOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateAliasOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateAliasOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateAliasOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateAliasOutputResponse(aliasArn: \(String(describing: aliasArn)), description: \(String(describing: description)), functionVersion: \(String(describing: functionVersion)), name: \(String(describing: name)), revisionId: \(String(describing: revisionId)), routingConfig: \(String(describing: routingConfig)))"}
}

extension UpdateAliasOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateAliasOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.aliasArn = output.aliasArn
            self.description = output.description
            self.functionVersion = output.functionVersion
            self.name = output.name
            self.revisionId = output.revisionId
            self.routingConfig = output.routingConfig
        } else {
            self.aliasArn = nil
            self.description = nil
            self.functionVersion = nil
            self.name = nil
            self.revisionId = nil
            self.routingConfig = nil
        }
    }
}

/// <p>Provides configuration information about a Lambda function <a href="https://docs.aws.amazon.com/lambda/latest/dg/versioning-aliases.html">alias</a>.</p>
public struct UpdateAliasOutputResponse: Equatable {
    /// <p>The Amazon Resource Name (ARN) of the alias.</p>
    public let aliasArn: String?
    /// <p>A description of the alias.</p>
    public let description: String?
    /// <p>The function version that the alias invokes.</p>
    public let functionVersion: String?
    /// <p>The name of the alias.</p>
    public let name: String?
    /// <p>A unique identifier that changes when you update the alias.</p>
    public let revisionId: String?
    /// <p>The <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-traffic-shifting-using-aliases.html">routing
    ///         configuration</a> of the alias.</p>
    public let routingConfig: AliasRoutingConfiguration?

    public init (
        aliasArn: String? = nil,
        description: String? = nil,
        functionVersion: String? = nil,
        name: String? = nil,
        revisionId: String? = nil,
        routingConfig: AliasRoutingConfiguration? = nil
    )
    {
        self.aliasArn = aliasArn
        self.description = description
        self.functionVersion = functionVersion
        self.name = name
        self.revisionId = revisionId
        self.routingConfig = routingConfig
    }
}

struct UpdateAliasOutputResponseBody: Equatable {
    public let aliasArn: String?
    public let name: String?
    public let functionVersion: String?
    public let description: String?
    public let routingConfig: AliasRoutingConfiguration?
    public let revisionId: String?
}

extension UpdateAliasOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case aliasArn = "AliasArn"
        case description = "Description"
        case functionVersion = "FunctionVersion"
        case name = "Name"
        case revisionId = "RevisionId"
        case routingConfig = "RoutingConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .aliasArn)
        aliasArn = aliasArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .name)
        name = nameDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let routingConfigDecoded = try containerValues.decodeIfPresent(AliasRoutingConfiguration.self, forKey: .routingConfig)
        routingConfig = routingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

public struct UpdateCodeSigningConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateCodeSigningConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCodeSigningConfigOutputError>
}

extension UpdateCodeSigningConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCodeSigningConfigInput(allowedPublishers: \(String(describing: allowedPublishers)), codeSigningConfigArn: \(String(describing: codeSigningConfigArn)), codeSigningPolicies: \(String(describing: codeSigningPolicies)), description: \(String(describing: description)))"}
}

extension UpdateCodeSigningConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedPublishers = allowedPublishers {
            try encodeContainer.encode(allowedPublishers, forKey: .allowedPublishers)
        }
        if let codeSigningPolicies = codeSigningPolicies {
            try encodeContainer.encode(codeSigningPolicies, forKey: .codeSigningPolicies)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

public struct UpdateCodeSigningConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateCodeSigningConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCodeSigningConfigOutputError>
}

public struct UpdateCodeSigningConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateCodeSigningConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateCodeSigningConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateCodeSigningConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateCodeSigningConfigInput>
    public typealias MOutput = OperationOutput<UpdateCodeSigningConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateCodeSigningConfigOutputError>
}

public struct UpdateCodeSigningConfigInput: Equatable {
    /// <p>Signing profiles for this code signing configuration.</p>
    public let allowedPublishers: AllowedPublishers?
    /// <p>The The Amazon Resource Name (ARN) of the code signing configuration.</p>
    public let codeSigningConfigArn: String?
    /// <p>The code signing policy.</p>
    public let codeSigningPolicies: CodeSigningPolicies?
    /// <p>Descriptive name for this code signing configuration.</p>
    public let description: String?

    public init (
        allowedPublishers: AllowedPublishers? = nil,
        codeSigningConfigArn: String? = nil,
        codeSigningPolicies: CodeSigningPolicies? = nil,
        description: String? = nil
    )
    {
        self.allowedPublishers = allowedPublishers
        self.codeSigningConfigArn = codeSigningConfigArn
        self.codeSigningPolicies = codeSigningPolicies
        self.description = description
    }
}

struct UpdateCodeSigningConfigInputBody: Equatable {
    public let description: String?
    public let allowedPublishers: AllowedPublishers?
    public let codeSigningPolicies: CodeSigningPolicies?
}

extension UpdateCodeSigningConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case allowedPublishers = "AllowedPublishers"
        case codeSigningPolicies = "CodeSigningPolicies"
        case description = "Description"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let allowedPublishersDecoded = try containerValues.decodeIfPresent(AllowedPublishers.self, forKey: .allowedPublishers)
        allowedPublishers = allowedPublishersDecoded
        let codeSigningPoliciesDecoded = try containerValues.decodeIfPresent(CodeSigningPolicies.self, forKey: .codeSigningPolicies)
        codeSigningPolicies = codeSigningPoliciesDecoded
    }
}

extension UpdateCodeSigningConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateCodeSigningConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateCodeSigningConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateCodeSigningConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateCodeSigningConfigOutputResponse(codeSigningConfig: \(String(describing: codeSigningConfig)))"}
}

extension UpdateCodeSigningConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateCodeSigningConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSigningConfig = output.codeSigningConfig
        } else {
            self.codeSigningConfig = nil
        }
    }
}

public struct UpdateCodeSigningConfigOutputResponse: Equatable {
    /// <p>The code signing configuration</p>
    public let codeSigningConfig: CodeSigningConfig?

    public init (
        codeSigningConfig: CodeSigningConfig? = nil
    )
    {
        self.codeSigningConfig = codeSigningConfig
    }
}

struct UpdateCodeSigningConfigOutputResponseBody: Equatable {
    public let codeSigningConfig: CodeSigningConfig?
}

extension UpdateCodeSigningConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSigningConfig = "CodeSigningConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeSigningConfigDecoded = try containerValues.decodeIfPresent(CodeSigningConfig.self, forKey: .codeSigningConfig)
        codeSigningConfig = codeSigningConfigDecoded
    }
}

public struct UpdateEventSourceMappingInputBodyMiddleware: Middleware {
    public let id: String = "UpdateEventSourceMappingInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventSourceMappingInput>
    public typealias MOutput = OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventSourceMappingOutputError>
}

extension UpdateEventSourceMappingInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEventSourceMappingInput(batchSize: \(String(describing: batchSize)), bisectBatchOnFunctionError: \(String(describing: bisectBatchOnFunctionError)), destinationConfig: \(String(describing: destinationConfig)), enabled: \(String(describing: enabled)), functionName: \(String(describing: functionName)), functionResponseTypes: \(String(describing: functionResponseTypes)), maximumBatchingWindowInSeconds: \(String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), parallelizationFactor: \(String(describing: parallelizationFactor)), sourceAccessConfigurations: \(String(describing: sourceAccessConfigurations)), tumblingWindowInSeconds: \(String(describing: tumblingWindowInSeconds)), uUID: \(String(describing: uUID)))"}
}

extension UpdateEventSourceMappingInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchSize = batchSize {
            try encodeContainer.encode(batchSize, forKey: .batchSize)
        }
        if let bisectBatchOnFunctionError = bisectBatchOnFunctionError {
            try encodeContainer.encode(bisectBatchOnFunctionError, forKey: .bisectBatchOnFunctionError)
        }
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let enabled = enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if let functionName = functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionResponseTypes = functionResponseTypes {
            var functionResponseTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functionResponseTypes)
            for functionresponsetypelist0 in functionResponseTypes {
                try functionResponseTypesContainer.encode(functionresponsetypelist0.rawValue)
            }
        }
        if let maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds {
            try encodeContainer.encode(maximumBatchingWindowInSeconds, forKey: .maximumBatchingWindowInSeconds)
        }
        if let maximumRecordAgeInSeconds = maximumRecordAgeInSeconds {
            try encodeContainer.encode(maximumRecordAgeInSeconds, forKey: .maximumRecordAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
        if let parallelizationFactor = parallelizationFactor {
            try encodeContainer.encode(parallelizationFactor, forKey: .parallelizationFactor)
        }
        if let sourceAccessConfigurations = sourceAccessConfigurations {
            var sourceAccessConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceAccessConfigurations)
            for sourceaccessconfigurations0 in sourceAccessConfigurations {
                try sourceAccessConfigurationsContainer.encode(sourceaccessconfigurations0)
            }
        }
        if let tumblingWindowInSeconds = tumblingWindowInSeconds {
            try encodeContainer.encode(tumblingWindowInSeconds, forKey: .tumblingWindowInSeconds)
        }
    }
}

public struct UpdateEventSourceMappingInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateEventSourceMappingInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventSourceMappingInput>
    public typealias MOutput = OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventSourceMappingOutputError>
}

public struct UpdateEventSourceMappingInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateEventSourceMappingInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateEventSourceMappingInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateEventSourceMappingOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateEventSourceMappingInput>
    public typealias MOutput = OperationOutput<UpdateEventSourceMappingOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateEventSourceMappingOutputError>
}

public struct UpdateEventSourceMappingInput: Equatable {
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Kinesis</b> - Default 100. Max 10,000.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon DynamoDB Streams</b> - Default 100. Max 1,000.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Simple Queue Service</b> - Default 10. For standard queues the max is 10,000. For FIFO queues the max is 10.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Amazon Managed Streaming for Apache Kafka</b> - Default 100. Max 10,000.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Self-Managed Apache Kafka</b> - Default 100. Max 10,000.</p>
    ///             </li>
    ///          </ul>
    public let batchSize: Int?
    /// <p>(Streams) If the function returns an error, split the batch in two and retry.</p>
    public let bisectBatchOnFunctionError: Bool?
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>If true, the event source mapping is active. Set to false to pause polling and invocation.</p>
    public let enabled: Bool?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Version or Alias ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:MyFunction:PROD</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:MyFunction</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it's limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    public let functionResponseTypes: [FunctionResponseType]?
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds.</p>
    public let maximumBatchingWindowInSeconds: Int?
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1).</p>
    public let maximumRecordAgeInSeconds: Int?
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records will be retried until the record expires.</p>
    public let maximumRetryAttempts: Int?
    /// <p>(Streams) The number of batches to process from each shard concurrently.</p>
    public let parallelizationFactor: Int?
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    public let tumblingWindowInSeconds: Int?
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        batchSize: Int? = nil,
        bisectBatchOnFunctionError: Bool? = nil,
        destinationConfig: DestinationConfig? = nil,
        enabled: Bool? = nil,
        functionName: String? = nil,
        functionResponseTypes: [FunctionResponseType]? = nil,
        maximumBatchingWindowInSeconds: Int? = nil,
        maximumRecordAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        parallelizationFactor: Int? = nil,
        sourceAccessConfigurations: [SourceAccessConfiguration]? = nil,
        tumblingWindowInSeconds: Int? = nil,
        uUID: String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.enabled = enabled
        self.functionName = functionName
        self.functionResponseTypes = functionResponseTypes
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct UpdateEventSourceMappingInputBody: Equatable {
    public let functionName: String?
    public let enabled: Bool?
    public let batchSize: Int?
    public let maximumBatchingWindowInSeconds: Int?
    public let destinationConfig: DestinationConfig?
    public let maximumRecordAgeInSeconds: Int?
    public let bisectBatchOnFunctionError: Bool?
    public let maximumRetryAttempts: Int?
    public let parallelizationFactor: Int?
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    public let tumblingWindowInSeconds: Int?
    public let functionResponseTypes: [FunctionResponseType]?
}

extension UpdateEventSourceMappingInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case enabled = "Enabled"
        case functionName = "FunctionName"
        case functionResponseTypes = "FunctionResponseTypes"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .enabled)
        enabled = enabledDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

extension UpdateEventSourceMappingOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateEventSourceMappingOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateEventSourceMappingOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceConflictException(ResourceConflictException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateEventSourceMappingOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateEventSourceMappingOutputResponse(batchSize: \(String(describing: batchSize)), bisectBatchOnFunctionError: \(String(describing: bisectBatchOnFunctionError)), destinationConfig: \(String(describing: destinationConfig)), eventSourceArn: \(String(describing: eventSourceArn)), functionArn: \(String(describing: functionArn)), functionResponseTypes: \(String(describing: functionResponseTypes)), lastModified: \(String(describing: lastModified)), lastProcessingResult: \(String(describing: lastProcessingResult)), maximumBatchingWindowInSeconds: \(String(describing: maximumBatchingWindowInSeconds)), maximumRecordAgeInSeconds: \(String(describing: maximumRecordAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), parallelizationFactor: \(String(describing: parallelizationFactor)), queues: \(String(describing: queues)), selfManagedEventSource: \(String(describing: selfManagedEventSource)), sourceAccessConfigurations: \(String(describing: sourceAccessConfigurations)), startingPosition: \(String(describing: startingPosition)), startingPositionTimestamp: \(String(describing: startingPositionTimestamp)), state: \(String(describing: state)), stateTransitionReason: \(String(describing: stateTransitionReason)), topics: \(String(describing: topics)), tumblingWindowInSeconds: \(String(describing: tumblingWindowInSeconds)), uUID: \(String(describing: uUID)))"}
}

extension UpdateEventSourceMappingOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateEventSourceMappingOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.batchSize = output.batchSize
            self.bisectBatchOnFunctionError = output.bisectBatchOnFunctionError
            self.destinationConfig = output.destinationConfig
            self.eventSourceArn = output.eventSourceArn
            self.functionArn = output.functionArn
            self.functionResponseTypes = output.functionResponseTypes
            self.lastModified = output.lastModified
            self.lastProcessingResult = output.lastProcessingResult
            self.maximumBatchingWindowInSeconds = output.maximumBatchingWindowInSeconds
            self.maximumRecordAgeInSeconds = output.maximumRecordAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
            self.parallelizationFactor = output.parallelizationFactor
            self.queues = output.queues
            self.selfManagedEventSource = output.selfManagedEventSource
            self.sourceAccessConfigurations = output.sourceAccessConfigurations
            self.startingPosition = output.startingPosition
            self.startingPositionTimestamp = output.startingPositionTimestamp
            self.state = output.state
            self.stateTransitionReason = output.stateTransitionReason
            self.topics = output.topics
            self.tumblingWindowInSeconds = output.tumblingWindowInSeconds
            self.uUID = output.uUID
        } else {
            self.batchSize = nil
            self.bisectBatchOnFunctionError = nil
            self.destinationConfig = nil
            self.eventSourceArn = nil
            self.functionArn = nil
            self.functionResponseTypes = nil
            self.lastModified = nil
            self.lastProcessingResult = nil
            self.maximumBatchingWindowInSeconds = nil
            self.maximumRecordAgeInSeconds = nil
            self.maximumRetryAttempts = nil
            self.parallelizationFactor = nil
            self.queues = nil
            self.selfManagedEventSource = nil
            self.sourceAccessConfigurations = nil
            self.startingPosition = nil
            self.startingPositionTimestamp = nil
            self.state = nil
            self.stateTransitionReason = nil
            self.topics = nil
            self.tumblingWindowInSeconds = nil
            self.uUID = nil
        }
    }
}

/// <p>A mapping between an AWS resource and an AWS Lambda function. See <a>CreateEventSourceMapping</a> for details.</p>
public struct UpdateEventSourceMappingOutputResponse: Equatable {
    /// <p>The maximum number of items to retrieve in a single batch.</p>
    public let batchSize: Int?
    /// <p>(Streams) If the function returns an error, split the batch in two and retry. The default value is false.</p>
    public let bisectBatchOnFunctionError: Bool?
    /// <p>(Streams) An Amazon SQS queue or Amazon SNS topic destination for discarded records.</p>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the event source.</p>
    public let eventSourceArn: String?
    /// <p>The ARN of the Lambda function.</p>
    public let functionArn: String?
    /// <p>(Streams) A list of current response type enums applied to the event source mapping.</p>
    public let functionResponseTypes: [FunctionResponseType]?
    /// <p>The date that the event source mapping was last updated, or its state changed.</p>
    public let lastModified: Date?
    /// <p>The result of the last AWS Lambda invocation of your Lambda function.</p>
    public let lastProcessingResult: String?
    /// <p>(Streams and SQS standard queues) The maximum amount of time to gather records before invoking the function, in seconds. The default value is zero.</p>
    public let maximumBatchingWindowInSeconds: Int?
    /// <p>(Streams) Discard records older than the specified age. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRecordAgeInSeconds: Int?
    /// <p>(Streams) Discard records after the specified number of retries. The default value is infinite (-1). When set to infinite (-1), failed records are retried until the record expires.</p>
    public let maximumRetryAttempts: Int?
    /// <p>(Streams) The number of batches to process from each shard concurrently. The default value is 1.</p>
    public let parallelizationFactor: Int?
    /// <p>
    ///       (MQ) The name of the Amazon MQ broker destination queue to consume.
    ///     </p>
    public let queues: [String]?
    /// <p>The Self-Managed Apache Kafka cluster for your event source.</p>
    public let selfManagedEventSource: SelfManagedEventSource?
    /// <p>An array of the authentication protocol, or the VPC components to secure your event source.</p>
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    /// <p>The position in a stream from which to start reading. Required for Amazon Kinesis, Amazon DynamoDB, and Amazon MSK Streams
    ///       sources. <code>AT_TIMESTAMP</code> is only supported for Amazon Kinesis streams.</p>
    public let startingPosition: EventSourcePosition?
    /// <p>With <code>StartingPosition</code> set to <code>AT_TIMESTAMP</code>, the time from which to start
    ///       reading.</p>
    public let startingPositionTimestamp: Date?
    /// <p>The state of the event source mapping. It can be one of the following: <code>Creating</code>,
    ///       <code>Enabling</code>, <code>Enabled</code>, <code>Disabling</code>, <code>Disabled</code>,
    ///       <code>Updating</code>, or <code>Deleting</code>.</p>
    public let state: String?
    /// <p>Indicates whether the last change to the event source mapping was made by a user, or by the Lambda
    ///       service.</p>
    public let stateTransitionReason: String?
    /// <p>The name of the Kafka topic.</p>
    public let topics: [String]?
    /// <p>(Streams) The duration in seconds of a processing window. The range is between 1 second up to 900 seconds.</p>
    public let tumblingWindowInSeconds: Int?
    /// <p>The identifier of the event source mapping.</p>
    public let uUID: String?

    public init (
        batchSize: Int? = nil,
        bisectBatchOnFunctionError: Bool? = nil,
        destinationConfig: DestinationConfig? = nil,
        eventSourceArn: String? = nil,
        functionArn: String? = nil,
        functionResponseTypes: [FunctionResponseType]? = nil,
        lastModified: Date? = nil,
        lastProcessingResult: String? = nil,
        maximumBatchingWindowInSeconds: Int? = nil,
        maximumRecordAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        parallelizationFactor: Int? = nil,
        queues: [String]? = nil,
        selfManagedEventSource: SelfManagedEventSource? = nil,
        sourceAccessConfigurations: [SourceAccessConfiguration]? = nil,
        startingPosition: EventSourcePosition? = nil,
        startingPositionTimestamp: Date? = nil,
        state: String? = nil,
        stateTransitionReason: String? = nil,
        topics: [String]? = nil,
        tumblingWindowInSeconds: Int? = nil,
        uUID: String? = nil
    )
    {
        self.batchSize = batchSize
        self.bisectBatchOnFunctionError = bisectBatchOnFunctionError
        self.destinationConfig = destinationConfig
        self.eventSourceArn = eventSourceArn
        self.functionArn = functionArn
        self.functionResponseTypes = functionResponseTypes
        self.lastModified = lastModified
        self.lastProcessingResult = lastProcessingResult
        self.maximumBatchingWindowInSeconds = maximumBatchingWindowInSeconds
        self.maximumRecordAgeInSeconds = maximumRecordAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.parallelizationFactor = parallelizationFactor
        self.queues = queues
        self.selfManagedEventSource = selfManagedEventSource
        self.sourceAccessConfigurations = sourceAccessConfigurations
        self.startingPosition = startingPosition
        self.startingPositionTimestamp = startingPositionTimestamp
        self.state = state
        self.stateTransitionReason = stateTransitionReason
        self.topics = topics
        self.tumblingWindowInSeconds = tumblingWindowInSeconds
        self.uUID = uUID
    }
}

struct UpdateEventSourceMappingOutputResponseBody: Equatable {
    public let uUID: String?
    public let startingPosition: EventSourcePosition?
    public let startingPositionTimestamp: Date?
    public let batchSize: Int?
    public let maximumBatchingWindowInSeconds: Int?
    public let parallelizationFactor: Int?
    public let eventSourceArn: String?
    public let functionArn: String?
    public let lastModified: Date?
    public let lastProcessingResult: String?
    public let state: String?
    public let stateTransitionReason: String?
    public let destinationConfig: DestinationConfig?
    public let topics: [String]?
    public let queues: [String]?
    public let sourceAccessConfigurations: [SourceAccessConfiguration]?
    public let selfManagedEventSource: SelfManagedEventSource?
    public let maximumRecordAgeInSeconds: Int?
    public let bisectBatchOnFunctionError: Bool?
    public let maximumRetryAttempts: Int?
    public let tumblingWindowInSeconds: Int?
    public let functionResponseTypes: [FunctionResponseType]?
}

extension UpdateEventSourceMappingOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case batchSize = "BatchSize"
        case bisectBatchOnFunctionError = "BisectBatchOnFunctionError"
        case destinationConfig = "DestinationConfig"
        case eventSourceArn = "EventSourceArn"
        case functionArn = "FunctionArn"
        case functionResponseTypes = "FunctionResponseTypes"
        case lastModified = "LastModified"
        case lastProcessingResult = "LastProcessingResult"
        case maximumBatchingWindowInSeconds = "MaximumBatchingWindowInSeconds"
        case maximumRecordAgeInSeconds = "MaximumRecordAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
        case parallelizationFactor = "ParallelizationFactor"
        case queues = "Queues"
        case selfManagedEventSource = "SelfManagedEventSource"
        case sourceAccessConfigurations = "SourceAccessConfigurations"
        case startingPosition = "StartingPosition"
        case startingPositionTimestamp = "StartingPositionTimestamp"
        case state = "State"
        case stateTransitionReason = "StateTransitionReason"
        case topics = "Topics"
        case tumblingWindowInSeconds = "TumblingWindowInSeconds"
        case uUID = "UUID"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uUIDDecoded = try containerValues.decodeIfPresent(String.self, forKey: .uUID)
        uUID = uUIDDecoded
        let startingPositionDecoded = try containerValues.decodeIfPresent(EventSourcePosition.self, forKey: .startingPosition)
        startingPosition = startingPositionDecoded
        let startingPositionTimestampDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .startingPositionTimestamp)
        startingPositionTimestamp = startingPositionTimestampDecoded
        let batchSizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .batchSize)
        batchSize = batchSizeDecoded
        let maximumBatchingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumBatchingWindowInSeconds)
        maximumBatchingWindowInSeconds = maximumBatchingWindowInSecondsDecoded
        let parallelizationFactorDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .parallelizationFactor)
        parallelizationFactor = parallelizationFactorDecoded
        let eventSourceArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .eventSourceArn)
        eventSourceArn = eventSourceArnDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let lastProcessingResultDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastProcessingResult)
        lastProcessingResult = lastProcessingResultDecoded
        let stateDecoded = try containerValues.decodeIfPresent(String.self, forKey: .state)
        state = stateDecoded
        let stateTransitionReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateTransitionReason)
        stateTransitionReason = stateTransitionReasonDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let topicsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .topics)
        var topicsDecoded0:[String]? = nil
        if let topicsContainer = topicsContainer {
            topicsDecoded0 = [String]()
            for string0 in topicsContainer {
                if let string0 = string0 {
                    topicsDecoded0?.append(string0)
                }
            }
        }
        topics = topicsDecoded0
        let queuesContainer = try containerValues.decodeIfPresent([String?].self, forKey: .queues)
        var queuesDecoded0:[String]? = nil
        if let queuesContainer = queuesContainer {
            queuesDecoded0 = [String]()
            for string0 in queuesContainer {
                if let string0 = string0 {
                    queuesDecoded0?.append(string0)
                }
            }
        }
        queues = queuesDecoded0
        let sourceAccessConfigurationsContainer = try containerValues.decodeIfPresent([SourceAccessConfiguration?].self, forKey: .sourceAccessConfigurations)
        var sourceAccessConfigurationsDecoded0:[SourceAccessConfiguration]? = nil
        if let sourceAccessConfigurationsContainer = sourceAccessConfigurationsContainer {
            sourceAccessConfigurationsDecoded0 = [SourceAccessConfiguration]()
            for structure0 in sourceAccessConfigurationsContainer {
                if let structure0 = structure0 {
                    sourceAccessConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        sourceAccessConfigurations = sourceAccessConfigurationsDecoded0
        let selfManagedEventSourceDecoded = try containerValues.decodeIfPresent(SelfManagedEventSource.self, forKey: .selfManagedEventSource)
        selfManagedEventSource = selfManagedEventSourceDecoded
        let maximumRecordAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRecordAgeInSeconds)
        maximumRecordAgeInSeconds = maximumRecordAgeInSecondsDecoded
        let bisectBatchOnFunctionErrorDecoded = try containerValues.decodeIfPresent(Bool.self, forKey: .bisectBatchOnFunctionError)
        bisectBatchOnFunctionError = bisectBatchOnFunctionErrorDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let tumblingWindowInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .tumblingWindowInSeconds)
        tumblingWindowInSeconds = tumblingWindowInSecondsDecoded
        let functionResponseTypesContainer = try containerValues.decodeIfPresent([FunctionResponseType?].self, forKey: .functionResponseTypes)
        var functionResponseTypesDecoded0:[FunctionResponseType]? = nil
        if let functionResponseTypesContainer = functionResponseTypesContainer {
            functionResponseTypesDecoded0 = [FunctionResponseType]()
            for string0 in functionResponseTypesContainer {
                if let string0 = string0 {
                    functionResponseTypesDecoded0?.append(string0)
                }
            }
        }
        functionResponseTypes = functionResponseTypesDecoded0
    }
}

public struct UpdateFunctionCodeInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFunctionCodeInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionCodeInput>
    public typealias MOutput = OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionCodeOutputError>
}

extension UpdateFunctionCodeInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionCodeInput(dryRun: \(String(describing: dryRun)), functionName: \(String(describing: functionName)), imageUri: \(String(describing: imageUri)), publish: \(String(describing: publish)), revisionId: \(String(describing: revisionId)), s3Bucket: \(String(describing: s3Bucket)), s3Key: \(String(describing: s3Key)), s3ObjectVersion: \(String(describing: s3ObjectVersion)), zipFile: \(String(describing: zipFile)))"}
}

extension UpdateFunctionCodeInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if dryRun != false {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let imageUri = imageUri {
            try encodeContainer.encode(imageUri, forKey: .imageUri)
        }
        if publish != false {
            try encodeContainer.encode(publish, forKey: .publish)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let s3Bucket = s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Key = s3Key {
            try encodeContainer.encode(s3Key, forKey: .s3Key)
        }
        if let s3ObjectVersion = s3ObjectVersion {
            try encodeContainer.encode(s3ObjectVersion, forKey: .s3ObjectVersion)
        }
        if let zipFile = zipFile {
            try encodeContainer.encode(zipFile.base64EncodedString(), forKey: .zipFile)
        }
    }
}

public struct UpdateFunctionCodeInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFunctionCodeInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionCodeInput>
    public typealias MOutput = OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionCodeOutputError>
}

public struct UpdateFunctionCodeInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFunctionCodeInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionCodeInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionCodeOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionCodeInput>
    public typealias MOutput = OperationOutput<UpdateFunctionCodeOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionCodeOutputError>
}

public struct UpdateFunctionCodeInput: Equatable {
    /// <p>Set to true to validate the request parameters and access permissions without modifying the function
    ///       code.</p>
    public let dryRun: Bool
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>URI of a container image in the Amazon ECR registry.</p>
    public let imageUri: String?
    /// <p>Set to true to publish a new version of the function after updating the code. This has the same effect as
    ///       calling <a>PublishVersion</a> separately.</p>
    public let publish: Bool
    /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       function that has changed since you last read it.</p>
    public let revisionId: String?
    /// <p>An Amazon S3 bucket in the same AWS Region as your function. The bucket can be in a different AWS account.</p>
    public let s3Bucket: String?
    /// <p>The Amazon S3 key of the deployment package.</p>
    public let s3Key: String?
    /// <p>For versioned objects, the version of the deployment package object to use.</p>
    public let s3ObjectVersion: String?
    /// <p>The base64-encoded contents of the deployment package. AWS SDK and AWS CLI clients handle the encoding for
    ///       you.</p>
    public let zipFile: Data?

    public init (
        dryRun: Bool = false,
        functionName: String? = nil,
        imageUri: String? = nil,
        publish: Bool = false,
        revisionId: String? = nil,
        s3Bucket: String? = nil,
        s3Key: String? = nil,
        s3ObjectVersion: String? = nil,
        zipFile: Data? = nil
    )
    {
        self.dryRun = dryRun
        self.functionName = functionName
        self.imageUri = imageUri
        self.publish = publish
        self.revisionId = revisionId
        self.s3Bucket = s3Bucket
        self.s3Key = s3Key
        self.s3ObjectVersion = s3ObjectVersion
        self.zipFile = zipFile
    }
}

struct UpdateFunctionCodeInputBody: Equatable {
    public let zipFile: Data?
    public let s3Bucket: String?
    public let s3Key: String?
    public let s3ObjectVersion: String?
    public let imageUri: String?
    public let publish: Bool
    public let dryRun: Bool
    public let revisionId: String?
}

extension UpdateFunctionCodeInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case dryRun = "DryRun"
        case imageUri = "ImageUri"
        case publish = "Publish"
        case revisionId = "RevisionId"
        case s3Bucket = "S3Bucket"
        case s3Key = "S3Key"
        case s3ObjectVersion = "S3ObjectVersion"
        case zipFile = "ZipFile"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let zipFileDecoded = try containerValues.decodeIfPresent(Data.self, forKey: .zipFile)
        zipFile = zipFileDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeyDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3Key)
        s3Key = s3KeyDecoded
        let s3ObjectVersionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .s3ObjectVersion)
        s3ObjectVersion = s3ObjectVersionDecoded
        let imageUriDecoded = try containerValues.decodeIfPresent(String.self, forKey: .imageUri)
        imageUri = imageUriDecoded
        let publishDecoded = try containerValues.decode(Bool.self, forKey: .publish)
        publish = publishDecoded
        let dryRunDecoded = try containerValues.decode(Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
    }
}

extension UpdateFunctionCodeOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionCodeOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeStorageExceededException" : self = .codeStorageExceededException(try CodeStorageExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionCodeOutputError: Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeStorageExceededException(CodeStorageExceededException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionCodeOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionCodeOutputResponse(codeSha256: \(String(describing: codeSha256)), codeSize: \(String(describing: codeSize)), deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionArn: \(String(describing: functionArn)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfigResponse: \(String(describing: imageConfigResponse)), kMSKeyArn: \(String(describing: kMSKeyArn)), lastModified: \(String(describing: lastModified)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(String(describing: lastUpdateStatusReasonCode)), layers: \(String(describing: layers)), masterArn: \(String(describing: masterArn)), memorySize: \(String(describing: memorySize)), packageType: \(String(describing: packageType)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), version: \(String(describing: version)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension UpdateFunctionCodeOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFunctionCodeOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// <p>Details about a function's configuration.</p>
public struct UpdateFunctionCodeOutputResponse: Equatable {
    /// <p>The SHA256 hash of the function's deployment package.</p>
    public let codeSha256: String?
    /// <p>The size of the function's deployment package, in bytes.</p>
    public let codeSize: Int
    /// <p>The function's dead letter queue.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>The function's description.</p>
    public let description: String?
    /// <p>The function's environment variables.</p>
    public let environment: EnvironmentResponse?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let functionArn: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The function that Lambda calls to begin executing your function.</p>
    public let handler: String?
    /// <p>The function's image configuration values.</p>
    public let imageConfigResponse: ImageConfigResponse?
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.</p>
    public let kMSKeyArn: String?
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let lastModified: String?
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    ///       after function creation completes.</p>
    public let lastUpdateStatus: LastUpdateStatus?
    /// <p>The reason for the last update that was performed on the function.</p>
    public let lastUpdateStatusReason: String?
    /// <p>The reason code for the last update that was performed on the function.</p>
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers</a>.</p>
    public let layers: [Layer]?
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    public let masterArn: String?
    /// <p>The amount of memory available to the function at runtime. </p>
    public let memorySize: Int?
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    public let packageType: PackageType?
    /// <p>The latest updated revision of the function or alias.</p>
    public let revisionId: String?
    /// <p>The function's execution role.</p>
    public let role: String?
    /// <p>The runtime environment for the Lambda function.</p>
    public let runtime: Runtime?
    /// <p>The ARN of the signing job.</p>
    public let signingJobArn: String?
    /// <p>The ARN of the signing profile version.</p>
    public let signingProfileVersionArn: String?
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    ///       invoking it.</p>
    public let state: State?
    /// <p>The reason for the function's current state.</p>
    public let stateReason: String?
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    ///       modify the function.</p>
    public let stateReasonCode: StateReasonCode?
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    public let timeout: Int?
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    public let tracingConfig: TracingConfigResponse?
    /// <p>The version of the Lambda function.</p>
    public let version: String?
    /// <p>The function's networking configuration.</p>
    public let vpcConfig: VpcConfigResponse?

    public init (
        codeSha256: String? = nil,
        codeSize: Int = 0,
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: EnvironmentResponse? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionArn: String? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfigResponse: ImageConfigResponse? = nil,
        kMSKeyArn: String? = nil,
        lastModified: String? = nil,
        lastUpdateStatus: LastUpdateStatus? = nil,
        lastUpdateStatusReason: String? = nil,
        lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil,
        layers: [Layer]? = nil,
        masterArn: String? = nil,
        memorySize: Int? = nil,
        packageType: PackageType? = nil,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: Runtime? = nil,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil,
        state: State? = nil,
        stateReason: String? = nil,
        stateReasonCode: StateReasonCode? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfigResponse? = nil,
        version: String? = nil,
        vpcConfig: VpcConfigResponse? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionCodeOutputResponseBody: Equatable {
    public let functionName: String?
    public let functionArn: String?
    public let runtime: Runtime?
    public let role: String?
    public let handler: String?
    public let codeSize: Int
    public let description: String?
    public let timeout: Int?
    public let memorySize: Int?
    public let lastModified: String?
    public let codeSha256: String?
    public let version: String?
    public let vpcConfig: VpcConfigResponse?
    public let deadLetterConfig: DeadLetterConfig?
    public let environment: EnvironmentResponse?
    public let kMSKeyArn: String?
    public let tracingConfig: TracingConfigResponse?
    public let masterArn: String?
    public let revisionId: String?
    public let layers: [Layer]?
    public let state: State?
    public let stateReason: String?
    public let stateReasonCode: StateReasonCode?
    public let lastUpdateStatus: LastUpdateStatus?
    public let lastUpdateStatusReason: String?
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [FileSystemConfig]?
    public let packageType: PackageType?
    public let imageConfigResponse: ImageConfigResponse?
    public let signingProfileVersionArn: String?
    public let signingJobArn: String?
}

extension UpdateFunctionCodeOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

public struct UpdateFunctionConfigurationInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFunctionConfigurationInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionConfigurationOutputError>
}

extension UpdateFunctionConfigurationInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionConfigurationInput(deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfig: \(String(describing: imageConfig)), kMSKeyArn: \(String(describing: kMSKeyArn)), layers: \(String(describing: layers)), memorySize: \(String(describing: memorySize)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension UpdateFunctionConfigurationInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deadLetterConfig = deadLetterConfig {
            try encodeContainer.encode(deadLetterConfig, forKey: .deadLetterConfig)
        }
        if let description = description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environment = environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let fileSystemConfigs = fileSystemConfigs {
            var fileSystemConfigsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .fileSystemConfigs)
            for filesystemconfiglist0 in fileSystemConfigs {
                try fileSystemConfigsContainer.encode(filesystemconfiglist0)
            }
        }
        if let handler = handler {
            try encodeContainer.encode(handler, forKey: .handler)
        }
        if let imageConfig = imageConfig {
            try encodeContainer.encode(imageConfig, forKey: .imageConfig)
        }
        if let kMSKeyArn = kMSKeyArn {
            try encodeContainer.encode(kMSKeyArn, forKey: .kMSKeyArn)
        }
        if let layers = layers {
            var layersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layers)
            for layerlist0 in layers {
                try layersContainer.encode(layerlist0)
            }
        }
        if let memorySize = memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let revisionId = revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let runtime = runtime {
            try encodeContainer.encode(runtime.rawValue, forKey: .runtime)
        }
        if let timeout = timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
        if let tracingConfig = tracingConfig {
            try encodeContainer.encode(tracingConfig, forKey: .tracingConfig)
        }
        if let vpcConfig = vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }
}

public struct UpdateFunctionConfigurationInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFunctionConfigurationInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionConfigurationOutputError>
}

public struct UpdateFunctionConfigurationInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFunctionConfigurationInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionConfigurationInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionConfigurationOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionConfigurationInput>
    public typealias MOutput = OperationOutput<UpdateFunctionConfigurationOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionConfigurationOutputError>
}

public struct UpdateFunctionConfigurationInput: Equatable {
    /// <p>A dead letter queue configuration that specifies the queue or topic where Lambda sends asynchronous events
    ///       when they fail processing. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/invocation-async.html#dlq">Dead Letter Queues</a>.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>A description of the function.</p>
    public let description: String?
    /// <p>Environment variables that are accessible from function code during execution.</p>
    public let environment: Environment?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The name of the Lambda function.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>The length constraint applies only to the full ARN. If you specify only the function name, it is limited to 64
    ///       characters in length.</p>
    public let functionName: String?
    /// <p>The name of the method within your code that Lambda calls to execute your function. The format includes the
    ///       file name. It can also include namespaces and other qualifiers, depending on the runtime. For more information,
    ///       see <a href="https://docs.aws.amazon.com/lambda/latest/dg/programming-model-v2.html">Programming Model</a>.</p>
    public let handler: String?
    /// <p>
    ///             <a href="https://docs.aws.amazon.com/lambda/latest/dg/images-parms.html">Container image configuration
    ///         values</a> that override the values in the container image Dockerfile.</p>
    public let imageConfig: ImageConfig?
    /// <p>The ARN of the AWS Key Management Service (AWS KMS) key that's used to encrypt your function's environment
    ///       variables. If it's not provided, AWS Lambda uses a default service key.</p>
    public let kMSKeyArn: String?
    /// <p>A list of <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">function layers</a>
    ///       to add to the function's execution environment. Specify each layer by its ARN, including the version.</p>
    public let layers: [String]?
    /// <p>The amount of memory available to the function at runtime. Increasing the function's memory also increases its CPU
    ///       allocation. The default value is 128 MB. The value can be any multiple of 1 MB.</p>
    public let memorySize: Int?
    /// <p>Only update the function if the revision ID matches the ID that's specified. Use this option to avoid modifying a
    ///       function that has changed since you last read it.</p>
    public let revisionId: String?
    /// <p>The Amazon Resource Name (ARN) of the function's execution role.</p>
    public let role: String?
    /// <p>The identifier of the function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html">runtime</a>.</p>
    public let runtime: Runtime?
    /// <p>The amount of time that Lambda allows a function to run before stopping it. The default is 3 seconds. The
    ///       maximum allowed value is 900 seconds.</p>
    public let timeout: Int?
    /// <p>Set <code>Mode</code> to <code>Active</code> to sample and trace a subset of incoming requests with AWS
    ///       X-Ray.</p>
    public let tracingConfig: TracingConfig?
    /// <p>For network connectivity to AWS resources in a VPC, specify a list of security groups and subnets in the VPC.
    ///       When you connect a function to a VPC, it can only access resources and the internet through that VPC. For more
    ///       information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings</a>.</p>
    public let vpcConfig: VpcConfig?

    public init (
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: Environment? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfig: ImageConfig? = nil,
        kMSKeyArn: String? = nil,
        layers: [String]? = nil,
        memorySize: Int? = nil,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: Runtime? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfig? = nil,
        vpcConfig: VpcConfig? = nil
    )
    {
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionName = functionName
        self.handler = handler
        self.imageConfig = imageConfig
        self.kMSKeyArn = kMSKeyArn
        self.layers = layers
        self.memorySize = memorySize
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationInputBody: Equatable {
    public let role: String?
    public let handler: String?
    public let description: String?
    public let timeout: Int?
    public let memorySize: Int?
    public let vpcConfig: VpcConfig?
    public let environment: Environment?
    public let runtime: Runtime?
    public let deadLetterConfig: DeadLetterConfig?
    public let kMSKeyArn: String?
    public let tracingConfig: TracingConfig?
    public let revisionId: String?
    public let layers: [String]?
    public let fileSystemConfigs: [FileSystemConfig]?
    public let imageConfig: ImageConfig?
}

extension UpdateFunctionConfigurationInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case handler = "Handler"
        case imageConfig = "ImageConfig"
        case kMSKeyArn = "KMSKeyArn"
        case layers = "Layers"
        case memorySize = "MemorySize"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(Environment.self, forKey: .environment)
        environment = environmentDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfig.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([String?].self, forKey: .layers)
        var layersDecoded0:[String]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [String]()
            for string0 in layersContainer {
                if let string0 = string0 {
                    layersDecoded0?.append(string0)
                }
            }
        }
        layers = layersDecoded0
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let imageConfigDecoded = try containerValues.decodeIfPresent(ImageConfig.self, forKey: .imageConfig)
        imageConfig = imageConfigDecoded
    }
}

extension UpdateFunctionConfigurationOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionConfigurationOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "CodeSigningConfigNotFoundException" : self = .codeSigningConfigNotFoundException(try CodeSigningConfigNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CodeVerificationFailedException" : self = .codeVerificationFailedException(try CodeVerificationFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidCodeSignatureException" : self = .invalidCodeSignatureException(try InvalidCodeSignatureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PreconditionFailedException" : self = .preconditionFailedException(try PreconditionFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceConflictException" : self = .resourceConflictException(try ResourceConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionConfigurationOutputError: Equatable {
    case codeSigningConfigNotFoundException(CodeSigningConfigNotFoundException)
    case codeVerificationFailedException(CodeVerificationFailedException)
    case invalidCodeSignatureException(InvalidCodeSignatureException)
    case invalidParameterValueException(InvalidParameterValueException)
    case preconditionFailedException(PreconditionFailedException)
    case resourceConflictException(ResourceConflictException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionConfigurationOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionConfigurationOutputResponse(codeSha256: \(String(describing: codeSha256)), codeSize: \(String(describing: codeSize)), deadLetterConfig: \(String(describing: deadLetterConfig)), description: \(String(describing: description)), environment: \(String(describing: environment)), fileSystemConfigs: \(String(describing: fileSystemConfigs)), functionArn: \(String(describing: functionArn)), functionName: \(String(describing: functionName)), handler: \(String(describing: handler)), imageConfigResponse: \(String(describing: imageConfigResponse)), kMSKeyArn: \(String(describing: kMSKeyArn)), lastModified: \(String(describing: lastModified)), lastUpdateStatus: \(String(describing: lastUpdateStatus)), lastUpdateStatusReason: \(String(describing: lastUpdateStatusReason)), lastUpdateStatusReasonCode: \(String(describing: lastUpdateStatusReasonCode)), layers: \(String(describing: layers)), masterArn: \(String(describing: masterArn)), memorySize: \(String(describing: memorySize)), packageType: \(String(describing: packageType)), revisionId: \(String(describing: revisionId)), role: \(String(describing: role)), runtime: \(String(describing: runtime)), signingJobArn: \(String(describing: signingJobArn)), signingProfileVersionArn: \(String(describing: signingProfileVersionArn)), state: \(String(describing: state)), stateReason: \(String(describing: stateReason)), stateReasonCode: \(String(describing: stateReasonCode)), timeout: \(String(describing: timeout)), tracingConfig: \(String(describing: tracingConfig)), version: \(String(describing: version)), vpcConfig: \(String(describing: vpcConfig)))"}
}

extension UpdateFunctionConfigurationOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFunctionConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.codeSha256 = output.codeSha256
            self.codeSize = output.codeSize
            self.deadLetterConfig = output.deadLetterConfig
            self.description = output.description
            self.environment = output.environment
            self.fileSystemConfigs = output.fileSystemConfigs
            self.functionArn = output.functionArn
            self.functionName = output.functionName
            self.handler = output.handler
            self.imageConfigResponse = output.imageConfigResponse
            self.kMSKeyArn = output.kMSKeyArn
            self.lastModified = output.lastModified
            self.lastUpdateStatus = output.lastUpdateStatus
            self.lastUpdateStatusReason = output.lastUpdateStatusReason
            self.lastUpdateStatusReasonCode = output.lastUpdateStatusReasonCode
            self.layers = output.layers
            self.masterArn = output.masterArn
            self.memorySize = output.memorySize
            self.packageType = output.packageType
            self.revisionId = output.revisionId
            self.role = output.role
            self.runtime = output.runtime
            self.signingJobArn = output.signingJobArn
            self.signingProfileVersionArn = output.signingProfileVersionArn
            self.state = output.state
            self.stateReason = output.stateReason
            self.stateReasonCode = output.stateReasonCode
            self.timeout = output.timeout
            self.tracingConfig = output.tracingConfig
            self.version = output.version
            self.vpcConfig = output.vpcConfig
        } else {
            self.codeSha256 = nil
            self.codeSize = 0
            self.deadLetterConfig = nil
            self.description = nil
            self.environment = nil
            self.fileSystemConfigs = nil
            self.functionArn = nil
            self.functionName = nil
            self.handler = nil
            self.imageConfigResponse = nil
            self.kMSKeyArn = nil
            self.lastModified = nil
            self.lastUpdateStatus = nil
            self.lastUpdateStatusReason = nil
            self.lastUpdateStatusReasonCode = nil
            self.layers = nil
            self.masterArn = nil
            self.memorySize = nil
            self.packageType = nil
            self.revisionId = nil
            self.role = nil
            self.runtime = nil
            self.signingJobArn = nil
            self.signingProfileVersionArn = nil
            self.state = nil
            self.stateReason = nil
            self.stateReasonCode = nil
            self.timeout = nil
            self.tracingConfig = nil
            self.version = nil
            self.vpcConfig = nil
        }
    }
}

/// <p>Details about a function's configuration.</p>
public struct UpdateFunctionConfigurationOutputResponse: Equatable {
    /// <p>The SHA256 hash of the function's deployment package.</p>
    public let codeSha256: String?
    /// <p>The size of the function's deployment package, in bytes.</p>
    public let codeSize: Int
    /// <p>The function's dead letter queue.</p>
    public let deadLetterConfig: DeadLetterConfig?
    /// <p>The function's description.</p>
    public let description: String?
    /// <p>The function's environment variables.</p>
    public let environment: EnvironmentResponse?
    /// <p>Connection settings for an Amazon EFS file system.</p>
    public let fileSystemConfigs: [FileSystemConfig]?
    /// <p>The function's Amazon Resource Name (ARN).</p>
    public let functionArn: String?
    /// <p>The name of the function.</p>
    public let functionName: String?
    /// <p>The function that Lambda calls to begin executing your function.</p>
    public let handler: String?
    /// <p>The function's image configuration values.</p>
    public let imageConfigResponse: ImageConfigResponse?
    /// <p>The KMS key that's used to encrypt the function's environment variables. This key is only returned if you've
    ///       configured a customer managed CMK.</p>
    public let kMSKeyArn: String?
    /// <p>The date and time that the function was last updated, in <a href="https://www.w3.org/TR/NOTE-datetime">ISO-8601 format</a> (YYYY-MM-DDThh:mm:ss.sTZD).</p>
    public let lastModified: String?
    /// <p>The status of the last update that was performed on the function. This is first set to <code>Successful</code>
    ///       after function creation completes.</p>
    public let lastUpdateStatus: LastUpdateStatus?
    /// <p>The reason for the last update that was performed on the function.</p>
    public let lastUpdateStatusReason: String?
    /// <p>The reason code for the last update that was performed on the function.</p>
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    /// <p>The function's <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-layers.html">
    ///       layers</a>.</p>
    public let layers: [Layer]?
    /// <p>For Lambda@Edge functions, the ARN of the master function.</p>
    public let masterArn: String?
    /// <p>The amount of memory available to the function at runtime. </p>
    public let memorySize: Int?
    /// <p>The type of deployment package. Set to <code>Image</code> for container image and set <code>Zip</code> for .zip file archive.</p>
    public let packageType: PackageType?
    /// <p>The latest updated revision of the function or alias.</p>
    public let revisionId: String?
    /// <p>The function's execution role.</p>
    public let role: String?
    /// <p>The runtime environment for the Lambda function.</p>
    public let runtime: Runtime?
    /// <p>The ARN of the signing job.</p>
    public let signingJobArn: String?
    /// <p>The ARN of the signing profile version.</p>
    public let signingProfileVersionArn: String?
    /// <p>The current state of the function. When the state is <code>Inactive</code>, you can reactivate the function by
    ///       invoking it.</p>
    public let state: State?
    /// <p>The reason for the function's current state.</p>
    public let stateReason: String?
    /// <p>The reason code for the function's current state. When the code is <code>Creating</code>, you can't invoke or
    ///       modify the function.</p>
    public let stateReasonCode: StateReasonCode?
    /// <p>The amount of time in seconds that Lambda allows a function to run before stopping it.</p>
    public let timeout: Int?
    /// <p>The function's AWS X-Ray tracing configuration.</p>
    public let tracingConfig: TracingConfigResponse?
    /// <p>The version of the Lambda function.</p>
    public let version: String?
    /// <p>The function's networking configuration.</p>
    public let vpcConfig: VpcConfigResponse?

    public init (
        codeSha256: String? = nil,
        codeSize: Int = 0,
        deadLetterConfig: DeadLetterConfig? = nil,
        description: String? = nil,
        environment: EnvironmentResponse? = nil,
        fileSystemConfigs: [FileSystemConfig]? = nil,
        functionArn: String? = nil,
        functionName: String? = nil,
        handler: String? = nil,
        imageConfigResponse: ImageConfigResponse? = nil,
        kMSKeyArn: String? = nil,
        lastModified: String? = nil,
        lastUpdateStatus: LastUpdateStatus? = nil,
        lastUpdateStatusReason: String? = nil,
        lastUpdateStatusReasonCode: LastUpdateStatusReasonCode? = nil,
        layers: [Layer]? = nil,
        masterArn: String? = nil,
        memorySize: Int? = nil,
        packageType: PackageType? = nil,
        revisionId: String? = nil,
        role: String? = nil,
        runtime: Runtime? = nil,
        signingJobArn: String? = nil,
        signingProfileVersionArn: String? = nil,
        state: State? = nil,
        stateReason: String? = nil,
        stateReasonCode: StateReasonCode? = nil,
        timeout: Int? = nil,
        tracingConfig: TracingConfigResponse? = nil,
        version: String? = nil,
        vpcConfig: VpcConfigResponse? = nil
    )
    {
        self.codeSha256 = codeSha256
        self.codeSize = codeSize
        self.deadLetterConfig = deadLetterConfig
        self.description = description
        self.environment = environment
        self.fileSystemConfigs = fileSystemConfigs
        self.functionArn = functionArn
        self.functionName = functionName
        self.handler = handler
        self.imageConfigResponse = imageConfigResponse
        self.kMSKeyArn = kMSKeyArn
        self.lastModified = lastModified
        self.lastUpdateStatus = lastUpdateStatus
        self.lastUpdateStatusReason = lastUpdateStatusReason
        self.lastUpdateStatusReasonCode = lastUpdateStatusReasonCode
        self.layers = layers
        self.masterArn = masterArn
        self.memorySize = memorySize
        self.packageType = packageType
        self.revisionId = revisionId
        self.role = role
        self.runtime = runtime
        self.signingJobArn = signingJobArn
        self.signingProfileVersionArn = signingProfileVersionArn
        self.state = state
        self.stateReason = stateReason
        self.stateReasonCode = stateReasonCode
        self.timeout = timeout
        self.tracingConfig = tracingConfig
        self.version = version
        self.vpcConfig = vpcConfig
    }
}

struct UpdateFunctionConfigurationOutputResponseBody: Equatable {
    public let functionName: String?
    public let functionArn: String?
    public let runtime: Runtime?
    public let role: String?
    public let handler: String?
    public let codeSize: Int
    public let description: String?
    public let timeout: Int?
    public let memorySize: Int?
    public let lastModified: String?
    public let codeSha256: String?
    public let version: String?
    public let vpcConfig: VpcConfigResponse?
    public let deadLetterConfig: DeadLetterConfig?
    public let environment: EnvironmentResponse?
    public let kMSKeyArn: String?
    public let tracingConfig: TracingConfigResponse?
    public let masterArn: String?
    public let revisionId: String?
    public let layers: [Layer]?
    public let state: State?
    public let stateReason: String?
    public let stateReasonCode: StateReasonCode?
    public let lastUpdateStatus: LastUpdateStatus?
    public let lastUpdateStatusReason: String?
    public let lastUpdateStatusReasonCode: LastUpdateStatusReasonCode?
    public let fileSystemConfigs: [FileSystemConfig]?
    public let packageType: PackageType?
    public let imageConfigResponse: ImageConfigResponse?
    public let signingProfileVersionArn: String?
    public let signingJobArn: String?
}

extension UpdateFunctionConfigurationOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case codeSha256 = "CodeSha256"
        case codeSize = "CodeSize"
        case deadLetterConfig = "DeadLetterConfig"
        case description = "Description"
        case environment = "Environment"
        case fileSystemConfigs = "FileSystemConfigs"
        case functionArn = "FunctionArn"
        case functionName = "FunctionName"
        case handler = "Handler"
        case imageConfigResponse = "ImageConfigResponse"
        case kMSKeyArn = "KMSKeyArn"
        case lastModified = "LastModified"
        case lastUpdateStatus = "LastUpdateStatus"
        case lastUpdateStatusReason = "LastUpdateStatusReason"
        case lastUpdateStatusReasonCode = "LastUpdateStatusReasonCode"
        case layers = "Layers"
        case masterArn = "MasterArn"
        case memorySize = "MemorySize"
        case packageType = "PackageType"
        case revisionId = "RevisionId"
        case role = "Role"
        case runtime = "Runtime"
        case signingJobArn = "SigningJobArn"
        case signingProfileVersionArn = "SigningProfileVersionArn"
        case state = "State"
        case stateReason = "StateReason"
        case stateReasonCode = "StateReasonCode"
        case timeout = "Timeout"
        case tracingConfig = "TracingConfig"
        case version = "Version"
        case vpcConfig = "VpcConfig"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionNameDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let runtimeDecoded = try containerValues.decodeIfPresent(Runtime.self, forKey: .runtime)
        runtime = runtimeDecoded
        let roleDecoded = try containerValues.decodeIfPresent(String.self, forKey: .role)
        role = roleDecoded
        let handlerDecoded = try containerValues.decodeIfPresent(String.self, forKey: .handler)
        handler = handlerDecoded
        let codeSizeDecoded = try containerValues.decode(Int.self, forKey: .codeSize)
        codeSize = codeSizeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .description)
        description = descriptionDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let lastModifiedDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let codeSha256Decoded = try containerValues.decodeIfPresent(String.self, forKey: .codeSha256)
        codeSha256 = codeSha256Decoded
        let versionDecoded = try containerValues.decodeIfPresent(String.self, forKey: .version)
        version = versionDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(VpcConfigResponse.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let deadLetterConfigDecoded = try containerValues.decodeIfPresent(DeadLetterConfig.self, forKey: .deadLetterConfig)
        deadLetterConfig = deadLetterConfigDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(EnvironmentResponse.self, forKey: .environment)
        environment = environmentDecoded
        let kMSKeyArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .kMSKeyArn)
        kMSKeyArn = kMSKeyArnDecoded
        let tracingConfigDecoded = try containerValues.decodeIfPresent(TracingConfigResponse.self, forKey: .tracingConfig)
        tracingConfig = tracingConfigDecoded
        let masterArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .masterArn)
        masterArn = masterArnDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let layersContainer = try containerValues.decodeIfPresent([Layer?].self, forKey: .layers)
        var layersDecoded0:[Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let stateDecoded = try containerValues.decodeIfPresent(State.self, forKey: .state)
        state = stateDecoded
        let stateReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .stateReason)
        stateReason = stateReasonDecoded
        let stateReasonCodeDecoded = try containerValues.decodeIfPresent(StateReasonCode.self, forKey: .stateReasonCode)
        stateReasonCode = stateReasonCodeDecoded
        let lastUpdateStatusDecoded = try containerValues.decodeIfPresent(LastUpdateStatus.self, forKey: .lastUpdateStatus)
        lastUpdateStatus = lastUpdateStatusDecoded
        let lastUpdateStatusReasonDecoded = try containerValues.decodeIfPresent(String.self, forKey: .lastUpdateStatusReason)
        lastUpdateStatusReason = lastUpdateStatusReasonDecoded
        let lastUpdateStatusReasonCodeDecoded = try containerValues.decodeIfPresent(LastUpdateStatusReasonCode.self, forKey: .lastUpdateStatusReasonCode)
        lastUpdateStatusReasonCode = lastUpdateStatusReasonCodeDecoded
        let fileSystemConfigsContainer = try containerValues.decodeIfPresent([FileSystemConfig?].self, forKey: .fileSystemConfigs)
        var fileSystemConfigsDecoded0:[FileSystemConfig]? = nil
        if let fileSystemConfigsContainer = fileSystemConfigsContainer {
            fileSystemConfigsDecoded0 = [FileSystemConfig]()
            for structure0 in fileSystemConfigsContainer {
                if let structure0 = structure0 {
                    fileSystemConfigsDecoded0?.append(structure0)
                }
            }
        }
        fileSystemConfigs = fileSystemConfigsDecoded0
        let packageTypeDecoded = try containerValues.decodeIfPresent(PackageType.self, forKey: .packageType)
        packageType = packageTypeDecoded
        let imageConfigResponseDecoded = try containerValues.decodeIfPresent(ImageConfigResponse.self, forKey: .imageConfigResponse)
        imageConfigResponse = imageConfigResponseDecoded
        let signingProfileVersionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingProfileVersionArn)
        signingProfileVersionArn = signingProfileVersionArnDecoded
        let signingJobArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .signingJobArn)
        signingJobArn = signingJobArnDecoded
    }
}

public struct UpdateFunctionEventInvokeConfigInputBodyMiddleware: Middleware {
    public let id: String = "UpdateFunctionEventInvokeConfigInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        do {
            if try !input.operationInput.allPropertiesAreNull() {
                let encoder = context.getEncoder()
                let data = try encoder.encode(input.operationInput)
                let body = HttpBody.data(data)
                input.builder.withBody(body)
            }
        } catch let err {
            return .failure(.client(ClientError.serializationFailed(err.localizedDescription)))
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

extension UpdateFunctionEventInvokeConfigInput: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionEventInvokeConfigInput(destinationConfig: \(String(describing: destinationConfig)), functionName: \(String(describing: functionName)), maximumEventAgeInSeconds: \(String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)), qualifier: \(String(describing: qualifier)))"}
}

extension UpdateFunctionEventInvokeConfigInput: Encodable, Reflection {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let maximumEventAgeInSeconds = maximumEventAgeInSeconds {
            try encodeContainer.encode(maximumEventAgeInSeconds, forKey: .maximumEventAgeInSeconds)
        }
        if let maximumRetryAttempts = maximumRetryAttempts {
            try encodeContainer.encode(maximumRetryAttempts, forKey: .maximumRetryAttempts)
        }
    }
}

public struct UpdateFunctionEventInvokeConfigInputHeadersMiddleware: Middleware {
    public let id: String = "UpdateFunctionEventInvokeConfigInputHeadersMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

public struct UpdateFunctionEventInvokeConfigInputQueryItemMiddleware: Middleware {
    public let id: String = "UpdateFunctionEventInvokeConfigInputQueryItemMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: SerializeStepInput<UpdateFunctionEventInvokeConfigInput>,
                  next: H) -> Swift.Result<OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>, MError>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context,
    Self.MError == H.MiddlewareError
    {
        if let qualifier = input.operationInput.qualifier {
            let qualifierQueryItem = URLQueryItem(name: "Qualifier".urlPercentEncoding(), value: String(qualifier).urlPercentEncoding())
            input.builder.withQueryItem(qualifierQueryItem)
        }
        return next.handle(context: context, input: input)
    }

    public typealias MInput = SerializeStepInput<UpdateFunctionEventInvokeConfigInput>
    public typealias MOutput = OperationOutput<UpdateFunctionEventInvokeConfigOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
    public typealias MError = SdkError<UpdateFunctionEventInvokeConfigOutputError>
}

public struct UpdateFunctionEventInvokeConfigInput: Equatable {
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    ///          <p class="title">
    ///             <b>Destinations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Queue</b> - The ARN of an SQS queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Topic</b> - The ARN of an SNS topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    ///             </li>
    ///          </ul>
    public let destinationConfig: DestinationConfig?
    /// <p>The name of the Lambda function, version, or alias.</p>
    ///          <p class="title">
    ///             <b>Name formats</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function name</b> - <code>my-function</code> (name-only), <code>my-function:v1</code> (with alias).</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Function ARN</b> - <code>arn:aws:lambda:us-west-2:123456789012:function:my-function</code>.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Partial ARN</b> - <code>123456789012:function:my-function</code>.</p>
    ///             </li>
    ///          </ul>
    ///          <p>You can append a version number or alias to any of the formats. The length constraint applies only to the full ARN.
    ///       If you specify only the function name, it is limited to 64 characters in length.</p>
    public let functionName: String?
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    public let maximumEventAgeInSeconds: Int?
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    public let maximumRetryAttempts: Int?
    /// <p>A version number or alias name.</p>
    public let qualifier: String?

    public init (
        destinationConfig: DestinationConfig? = nil,
        functionName: String? = nil,
        maximumEventAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil,
        qualifier: String? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionName = functionName
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
        self.qualifier = qualifier
    }
}

struct UpdateFunctionEventInvokeConfigInputBody: Equatable {
    public let maximumRetryAttempts: Int?
    public let maximumEventAgeInSeconds: Int?
    public let destinationConfig: DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigInputBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension UpdateFunctionEventInvokeConfigOutputError: HttpResponseBinding {
    public init(httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        let errorDetails = try RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFunctionEventInvokeConfigOutputError {
    public init(errorType: String?, httpResponse: HttpResponse, decoder: ResponseDecoder? = nil, message: String? = nil, requestID: String? = nil) throws {
        switch errorType {
        case "InvalidParameterValueException" : self = .invalidParameterValueException(try InvalidParameterValueException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceException" : self = .serviceException(try ServiceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TooManyRequestsException" : self = .tooManyRequestsException(try TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID))
        }
    }
}

public enum UpdateFunctionEventInvokeConfigOutputError: Equatable {
    case invalidParameterValueException(InvalidParameterValueException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceException(ServiceException)
    case tooManyRequestsException(TooManyRequestsException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFunctionEventInvokeConfigOutputResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "UpdateFunctionEventInvokeConfigOutputResponse(destinationConfig: \(String(describing: destinationConfig)), functionArn: \(String(describing: functionArn)), lastModified: \(String(describing: lastModified)), maximumEventAgeInSeconds: \(String(describing: maximumEventAgeInSeconds)), maximumRetryAttempts: \(String(describing: maximumRetryAttempts)))"}
}

extension UpdateFunctionEventInvokeConfigOutputResponse: HttpResponseBinding {
    public init (httpResponse: HttpResponse, decoder: ResponseDecoder? = nil) throws {
        if case .data(let data) = httpResponse.body,
            let unwrappedData = data,
            let responseDecoder = decoder {
            let output: UpdateFunctionEventInvokeConfigOutputResponseBody = try responseDecoder.decode(responseBody: unwrappedData)
            self.destinationConfig = output.destinationConfig
            self.functionArn = output.functionArn
            self.lastModified = output.lastModified
            self.maximumEventAgeInSeconds = output.maximumEventAgeInSeconds
            self.maximumRetryAttempts = output.maximumRetryAttempts
        } else {
            self.destinationConfig = nil
            self.functionArn = nil
            self.lastModified = nil
            self.maximumEventAgeInSeconds = nil
            self.maximumRetryAttempts = nil
        }
    }
}

public struct UpdateFunctionEventInvokeConfigOutputResponse: Equatable {
    /// <p>A destination for events after they have been sent to a function for processing.</p>
    ///          <p class="title">
    ///             <b>Destinations</b>
    ///          </p>
    ///          <ul>
    ///             <li>
    ///                <p>
    ///                   <b>Function</b> - The Amazon Resource Name (ARN) of a Lambda function.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Queue</b> - The ARN of an SQS queue.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Topic</b> - The ARN of an SNS topic.</p>
    ///             </li>
    ///             <li>
    ///                <p>
    ///                   <b>Event Bus</b> - The ARN of an Amazon EventBridge event bus.</p>
    ///             </li>
    ///          </ul>
    public let destinationConfig: DestinationConfig?
    /// <p>The Amazon Resource Name (ARN) of the function.</p>
    public let functionArn: String?
    /// <p>The date and time that the configuration was last updated.</p>
    public let lastModified: Date?
    /// <p>The maximum age of a request that Lambda sends to a function for processing.</p>
    public let maximumEventAgeInSeconds: Int?
    /// <p>The maximum number of times to retry when the function returns an error.</p>
    public let maximumRetryAttempts: Int?

    public init (
        destinationConfig: DestinationConfig? = nil,
        functionArn: String? = nil,
        lastModified: Date? = nil,
        maximumEventAgeInSeconds: Int? = nil,
        maximumRetryAttempts: Int? = nil
    )
    {
        self.destinationConfig = destinationConfig
        self.functionArn = functionArn
        self.lastModified = lastModified
        self.maximumEventAgeInSeconds = maximumEventAgeInSeconds
        self.maximumRetryAttempts = maximumRetryAttempts
    }
}

struct UpdateFunctionEventInvokeConfigOutputResponseBody: Equatable {
    public let lastModified: Date?
    public let functionArn: String?
    public let maximumRetryAttempts: Int?
    public let maximumEventAgeInSeconds: Int?
    public let destinationConfig: DestinationConfig?
}

extension UpdateFunctionEventInvokeConfigOutputResponseBody: Decodable {
    enum CodingKeys: String, CodingKey {
        case destinationConfig = "DestinationConfig"
        case functionArn = "FunctionArn"
        case lastModified = "LastModified"
        case maximumEventAgeInSeconds = "MaximumEventAgeInSeconds"
        case maximumRetryAttempts = "MaximumRetryAttempts"
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedDecoded = try containerValues.decodeIfPresent(Date.self, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let functionArnDecoded = try containerValues.decodeIfPresent(String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let maximumRetryAttemptsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumRetryAttempts)
        maximumRetryAttempts = maximumRetryAttemptsDecoded
        let maximumEventAgeInSecondsDecoded = try containerValues.decodeIfPresent(Int.self, forKey: .maximumEventAgeInSeconds)
        maximumEventAgeInSeconds = maximumEventAgeInSecondsDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(DestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension VpcConfig: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
    }
}

extension VpcConfig: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfig(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)))"}
}

/// <p>The VPC security groups and subnets that are attached to a Lambda function. For more information, see <a href="https://docs.aws.amazon.com/lambda/latest/dg/configuration-vpc.html">VPC Settings</a>.</p>
public struct VpcConfig: Equatable {
    /// <p>A list of VPC security groups IDs.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of VPC subnet IDs.</p>
    public let subnetIds: [String]?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
    }
}

extension VpcConfigResponse: Codable, Reflection {
    enum CodingKeys: String, CodingKey {
        case securityGroupIds = "SecurityGroupIds"
        case subnetIds = "SubnetIds"
        case vpcId = "VpcId"
    }

    public func encode(to encoder: Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroupIds = securityGroupIds {
            var securityGroupIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroupIds)
            for securitygroupids0 in securityGroupIds {
                try securityGroupIdsContainer.encode(securitygroupids0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for subnetids0 in subnetIds {
                try subnetIdsContainer.encode(subnetids0)
            }
        }
        if let vpcId = vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let securityGroupIdsContainer = try containerValues.decodeIfPresent([String?].self, forKey: .securityGroupIds)
        var securityGroupIdsDecoded0:[String]? = nil
        if let securityGroupIdsContainer = securityGroupIdsContainer {
            securityGroupIdsDecoded0 = [String]()
            for string0 in securityGroupIdsContainer {
                if let string0 = string0 {
                    securityGroupIdsDecoded0?.append(string0)
                }
            }
        }
        securityGroupIds = securityGroupIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension VpcConfigResponse: CustomDebugStringConvertible {
    public var debugDescription: String {
        "VpcConfigResponse(securityGroupIds: \(String(describing: securityGroupIds)), subnetIds: \(String(describing: subnetIds)), vpcId: \(String(describing: vpcId)))"}
}

/// <p>The VPC security groups and subnets that are attached to a Lambda function.</p>
public struct VpcConfigResponse: Equatable {
    /// <p>A list of VPC security groups IDs.</p>
    public let securityGroupIds: [String]?
    /// <p>A list of VPC subnet IDs.</p>
    public let subnetIds: [String]?
    /// <p>The ID of the VPC.</p>
    public let vpcId: String?

    public init (
        securityGroupIds: [String]? = nil,
        subnetIds: [String]? = nil,
        vpcId: String? = nil
    )
    {
        self.securityGroupIds = securityGroupIds
        self.subnetIds = subnetIds
        self.vpcId = vpcId
    }
}
